<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张啸</title>
  
  <subtitle>世界上最快乐的事，莫过于为理想而奋斗。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaoleon.cn/"/>
  <updated>2018-05-22T15:05:18.475Z</updated>
  <id>http://www.xiaoleon.cn/</id>
  
  <author>
    <name>Leon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6(6) Symbol</title>
    <link href="http://www.xiaoleon.cn/2018/05/21/es6-6/"/>
    <id>http://www.xiaoleon.cn/2018/05/21/es6-6/</id>
    <published>2018-05-21T09:07:10.000Z</published>
    <updated>2018-05-22T15:05:18.475Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中<code>Symbol</code>的语法及使用方法。节选自<a href="(http://es6.ruanyifeng.com/#docs/symbol">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。比如，你是用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本是防止属性名的冲突。这就是ES6引入<code>Symbol</code>的原因。</p><p>ES6引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是JavaScript的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><p>Symbol值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s                <span class="comment">// 'symbol'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是Symbol数据类型，而不是字符串之类的其它类型。</p><p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1                      <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2                      <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.toString()           <span class="comment">// 'Symbol(foo)'</span></span><br><span class="line">s2.toString()           <span class="comment">// 'Symbol(bar)'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>是两个Symbol值。如果不加上参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分，有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><p>如果Symbol的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转换为字符串，然后才生成一个Symbol值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'obj'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</span><br><span class="line">sym             <span class="comment">// Symbol(abc)</span></span><br></pre></td></tr></table></figure><p>注意，<code>Symbol</code>函数的参数只是表示对当前Symbol值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2           <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2           <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。</p><p>Symbol值不能与其他类型的值进行运算，会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'my symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">'your symbol is'</span> + sym      <span class="comment">// TypeError: can't convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span>     <span class="comment">// TypeError: can't convert symbol to string</span></span><br></pre></td></tr></table></figure><p>但是，Symbol值可以显示转为字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'my symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(sym)                 <span class="comment">// 'Symbol(my symbol)'</span></span><br><span class="line">sym.toString()              <span class="comment">// 'Symbol(my symbol)'</span></span><br></pre></td></tr></table></figure><p>另外，Symbol值也可以转为布尔值，但是不能转为数值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">Boolean</span>(sym)                <span class="comment">// true</span></span><br><span class="line">!sym                        <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(sym)                 <span class="comment">// TypeError</span></span><br><span class="line">sym + <span class="number">2</span>                     <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><hr><h3 id="二、作为属性名的Symbol"><a href="#二、作为属性名的Symbol" class="headerlink" title="二、作为属性名的Symbol"></a>二、作为属性名的Symbol</h3><p>由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    [mySymbol]: <span class="string">'Hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123;<span class="attr">value</span>: <span class="string">'Hello'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol]                 <span class="comment">// 'Hello'</span></span><br></pre></td></tr></table></figure><p>上面代码通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个Symbol值。</p><p>注意，Symbol值作为对象属性名时，不能用点运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">'Hello'</span>;</span><br><span class="line">a[mySymbol]                 <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">'mySymbol'</span>]               <span class="comment">// 'Hello'</span></span><br></pre></td></tr></table></figure><p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个Symbol值。</p><p>同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [s]: <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[s](<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个Symbol值。</p><p>采用增强的对象写法，上面代码的<code>obj</code>对象可以写得更简洁一些。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [s](arg) &#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log.levels = &#123;</span><br><span class="line">    DEBUG: <span class="built_in">Symbol</span>(<span class="string">'debug'</span>),</span><br><span class="line">    INFO: <span class="built_in">Symbol</span>(<span class="string">'info'</span>),</span><br><span class="line">    WARN: <span class="built_in">Symbol</span>(<span class="string">'warn'</span>)</span><br><span class="line">&#125;;</span><br><span class="line">log(log.levels.DEBUG, <span class="string">'debug message'</span>);</span><br><span class="line">log(log.levels.INFO, <span class="string">'info message'</span>);</span><br></pre></td></tr></table></figure><p>下面是另外一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> COLOR_RED = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> COLOR_GREEN = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComplement</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(color) &#123;</span><br><span class="line">        <span class="keyword">case</span> COLOR_RED:</span><br><span class="line">            <span class="keyword">return</span> COLOR_GREEN;</span><br><span class="line">        <span class="keyword">case</span> COLOR_GREEN;</span><br><span class="line">            RETURN COLOR_RED;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Undefined color'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量使用Symbol值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按照设计的方式工作。</p><p>还有一点需要注意，Symbol值作为属性名时，该属性还是公开属性，不是私有属性。</p><hr><h3 id="三、实例：消除魔术字符串"><a href="#三、实例：消除魔术字符串" class="headerlink" title="三、实例：消除魔术字符串"></a>三、实例：消除魔术字符串</h3><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(shape) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'Triangle'</span>:        <span class="comment">// 魔术字符串</span></span><br><span class="line">            area = <span class="number">.5</span> * options.width * options.height;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(<span class="string">'Triangle'</span>, &#123;<span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;);     <span class="comment">// 魔术字符串</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p><p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">    triangle: <span class="string">'Triangle'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(shape) &#123;</span><br><span class="line">        <span class="keyword">case</span> shapeType.triangle:</span><br><span class="line">            area = <span class="number">.5</span> * options.width * options.height;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(shapeType.triangle, &#123;<span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，我们把<code>Triangle</code>写成<code>shapeType</code>对象的<code>triangle</code>属性，这样就消除了强耦合。</p><p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会根其他的<code>shapeType</code>属性的值冲突即可。因此，这里就很适合改用Symbol值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">    triangle: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，除了将<code>shapeType.triangle</code>的值设为一个Symbol，其他地方都不用修改。</p><hr><h3 id="四、属性名的遍历"><a href="#四、属性名的遍历" class="headerlink" title="四、属性名的遍历"></a>四、属性名的遍历</h3><p>Symbol作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有Symbol属性名。</p><p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的Symbol值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols               <span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure><p>下面是另一个例子，<code>Object.getOwnPropertySymbols</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, foo, &#123;</span><br><span class="line">    value: <span class="string">'foobar'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);         <span class="comment">// 无输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)     <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj)   <span class="comment">// [Symbol(foo)]</span></span><br></pre></td></tr></table></figure><p>上面代码中，使用<code>Object.getOwnPropertyNames</code>方法得不到<code>Symbol</code>属性名，需要使用<code>Object.getOwnPropertySymbols</code>方法。</p><p>另一个新的API，<code>Reflect.ownKeys</code>方法可以返回所有类型的键名，包括常规键名和Symbol键名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">    enum: <span class="number">2</span>,</span><br><span class="line">    nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)        <span class="comment">// ['enum', 'nonEnum', Symbol(my_key)]</span></span><br></pre></td></tr></table></figure><p>由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sie = <span class="built_in">Symbol</span>(<span class="string">'size'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>[size] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>[<span class="keyword">this</span>[size]] = item;</span><br><span class="line">        <span class="keyword">this</span>[size]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> sizeOf(instance) &#123;</span><br><span class="line">        <span class="keyword">return</span> instance[size]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> Collection();</span><br><span class="line">Collection.sizeOf(x);           <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">x.add(<span class="string">'foo'</span>);</span><br><span class="line">Collection.sizeOf(x);           <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(x)                  <span class="comment">// ['0']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(x)   <span class="comment">// ['0']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(x) <span class="comment">// [Symbol(size)]</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个Symbol值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它，这就造成了一种非私有的内部方法的效果。</p><hr><h3 id="五、Symbol-for-，Symbol-keyFor"><a href="#五、Symbol-for-，Symbol-keyFor" class="headerlink" title="五、Symbol.for()，Symbol.keyFor()"></a>五、Symbol.for()，Symbol.keyFor()</h3><p>有时候，我们希望重新使用同一个Symbol值，<code>Symbol.for</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2;                      <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>都是Symbol值，但是它们都是同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中提供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的Symbol类型的值，而是会检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果调用<code>Symbol.for(&quot;cat&quot;)</code>30次，每次都会返回同一个Symbol值，但是调用<code>Symbol(&#39;cat&#39;)</code>30次，会返回30个不同的Symbol值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'bar'</span>) === <span class="built_in">Symbol</span>(<span class="string">'bar'</span>)             <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p><p><code>Symbol.keyFor</code>方法返回一个已登记的Symbol类型值的<code>key</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1);              <span class="comment">// 'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2);              <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s2</code>属于未登记的Symbol值，所以返回<code>undefined</code>。</p><p>需要注意的是，<code>Symbol.for</code>为Symbol值登记的名字，是全局环境的，可以在不同的<code>iframe</code>或<code>service worker</code>中取到同一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = <span class="built_in">String</span>(<span class="built_in">window</span>.location);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">iframe.contentWindow.Symbol.for(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，iframe窗口生成的Symbol值，可以在主页面得到。</p><hr><h3 id="六、实例：模块的Singleton模式"><a href="#六、实例：模块的Singleton模式" class="headerlink" title="六、实例：模块的Singleton模式"></a>六、实例：模块的Singleton模式</h3><p>Singleton模式指的是调用一个类，任何时候返回的都是同一个实例。</p><p>对于Node来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p><p>很容易想到，可以把实例放到顶层对象<code>global</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!global._foo) &#123;</span><br><span class="line">    global._foo = <span class="keyword">new</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modules.exports = global._foo;</span><br></pre></td></tr></table></figure><p>然后，加载上面的<code>mod.js</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./mod.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.foo);</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例。</p><p>但是，这里有一个问题，全局变量<code>global._foo</code>是可写的，任何文件都可以修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">global._foo = &#123;<span class="attr">foo</span>: <span class="string">'world'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./mod.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.foo);</span><br></pre></td></tr></table></figure><p>上面的代码，会使得加载<code>mod.js</code>的脚本都失真。</p><p>为了防止这种情况出现，我们就可以使用Symbol。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">const</span> FOO_KEY = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!global[FOO_KEY]) &#123;</span><br><span class="line">    global[FOO_KEY] = <span class="keyword">new</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = global[FOO_KEY];</span><br></pre></td></tr></table></figure><p>上面代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">global[<span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)] = &#123;<span class="attr">foo</span>: <span class="string">'world'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./mod.js'</span>);</span><br></pre></td></tr></table></figure><p>如果键名使用<code>Symbol</code>方法生成，那么外部将无法引用这个值，当然也就无法改写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">const</span> FOO_KEY = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure><p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的<code>FOO_KEY</code>都是不一样的。虽然Node会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。</p><hr><h3 id="七、内置的Symbol值"><a href="#七、内置的Symbol值" class="headerlink" title="七、内置的Symbol值"></a>七、内置的Symbol值</h3><p>除了定义自己使用的Symbol值以外，ES6还提供了11各内置的Symbol值，指向语言内部使用的方法。</p><h4 id="1-Symbol-hasInstance"><a href="#1-Symbol-hasInstance" class="headerlink" title="1. Symbol.hasInstance"></a>1. Symbol.hasInstance</h4><p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.hasInstance](foo) &#123;</span><br><span class="line">        <span class="keyword">return</span> foo <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> MyClass();     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p><p>下面是另一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Even</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> Even = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> Even           <span class="comment">// false</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">instanceof</span> Even           <span class="comment">// true</span></span><br><span class="line"><span class="number">12345</span> <span class="keyword">instanceof</span> Even       <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="2-Symbol-isConcatSpreadable"><a href="#2-Symbol-isConcatSpreadable" class="headerlink" title="2. Symbol.isConcatSpreadable"></a>2. Symbol.isConcatSpreadable</h4><p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr1, <span class="string">'e'</span>)        <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br><span class="line">arr1[<span class="built_in">Symbol</span>.isConcatSpreadable]     <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr2, <span class="string">'e'</span>)        <span class="comment">// ['a', 'b', ['c', 'd'], 'e']</span></span><br></pre></td></tr></table></figure><p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p><p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'c'</span>, <span class="number">1</span>: <span class="string">'d'</span>&#125;;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>);        <span class="comment">// ['a', 'b', obj, 'e']</span></span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>);        <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure><p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">        <span class="keyword">super</span>(args);</span><br><span class="line">        <span class="keyword">this</span>[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">        <span class="keyword">super</span>(args);</span><br><span class="line">    &#125;</span><br><span class="line">    get [<span class="built_in">Symbol</span>.isConcatSpreadable]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> A1();</span><br><span class="line">a1[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">a1[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> A2();</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(a1).concat(a2)    <span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br></pre></td></tr></table></figure><p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p><p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p><h4 id="3-Symbol-species"><a href="#3-Symbol-species" class="headerlink" title="3. Symbol.species"></a>3. Symbol.species</h4><p>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> b = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x);</span><br><span class="line"><span class="keyword">const</span> c = a.filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">b.instanceof MyArray;           <span class="comment">// true</span></span><br><span class="line">c <span class="keyword">instanceof</span> MyArray;           <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，<code>a</code>是<code>MyArray</code>的实例，<code>b</code>和<code>c</code>是<code>a</code>的衍生对象。你可能会认为，<code>b</code>和<code>c</code>都是调用数组方法生成的，所以应该是数组(<code>Array</code>的实例)，但实际上它们也是<code>MyArray</code>的实例。</p><p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。现在，我们可以为<code>MyArray</code>设置<code>Symbol.species</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="title">extens</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，由于定义了<code>Symbol.species</code>属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>取值器。默认的<code>Symbol.species</code>属性等同于下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，再来看前面的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> MyArray();</span><br><span class="line"><span class="keyword">const</span> b = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x);</span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> MyArray        <span class="comment">// false</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Array</span>          <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a.map(x =&gt; x)</code>生成的衍生对象，就不是<code>MyArray</code>的实例，而直接就是<code>Array</code>的实例。</p><p>再看一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T2</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> T1(<span class="function"><span class="params">r</span> =&gt;</span> r()).then(<span class="function"><span class="params">v</span> =&gt;</span> v) <span class="keyword">instanceof</span> T1     <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> T2(<span class="function"><span class="params">r</span> =&gt;</span> r()).then(<span class="function"><span class="params">v</span> =&gt;</span> v) <span class="keyword">instanceof</span> T2     <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>T2</code>定义了<code>Symbol.species</code>属性，<code>T1</code>没有。结果就导致了创建衍生对象时（<code>then</code>方法），<code>T1</code>调用的是自身的构造方法，而<code>T2</code>调用的是<code>Promise</code>的构造方法。</p><p>总之，<code>Symbol.species</code>的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的作用是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p><h4 id="4-Symbol-match"><a href="#4-Symbol-match" class="headerlink" title="4. Symbol.match"></a>4. Symbol.match</h4><p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.match(regexp)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">regexp[<span class="built_in">Symbol</span>.match](<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMatcher</span> </span>&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.match](string) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span>.indexOf(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'e'</span>.match(<span class="keyword">new</span> MyMatcher())      <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="5-Symbol-replace"><a href="#5-Symbol-replace" class="headerlink" title="5. Symbol.replace"></a>5. Symbol.replace</h4><p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.replace(searchValue, replaceValue)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">searchValue[<span class="built_in">Symbol</span>.replace](<span class="keyword">this</span>, replaceValue)</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123;&#125;;</span><br><span class="line">x[<span class="built_in">Symbol</span>.replace] = <span class="function">(<span class="params">...s</span>) =&gt;</span> <span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="string">'Hello'</span>.replace(x, <span class="string">'World'</span>)     <span class="comment">// ['Hello', 'World']</span></span><br></pre></td></tr></table></figure><p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p><h4 id="6-Symbol-search"><a href="#6-Symbol-search" class="headerlink" title="6. Symbol.search"></a>6. Symbol.search</h4><p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.search(regexp)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">regexp[<span class="built_in">Symbol</span>.search](<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.search](string) &#123;</span><br><span class="line">        <span class="keyword">return</span> string.indexOf(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'foobar'</span>.search(<span class="keyword">new</span> MySearch(<span class="string">'foo'</span>))    <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h4 id="7-Symbol-split"><a href="#7-Symbol-split" class="headerlink" title="7. Symbol.split"></a>7. Symbol.split</h4><p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.split(separator, limit)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">separator[<span class="built_in">Symbol</span>.split](<span class="keyword">this</span>, limit)</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySpliter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.split](string) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = string.indexOf(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> string;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            string.substr(<span class="number">0</span>, index),</span><br><span class="line">            string.substr(index + <span class="keyword">this</span>.value.length)</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySeperator(<span class="string">'foo'</span>))      <span class="comment">// ['', 'bar']</span></span><br><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySeperator(<span class="string">'bar'</span>))      <span class="comment">// ['foo', '']</span></span><br><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySeperator(<span class="string">'baz'</span>))      <span class="comment">// 'foobar'</span></span><br></pre></td></tr></table></figure><p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为。</p><h4 id="8-Symbol-iterator"><a href="#8-Symbol-iterator" class="headerlink" title="8. Symbol.iterator"></a>8. Symbol.iterator</h4><p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable]     <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>[i] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">this</span>[i];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myCollection = <span class="keyword">new</span> Collection();</span><br><span class="line">myCollection[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">myCollection[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myCollection) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="9-Symbol-toPrimitive"><a href="#9-Symbol-toPrimitive" class="headerlink" title="9. Symbol.toPrimitive"></a>9. Symbol.toPrimitive</h4><p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p><p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p><ul><li><p>Number：该场合需要转成数值</p></li><li><p>String：该场合需要转成字符串</p></li><li><p>Default：该场合可以转成数值，也可以转成字符串</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(hint) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'str'</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'default'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'default'</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> * obj             <span class="comment">// 246，Number模式</span></span><br><span class="line"><span class="number">3</span> + obj             <span class="comment">// '3default'，Default模式</span></span><br><span class="line">obj == <span class="string">'default'</span>    <span class="comment">// true，Default模式</span></span><br><span class="line"><span class="built_in">String</span>(obj)         <span class="comment">// 'str'，String模式</span></span><br></pre></td></tr></table></figure><h4 id="10-Symbol-toStringTag"><a href="#10-Symbol-toStringTag" class="headerlink" title="10. Symbol.toStringTag"></a>10. Symbol.toStringTag</h4><p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法，在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line">(&#123;[<span class="built_in">Symbol</span>.toStringTag]: <span class="string">'Foo'</span>&#125;.toString())  <span class="comment">// "[object Foo]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    get [<span class="built_in">Symbol</span>.toStringTag]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'xxx'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> Collection();</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(x)           <span class="comment">// "[object xxx]"</span></span><br></pre></td></tr></table></figure><p>ES6新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p><ul><li><p><code>JSON[Symbol.toStringTag]</code>: ‘JSON’</p></li><li><p><code>Math[Symbol.toStringTag]</code>: ‘Math’</p></li><li><p>Module对象<code>M[Symbol.toStringTag]</code>: ‘Module’</p></li><li><p><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>: ‘ArrayBuffer’</p></li><li><p><code>DataView.prototype[Symbol.toStringTag]</code>: ‘DataView’</p></li><li><p><code>Map.prototype[Symbol.toStringTag]</code>: ‘Map’</p></li><li><p><code>Promise.prototype[Symbol.toStringTag]</code>: ‘Promise’</p></li><li><p><code>Set.prototype[Symbol.toStringTag]</code>: ‘Set’</p></li><li><p><code>%TypedArray%.prototype[Symbol.toStringTag]</code>: ‘Uint8Array’等</p></li><li><p><code>WeakMap.prototype[Symbol.toStringTag]</code>: ‘WeakMap’</p></li><li><p><code>WeakSet.prototype[Symbol.toStringTag]</code>: ‘WeakSet’</p></li><li><p><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>: ‘Map Iterator’</p></li><li><p><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>: ‘Set Iterator’</p></li><li><p><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>: ‘String Iterator’</p></li><li><p><code>Symbol.prototype[Symbol.toStringTag]</code>: ‘Symbol’</p></li><li><p><code>Generator.prototype[Symbol.toStringTag]</code>: ‘Generator’</p></li><li><p><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>: ‘GeneratorFunction’</p></li></ul><h4 id="11-Symbol-unscopables"><a href="#11-Symbol-unscopables" class="headerlink" title="11. Symbol.unscopables"></a>11. Symbol.unscopables</h4><p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables]</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//      copeWithin: true,</span></span><br><span class="line"><span class="comment">//      entries: true,</span></span><br><span class="line"><span class="comment">//      fill: true,</span></span><br><span class="line"><span class="comment">//      find: true,</span></span><br><span class="line"><span class="comment">//      findIndex: true,</span></span><br><span class="line"><span class="comment">//      includes: true,</span></span><br><span class="line"><span class="comment">//      keys: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(<span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables])</span><br><span class="line"><span class="comment">// ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'includes', 'keys']</span></span><br></pre></td></tr></table></figure><p>上面代码说明，数组有7个属性，会被<code>with</code>命令排除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有unscopables时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    foo() &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (MyClass.prototype) &#123;</span><br><span class="line">    foo();          <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有unscopables时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    foo() &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    get [<span class="built_in">Symbol</span>.unscopables]() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">foo</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (Myclass.prototype) &#123;</span><br><span class="line">    foo();          <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/symbol">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中&lt;code&gt;Symbol&lt;/code&gt;的语法及使用方法。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/symbol&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(5) Module的加载实现</title>
    <link href="http://www.xiaoleon.cn/2018/05/19/es6-5/"/>
    <id>http://www.xiaoleon.cn/2018/05/19/es6-5/</id>
    <published>2018-05-19T15:13:05.000Z</published>
    <updated>2018-05-22T15:05:13.529Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中<code>Module</code>的语法及使用方法。节选自<a href="(http://es6.ruanyifeng.com/#docs/module-loader">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、浏览器加载"><a href="#一、浏览器加载" class="headerlink" title="一、浏览器加载"></a>一、浏览器加载</h3><h4 id="1-传统方法"><a href="#1-传统方法" class="headerlink" title="1. 传统方法"></a>1. 传统方法</h4><p>HTML网页中，浏览器通过<code>&lt;script&gt;</code>标签加载JavaScript脚本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面内嵌的脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// module code</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于浏览器脚本的默认语言是JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。</p><p>默认情况下，浏览器是同步加载JavaScript脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/myModule.js"</span> defer&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"path/to/myModule.js"</span> <span class="keyword">async</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>和<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p><p><code>defer</code>与<code>async</code>的区别是：<code>defer</code>要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行；<code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</p><h4 id="2-加载规则"><a href="#2-加载规则" class="headerlink" title="2. 加载规则"></a>2. 加载规则</h4><p>浏览器加载ES6模块，也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个ES6模块。</p><p>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面中出现的顺序依次执行。</p><p><code>&lt;script&gt;</code>标签的<code>async</code>属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一旦使用了<code>async</code>属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</p><p>ES6模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'./utils.js'</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// other code</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p><ul><li><p>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</p></li><li><p>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</p></li><li><p>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对URL或者相对URL），也可以使用<code>export</code>命令输出对外接口。</p></li><li><p>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</p></li><li><p>同一个模块如果加载多次，将只执行一次。</p></li></ul><p>下面是一个示例模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'https://example.com/js/utils.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="built_in">window</span>.x);        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="literal">undefined</span>);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在ES6模块之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotModuleScript = <span class="keyword">this</span> !== <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="二、ES6模块与CommonJS模块的差异"><a href="#二、ES6模块与CommonJS模块的差异" class="headerlink" title="二、ES6模块与CommonJS模块的差异"></a>二、ES6模块与CommonJS模块的差异</h3><p>讨论Node加载ES6之前，必须了解ES6模块与CommonJS模块完全不同。</p><p>它们有两个重大差异。</p><ul><li><p>CommonJS模块输出的是一个拷贝，ES6模块输出的是值的引用。</p></li><li><p>CommonJS模块是运行时加载，ES6模块是编译时输出接口。</p></li></ul><p>第二个差异是因为CommonJS加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本完全运行完才会生成。而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>下面重点解释第一个差异。</p><p>CommonJS模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件<code>lib.js</code>的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码输出内部变量<code>counter</code>和改写这个变量的内部方法<code>incCounter</code>。然后，在<code>main.js</code>里面加载这个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);     <span class="comment">// 3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  get counter() &#123;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;,</span><br><span class="line">  incCounter: incCounter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，输出的<code>counter</code>属性实际上是一个取值器函数。现在再执行<code>main.js</code>，就可以正确读取内部变量<code>counter</code>的变动了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node main.js</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>ES6模块的运行机制与CommonJS不一样。JS引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6的<code>import</code>有点像Unix系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p><p>还是举上面的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;counter, incCounter&#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter);       <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter);       <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>上面代码说明，ES6模块输入的<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p><p>再举一个出现在<code>export</code>一节中的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// m2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./m1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(foo), <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>m1.js</code>的变量<code>foo</code>，在刚加载的时候等于<code>bar</code>，过了500毫秒，又变为等于<code>baz</code>。</p><p>让我们看看，<code>m2.js</code>是否正确读取这个变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">babel-node m2.js</span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure><p>上面代码表明，ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p><p>由于ES6输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;obj&#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">123</span>;       <span class="comment">// ok</span></span><br><span class="line">obj = &#123;&#125;;             <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>main.js</code>从<code>lib.js</code>输入变量<code>obj</code>，可以对<code>obj</code>添加属性，但是重新赋值就会报错。因为变量<code>obj</code>指向的地址是只读的，不能重新赋值，这就好比<code>main.js</code>创造了一个名为<code>obj</code>的<code>const</code>变量。</p><p>最后，<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sum += <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.sum);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br></pre></td></tr></table></figure><p>上面的脚本<code>mod.js</code>，输出的是一个<code>c</code>的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">'./mod'</span>;</span><br><span class="line">c.add();</span><br><span class="line"></span><br><span class="line"><span class="comment">// y.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">'./mod'</span>;</span><br><span class="line">c.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./x'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./y'</span>;</span><br></pre></td></tr></table></figure><p>现在执行<code>main.js</code>，输出的是<code>1</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">babel-node main.js</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>这就证明了<code>x.js</code>和<code>y.js</code>加载的都是<code>c</code>的同一个实例。</p><hr><h3 id="三、Node加载"><a href="#三、Node加载" class="headerlink" title="三、Node加载"></a>三、Node加载</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>Node对ES6模块的处理比较麻烦，因为它有自己的CommonJS模块格式，与ES6模块格式是不兼容的。目前的解决方案是，将两者分开，ES6模块和CommonJS采用各自的加载方案。</p><p>Node要求ES6模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，那么就必须采用<code>.mjs</code>后缀名。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错。只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。</p><p>目前，这项功能还在试验阶段。安装Node V8.5.0或以上版本，要用<code>--experimental-modules</code>参数才能打开该功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --experimental-modules my-app.mjs</span><br></pre></td></tr></table></figure><p>为了与浏览器的<code>import</code>加载规则相同，Node的<code>.mjs</code>文件支持URL路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./foo?query=1'</span>;   <span class="comment">// 加载 ./foo 传入参数 ?query=1</span></span><br></pre></td></tr></table></figure><p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node会按URL规则来解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。</p><p>目前，Node的<code>import</code>命令只支持加载本地模块（<code>file:</code>协议），不支持加载远程模块。</p><p>如果模块名不含路径，那么<code>import</code>命令会去<code>node_modules</code>目录寻找这个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'baz'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'abc/123'</span>;</span><br></pre></td></tr></table></figure><p>如果模块包含路径，那么<code>import</code>命令会按照路径去寻找这个名字的脚本文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'file:///etc/config/app.json'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./foo'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./foo?search'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../bar'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'/baz'</span>;</span><br></pre></td></tr></table></figure><p>如果脚本文件省略了后缀名，比如<code>import &#39;./foo&#39;</code>，Node会依次尝试四个后缀名：<code>./foo.mjs</code>、<code>./foo.js</code>、<code>./foo.json</code>、<code>./foo.node</code>。如果这些脚本文件都不存在，Node就会去加载<code>./foo/package.json</code>的<code>main</code>字段指定的脚本。如果<code>./foo/package.json</code>不存在或者没有<code>main</code>字段，那么就会依次加载<code>./foo/index.mjs</code>、<code>./foo/index.js</code>、<code>./foo/index.json</code>、<code>./foo/index.node</code>。如果以上四个文件还是都不存在，就会抛出错误。</p><p>最后，Node的<code>import</code>命令是异步加载，这一点与浏览器的处理方法相同。</p><h4 id="2-内部变量"><a href="#2-内部变量" class="headerlink" title="2. 内部变量"></a>2. 内部变量</h4><p>ES6模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node规定ES6模块之中不能使用CommonJS模块的特有的一些内部变量。</p><p>首先，就是<code>this</code>关键字。ES6模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</p><p>其次，以下这些顶层变量在ES6模块之中都是不存在的。</p><ul><li><p><code>arguments</code></p></li><li><p><code>require</code></p></li><li><p><code>module</code></p></li><li><p><code>exports</code></p></li><li><p><code>__filename</code></p></li><li><p><code>__dirname</code></p></li></ul><p>如果一定要使用这些变量，有一个变通方法，就是写一个CommonJS模块输出这些变量，然后再用ES6模块加载这个CommonJS模块。但是这样一来，该ES6模块就不能直接用于浏览器环境了，所以不推荐这么做。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expose.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;__dirname&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use.mjs</span></span><br><span class="line"><span class="keyword">import</span> expose <span class="keyword">from</span> <span class="string">'./expose.js'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123;__dirname&#125; = expose;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>expose.js</code>是一个CommonJS模块，输出变量<code>__dirname</code>，该变量在ES6模块之中不存在。ES6模块加载<code>expose.js</code>，就可以得到<code>__dirname</code>。</p><h4 id="3-ES6模块加载CommonJS模块"><a href="#3-ES6模块加载CommonJS模块" class="headerlink" title="3. ES6模块加载CommonJS模块"></a>3. ES6模块加载CommonJS模块</h4><p>CommonJS模块的输出都定义在<code>module.exports</code>这个属性上面。Node的<code>import</code>命令加载CommonJS模块，Node会自动将<code>module.exports</code>属性，当作模块的默认输出，即等同于<code>export default xxx</code>。</p><p>下面是一个CommonJS模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span>,</span><br><span class="line">  bar: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span>,</span><br><span class="line">  bar: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>import</code>命令加载上面的模块，<code>module.exports</code>会被视为默认输出，即<code>import</code>命令实际上输入的是这样一个对象<code>{default: module.exports}</code>。</p><p>所以，一共有三种写法，可以拿到CommonJS模块的<code>module.exports</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">import</span> baz <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="comment">// baz = &#123;foo: 'hello', bar: 'world'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> baz&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="comment">// baz = &#123;foo: 'hello', bar: 'world'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> baz <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="comment">// baz = &#123;</span></span><br><span class="line"><span class="comment">//    get default() &#123;return module.exports&#125;,</span></span><br><span class="line"><span class="comment">//    get foo() &#123;return this.default.foo&#125;.bind(baz),</span></span><br><span class="line"><span class="comment">//    get bar() &#123;return this.default.bar&#125;.bind(baz)  </span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码的第三种写法，可以通过<code>baz.default</code>拿到<code>module.exports</code>。<code>foo</code>属性和<code>bar</code>属性就是可以通过这种方法拿到了<code>module.exports</code>。</p><p>下面是一些例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="comment">// foo = null;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bar <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="comment">// bar = &#123;default: null&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>es.js</code>采用第二种写法时，要通过<code>bar.default</code>这样的写法，才能拿到<code>module.exports</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'./c'</span>;</span><br><span class="line">foo();      <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bar <span class="keyword">from</span> <span class="string">'./c'</span>;</span><br><span class="line">bar.default();    <span class="comment">// 2</span></span><br><span class="line">bar();            <span class="comment">// throws, bar is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>bar</code>本身是一个对象，不能当做函数调用，只能通过<code>bar.default</code>调用。</p><p>CommonJS模块的输出缓存机制，在ES6加载方式下依然有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="number">123</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">module</span>.exports = <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，对于加载<code>foo.js</code>的脚本，<code>module.exports</code>将一直是<code>123</code>，而不会变成<code>null</code>。</p><p>由于ES6模块是编译时确定输出接口，CommonJS模块是运行时确定输出接口，所以采用<code>import</code>命令加载CommonJS模块时，不允许采用下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不正确</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure><p>上面的写法不正确，因为<code>fs</code>是CommonJS格式，只有在运行时才能确定<code>readFile</code>接口，而<code>import</code>命令要求编译时就确定这个接口。解决方法就是改为整体输入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法一</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">const</span> app = express.default();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确地写法二</span></span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br></pre></td></tr></table></figure><h4 id="4-CommonJS模块加载ES6模块"><a href="#4-CommonJS模块加载ES6模块" class="headerlink" title="4. CommonJS模块加载ES6模块"></a>4. CommonJS模块加载ES6模块</h4><p>CommonJS模块加载ES6模块，不能使用<code>require</code>命令，而要用<code>import()</code>函数。ES6模块的所有输出接口，会成为输入对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es.mjs</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123;<span class="attr">bar</span>: <span class="string">'my-default'</span>&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="keyword">const</span> es_namespace = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./es.mjs'</span>);</span><br><span class="line"><span class="comment">// es_namespace = &#123;</span></span><br><span class="line"><span class="comment">//    get default() &#123;</span></span><br><span class="line"><span class="comment">//      ...</span></span><br><span class="line"><span class="comment">//    &#125; </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(es_namespace.default);</span><br><span class="line"><span class="comment">// &#123;bar: 'my-default'&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>default</code>接口变成了<code>es_namespace.default</code>属性。</p><p>下面是另一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = &#123;<span class="attr">bar</span>: <span class="string">'my-default'</span>&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123;foo <span class="keyword">as</span> bar&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">c</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="keyword">const</span> es_namespace = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./es'</span>);</span><br><span class="line"><span class="comment">// es_namespace = &#123;</span></span><br><span class="line"><span class="comment">//   get foo() &#123;return foo;&#125;</span></span><br><span class="line"><span class="comment">//   get bar() &#123;return foo;&#125;</span></span><br><span class="line"><span class="comment">//   get f() &#123;return f;&#125;</span></span><br><span class="line"><span class="comment">//   get c() &#123;return c;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、循环加载"><a href="#四、循环加载" class="headerlink" title="四、循环加载"></a>四、循环加载</h3><p>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p><p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</p><p>对于JavaScript语言来说，目前最常见的两种模块格式CommonJS和ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p><h4 id="1-CommonJS模块的加载原理"><a href="#1-CommonJS模块的加载原理" class="headerlink" title="1. CommonJS模块的加载原理"></a>1. CommonJS模块的加载原理</h4><p>介绍ES6如何处理“循环加载”之前，先介绍目前最流行的CommonJS模块格式的加载原理。</p><p>CommonJS的一个模块，就是一个脚本。<code>require</code>命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: <span class="string">'...'</span>,</span><br><span class="line">  exports: &#123;...&#125;,</span><br><span class="line">  loaded: <span class="literal">true</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是Node内部加载模块后生成的一个对象。该对象的<code>id</code>属性是模块名，<code>exports</code>属性是模块输出的各个接口，<code>loaded</code>属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p><p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。即使再次执行<code>require</code>命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p><h4 id="2-CommonJS模块的循环加载"><a href="#2-CommonJS模块的循环加载" class="headerlink" title="2. CommonJS模块的循环加载"></a>2. CommonJS模块的循环加载</h4><p>CommonJS模块的重要特性是加载时执行，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p><p>让我们来看，Node官方文档里面的例子。脚本文件<code>a.js</code>代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在a.js之中，b.done = %j'</span>, b.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.js执行完毕'</span>);</span><br></pre></td></tr></table></figure><p>上面代码之中，<code>a.js</code>脚本先输出一个<code>done</code>变量，然后加载另一个脚本文件<code>b.js</code>。注意，此时<code>a.js</code>代码就停在这里，等待<code>b.js</code>执行完毕，再往下执行。</p><p>再看<code>b.js</code>的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在b.js之中，a.done = %j'</span>, a.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.js执行完毕'</span>);</span><br></pre></td></tr></table></figure><p>上面代码之中，<code>b.js</code>执行到第二行，就会去加载<code>a.js</code>，这时，就发生了“循环加载”。系统会去<code>a.js</code>模块对应对象的<code>exports</code>属性取值，可是因为<code>a.js</code>还没有执行完，从<code>exports</code>属性只能取回已经执行的部分，而不是最后的值。</p><p><code>a.js</code>已经执行的部分，只有一行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports.done = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>因此，对于<code>b.js</code>来说，它从<code>a.js</code>只输入一个变量<code>done</code>，值为<code>false</code>。</p><p>然后，<code>b.js</code>接着往下执行，等到全部执行完毕，再把执行权交还给<code>a.js</code>。于是，<code>a.js</code>接着往下执行，直到执行完毕。我们写一个脚本<code>main.js</code>，验证这个过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在main.js之中，a.done=%j，b.done=%j'</span>, a.done, b.done);</span><br></pre></td></tr></table></figure><p>执行<code>main.js</code>，运行结果如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node main.js</span><br><span class="line"></span><br><span class="line">在b.js之中，a.done = <span class="literal">false</span></span><br><span class="line">b.js执行完毕</span><br><span class="line">在a.js之中，b.done = <span class="literal">true</span></span><br><span class="line">a.js执行完毕</span><br><span class="line">在main.js之中，a.done=<span class="literal">true</span>, b.done=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面的代码证明了两件事。一是，在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。二是，<code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，二是输出缓存的<code>b.js</code>的执行结果，即它的第四行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports.done = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>总之，CommonJS输入的是被输出值的拷贝，不是引用。</p><p>另外，由于CommonJS模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>);           <span class="comment">// 安全的写法</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">'a'</span>).foo;     <span class="comment">// 危险的写法</span></span><br><span class="line"></span><br><span class="line">exports.good = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.foo(<span class="string">'good'</span>, arg);    <span class="comment">// 使用的是a.foo的最新值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.bad = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo(<span class="string">'bad'</span>, arg);       <span class="comment">// 使用的是一个部分加载时的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点。</p><h4 id="3-ES6模块的循环加载"><a href="#3-ES6模块的循环加载" class="headerlink" title="3. ES6模块的循环加载"></a>3. ES6模块的循环加载</h4><p>ES6处理“循环加载”与CommonJS有本质的不同。ES6模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from &#39;foo&#39;</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">'bar'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node --experimental-modules a.mjs</span><br><span class="line"></span><br><span class="line">b.mjs</span><br><span class="line"><span class="built_in">ReferenceError</span>: foo is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？</p><p>让我们一行行来看，ES6循环加载是怎么处理的。首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。</p><p>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">'foo'</span>;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">'bar'</span>;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;bar&#125;;</span><br></pre></td></tr></table></figure><p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node --experimental-modules a.mjs</span><br><span class="line"></span><br><span class="line">b.mjs</span><br><span class="line">foo</span><br><span class="line">a.mjs</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>这是因为函数具有提升作用，在执行<code>import {bar} from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。这也意味着，如果把函数<code>foo</code>改写成函数表达式，也会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar());</span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。</p><p>我们再看看ES6模块加载器SystemJS给出的一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;odd&#125; <span class="keyword">from</span> <span class="string">'./odd'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n === <span class="number">0</span> || odd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;even&#125; <span class="keyword">from</span> <span class="string">'./even'</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">odd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n !== <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于0，就会减去1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p><p>运行上面这段代码，结果如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">node</span><br><span class="line">&gt; <span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">'./even.js'</span>;</span><br><span class="line">&gt; m.even(<span class="number">10</span>);</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.counter;</span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt; m.even(<span class="number">20</span>);</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">m.counter</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>n</code>从10变为0的过程中，<code>even()</code>一共会执行6次，所以变量<code>counter</code>等于6。第二次调用<code>even()</code>时，参数<code>n</code>从20变为0，<code>even()</code>一共会执行11次，加上前面的6次，所以变量<code>counter</code>等于17。</p><p>这个例子要是改写成CommonJS，就根本无法执行，会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">'./odd'</span>);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">exports.counter = counter;</span><br><span class="line">exports.even = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">'./even'</span>).even;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n !== <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分（不存在任何结果），所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node</span><br><span class="line">&gt; <span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">'./even'</span>);</span><br><span class="line">&gt; m.even(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">TypeError</span>: even is not a <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="五、ES6模块的转码"><a href="#五、ES6模块的转码" class="headerlink" title="五、ES6模块的转码"></a>五、ES6模块的转码</h3><p>浏览器目前还不支持ES6模块，为了现在就能使用，可以将其转为ES5的写法。除了Babel可以用来转码之外，还有以下两个方法，也可以用来转码。</p><h4 id="1-ES6-module-transpiler"><a href="#1-ES6-module-transpiler" class="headerlink" title="1. ES6 module transpiler"></a>1. ES6 module transpiler</h4><p>ES6 module transpiler是square公司开源的一个转码器，可以将ES6模块转为CommonJS模块或AMD模块的写法，从而在浏览器中使用。</p><p>首先，安装这个转码器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g es6-<span class="built_in">module</span>-transpiler</span><br></pre></td></tr></table></figure><p>然后，使用<code>compile-modules convert</code>命令，将ES6模块文件转码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile modules convert file1.js file2.js</span><br></pre></td></tr></table></figure><p><code>-o</code>参数可以指定转码后的文件名。</p><h4 id="2-SystemJS"><a href="#2-SystemJS" class="headerlink" title="2. SystemJS"></a>2. SystemJS</h4><p>另一种解决方法是使用SystemJS。它是一个垫片库（polyfill），可以在浏览器内加载ES6模块、AMD模块和CommonJS模块，将其转为ES5格式。它在后台调用的是Google和Traceur转码器。</p><p>使用时，先在网页内载入<code>system.js</code>文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"system.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，使用<code>System.import</code>方法加载模块文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  System.import(<span class="string">'./app.js'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中的<code>./app</code>，指的是当前目录下的app.js文件。它可以是ES6模块文件，<code>System.import</code>会自动将其转码。</p><p>需要注意的是，<code>System.import</code>使用异步加载，返回一个Promise对象，可以针对这个对象编程。下面是一个模块文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/es6-file.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">q</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.es6 = <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在网页内加载这个模块文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  System.import(<span class="string">'app/es6-file'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">new</span> m.q().es6);     <span class="comment">// hello</span></span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>System.import</code>方法返回的是一个Promise对象，所以可以用<code>then</code>方法指定回调函数。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/module-loader">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中&lt;code&gt;Module&lt;/code&gt;的语法及使用方法。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/module-loader&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(4) Module的语法</title>
    <link href="http://www.xiaoleon.cn/2018/05/18/es6-4/"/>
    <id>http://www.xiaoleon.cn/2018/05/18/es6-4/</id>
    <published>2018-05-18T13:59:58.000Z</published>
    <updated>2018-05-19T06:29:45.313Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中<code>Module</code>的语法及使用方法。节选自<a href="(http://es6.ruanyifeng.com/#docs/module">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>历史上，JavaScript一直没有模块（module）体系，无法讲一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的<code>require</code>、Python的<code>import</code>，甚至就连CSS都有<code>@import</code>，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123;stat, exists, readfile&#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取3个方法。这种加载成为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p><p>ES6模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;stat, exists, readfile&#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure><p>上面代码的实质是从<code>fs</code>模块加载了3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即ES6可以再编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。</p><p>由于ES6模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽JavaScript的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p><p>除了静态加载带来的各种好处，ES6模块还有以下好处。</p><ul><li><p>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这一点。</p></li><li><p>将来浏览器的新API就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</p></li><li><p>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</p></li></ul><hr><h3 id="二、严格模式"><a href="#二、严格模式" class="headerlink" title="二、严格模式"></a>二、严格模式</h3><p>ES6的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p><p>严格模式主要有以下限制：</p><ul><li><p>变量必须声明后再使用</p></li><li><p>函数的参数不能有同名属性，否则报错</p></li><li><p>不能使用<code>with</code>语句</p></li><li><p>不能对只读属性赋值，否则报错</p></li><li><p>不能使用前缀<code>0</code>表示八进制数，否则报错</p></li><li><p>不能删除不可删除的属性，否则报错</p></li><li><p>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></p></li><li><p><code>eval</code>不会在它的外层作用域引入变量</p></li><li><p><code>eval</code>和<code>arguments</code>不能被重新赋值</p></li><li><p><code>arguments</code>不会自动反映函数参数的变化</p></li><li><p>不能使用<code>arguments.callee</code></p></li><li><p>不能使用<code>arguments.caller</code></p></li><li><p>禁止<code>this</code>指向全局对象</p></li><li><p>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</p></li><li><p>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</p></li></ul><p>上面这些限制，模块都必须遵守。由于严格模式是ES5引入的，不属于ES6，所以请参阅相关ES5书籍。</p><p>其中，尤其需要注意<code>this</code>的限制。ES6模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code>。</p><hr><h3 id="三、export命令"><a href="#三、export命令" class="headerlink" title="三、export命令"></a>三、export命令</h3><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个JS文件，里面使用<code>export</code>命令输出变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br></pre></td></tr></table></figure><p>上面的代码是<code>profile.js</code>文件，保存了用户信息。ES6将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p><p><code>export</code>的写法，除了像上面这样，还有另外一种。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在<code>var</code>语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p><p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码对外输出一个函数<code>multiply</code>。</p><p>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p><p>需要特别注意的是，<code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> m;</span><br></pre></td></tr></table></figure><p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量<code>m</code>，还是直接输出1。<code>1</code>只是一个值，不是接口。正确地写法是下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br></pre></td></tr></table></figure><p>上面三种写法都是正确的，规定了对外的接口<code>m</code>。其他脚本可以通过这个接口，取到值<code>1</code>。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p><p>同样的，<code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;f&#125;;</span><br></pre></td></tr></table></figure><p>另外，<code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500毫秒之后变成<code>baz</code>。</p><p>这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新。</p><p>最后，<code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'bar'</span>      <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>上面代码中，<code>export</code>语法放在函数之中，结果报错。</p><hr><h3 id="四、import命令"><a href="#四、import命令" class="headerlink" title="四、import命令"></a>四、import命令</h3><p>使用<code>export</code>命令定义了模块的对外接口以后，其他JS文件就可以通过<code>import</code>命令加载这个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  element.textContent = firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<code>import</code>命令，用于加载<code>profile.js</code>文件，并从中输入变量。<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p><p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;lastName <span class="keyword">as</span> surname&#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br></pre></td></tr></table></figure><p><code>import</code>命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在家在模块的脚本里面，改写接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./xxx.js'</span>;</span><br><span class="line"></span><br><span class="line">a = &#123;&#125;;           <span class="comment">// Syntax Error: 'a' is read-only</span></span><br></pre></td></tr></table></figure><p>上面代码中，脚本加载了变量<code>a</code>，对其重新赋值就会报错，因为<code>a</code>是一个只读的接口。但是，如果<code>a</code>是一个对象，改写<code>a</code>的属性是允许的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./xxx.js'</span>;</span><br><span class="line"></span><br><span class="line">a.foo = <span class="string">'hello'</span>;      <span class="comment">// 合法操作</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a</code>的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当做完全只读，轻易不要改变它的属性。</p><p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径，<code>.js</code>后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉JavaScript引擎该模块的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;myMethod&#125; <span class="keyword">from</span> <span class="string">'util'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>util</code>是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p><p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure><p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</p><p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="string">'f'</span> + <span class="string">'oo'</span>&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'module1'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'module2'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种写法都会报错，因为它们用到了表达式、变量和<code>if</code>结构。在静态分析阶段，这些语法都是没法得到值的。</p><p>最后，<code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure><p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p><p>如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure><p>上面代码加载了两次<code>lodash</code>，但是只会执行一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，虽然<code>foo</code>和<code>bar</code>在两个语句中加载，但是它们对应的是同一个<code>my_module</code>实例。也就是说，<code>import</code>语句是Singleton模式。</p><p>目前阶段，通过Babel转码，CommonJS模块的<code>require</code>命令和ES6模块的<code>import</code>命令，可以写在同一个模块里面，但是最好不要这么做。因为<code>import</code>在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/modules/es6.symbol'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/modules/es6.promise'</span>);</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'React'</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="五、模块的整体加载"><a href="#五、模块的整体加载" class="headerlink" title="五、模块的整体加载"></a>五、模块的整体加载</h3><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p><p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，加载这个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;area, circumference&#125; <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure><p>上面写法是逐一指定要加载的方法，整体加载的写法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + circle.area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circle.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure><p>注意，模块整体加载所在的那个对象（上例是<code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两行都是不允许的</span></span><br><span class="line">circle.foo = <span class="string">'hello'</span>;</span><br><span class="line">circle.area = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="六、export-default命令"><a href="#六、export-default命令" class="headerlink" title="六、export default命令"></a>六、export default命令</h3><p>从前面的例子可以看出，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p><p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p><p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line">customName();     <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p><p><code>export default</code>命令用在非匿名函数前，也是可以的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者写成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>foo</code>函数的函数名<code>foo</code>，在模块外部是无效的。加载的时候，视同匿名函数加载。</p><p>下面比较一下默认输出和正常输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一组</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">'crc32'</span>;          <span class="comment">// 输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二组</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123;           <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;crc32&#125; <span class="keyword">from</span> <span class="string">'crc32'</span>;        <span class="comment">// 输入</span></span><br></pre></td></tr></table></figure><p>上面代码的两组写法，第一组是使用<code>export default</code>的，对应的<code>import</code>语句不需要使用大括号；第二组是不使用<code>export default</code>的，对应的<code>import</code>语句需要使用大括号。</p><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，<code>import</code>命令后面不用加大括号，因为只可能唯一对应<code>export default</code>命令。</p><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> foo&#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// import foo from 'modules';</span></span><br></pre></td></tr></table></figure><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>export default a</code>的含义是将变量<code>a</code>的值赋给变量<code>default</code>。所以，最后一种写法会报错。</p><p>同样的，因为<code>export default</code>命令的本质是将后面的值，赋给<code>default</code>变量，所以可以直接将一个值写在<code>export default</code>之后。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为<code>default</code>。</p><p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入<code>lodash</code>模块为例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure><p>如果想在一条<code>import</code>语句中，同时输入默认方法和其他接口，可以写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _, &#123;each, each <span class="keyword">as</span> forEach&#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure><p>对应上面代码的<code>export</code>语句如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;each <span class="keyword">as</span> forEach&#125;;</span><br></pre></td></tr></table></figure><p>上面代码和最后一行的意思是，暴露出<code>forEach</code>接口，默认指向<code>each</code>接口，即<code>forEach</code>和<code>each</code>指向同一个方法。</p><p><code>export default</code>也可以用来输出类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'MyClass'</span>;</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> MyClass();</span><br></pre></td></tr></table></figure><hr><h3 id="七、export与import的复合写法"><a href="#七、export与import的复合写法" class="headerlink" title="七、export与import的复合写法"></a>七、export与import的复合写法</h3><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;foo, bar&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>export</code>和<code>import</code>语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，<code>foo</code>和<code>bar</code>实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用<code>foo</code>和<code>bar</code>。</p><p>模块的接口改名和整体输出，也可以采用这种写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口改名</span></span><br><span class="line"><span class="keyword">export</span> &#123;foo <span class="keyword">as</span> myFoo&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体输出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure><p>默认接口的写法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span>&#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br></pre></td></tr></table></figure><p>具名接口改为默认接口的写法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;es6 <span class="keyword">as</span> <span class="keyword">default</span>&#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123;es6&#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br></pre></td></tr></table></figure><p>同样的，默认接口也可以改名为具名接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> es6&#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br></pre></td></tr></table></figure><p>下面三种<code>import</code>语句，没有对应的复合写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">from</span> someIdentifier <span class="keyword">from</span> <span class="string">'someModule'</span>;</span><br><span class="line"><span class="keyword">import</span> someIdentifier <span class="keyword">from</span> <span class="string">'someModule'</span>;</span><br><span class="line"><span class="keyword">import</span> someIdentifier, &#123;namedIdentifier&#125; <span class="keyword">from</span> <span class="string">'someModule'</span>;</span><br></pre></td></tr></table></figure><p>为了做到形式的对称，现在有提案，提出补上这三种复合写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> someIdentifier <span class="keyword">from</span> <span class="string">'someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> someIdentifier <span class="keyword">from</span> <span class="string">'someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> someIdentifier, &#123;namedIdentifier&#125; <span class="keyword">from</span> <span class="string">'someModule'</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="八、模块的继承"><a href="#八、模块的继承" class="headerlink" title="八、模块的继承"></a>八、模块的继承</h3><p>模块之间也可以继承。</p><p>假设有一个<code>circleplus</code>模块，继承了<code>circle</code>模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71827182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>export *</code>，表示再输出<code>circle</code>模块的所有属性和方法。注意，<code>export *</code>命令会忽略<code>circle</code>模块的<code>default</code>方法。然后，上面代码又输出了自定义的<code>e</code>变量和默认方法。</p><p>这时，也可以将<code>circle</code>的属性或方法，改名后再输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line"><span class="keyword">export</span> &#123;area <span class="keyword">as</span> circleArea&#125; <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br></pre></td></tr></table></figure><p>上面代码表示，只输出<code>circle</code>模块的<code>area</code>方法，且将其改名为<code>circleArea</code>。</p><p>加载上面模块的写法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">'circleplus'</span>;</span><br><span class="line"><span class="keyword">import</span> exp <span class="keyword">from</span> <span class="string">'circleplus'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exp(math.e));</span><br></pre></td></tr></table></figure><p>上面代码中的<code>import exp</code>表示，将<code>circleplus</code>模块的默认方法加载为<code>exp</code>方法。</p><hr><h3 id="九、跨模块常量"><a href="#九、跨模块常量" class="headerlink" title="九、跨模块常量"></a>九、跨模块常量</h3><p><code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.js 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> C = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.js 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(constants.A);       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(constants.B);       <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.js 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(A);                 <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(B);                 <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/db.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = &#123;</span><br><span class="line">  url: <span class="string">'http://my.couchdbserver.local:5984'</span>,</span><br><span class="line">  admin_username: <span class="string">'admin'</span>,</span><br><span class="line">  admin_password: <span class="string">'admin password'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constants/user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> users = [<span class="string">'root'</span>, <span class="string">'admin'</span>, <span class="string">'staff'</span>, <span class="string">'ceo'</span>, <span class="string">'chief'</span>, <span class="string">'moderator'</span>];</span><br></pre></td></tr></table></figure><p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/index.js</span></span><br><span class="line"><span class="keyword">export</span> &#123;db&#125; <span class="keyword">from</span> <span class="string">'./db'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;users&#125; <span class="keyword">from</span> <span class="string">'./users'</span>;</span><br></pre></td></tr></table></figure><p>使用的时候，直接加载<code>index.js</code>就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;db, users&#125; <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="十、import"><a href="#十、import" class="headerlink" title="十、import()"></a>十、import()</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p>前面介绍过，<code>import</code>命令会被JavaScript引擎静态分析，先于模块内的其他与句执行（<code>import</code>命令叫做“连接”）。所以，下面的代码会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> MyModule <span class="keyword">from</span> <span class="string">'./myModule'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报语法错误，而不是执行时错误。也就是说，<code>import</code>和<code>export</code>命令只能在模块的顶层，不能在代码块之中（比如，在<code>if</code>代码块之中，或在函数之中）。</p><p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代Node的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">'./'</span> + fileName;</span><br><span class="line"><span class="keyword">const</span> myModule = <span class="built_in">require</span>(path);</span><br></pre></td></tr></table></figure><p>上面的语句就是动态加载，<code>require</code>到底加载哪一个模块，只有运行时才知道。</p><p><code>import</code>命令做不到这一点。因此，有一个提案，建议引入<code>import()</code>函数，完成动态加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(specifier);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p><p><code>import()</code>返回一个Promise对象。下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">'main'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">`./section-modules/<span class="subst">$&#123;someVariable&#125;</span>.js`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.loadPageInfo(main);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    main.textContent = err.message;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于Node的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</p><h4 id="2-适用场合"><a href="#2-适用场合" class="headerlink" title="2. 适用场合"></a>2. 适用场合</h4><p>下面是<code>import()</code>的一些适用场合。</p><ul><li>1) 按需加载</li></ul><p><code>import()</code>可以在需要的时候，再加载某个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./dialogBox.js'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">dialogBox</span> =&gt;</span> &#123;</span><br><span class="line">      dialogBox.open();</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>import()</code>方法放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p><ul><li>2) 条件加载</li></ul><p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'moduleA'</span>).then(...);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'moduleB'</span>).then(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，如果满足条件，就加载模块A，否则加载模块B。</p><ul><li>3) 动态的模块路径</li></ul><p><code>import()</code>允许模块路径动态生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(f())</span><br><span class="line">  .then(...);</span><br></pre></td></tr></table></figure><p>上面代码中，根据函数<code>f()</code>的返回结果，加载不同的模块。</p><h4 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3. 注意点"></a>3. 注意点</h4><p><code>import()</code>加载模块成功以后，这个模块会作为一个对象，当作<code>then</code>方法的参数。因此，可以使用对象解构赋值的语句，获取输出接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./myModule.js'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123;export1, export2&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>export1</code>和<code>export2</code>都是<code>myModule.js</code>的输出接口，可以解构获得。</p><p>如果模块有<code>default</code>输出接口，可以用参数直接获得。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./myModule.js'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">myModule</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myModule.default);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面的代码也可以使用具名输入的形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./myModule.js'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>: theDefault&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(theDefault);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>如果想同时加载多个模块，可以采用下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./module1.js'</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./module2.js'</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./module3.js'</span>),</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[module1, module2, module3]</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>import()</code>也可以用在<code>async</code>函数之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> myModule = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./myModule.js'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;export1, export2&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./myModule.js'</span>);</span><br><span class="line">  <span class="keyword">const</span> [module1, module2, module3] = </span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">'./module1.js'</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">'./module2.js'</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">'./module3.js'</span>)</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/module">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中&lt;code&gt;Module&lt;/code&gt;的语法及使用方法。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/module&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(3) Iterator和for...of循环</title>
    <link href="http://www.xiaoleon.cn/2018/05/16/es6-3/"/>
    <id>http://www.xiaoleon.cn/2018/05/16/es6-3/</id>
    <published>2018-05-16T13:23:17.000Z</published>
    <updated>2018-05-19T06:29:24.280Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中<code>Iterator</code>遍历器和<code>for...of</code>循环方法。节选自<a href="(http://es6.ruanyifeng.com/#docs/iterator">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、Iterator（遍历器）的概念"><a href="#一、Iterator（遍历器）的概念" class="headerlink" title="一、Iterator（遍历器）的概念"></a>一、Iterator（遍历器）的概念</h3><p>JavaScript原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p><p>遍历器（<code>Iterator</code>）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署<code>Iterator</code>接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><p><code>Iterator</code>的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令<code>for...of</code>循环，<code>Iterator</code>接口主要供<code>for...of</code>消费。</p><p><code>Iterator</code>的遍历过程是这样的。</p><ul><li><p>1) 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p></li><li><p>2) 第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p></li><li><p>3) 第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p></li><li><p>4) 不断调用指针对象的<code>next</code>方法，知道它指向数据结构的结束位置。</p></li></ul><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p><p>下面是一个模拟<code>next</code>方法返回值的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"></span><br><span class="line">it.next()         <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line">it.next()         <span class="comment">// &#123;value: 'b', done: false&#125;</span></span><br><span class="line">it.next()         <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: arr[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个<code>makeIterator</code>函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组<code>[&#39;a&#39;, &#39;b&#39;]</code>执行这个函数，就会返回该数组的遍历器对象（即指针对象）<code>it</code>。</p><p>指针对象的<code>next</code>方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用<code>next</code>方法，指针就会指向数组的下一个成员。第一次调用，指向<code>a</code>；第二次调用，指向<code>b</code>。</p><p><code>next</code>方法返回一个对象，表示当前数据成员的信息。这个对象具有<code>value</code>和<code>done</code>两个属性，<code>value</code>属性返回当前位置的成员，<code>done</code>属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用<code>next</code>方法。</p><p>总之，调用指针对象的<code>next</code>方法，就可以遍历事先给定的数据结构。</p><p>对于遍历器对象来说，<code>done: false</code>和<code>value: undefined</code>属性都是可以省略的，因此上面的<code>makeIterator</code>函数可以简写成下面的形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++]&#125; :</span><br><span class="line">        &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>Iterator</code>只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = idMaker();</span><br><span class="line"></span><br><span class="line">it.next().value       <span class="comment">// 1</span></span><br><span class="line">it.next().value       <span class="comment">// 2</span></span><br><span class="line">it.next().value       <span class="comment">// 3</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">idMaker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>: index++, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，遍历器生成函数<code>idMaker</code>，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。</p><p>如果使用TypeScript的写法，遍历器接口（<code>Iterable</code>）、指针对象（<code>Iterator</code>）和<code>next</code>方法返回值的规格可以描述如下。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Iterable &#123;</span><br><span class="line">  [Symbol.iterator](): Iterator,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Iterator &#123;</span><br><span class="line">  next(value?: <span class="built_in">any</span>): IterationResult,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IterationResult &#123;</span><br><span class="line">  value: <span class="built_in">any</span>, done: <span class="built_in">boolean</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、默认Iterator接口"><a href="#二、默认Iterator接口" class="headerlink" title="二、默认Iterator接口"></a>二、默认Iterator接口</h3><p><code>Iterator</code>接口的目的，就是为所有的数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找<code>Iterator</code>接口。</p><p>一种数据结构只要部署了<code>Iterator</code>接口，我们就称这种数据结构是“可遍历的”（<code>iterable</code>）。</p><p>ES6规定，默认的<code>Iterator</code>接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（<code>iterable</code>）。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为<code>Symbol</code>的特殊值，所以要放在方括号内。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: <span class="number">1</span>,</span><br><span class="line">          done: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>是可遍历的（<code>iterable</code>），因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。</p><p>ES6的有些数据结构原生具备Iterator接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性，另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p><p>原生具备Iterator接口的数据结构如下：</p><ul><li><p>Array</p></li><li><p>Map</p></li><li><p>Set</p></li><li><p>String</p></li><li><p>TypedArray</p></li><li><p>函数的arguments对象</p></li><li><p>NodeList对象</p></li></ul><p>下面的例子是数组的<code>Symbol.iterator</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next()         <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line">iter.next()         <span class="comment">// &#123;value: 'b', done: false&#125;</span></span><br><span class="line">iter.next()         <span class="comment">// &#123;value: 'c', done: false&#125;</span></span><br><span class="line">iter.next()         <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>arr</code>是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以，调用这个属性，就得到遍历器对象。</p><p>对于原生部署Iterator接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的Iterator接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历。</p><p>对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当做Map接口使用，ES5没有Map结构，而ES6原生提供了。</p><p>一个对象如果要具备可被<code>for...of</code>循环调用的Iterator接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可以）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(start, stop) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = start;</span><br><span class="line">    <span class="keyword">this</span>.stop = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.stop) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value++;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, stop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> range(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);       <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个类部署Iterator接口的写法。<code>Symbol.iterator</code>属性对应一个函数，执行后返回当前对象的遍历器对象。</p><p>下面是通过遍历器实现指针结构的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Obj.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> iterator = &#123;<span class="attr">next</span>: next&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> current = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = current.value;</span><br><span class="line">      current = current.next;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> iterator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> one = <span class="keyword">new</span> Obj(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> two = <span class="keyword">new</span> Obj(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> three = <span class="keyword">new</span> Obj(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">one.next = two;</span><br><span class="line">two.next = three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> one) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);       <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码首先在构造函数的原型链上部署<code>Symbol.iterator</code>方法，调用该方法会返回遍历器对象<code>iterator</code>，调用该对象的<code>next</code>方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p><p>下面是为另一个对象添加Iterator接口的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  data: [<span class="string">'hello'</span>, <span class="string">'world'</span>],</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; self.data.length) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            value: self.data[index++],</span><br><span class="line">            done: <span class="literal">false</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于类似数组的对象（存在数值键名和<code>length</code>属性），部署Iterator接口，有一个简便方法，就是<code>Symbol.iterator</code>方法直接引用数组的Iterator接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = [][<span class="built_in">Symbol</span>.iterator];</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)] <span class="comment">// 可以执行了</span></span><br></pre></td></tr></table></figure><p>NodeList对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的<code>Symbol.iterator</code>属性，可以看到没有任何影响。</p><p>下面是另一个类似数组的对象调用数组的<code>Symbol.iterator</code>方法的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);      <span class="comment">// 'a', 'b', 'c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，普通对象部署数组的<code>Symbol.iterator</code>方法，并无效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  a: <span class="string">'a'</span>,</span><br><span class="line">  b: <span class="string">'b'</span>,</span><br><span class="line">  c: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);      <span class="comment">// undefined, undefined, undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="params">()</span> =&gt;</span> i;</span><br><span class="line"></span><br><span class="line">[...obj]        <span class="comment">// TypeError: [] is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>obj</code>的<code>Symbol.iterator</code>方法对应的不是遍历器生成函数，因此报错。</p><p>有了遍历器接口，数据结构就可以用<code>for...of</code>循环遍历，也可以使用<code>while</code>循环遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $iterator = ITERABLE[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">var</span> $result = $iterator.next();</span><br><span class="line"><span class="keyword">while</span>(!$result.done) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = $result.value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  $result = $iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>ITERABLE</code>代表某种可遍历的数据结构，<code>$iterator</code>是它的遍历器对象。遍历器对象每次移动指针（<code>next</code>方法），都检查一下返回值的<code>done</code>属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（<code>next</code>方法），不断循环。</p><hr><h3 id="三、调用Iterator接口的场合"><a href="#三、调用Iterator接口的场合" class="headerlink" title="三、调用Iterator接口的场合"></a>三、调用Iterator接口的场合</h3><p>有一些场合会默认调用Iterator接口（即<code>Symbol.iterator</code>方法），除了下文介绍的<code>for...of</code>循环，还有几个别的场合。</p><ul><li>1) 解构赋值</li></ul><p>对数组和Set结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">'a'</span>).add(<span class="string">'b'</span>).add(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y] = set;</span><br><span class="line"><span class="comment">// x='a'; y='b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, ...rest] = set;</span><br><span class="line"><span class="comment">// first='a'; rest=['b', 'c'];</span></span><br></pre></td></tr></table></figure><ul><li>2) 扩展运算符</li></ul><p>扩展运算符（<code>...</code>）也会调用默认的Iterator接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line">[...str]            <span class="comment">// ['h', 'e', 'l', 'l', 'o']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>]  <span class="comment">// ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure><p>上面代码的扩展运算符内部就调用Iterator接口。</p><p>实际上，这提供了一种简便机制，可以将任何部署了Iterator接口的数据结构，转为数组。也就是说，只要某个数据结构部署了Iterator接口，就可以对它使用扩展运算符，将其转为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure><ul><li>3) yield*</li></ul><p><code>yield*</code>后面跟的是一个可遍历的解构，它会调用该结构的遍历器接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next();            <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">iterator.next();            <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">iterator.next();            <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">iterator.next();            <span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line">iterator.next();            <span class="comment">// &#123;value: 5, done: false&#125;</span></span><br><span class="line">iterator.next();            <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><ul><li>4) 其他场合</li></ul><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p><ul><li><p><code>for...of</code></p></li><li><p><code>Array.from()</code></p></li><li><p><code>Map()</code>, <code>Set()</code>, <code>WeakMap()</code>, <code>WeakSet</code></p></li><li><p><code>Promise.all()</code></p></li><li><p><code>Promise.race()</code></p></li></ul><hr><h3 id="四、字符串的Iterator接口"><a href="#四、字符串的Iterator接口" class="headerlink" title="四、字符串的Iterator接口"></a>四、字符串的Iterator接口</h3><p>字符串是一个类似数组的对象，也原生具有Iterator接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">'hi'</span>;</span><br><span class="line"><span class="keyword">typeof</span> someString[<span class="built_in">Symbol</span>.iterator];</span><br><span class="line"><span class="comment">// 'function'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iterator.next()             <span class="comment">// &#123;value: 'h', done: false&#125;</span></span><br><span class="line">iterator.next()             <span class="comment">// &#123;value: 'i', done: false&#125;</span></span><br><span class="line">iterator.next()             <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>Symbol.iterator</code>方法返回一个遍历器对象，在这个遍历器上可以调用<code>next</code>方法，实现对于字符串的遍历。</p><p>可以覆盖原生的<code>Symbol.iterator</code>方法，达到修改遍历器行为的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hi'</span>);</span><br><span class="line"></span><br><span class="line">[...str]            <span class="comment">// ['h', 'i']</span></span><br><span class="line"></span><br><span class="line">str[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._first) &#123;</span><br><span class="line">                <span class="keyword">this</span>._first = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="string">'bye'</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        _first: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...str]            <span class="comment">// ['bye']</span></span><br><span class="line">str                 <span class="comment">// 'hi'</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串str的<code>Symbol.iterator</code>方法被修改了，所以扩展运算符（<code>...</code>）返回的值变成了<code>bye</code>，而字符串本身还是<code>hi</code>。</p><hr><h3 id="五、Iterator接口和Generator函数"><a href="#五、Iterator接口和Generator函数" class="headerlink" title="五、Iterator接口和Generator函数"></a>五、Iterator接口和Generator函数</h3><p><code>Symbol.iterator</code>方法的最简单实现，还是使用后面要介绍的Generator函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[...myIterable]             <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'hello'</span></span><br><span class="line"><span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Symbol.iterator</code>方法几乎不用部署任何代码，只要yield命令给出每一步的返回值即可。</p><hr><h3 id="六、遍历器对象的return-，throw"><a href="#六、遍历器对象的return-，throw" class="headerlink" title="六、遍历器对象的return()，throw()"></a>六、遍历器对象的return()，throw()</h3><p>遍历器对象除了具有<code>next</code>方法，还可以具有<code>return</code>方法和<code>throw</code>方法。如果我们自己写遍历器对象生成函数，那么<code>next</code>方法是必须部署的，<code>return</code>方法和<code>throw</code>方法是否部署是可选的。</p><p><code>return</code>方法的使用场合是，如果<code>for...of</code>循环提前退出（通常是因为报错，或者有<code>break</code>语句或<code>continue</code>语句），就会调用<code>return</code>方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLinesSync</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                next() () &#123;</span><br><span class="line">                    <span class="keyword">return</span>  &#123;<span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">return</span>() &#123;</span><br><span class="line">                    file.close();</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>readLinesSync</code>接受一个文件对象作为参数，返回一个遍历器对象，其中除了<code>next</code>方法，还部署了<code>return</code>方法。下面三种情况，都会触发执行<code>return</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(line);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(line);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(line);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，情况一输出文件的第一行后，就会执行<code>return</code>方法，关闭这个文件；情况二输出所有行以后，执行<code>return</code>方法，关闭该文件；情况三在执行<code>return</code>方法关闭文件之后，再抛出错误。</p><p>注意，<code>return</code>方法必须返回一个对象，这是Generator规格决定的。</p><p><code>throw</code>方法主要是配合Generator函数使用的，一般的遍历器对象用不到这个方法。</p><hr><h3 id="七、for…of循环"><a href="#七、for…of循环" class="headerlink" title="七、for…of循环"></a>七、for…of循环</h3><p>ES6借鉴C++、Java、C#和Python语言，引入了<code>for...of</code>循环，作为遍历所有数据结构的统一的方法。</p><p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有iterator接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p><p><code>for...of</code>循环可以使用的范围包括数组、Set和Map解构、某些类似数组的对象（比如<code>arguments</code>对象、Dom NodeList对象）、Generator对象，以及字符串。</p><h4 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h4><p>数组原生具备iterator接口（即默认部署了<code>Symbol.iterator</code>属性），<code>for...of</code>循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);         <span class="comment">// 'red', 'green', 'blue'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = arr[<span class="built_in">Symbol</span>.iterator].bind(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);         <span class="comment">// 'red', 'green', 'blue'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，空对象obj部署了数组arr的<code>Symbol.iterator</code>属性，结果obj的<code>for...of</code>循环，产生了与arr完全一样的结果。</p><p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element, index</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);       <span class="comment">// red green blue</span></span><br><span class="line">    <span class="built_in">console</span>.log(index);         <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>JavaScript原有的<code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。ES6提供<code>for...of</code>循环，允许遍历获得键值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);             <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);             <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法（参见ES6数组扩展）。</p><p><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);             <span class="comment">// '0', '1', '2', 'foo'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);             <span class="comment">// '3', '5', '7'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>for...of</code>循环不会返回数组arr的foo属性。</p><h4 id="2-Set和Map结构"><a href="#2-Set和Map结构" class="headerlink" title="2. Set和Map结构"></a>2. Set和Map结构</h4><p>Set和Map结构也原生具有Iterator接口，可以直接使用<code>for...of</code>循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'Gecko'</span>, <span class="string">'Trident'</span>, <span class="string">'Webkit'</span>, <span class="string">'Webkit'</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> engines) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Gecko</span></span><br><span class="line"><span class="comment">// Trident</span></span><br><span class="line"><span class="comment">// Webkit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> es6 = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">es6.set(<span class="string">'edition'</span>, <span class="number">6</span>);</span><br><span class="line">es6.set(<span class="string">'committee'</span>, <span class="string">'TC39'</span>);</span><br><span class="line">es6.set(<span class="string">'standard'</span>, <span class="string">'ECMA-262'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, value] <span class="keyword">of</span> es6) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name + <span class="string">': '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br></pre></td></tr></table></figure><p>上面代码演示了如何遍历Set结构和Map结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加仅数据结构的顺序。其次，Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别是当前Map成员的键名和键值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'a'</span>, <span class="number">1</span>).set(<span class="string">'b'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ['a', 1]</span></span><br><span class="line"><span class="comment">// ['b', 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">': '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a: 1</span></span><br><span class="line"><span class="comment">// b: 2</span></span><br></pre></td></tr></table></figure><h4 id="3-计算生成的数据结构"><a href="#3-计算生成的数据结构" class="headerlink" title="3. 计算生成的数据结构"></a>3. 计算生成的数据结构</h4><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6的数组、Set、Map都部署了以下三个方法，调用后都返回遍历器对象。</p><ul><li><p><code>entries()</code> 返回一个遍历器对象，用来遍历<code>[键名, 键值]</code>组成的数组。对于数组，键名就是索引值；对于Set，键名与键值相同。Map结构的Iterator接口，默认就是调用<code>entries</code>方法。</p></li><li><p><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</p></li><li><p><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</p></li></ul><p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure><h4 id="4-类似数组的对象"><a href="#4-类似数组的对象" class="headerlink" title="4. 类似数组的对象"></a>4. 类似数组的对象</h4><p>类似数组的对象包括好几类。下面是<code>for...of</code>循环用于字符串、DOM NodeList对象、<code>arguments</code>对象的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s);         <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList</span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">    p.classList.add(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printArgs(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br></pre></td></tr></table></figure><p>对于字符串来说，<code>for...of</code>循环还有一个特点，就是会正确识别32位UTF-16字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="string">'a\uD83D\uDC0A'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// '\uD83D\uDC0A'</span></span><br></pre></td></tr></table></figure><p>并不是所有类似数组的对象都具有Iterator接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">3</span>, <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">Array</span>.from(arrayLike)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-对象"><a href="#5-对象" class="headerlink" title="5. 对象"></a>5. 对象</h4><p>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了Iterator接口后才能使用。但是，这样情况下，<code>for...in</code>循环依然可以用来遍历键名，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> es6 = &#123;</span><br><span class="line">    edition: <span class="number">6</span>,</span><br><span class="line">    committee: <span class="string">'TC39'</span>,</span><br><span class="line">    standard: <span class="string">'ECMA-262'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">in</span> es6) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition</span></span><br><span class="line"><span class="comment">// committee</span></span><br><span class="line"><span class="comment">// standard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> es6) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TypeError: es6[Symbol.iterator] is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码表示，对于普通的对象，<code>for...in</code>循环可以遍历键名，<code>for...of</code>循环会报错。</p><p>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(someObject)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">': '</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种解决方法是，使用Generator函数将对象重新包装一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, <span class="string">'-&gt;'</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure><h4 id="6-与其他遍历语法的比较"><a href="#6-与其他遍历语法的比较" class="headerlink" title="6. 与其他遍历语法的比较"></a>6. 与其他遍历语法的比较</h4><p>以数组为例，JavaScript提供多种遍历语法，最原始的写法就是<code>for</code>循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; array.length; index++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(array[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法比较麻烦，因此数组提供内置的<code>forEach</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种写法的问题在于，无法中途跳出<code>forEach</code>循环，<code>break</code>命令或<code>return</code>命令都不能奏效。</p><p><code>for...in</code>循环可以遍历数组的键名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for...in</code>循环有几个缺点：</p><ul><li><p>数组的键名是数字，但是<code>for...in</code>循环是以字符串作为键名，“0”、“1”、“2”等等。</p></li><li><p><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</p></li><li><p>某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</p></li></ul><p>总之，<code>for...in</code>循环主要是为遍历对象而设计的，不适用于遍历数组。</p><p><code>for...of</code>循环相比上面几种做法，有一些显著的优点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点。</p></li><li><p>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用。</p></li><li><p>提供了遍历所有数据结构的统一操作接口。</p></li></ul><p>下面是一个使用<code>break</code>语句，跳出<code>for...of</code>循环的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子，会输出斐波那契数列小于等于1000的项。如果当前项大于1000，就会使用<code>break</code>语句跳出<code>for...of</code>循环。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/iterator">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中&lt;code&gt;Iterator&lt;/code&gt;遍历器和&lt;code&gt;for...of&lt;/code&gt;循环方法。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/iterator&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(2) 解构赋值</title>
    <link href="http://www.xiaoleon.cn/2018/05/16/es6-2/"/>
    <id>http://www.xiaoleon.cn/2018/05/16/es6-2/</id>
    <published>2018-05-15T23:58:11.000Z</published>
    <updated>2018-05-16T13:22:30.227Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中添加的解构赋值。节选自<a href="(http://es6.ruanyifeng.com/#docs/destructuring">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、数组的解构赋值"><a href="#一、数组的解构赋值" class="headerlink" title="一、数组的解构赋值"></a>一、数组的解构赋值</h3><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>以前，为变量赋值，只能直接指定值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>ES6允许写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo                 <span class="comment">// 1</span></span><br><span class="line">bar                 <span class="comment">// 2</span></span><br><span class="line">baz                 <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>];</span><br><span class="line">third               <span class="comment">// 'baz'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x                   <span class="comment">// 1</span></span><br><span class="line">y                   <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head                <span class="comment">// 1</span></span><br><span class="line">tail                <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x                   <span class="comment">// 'a'</span></span><br><span class="line">y                   <span class="comment">// undefined</span></span><br><span class="line">z                   <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果结构不成功，变量的值就等于<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = [];</span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [];</span><br></pre></td></tr></table></figure><p>以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code>。</p><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x                   <span class="comment">// 1</span></span><br><span class="line">y                   <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a                   <span class="comment">// 1</span></span><br><span class="line">b                   <span class="comment">// 2</span></span><br><span class="line">d                   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>上面两个例子，都属于不完全解构，但是可以成功。</p><p>如果等号的右边不是数组（或者严格地说，不是可遍历的解构），那么将会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备<code>Iterator</code>接口（前五个表达式），要么本身就不具备<code>Iterator</code>接口（最后一个表达式）。</p><p>对于<code>Set</code>解构，也可以使用数组的解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">x                   <span class="comment">// 'a'</span></span><br></pre></td></tr></table></figure><p>事实上，只要某种数据结构具有<code>Iterator</code>接口，都可以采用数组形式的解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth               <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>fibs</code>是一个<code>Generator</code>函数，原生具有<code>Iterator</code>接口。解构赋值会依次从这个接口获取值。</p><h4 id="2-默认值"><a href="#2-默认值" class="headerlink" title="2. 默认值"></a>2. 默认值</h4><p>解构赋值允许指定默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo                 <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>];       <span class="comment">// x='a', y='b'</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>];        <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure><p>注意，ES6内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x                   <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x                   <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>上面代码中，因为<code>x</code>能取到值，所以函数<code>f</code>根本不会执行。上面代码其实等价于下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x = [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值可以引用解构赋值的其他变量，但是该变量必须已经声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];            <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];           <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>];        <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];            <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure><p>上面最后一个表达式之所以会报错，是因为<code>x</code>用<code>y</code>做默认值时，<code>y</code>还没有声明。</p><hr><h3 id="二、对象的解构赋值"><a href="#二、对象的解构赋值" class="headerlink" title="二、对象的解构赋值"></a>二、对象的解构赋值</h3><p>解构不仅可以用于数组，还可以用于对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">foo             <span class="comment">// 'aaa'</span></span><br><span class="line">bar             <span class="comment">// 'bbb'</span></span><br></pre></td></tr></table></figure><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">foo             <span class="comment">// 'aaa'</span></span><br><span class="line">bar             <span class="comment">// 'bbb'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz             <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。</p><p>如果变量名与属性名不一致，必须写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz             <span class="comment">// aaa</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">'hello'</span>, <span class="attr">last</span>: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l&#125; = obj;</span><br><span class="line">f               <span class="comment">// 'hello'</span></span><br><span class="line">l               <span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure><p>这实际上说明，对象的解构赋值是下面形式的简写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar&#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span>&#125;</span><br></pre></td></tr></table></figure><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz             <span class="comment">// 'aaa'</span></span><br><span class="line">foo             <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p><p>与数组一样，解构也可以用于嵌套结构的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    p: [</span><br><span class="line">        <span class="string">'Hello'</span>,</span><br><span class="line">        &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x               <span class="comment">// 'Hello'</span></span><br><span class="line">y               <span class="comment">// 'World'</span></span><br></pre></td></tr></table></figure><p>注意，这时<code>p</code>是模式，不是变量，因此不会被赋值。如果<code>p</code>也要作为变量赋值，可以写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    p: [</span><br><span class="line">        <span class="string">'Hello'</span>,</span><br><span class="line">        &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x               <span class="comment">// 'Hello'</span></span><br><span class="line">y               <span class="comment">// 'World'</span></span><br><span class="line">p               <span class="comment">// ["Hello", &#123;y: 'World'&#125;]</span></span><br></pre></td></tr></table></figure><p>下面是另一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cosnt node = &#123;</span><br><span class="line">    loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">            line: <span class="number">1</span>,</span><br><span class="line">            column: <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125;&#125; = node;</span><br><span class="line">line            <span class="comment">// 1</span></span><br><span class="line">loc             <span class="comment">// Object &#123;start: Object&#125;</span></span><br><span class="line">start           <span class="comment">// Object &#123;line: 1, column: 5&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码有三次解构赋值，分别是对<code>loc</code>、<code>start</code>、<code>line</code>三个属性的解构赋值。注意，最后一次对<code>line</code>属性的解构赋值之中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不是变量。</p><p>下面是嵌套赋值的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; <span class="attr">foo</span>: obj.prop, <span class="attr">bar</span>: arr[<span class="number">0</span>] &#125;) = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">obj             <span class="comment">// &#123;prop: 123&#125;</span></span><br><span class="line">arr             <span class="comment">// [true]</span></span><br></pre></td></tr></table></figure><p>对象的解构也可以指定默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; x = <span class="number">3</span> &#125; = &#123;&#125;;</span><br><span class="line">x               <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; x, y = <span class="number">5</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>&#125;</span><br><span class="line">x               <span class="comment">// 1</span></span><br><span class="line">y               <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y               <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123; <span class="attr">x</span>: <span class="number">5</span> &#125;</span><br><span class="line">y               <span class="comment">// 5 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;</span><br><span class="line">msg             <span class="comment">// 'Something went wrong'</span></span><br></pre></td></tr></table></figure><p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  &#123; x = <span class="number">3</span> &#125; = &#123; <span class="attr">x</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">x               <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  &#123; x = <span class="number">3</span> &#125; = &#123; <span class="attr">x</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">x               <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码中，属性<code>x</code>等于<code>null</code>，因为<code>null</code>与<code>undefined</code>不严格相等，所以是个有效的赋值，导致默认值<code>3</code>不生效。</p><p>如果结构失败，变量的值等于<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;foo&#125; = &#123; <span class="attr">bar</span>: <span class="string">'baz'</span> &#125;;</span><br><span class="line">foo             <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: &#123; bar &#125; &#125; = &#123; <span class="attr">bar</span>: <span class="string">'baz'</span> &#125; ;</span><br></pre></td></tr></table></figure><p>上面代码中，等号左边对象的<code>foo</code>属性，对应一个子对象。该子对象的<code>bar</code>属性，解构时会报错。原因很简单，因为<code>foo</code>这时等于<code>undefined</code>，再取子属性就会报错，请看下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  _tmp = &#123; <span class="attr">baz</span>: <span class="string">'baz'</span> &#125;;</span><br><span class="line">_tmp.foo.bar        <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>上面代码的写法会报错，因为JavaScript引擎会将<code>{x}</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p><p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;log, sin, cos&#125; = <span class="built_in">Math</span>;</span><br></pre></td></tr></table></figure><p>上面代码将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span>: first, [arr.length - <span class="number">1</span>]: last&#125; = arr;</span><br><span class="line">first               <span class="comment">// 1</span></span><br><span class="line">last                <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码对数组进行对象解构。数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>键，对应的值是`3``。方括号这种写法，属于“属性名表达式”。</p><hr><h3 id="三、字符串的解构赋值"><a href="#三、字符串的解构赋值" class="headerlink" title="三、字符串的解构赋值"></a>三、字符串的解构赋值</h3><p>字符串也可以解构赋值，这是因为此时，字符串被转换成了一个类似数组的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a               <span class="comment">// 'h'</span></span><br><span class="line">b               <span class="comment">// 'e'</span></span><br><span class="line">c               <span class="comment">// 'l'</span></span><br><span class="line">d               <span class="comment">// 'l'</span></span><br><span class="line">e               <span class="comment">// 'o'</span></span><br></pre></td></tr></table></figure><p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span>: len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len             <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、数值和布尔值的解构赋值"><a href="#四、数值和布尔值的解构赋值" class="headerlink" title="四、数值和布尔值的解构赋值"></a>四、数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值或布尔值，则会先转为对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString;    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString;   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p><p>解构赋值的意思是，只要等号右边的值不是对象或数组，就先将其转换为对象。由于<code>undefined</code>和<code>null</code>无法转换为对象，所以对它们进行解构赋值，都会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">prop</span>: x&#125; = <span class="literal">undefined</span>;          <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">prop</span>: y&#125; = <span class="literal">null</span>;               <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><hr><h3 id="五、函数参数的解构赋值"><a href="#五、函数参数的解构赋值" class="headerlink" title="五、函数参数的解构赋值"></a>五、函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]);            <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);        <span class="comment">// [3, 7]</span></span><br></pre></td></tr></table></figure><p>函数参数的解构也可以使用默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);         <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);               <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;);                   <span class="comment">// [0, 0]</span></span><br><span class="line">move();                     <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>move</code>的参数是一个对象，通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。</p><p>注意，下面的写法会得到不一样的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);         <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);               <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;);                   <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move();                     <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值，所以会得到与前一种写法不同的结果。</p><p><code>undefined</code>就会触发函数参数的默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">'yes'</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [1, 'yes', 3]</span></span><br></pre></td></tr></table></figure><hr><h3 id="六、圆括号问题"><a href="#六、圆括号问题" class="headerlink" title="六、圆括号问题"></a>六、圆括号问题</h3><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p><p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解析的歧义，就不得使用圆括号。</p><p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p><h4 id="1-不能使用圆括号的情况"><a href="#1-不能使用圆括号的情况" class="headerlink" title="1. 不能使用圆括号的情况"></a>1. 不能使用圆括号的情况</h4><p>以下三种解构赋值不得使用圆括号。</p><ul><li>1) 变量声明语句</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">o</span>: (&#123;<span class="attr">p</span>: p&#125;)&#125; = &#123;<span class="attr">o</span>: &#123;<span class="attr">p</span>: <span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>上面六个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p><ul><li>2) 函数参数</li></ul><p>函数参数也属于变量声明，因此不能带有圆括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z, (x</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br></pre></td></tr></table></figure><ul><li>3) 赋值语句的模式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123;<span class="attr">p</span>: a&#125;) = &#123;<span class="attr">p</span>: <span class="number">42</span>&#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>上面代码将整个模式放在圆括号之中，导致报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">[(&#123;<span class="attr">p</span>: a&#125;, &#123;<span class="attr">x</span>: c&#125;)] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><p>上面代码将一部分模式放在圆括号之中，导致报错。</p><h4 id="2-可以使用圆括号的情况"><a href="#2-可以使用圆括号的情况" class="headerlink" title="2. 可以使用圆括号的情况"></a>2. 可以使用圆括号的情况</h4><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>];</span><br><span class="line">(&#123;<span class="attr">p</span>: (d)&#125; = &#123;&#125;);</span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是<code>p</code>，而不是<code>d</code>；第三行语句与第一行语句的性质一致。</p><hr><h3 id="七、用途"><a href="#七、用途" class="headerlink" title="七、用途"></a>七、用途</h3><p>变量的解构赋值用途很多。</p><h4 id="1-交换变量的值"><a href="#1-交换变量的值" class="headerlink" title="1. 交换变量的值"></a>1. 交换变量的值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简介，而且易读，语义非常清晰。</p><h4 id="2-从函数返回多个值"><a href="#2-从函数返回多个值" class="headerlink" title="2. 从函数返回多个值"></a>2. 从函数返回多个值</h4><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        foo: <span class="number">1</span>,</span><br><span class="line">        bar: <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;foo, bar&#125; = example();</span><br></pre></td></tr></table></figure><h4 id="3-函数参数定义"><a href="#3-函数参数定义" class="headerlink" title="3. 函数参数定义"></a>3. 函数参数定义</h4><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123;...&#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123;...&#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-提取JSON数据"><a href="#4-提取JSON数据" class="headerlink" title="4. 提取JSON数据"></a>4. 提取JSON数据</h4><p>解构赋值对提取JSON对象中的数据，尤其有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">    id: <span class="number">42</span>,</span><br><span class="line">    status: <span class="string">'OK'</span>,</span><br><span class="line">    data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;id, status, <span class="attr">data</span>: number&#125; = jsonData;</span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);        <span class="comment">// 42, 'OK', [867, 5309]</span></span><br></pre></td></tr></table></figure><h4 id="5-函数参数的默认值"><a href="#5-函数参数的默认值" class="headerlink" title="5. 函数参数的默认值"></a>5. 函数参数的默认值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">    beforeSend = function(</span>) </span>&#123;&#125;,</span><br><span class="line">    cache = <span class="literal">true</span>,</span><br><span class="line">    complete = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    crossDomain = <span class="literal">false</span>,</span><br><span class="line">    global = <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;</code>这样的语句。</p><h4 id="6-遍历Map结构"><a href="#6-遍历Map结构" class="headerlink" title="6. 遍历Map结构"></a>6. 遍历Map结构</h4><p>任何部署了<code>Iterator</code>接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持<code>Iterator</code>接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">' is '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-输入模块的指定方法"><a href="#7-输入模块的指定方法" class="headerlink" title="7. 输入模块的指定方法"></a>7. 输入模块的指定方法</h4><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">'source-map'</span>);</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">《ESMAScript 6 入门 —— 阮一峰》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中添加的解构赋值。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/destructuring&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(1) let和const命令</title>
    <link href="http://www.xiaoleon.cn/2018/05/15/es6-1/"/>
    <id>http://www.xiaoleon.cn/2018/05/15/es6-1/</id>
    <published>2018-05-15T13:31:08.000Z</published>
    <updated>2018-05-16T13:22:30.217Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中添加的<code>let</code>和<code>const</code>指令。节选自<a href="(http://es6.ruanyifeng.com/#docs/let">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、let命令"><a href="#一、let命令" class="headerlink" title="一、let命令"></a>一、let命令</h3><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><p><code>let</code>命令用来声明变量，它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a       <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">b       <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量，然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p><p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);     <span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>];     <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面的代码中，使用<code>var</code>声明的变量<code>i</code>，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是10。</p><p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是6。</p><p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>上面代码运行正确，输出了3次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p><h4 id="2-不存在变量提升"><a href="#2-不存在变量提升" class="headerlink" title="2. 不存在变量提升"></a>2. 不存在变量提升</h4><p><code>var</code>命令会发生“变量提升”现象，即变量可以再声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p><p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明之后使用，否则报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);     <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar);     <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表明在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p><h4 id="3-暂时性死区"><a href="#3-暂时性死区" class="headerlink" title="3. 暂时性死区"></a>3. 暂时性死区</h4><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就绑定（binding）这个区域，不再受外部的影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>;      <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p><p>ES6明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，被称为“暂时性死区”（temporal dead zone, TDZ）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ start</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>;          <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp);     <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp;              <span class="comment">// TDZ end</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp);     <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);     <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p><p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x;         <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>x</code>使用<code>let</code>命令声明，所以在声明之前，都属于<code>x</code>的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个<code>ReferenceError</code>。</p><p>作为比较，如果一个变量根本没有声明，使用<code>typeof</code>反而不会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable;   <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><p>有些“死区”比较隐蔽，不太容易发现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();        <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>bar</code>函数之所以报错，是因为参数<code>x</code>默认值等于另一个参数<code>y</code>，而此时<code>y</code>还没有声明，属于“死区”。如果<code>y</code>的默认值是<code>x</code>，就不会报错，因为此时<code>x</code>已经声明了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = <span class="number">2</span>, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();        <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure><p>另外，下面的代码也会报错，与<code>var</code>的行为不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> x = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> x = x;</span><br></pre></td></tr></table></figure><p>上面代码报错，也是因为暂时性死区。使用<code>let</code>声明变量时，只要变量在还没有声明完成之前使用，就会报错。</p><p>ES6规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><h4 id="4-不允许重复声明"><a href="#4-不允许重复声明" class="headerlink" title="4. 不允许重复声明"></a>4. 不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，不能在函数内部重新声明参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg;    <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg;    <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、块级作用域"><a href="#二、块级作用域" class="headerlink" title="二、块级作用域"></a>二、块级作用域</h3><h4 id="1-为什么需要块级作用域"><a href="#1-为什么需要块级作用域" class="headerlink" title="1. 为什么需要块级作用域"></a>1. 为什么需要块级作用域</h4><p>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p><p>第一种场景，内层变量可能会覆盖外层变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">"hello world"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();        <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);       <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>只能用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><h4 id="2-ES6的块级作用域"><a href="#2-ES6的块级作用域" class="headerlink" title="2. ES6的块级作用域"></a>2. ES6的块级作用域</h4><p><code>let</code>实际上为JavaScript新增了块级作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n);     <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是10。</p><p>ES6允许块级作用域的任意嵌套。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;&#123;<span class="keyword">let</span> insane = <span class="string">'hello world'</span>&#125;&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>外层作用域无法读取内层作用域的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'hello world'</span>&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(insane);        <span class="comment">// 报错</span></span><br><span class="line">&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>内层作用域可以定义外层作用域的同名变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  <span class="keyword">let</span> insane = <span class="string">'hello world'</span>;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'hello world'</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-块级作用域与函数声明"><a href="#3-块级作用域与函数声明" class="headerlink" title="3. 块级作用域与函数声明"></a>3. 块级作用域与函数声明</h4><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p><p>ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种函数声明，根据ES5的规定都是非法的。</p><p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p><p>ES6引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>);&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>上面代码在ES5中运行，会得到<code>I am inside!</code>，因为<code>if</code>内声明的函数<code>f</code>会被提升到函数头部，实际运行的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>);&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>);&#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>ES6就完全不一样了，理论上会得到<code>I am outside!</code>。因为块级作用域内声明的函数类似于<code>let</code>，对作用域之外没有影响。但是，如果真的在ES6浏览器中运行，会报错。</p><p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p><ul><li><p>允许在块级作用域内声明函数</p></li><li><p>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部</p></li><li><p>同时，函数声明还会提升到所在的块级作用域的头部。</p></li></ul><p>注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作<code>let</code>处理。</p><p>根据这三条规则，在浏览器的ES6环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的ES6环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>);&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;())</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>上面的代码在ES6的浏览器中，都会报错，因为实际运行的是下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的ES6环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;consoel.log(<span class="string">'I am outside!'</span>);&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;())</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明语句</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、const命令"><a href="#三、const命令" class="headerlink" title="三、const命令"></a>三、const命令</h3><h4 id="1-基本用法-1"><a href="#1-基本用法-1" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">PI            <span class="comment">// 3.1415</span></span><br><span class="line"></span><br><span class="line">PI = <span class="number">3</span>;       <span class="comment">// TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo;      <span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(MAX);   <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">const</span> MAX = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两行都会报错</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">'Goodbye'</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h4 id="2-本质"><a href="#2-本质" class="headerlink" title="2. 本质"></a>2. 本质</h4><p><code>const</code>实际上保证的，并不是变量的值不得改变，而是变量指向的那个内存地址不得改变。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于符合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，<code>const</code>只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，讲一个对象声明为常量必须非常小心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为foo添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop            <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将foo指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;;           <span class="comment">// TypeError: "foo" is read-only</span></span><br></pre></td></tr></table></figure><p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>);      <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;         <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];         <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p><p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通模式下，下面一行不起作用</span></span><br><span class="line"><span class="comment">// 严格模式下，下面一行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">      constanize(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-ES6声明变量的六种方法"><a href="#3-ES6声明变量的六种方法" class="headerlink" title="3. ES6声明变量的六种方法"></a>3. ES6声明变量的六种方法</h4><p>ES5只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6除了添加<code>let</code>和<code>const</code>命令，还增加了两种方法：<code>import</code>和<code>class</code>。所以，ES6一共有6种声明变量的方法。</p><hr><h3 id="四、顶层对象的属性"><a href="#四、顶层对象的属性" class="headerlink" title="四、顶层对象的属性"></a>四、顶层对象的属性</h3><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在Node指的是<code>global</code>对象。ES5之中，顶层对象的属性与全局变量是等价的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a                 <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a          <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p><p>顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序猿很容易不知不觉就创建了全局变量；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在node的repl环境，可以写成global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成this.a</span></span><br><span class="line"><span class="built_in">window</span>.a      <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b      <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p><hr><h3 id="五、global对象"><a href="#五、global对象" class="headerlink" title="五、global对象"></a>五、global对象</h3><p>ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p><ul><li><p>浏览器里面，顶层对象是<code>window</code>，但Node和Web Worker没有<code>window</code></p></li><li><p>浏览器和Web Worker里面，<code>self</code>也指向顶层对象，但是Node没有<code>self</code></p></li><li><p>Node里面，顶层对象是<code>global</code>，但其他环境都不支持</p></li></ul><p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>变量，但是有局限性。</p><ul><li><p>全局环境中，<code>this</code>会返回顶层对象。但是，Node模块和ES6模块中，<code>this</code>返回的是当前模块</p></li><li><p>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code></p></li><li><p>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器使用了CSP（Content Security Policy，内容安全政策），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</p></li></ul><p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line">  ? <span class="built_in">window</span></span><br><span class="line">  : (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">     <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">     <span class="keyword">typeof</span> global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有一个提案，在语言标准的层面，引入<code>global</code>作为顶层对象。也就是说，在所有环境下，<code>global</code>都是存在的，都可以从它拿到顶层对象。</p><p>垫片库<code>system.global</code>模拟了这个提案，可以再所有环境拿到<code>global</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS的写法</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'system.global/shim'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6模块的写法</span></span><br><span class="line"><span class="keyword">import</span> shim <span class="keyword">from</span> <span class="string">'system.global'</span>;</span><br><span class="line">shim();</span><br></pre></td></tr></table></figure><p>上面代码可以保证各种环境里面，<code>global</code>对象都是存在的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS写法</span></span><br><span class="line"><span class="keyword">var</span> global = <span class="built_in">require</span>(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6模块写法</span></span><br><span class="line"><span class="keyword">import</span> getGlobal <span class="keyword">from</span> <span class="string">'system.global'</span>;</span><br><span class="line"><span class="keyword">const</span> global = getGlobal();</span><br></pre></td></tr></table></figure><p>上面代码将顶层对象放入变量<code>global</code>。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">《ESMAScript 6 入门 —— 阮一峰》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中添加的&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;指令。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/let&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>React(4) 模块化React和Redux应用</title>
    <link href="http://www.xiaoleon.cn/2018/03/13/react-4/"/>
    <id>http://www.xiaoleon.cn/2018/03/13/react-4/</id>
    <published>2018-03-13T15:02:05.000Z</published>
    <updated>2018-03-19T13:15:53.831Z</updated>
    
    <content type="html"><![CDATA[<p>在第一部分中，我们已经了解了React的基本工作方式，也知道了Redux在组合React组件中的作用，但是更多的只是了解其基本原理和使用方法，上手练习的也是一个简单的例子。</p><a id="more"></a><p>实际工作中我们要创建的应用无论结构和大小都要复杂得多，在这一章中，我们要介绍创建一个复杂一点的应用应该如何做，包含以下内容：</p><ul><li><p>模块化应用的要点</p></li><li><p>代码文件的组织方式</p></li><li><p>状态树的设计</p></li><li><p>开发辅助工具</p></li></ul><h3 id="一、模块化应用要点"><a href="#一、模块化应用要点" class="headerlink" title="一、模块化应用要点"></a>一、模块化应用要点</h3><p>在本书中，我们探讨的是如何用React和Redux来构建前端网页应用，这两者都奉行这样一个公式<code>UI=render(state)</code>来产生用户界面。React适合于视图层面的东西，但是不能指望靠React来管理应用的状态，Redux才适合担当应用状态的管理工作。</p><p>从架构出发，当我们开始一个新的应用的时候，有几件事情是一定要考虑清楚的：</p><ul><li><p>代码文件的组织结构</p></li><li><p>确定模块的边界</p></li><li><p>Store的状态树设计</p></li></ul><p>这三件事情，是构建一个应用的基础。如果我们在一开始深入思考这三件事，并做出合乎需要的判断，可以在后面的路上省去很多麻烦。</p><p>从本章开始，我们将构造一个“待办事项”（Todo）应用，逐步完善这个应用，增加新的功能，在这个Todo应用的进化过程中来学习各个层次的知识。</p><p>在这个各种JavaScript框架层出不穷的时代，Todo应用几乎就代替了传统Hello World应用的作用，每个框架问世的时候都会用一个Todo应用来展示自己的不同，不要小看了这样一个Todo应用，它非常适合用于做技术展示，首先，这个应用的复杂度刚刚好，没有复杂到可能要很多篇幅才能解释清楚做什么，也没有简单到只需要几行代码就能够搞定；其次，这样的功能非常利于理解，恰好能够考验一个JavaScript框架的表达能力。</p><p>确定了我们的应用要做什么之后，不要上来就开始写代码，磨刀不误砍柴工，先要思考上面提到的三个问题。让我们从第一个问题开始。</p><hr><h3 id="二、代码文件的组织方式"><a href="#二、代码文件的组织方式" class="headerlink" title="二、代码文件的组织方式"></a>二、代码文件的组织方式</h3><h4 id="1-按角色组织"><a href="#1-按角色组织" class="headerlink" title="1. 按角色组织"></a>1. 按角色组织</h4><p>如果读者之前曾用MVC框架开发过应用程序，应该知道MVC框架之下，通常有这样一种代码的组织方式，文件目录列表如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">controllers/</span><br><span class="line">  todoController.js</span><br><span class="line">  filterController.js</span><br><span class="line">models/</span><br><span class="line">  todoModel.js</span><br><span class="line">  filterModel.js</span><br><span class="line">views/</span><br><span class="line">  todo.js</span><br><span class="line">  todoItem.js</span><br><span class="line">  filter.js</span><br></pre></td></tr></table></figure><p>在MVC中，应用代码分为Controller、Model和View，分别代表三种模块角色，就是把所有的Controller代码放在controllers目录下，把所有的Model代码方法在models目录下，把View代码放在views目录下。这种组织代码的方式，叫做“按角色组织”（Organized by Roles）。</p><p>我们当然不会使用MVC，在上一章中我们介绍过MVC框架的缺点。和众多前端开发者一样，我们选择Flux和Redux就是为了克服这些缺点的，但是因为MVC框架的影响非常深远，一些风格依然影响了前端开发人员的思维方式。</p><p>因为MVC这种“按角色组织”代码文件的影响，在Redux应用的构建中，就有这样一种代码组织方法，文件目录列表如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">reducers/</span><br><span class="line">  todoReducer.js</span><br><span class="line">  filterReducer.js</span><br><span class="line">actions/</span><br><span class="line">  todoActions.js</span><br><span class="line">  filterActions.js</span><br><span class="line">components/</span><br><span class="line">  todoList.js</span><br><span class="line">  todoItem.js</span><br><span class="line">  filter.js</span><br><span class="line">containers/</span><br><span class="line">  todoListContainer.js</span><br><span class="line">  todoItemContainer.js</span><br><span class="line">  filterContainer.js</span><br></pre></td></tr></table></figure><p>和MVC的代码组织方式不同，只不过是把controller、models和views目录换成了reducers、actions、components和containers，各个目录下代码文件的角色如下：</p><ul><li><p>reducer目录包含所有Redux的reducer</p></li><li><p>actions目录包含所有action构造函数</p></li><li><p>components目录包含所有的傻瓜组件</p></li><li><p>containers目录包含所有的容器组件</p></li></ul><p>这种组织方式看起来还不错，把一个类型的代码文件放在了一个目录下，至少比把所有代码全放在一个目录下要有道理。</p><p>实际上，在前面章节的所有ControlPanel例子中，我们采用的也是类似的方法，当我们发现代码文件变多，全都直接放在一个src目录下不合理时，首先想到的就是建一个views目录，把所有视图相关的目录移到views目录里面去。我们没有移动action相关和reducer相关的文件，只因为ControlPanel应用实在太简单，因为只有一个组件Counter可能发出动作，所以只有一个Action文件，也只有一个对应的Reducer文件，所以到最后我们都没有觉得有必要把它们移动到代表各自角色的目录里面去。</p><p>有过MVC框架开发经历的朋友可以回忆一下，当你需要对一个功能进行修改，虽然这个功能只是针对某一个具体的应用模块，但是却牵扯到MVC中的三个角色Controller、Model和View，不管你用的是什么样的编辑器，你都得费点劲才能在这三个目录之间跳转，或者需要滚动文件列表跳过无关的分发器文件才能找到你想要修改的那一个分发器文件。</p><p>如果说MVC框架下，因为三个角色之间的交叉关系，也只能默默接受，那么在Redux框架下，我们已经有机会实现严格模块化的思想，就应该想一想更好的组织文件的方式。</p><h4 id="2-按功能组织"><a href="#2-按功能组织" class="headerlink" title="2. 按功能组织"></a>2. 按功能组织</h4><p>Redux应用适合于“按功能组织”（Organzied by Feature），也就是完成同一应用功能的代码放在一个目录下，一个应用功能包含多个角色的代码。在Redux中，不同的角色就是reducer、actions和视图，而应用功能对应的就是用户界面上的交互模块。</p><p>拿Todo应用为例子，这个应用的两个基本功能就是TodoList和Filter，所以代码就这样组织，文件目录列表如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">todoList/</span><br><span class="line">  actions.js</span><br><span class="line">  actionTypes.js</span><br><span class="line">  index.js</span><br><span class="line">  reducer.js</span><br><span class="line">  views/</span><br><span class="line">    component.js</span><br><span class="line">    container.js</span><br><span class="line">filter/</span><br><span class="line">  actions.js</span><br><span class="line">  actionTypes.js</span><br><span class="line">  index.js</span><br><span class="line">  reducer.js</span><br><span class="line">  views/</span><br><span class="line">    component.js</span><br><span class="line">    container.js</span><br></pre></td></tr></table></figure><p>每个基本功能对应的其实就是一个模块，每个功能模块对应一个目录，这个例子中分别是todoList和filter，每个目录下包含同样名字的角色文件：</p><ul><li><p>actionTypes.js 定义action类型</p></li><li><p>actions.js 定义action构造函数，决定了这个功能模块可以接受的动作</p></li><li><p>reducer.js 定义这个功能模块如何响应actions.js中定义的动作</p></li><li><p>views目录，包含这个功能模块中所有的React组件，包括傻瓜组件和容器组件</p></li><li><p>index.js 这个文件把所有的角色导入，然后统一导出</p></li></ul><p>在这种组织方式下，当我们要修改某个功能模块的代码的时候，只要关注对应的目录就行了，所有需要修改的代码文件都能在这个目录下找到。</p><p>表面上看，“按照角色组织”还是“按照功能组织”只是一个审美的问题，也许你觉得自己已经习惯了MVC世界的“按照角色组织”方式，也许你已经有一套很厉害的代码编辑器可以完美解决在不同目录下寻找代码文件困难的问题。但是，开发Redux应用你依然应该用“按照功能组织”的方式，为什么呢？我们看看下一条“确定模块的边界”就明白了。</p><hr><h3 id="三、模块接口"><a href="#三、模块接口" class="headerlink" title="三、模块接口"></a>三、模块接口</h3><p>不同功能模块之间的依赖关系应该简单而且清晰，也就是所谓的保持模块之间低耦合性；一个模块应该把自己的功能封装得很好，让外界不要太依赖与自己内部的结构，这样不会因为内部变化而影响外部模块的功能，这就是所谓高内聚性。</p><p>React组件本身应该具有低耦合性和高内聚性的特点，不过在Redux的游乐场中，React组件扮演的就是一个视图的角色，还有reducer、actions这些角色参与这个游戏。对于整个Redux应用而言，整体由模块构成，但是模块不再是React组件，而是由React组件加上关于reducer和actions构成的小整体。</p><p>以我们将要实现的Todo应用为例，功能模块就是todoList和filter，这两个功能模块分别用各自的React组件、reducer和action定义。</p><p>可以预期每个模块之间会有依赖关系，比如filter模块想要使用todoList的action构造函数和视图，那么我们希望对方如何导入呢？一种写法是像下面的代码这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'../todoList/actions'</span>;</span><br><span class="line"><span class="keyword">import</span> container <span class="keyword">as</span> TodoList <span class="keyword">from</span> <span class="string">'../todoList/views/container'</span>;</span><br></pre></td></tr></table></figure><p>这种写法当然能够完成功能，但是却非常不合理，因为这让filter模块依赖于todoList模块的内部结构，而且直接伸手到todoList内部去导入想要的部分。</p><p>虽然我们在上面的例子中，todoList和filter中的文件名几乎一样，但是这毕竟是模块内部的事情，不应该硬性要求，更不应该假设所有的模块都应该按照这样的文件命名。在我们的例子中，存储视图代码文件的目录叫做views，但是有的开发者习惯把这个目录叫做components；我们把包含容器组件的文件名叫做container.js，根据开发者个人习惯也可能叫做TodoList，这些都没有必要而且也不应该有硬性规定。</p><p>现在既然我们把一个目录看作一个模块，那么我们要做的是明确这个模块对外的接口，而这个接口应该实现把内部封装起来。</p><p>请注意我们的todoList和filter模块目录下，都有一个index.js文件，这个文件就是我们的模块接口。</p><p>比如，在todoList/index.js中，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions.js'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer.js'</span>;</span><br><span class="line"><span class="keyword">import</span> view <span class="keyword">from</span> <span class="string">'./views/container.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;actions, reducer, view&#125;;</span><br></pre></td></tr></table></figure><p>如果filter中的组件想要使用todoList中的功能，应该导入todoList这个目录，因为导入一个目录的时候，默认导入的就是这个目录下的index.js文件，index.js文件中导出的内容，就是这个模块想要公开出来的接口。</p><blockquote><p>注意：虽然每个模块目录下都会有一个actionTypes.js文件定义action类型，但是通常不会把actionTypes中内容作为模块的接口之一导出，因为action类型只有两个部分依赖，一个是reducer，一个是action构造函数，而且只有当前模块的reducer和action构造函数才会直接使用action类型。模块之外，不会关心这个模块的action类型，如果模块之外要使用这个模块的动作，也只需要直接使用action构造函数就行。</p></blockquote><p>下面就是对应的导入todoList的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;actions, reducer, view <span class="keyword">as</span> TodoList&#125; <span class="keyword">from</span>  <span class="string">'../todoList'</span>;</span><br></pre></td></tr></table></figure><p>当我们想要修改todoList的内部代码结构，比如把views目录改名为components目录，或者把container.js改名为TodoListView.js时，所要做的只是修改todoList目录下的index.js内容，而这个文件export出来的内容不会有任何改变，也就是说对导入todoList的代码不用任何改变。这就是我们确定模块边界想要达到的目的。</p><p>还有一种导出模块接口的方式，是不以命名式export的方式导出模块接口，而是以export default的方式默认导出，就像这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions.js'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer.js'</span>;</span><br><span class="line"><span class="keyword">import</span> view <span class="keyword">from</span> <span class="string">'./views/container.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;actions, reducer, view&#125;</span><br></pre></td></tr></table></figure><p>如果像上面这样导出，那么导入时的代码会有一点区别，因为ES6语法中，export default和export两种导出方式的导入方式也会不同，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TodoListComponent <span class="keyword">from</span> <span class="string">'./actions.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = TodoListComponent.reducer;</span><br><span class="line"><span class="keyword">const</span> actions = TodoListComponent.actions;</span><br><span class="line"><span class="keyword">const</span> TodoList = TodoListComponent.view;</span><br></pre></td></tr></table></figure><p>无论使用哪种导出方式，都请在整个应用中只用一中模块导出方式，保持一致，避免混乱。</p><p>在本书中，全部使用export的方式，因为从上面的代码看得出来，如果使用export default的方式，在导入的时候不可避免要使用多行代码才能得到actions、reducer和view，而用导入命名式export只用一行就可以搞定，相对而言要更加简洁。</p><p>读者可能注意到了，上面接口代码中导入actions的语句和导入view和reducer不一样，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions.js'</span>;</span><br></pre></td></tr></table></figure><p>我们预期actions.js中是按照命名式export，原因和上面陈述的一样，actions.js可能会导出很多action构造函数，命名式导出是为了导入actions方便。对于view和reducer，一个功能模块绝对只有一个根视图模块，一个功能模块也只应该有一个导出的reducer，所以它们两个在各自代码文件中是以默认方式导出的。</p><hr><h3 id="四、状态树的设计"><a href="#四、状态树的设计" class="headerlink" title="四、状态树的设计"></a>四、状态树的设计</h3><p>上面说的“代码文件组织结构”和“确定模块的边界”更多的只是确定规矩，然后在每个应用中我们只要都遵循这个规矩就足够了，而要注意的第三点“Store上状态树的设计”，更像是一门技术，需要我们动一动脑子。</p><p>因为所有的状态都存在Store上，Store的状态树设计，直接决定了要写哪些reducer，还有action怎么写，所以是程序逻辑的源头。</p><p>我们认为状态树设计要遵循如下几个原则：</p><ul><li><p>一个模块控制一个状态节点</p></li><li><p>避免冗余数据</p></li><li><p>树形结构扁平</p></li></ul><h4 id="1-一个状态节点只属于一个模块"><a href="#1-一个状态节点只属于一个模块" class="headerlink" title="1. 一个状态节点只属于一个模块"></a>1. 一个状态节点只属于一个模块</h4><p>这个规则与其说是规则，不如说是Redux中模块必须遵守的限制，完全无法无视这个限制。</p><p>在Redux应用中，Store上的每个state都只能通过reducer来更改，而我们每个模块都有机会导出自己的reducer，这个导出的reducer只能最多更改Redux的状态树上一个节点下的数据，因为reducer之间对状态树上的修改权是互斥的，不可能让两个reducer都可以修改同一个状态树上的节点。</p><p>比如，如果A模块的reducer负责修改状态树上a字段下的数据，那么另一个模块B的reducer就不可能有机会修改a字段下的数据。</p><p>这里所说的“拥有权”指的是“修改权”，而不是“读取权”，实际上，Redux Store上的全部状态，在任何时候，对任何模块都是开放的，通过store.getState()总能够读取当前整个状态树的数据，但是只能更新自己相关那一部分模块的数据。</p><h4 id="2-避免冗余数据"><a href="#2-避免冗余数据" class="headerlink" title="2. 避免冗余数据"></a>2. 避免冗余数据</h4><p>冗余数据是一致性的大敌，如果在Store上存储冗余数据，那么维持不同部分数据一致就是一个大问题。</p><p>传统的关系型数据库中，对数据结构的各种“范式化”，其实就是在去除数据的冗余。而近年风生水起的NoSQL运动，提倡的就是在数据存储中“去范式化”，对数据结构的处理和关系型数据库正好相反，利用数据冗余来减少读取数据库时的数据关联工作。</p><p>面向用户的应用处于性能的考虑，倾向于直接使用“去范式化”的应用。但是带来的问题就是维持数据一致性就会困难。</p><p>不同的应用当然应该从自己的需要出发，在选择数据库的问题上，选择SQL关系型数据库或者NoSQL类型的数据库要根据应用特点，这个问题不是我们要在本书中讨论的。但是要强调的是，不管服务器端数据库用的是“范式化”还是“去范式化”的数据存储方式，在前段Redux的Store中，一定要避免数据冗余的出现。</p><p>并不是说Redux应用不需要考虑性能，而是相对于性能问题，数据一致性的问题才更加重要。</p><p>在后面的章节中我们会介绍，即使使用“范式化”的无冗余数据结构，我们借助reselector等工具一样可以获得很高的性能。</p><h4 id="3-树形结构扁平"><a href="#3-树形结构扁平" class="headerlink" title="3. 树形结构扁平"></a>3. 树形结构扁平</h4><p>理论上，一个树形结构可以有很深的层次，但是我们在设计Redux Store的状态树时，要尽量保持树形结构的扁平。</p><p>如果树形结构层次很深，往往意味着树形很复杂，一个很复杂的状态树是难以管理的，如果你曾不幸开发过Windows操作系统中依赖于“注册表”的应用，就一定深有体会，Windows中的注册表就是一个庞大而且层次很深的属性结果，看起来很灵活，实际上总让软件开发陷入麻烦的泥沼。</p><p>从代码的角度出发，深层次树形状态结构会让代码冗长。</p><p>假设，一个树形从上往下依次有A、B、C、D四个节点，为了访问节点D，就只能通过上面三层逐级访问，不过，谁也不敢保证A、B、C三个节点真的存在，为了防止运行时出错，代码就要考虑到所有的可能，最后为了访问D，代码不得不写成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> d = state.A &amp;&amp; state.A.B &amp;&amp; state.A.B.C &amp;&amp;&amp; state.A.B.C.D</span><br></pre></td></tr></table></figure><p>相信没有开发者会愿意写很多类似上面这样的代码。</p><hr><h3 id="五、Todo应用实例"><a href="#五、Todo应用实例" class="headerlink" title="五、Todo应用实例"></a>五、Todo应用实例</h3><p>了解上述创建应用的原则之后，我们现在终于可以开始构建Todo应用了。</p><p>Todo应用从界面上看应该由三部分组成：</p><ul><li><p>待办事项的列表</p></li><li><p>增加新待办事项的输入框和按钮</p></li><li><p>待办事项过滤器，可以选择过滤不同状态的待办事项</p></li></ul><p>看起来需要三个功能模块，但是第一部分和第二部分的关系密切，可以放在一个模块中，所以最后我们确定有两个功能模块todos和filter，其中todos包含第一部分和第二部分的功能。</p><p>我们遵循“按照功能组织”的原则来设计代码，创建三个目录来容纳各自的代码文件，每个目录下都有一个index.js文件，这是模块的边界。各个模块之间只能假设其他模块包含index.js文件，要引用模块只能导入index.js，不能够直接去导入其他文件，文件目录如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">todos/</span><br><span class="line">  index.js</span><br><span class="line">filter/</span><br><span class="line">  index.js</span><br></pre></td></tr></table></figure><h4 id="1-Todo状态设计"><a href="#1-Todo状态设计" class="headerlink" title="1. Todo状态设计"></a>1. Todo状态设计</h4><p>至于Todo应用状态，从界面上看，应用中可以有很多待办事项，并有先后顺序的关系，明显用一个数组很合适。所以，我们的状态树上应该有一个表示待办事项的数组。</p><p>至于每个待办事项，应该用一个对象代表，这个对象肯定要包含文字，记录待办事项的内容，因为我们可以把一个待办事项标记为“已完成”，所以还要有一个布尔字段记录是否完成的状态，当我们把一个待办事项标记位“已完成”或者“未完成”时，必须要能唯一确定一个待办事项对象，没有规则说一个待办事项的文字必须唯一，所以我们需要一个字段来唯一标识一个待办事项，所以一个待办事项的对象格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: //唯一标识</span><br><span class="line">  text: //待办事项内容</span><br><span class="line">  completed: //布尔值，标识待办事项是否已完成</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器选项设定界面上显示什么样状态的代表事项，我们已知过滤器有三种选择：</p><ul><li><p>全部待办事项</p></li><li><p>已完成待办事项</p></li><li><p>未完成待办事项</p></li></ul><p>看起来就是一个列举类型的结构，不过JavaScript里面并没有原生的enum类型支持，所以我们只能用类似常量标识符的方式来定义三种状态。在代码中，可以分别用体现语义的ALL、COMPLETED和UNCOMPLETED代表这三种状态，但是这三个标识符的实际值的选择，也值得商榷。</p><p>最简单的方式，就是让这三个状态标识符的值是整型，比如这样的代码形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ALL = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> COMPLETED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> UNCOMPLETED = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>但是，考虑到将来无论是debug还是产生log，一个数字在开发人员眼里不容易看出来代表什么意思，最后还需要对照代码才知道0代表ALL、1代表COMPLETED，这样很不方便。所以，开发中一个惯常的方法，就是把这些枚举型的常量定义为字符串，比如这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ALL = <span class="string">'all'</span>;</span><br><span class="line"><span class="keyword">const</span> COMPLETED = <span class="string">'completed'</span>;</span><br><span class="line"><span class="keyword">const</span> UNCOMPLETED = <span class="string">'uncompleted'</span>;</span><br></pre></td></tr></table></figure><p>综合起来看，我们知道Todo应用的Store状态树大概是这样一个样子，JavaScript对象的表示形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  todos: [</span><br><span class="line">    &#123;</span><br><span class="line">      text: <span class="string">'First todo'</span>,</span><br><span class="line">      completed: <span class="literal">false</span>,</span><br><span class="line">      id: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      text: <span class="string">'Second todo'</span>,</span><br><span class="line">      completed: <span class="literal">false</span>,</span><br><span class="line">      id: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  filter: <span class="string">'all'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当增加一个待办事项，就在数组类型的todos中增加一个元素，当药标记一个待办事项为“已完成”或者“未完成”，就更新对应待办事项的complete字段值，而哪些待办事项应该显示出来，则要根据todos和filter共同决定。</p><p>在应用的入口文件src/index.js中，我们和ControlPanel一样，用Provider包住最顶层的TodoApp模块，这样让store可以被所有组件访问到，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;TodoApp /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>而在顶层模块src/TodoApp.js中，所要做的只是把两个关键视图显示出来，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;view <span class="keyword">as</span> Todos&#125; <span class="keyword">from</span> <span class="string">'./todos/'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;view <span class="keyword">as</span> Filter&#125; <span class="keyword">from</span> <span class="string">'./filter/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Todos /&gt;</span><br><span class="line">      &lt;Filter /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default TodoApp;</span></span><br></pre></td></tr></table></figure><h4 id="2-action构造函数"><a href="#2-action构造函数" class="headerlink" title="2. action构造函数"></a>2. action构造函数</h4><p>确定好状态树的结构之后，接下来就可以写action构造函数了。</p><p>在todos和filter目录下，我们都要分别创造actionTypes.js和actions.js文件，这两个文件几乎每个功能模块都需要，文件如此命名是大家普遍接受的习惯。</p><p>在src/todos/actionTypes.js中，我们定义的是todos支持的action类型。在Todo应用中，支持对待办事项的增加、反转和删除三种action类型，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO = <span class="string">'TODO/ADD'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TOGGLE_TODO = <span class="string">'TODO/TOGGLE'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REMOVE_TODO = <span class="string">'TODO/REMOVE'</span>;</span><br></pre></td></tr></table></figure><p>和index.js中使用命名式导出而不用默认导出一样，在actionTypes中我们也使用命名式导出，这样，使用actionTypes的文件可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ADD_TODO, TOGGLE_TODO, REMOVE_TODO&#125; <span class="keyword">from</span> <span class="string">'./actionTypes.js'</span>;</span><br></pre></td></tr></table></figure><p>也同样是为了便于debug和输出到log里面查看清晰，所有的action类型的值都是字符串，字符串还有一个好处就是可以直接通过===来比较是否相等，而其他对象用===则要求必须引用同一个对象。</p><blockquote><p>提示：严格来说，使用Symbol来代替字符串表示这样的枚举值更合适，但是有的浏览器并不支持Symbol，我们在这里不作深入探讨。</p></blockquote><p>考虑到应用可以无限扩展，每个组件也要避免明明冲突。所以，最好是每个组件的action类型字符串都有一个唯一的前缀。在我们的例子中，所有todos的action类型字符串都有共同前缀“TODO/”，所有filter的action类型字符串前缀“FILTER/”。</p><p>在src/todos/actions.js中，我们定义todos相关的action构造函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ADD_TODO, TOGGLE_TODO, REMOVE_TODO&#125; <span class="keyword">from</span> <span class="string">'./actionTypes.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextTodoId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addTodo = <span class="function">(<span class="params">text</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: ADD_TODO,</span><br><span class="line">  completed: <span class="literal">false</span>,</span><br><span class="line">  id: nextTodoId++,</span><br><span class="line">  text: text</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toggleTodo = <span class="function">(<span class="params">id</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: TOGGLE_TODO,</span><br><span class="line">  id: id</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeTodo = <span class="function">(<span class="params">id</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: REMOVE_TODO,</span><br><span class="line">  id: id</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上一章中我们已经知道，Redux的action构造函数就是创造action对象的函数，返回的action对象中必须有一个type字段代表action类型，还可能有其他字段代表这个动作承载的数据。</p><p>在src/todos/actions.js文件中定义了一个文件级别的变量nextTodoId，每调用一次addTodo action构造函数就加一，实现为每个产生的待办事项赋予一个唯一id的目的。当然，这种方法非常简陋，我们在后面的章节中会改进唯一id的生成方法。</p><p>读者可能会注意到我们用了一种新的写法，虽然action构造函数应该是一个返回action对象的方法，我们却看不见return的字样。对于只return一个对象的函数体，ES6允许简写为省去return，直接用圆括号把返回的对象包起来就行，比如上面的toggleTodo对象构造器，实际上是下面方法的简写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toggleTodo = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: TOGGLE_TODO,</span><br><span class="line">    id: id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-组合reducer"><a href="#3-组合reducer" class="headerlink" title="3. 组合reducer"></a>3. 组合reducer</h4><p>在todos和filter目录下，各有一个reducer.js文件定义的两个功能模块reducer。</p><p>对于reducer我们并不陌生，在前面的ControlPanel例子中我们就创建过reducer。但是在那个例子中，整个应用只有一个reducer。而在Todo应用中，两个功能模块都有自己的reducer，而Redux的createStore函数只能接受一个reducer，那么怎么办？</p><p>这是Redux最有意思的部分，虽然Redux的createStore只接受一个reducer，却可以把多个reducer组合起来，成为一体，然后就可以被createStore函数接受。</p><p>在src/Store.js文件中，我们完成了reducer的组合，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore, combineReducer&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;reducer <span class="keyword">as</span> todoReducer&#125; <span class="keyword">from</span> <span class="string">'./todos'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;reducer <span class="keyword">as</span> filterReducer&#125; <span class="keyword">from</span> <span class="string">'./filter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducer(&#123;</span><br><span class="line">  todos: todoReducer,</span><br><span class="line">  filter: filterReducer</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(reducer);</span><br></pre></td></tr></table></figure><p>我们使用了Redux提供的一个函数combineReducers来把多个reducer函数合成为一个reducer函数。</p><p>combineReducers函数接受一个对象作为参数，参数对象的每个字段名对应了state状态上的字段名（在上面的例子中分别是todoReducer和filterReducer），combineReducers函数返回一个新的reducer函数，当这个新的reducer函数被执行时，会把传入的state参数对象拆开处理，todo字段下的子状态交给todoReducer，filter字段下的子状态交给filterReducer，然后再把这两个调用的返回结果合并成一个新的state，作为整体reducer函数的返回结果。</p><p>假设，当前State上的状态可以用currentState代表，这时候给Store派发一个action对象，combineReducers产生的这个reducer函数就会被调用，调用参数state就是currentState。这个reducer函数会分别调用todoReducer和filterReducer，不过传递过去的state参数有些变化，调用todoReducer的参数state值是currentStore.todos，调用filterReducer的state是currentState.filter，当todoReducer和filterReducer这两个函数返回结果之后，combineReducers产生的reducer函数就用这两个结果分别去更新Store上的todos和filter字段。</p><p>所以，现在我们来看功能模块的reducer，会发现state的值不是Redux上那个完整的状态，而是状态上对应自己的那一部分。</p><p>在src/todos/reducer.js中可以看到，state参数对应的是Store上todos字段的值，默认值是一个数组，reducer函数往往就是一个以action.type为条件的switch语句构成，代表模式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ADD_TODO, TOGGLE_TODO, REMOVE_TODO&#125; <span class="keyword">from</span> <span class="string">'./actionTypes.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = [], action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="comment">// 针对action.type所有可能值的case语句</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先看对于ADD_TODO这种action类型的处理，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ADD_TODO: &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      id: action.id,</span><br><span class="line">      text: action.text,</span><br><span class="line">      completed: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...state</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们使用了ES6的扩展操作符来简化reducer的代码，扩展操作符可以用来扩展一个对象，也可以用来扩展一个数组。</p><p>现在state是一个数组，我们想要返回一个增加了一个对象的数组，就这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [newObject, ...state];</span><br></pre></td></tr></table></figure><p>为什么我们不直接使用熟悉的数组push或者unshift操作呢？</p><p>绝对不能，因为push和unshift会改变原来的那个数组，还记得吗？reducer必须是一个纯函数，纯函数不能有任何副作用，包括不能修改参数对象。</p><p>对于TOGGLE_TODO这种action累i系那个的处理，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TOGGLE_TODO: &#123;</span><br><span class="line">    <span class="keyword">return</span> state.map(<span class="function">(<span class="params">todoItem</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (todoItem.id === action.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;...todoItem, <span class="attr">complated</span>: !todoItem.completed&#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> todoItem;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展操作符可以在一对{}符号中把一个对象展开，这样，在{}中后面的部分的字段值，可以覆盖展开的部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;...todoItem, <span class="attr">completed</span>: !todoItem.completed&#125;;</span><br></pre></td></tr></table></figure><p>像上面的代码中，返回了一个新的对象，所有字段都和todoItem一样，只是completed字段和todoItem中的completed布尔类型值正好相反。</p><p>对于REMOVE_TODO这种action类型的处理，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> REMOVE_TODO: &#123;</span><br><span class="line">  <span class="keyword">return</span> state.filter(<span class="function">(<span class="params">todoItem</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> todoItem.id !== action.id;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于删除操作，我们使用数组的filter方法，将id匹配的待办事项过滤掉，产生了一个新的数组。</p><p>最后，reducer中的switch语句一定不要漏掉了default的条件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为reducer函数会接收到任意action，包括它根本不感兴趣的action，这样就会执行default中的语句，应该将state原样返回，表示不需要更改state。</p><p>在src/filter/reducer.js中定义了filter模块的reducer，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;SET_FILTER&#125; <span class="keyword">from</span> <span class="string">'./actionTypes.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;FilterTypes&#125; <span class="keyword">from</span> <span class="string">'../constants.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = FilterTypes.ALL, action) = &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SET_FILTER: &#123;</span><br><span class="line">      <span class="keyword">return</span> action.filter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个reducer更加简单，所做的就是把Redux Store上filter字段的值设为action对象上的filter值。</p><p>我们来总结一下Redux的组合reducer功能，利用combineReducers可以把多个只针对局部状态的“小的”reducer合并为一个操纵整个状态树的“大的”reducer，更妙的事，没有两个“小的”reducer会发生冲突，因为无论怎么组合，状态树上一个子状态都只会被一个reducer处理，Redux就是用这种方法隔绝了各个模块。</p><p>很明显，无论我们有多少“小的”reducer，也无论如何组合，都不用在乎它们被因为调用的顺序，因为调用顺序和结果没有关系。</p><h4 id="4-Todo视图"><a href="#4-Todo视图" class="headerlink" title="4. Todo视图"></a>4. Todo视图</h4><p>对于一个功能模块，定义action类型、action构造函数和reducer基本上各用一个文件就行，约定俗成地分别放在模块目录下（actionTypes.js、actions.js和reducer.js文件中）。但是，一个模块涉及的视图文件往往包含多个，因为对于充当视图的React组件，我们往往会让一个React组件的功能精良、小，导致视图分布在多个文件之中。</p><p>既然有多个文件，那么也就没有太大必要保持统一的文件名，反正模块导出的只是一个view字段，在模块内部只要文件名能够表达视图的含义就行。</p><ul><li>1) todos视图</li></ul><p>对于todos模块，在index.js中被导出的view存在src/todos/views/todos.js中，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> AddTodo <span class="keyword">from</span> <span class="string">'./addTodo.js'</span>;</span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'./todoList.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"todos"</span>&gt;</span><br><span class="line">      &lt;AddTodo /&gt;</span><br><span class="line">      &lt;TodoList /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>很简单，就是把AddTodo组件和TodoList两个组件摆放在一个div中，这样的简单组合自然不需要什么状态，所以用一个函数表示成无状态组件就可以了。</p><p>在Todos的顶层div上添加了className属性，值为字符串todos，最后产生的DOM元素上就会有CSS类todos。这个类是为了将来定制样式而使用的，并不影响功能。</p><p>对于AddTodo组件，涉及处理用户的输入。当用户点击“增加”按钮或者在输入栏input中直接回车键的时候，要让JavaScript读取到input这个DOM元素的value值，React为了支持这种方法，提供了一个叫ref的功能。</p><p>在src/todos/views/addTodo.js中有对AddTodo组件的定义，我们先来看其中render函数对ref的用法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"add-todo"</span>&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.onSubmit&#125;&gt;</span><br><span class="line">        &lt;input className=<span class="string">"new-todo"</span> ref=&#123;<span class="keyword">this</span>.refInput&#125; /&gt;</span><br><span class="line">        &lt;button className=<span class="string">"add-btn"</span> type=<span class="string">"submit"</span>&gt;</span><br><span class="line">        添加</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>当一个包含ref属性的组件完成装载（mount）过程的时候，会看一看ref属性是不是一个函数，如果是，就会调用这个函数，参数就是这个组件代表的DOM元素，注意，是DOM元素，不是Virtual DOM元素，通过这种方法，我们的代码可以访问到实际的DOM元素。</p><p>AddTodo的render渲染出来了一个form，通过onSubmit属性把form被提交的事件挂在AddTodo组件的onSubmit函数上。</p><p>在上面的例子中，input元素的ref属性是AddTodo组件的一个成员函数refInput，所以当这个input元素完成装载之后，refInput会被调用。</p><p>refInput的函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refInput(node) &#123;</span><br><span class="line">  <span class="keyword">this</span>.input = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当refInput被调用时，参数node就是那个input元素，refInput把这个node记录在成员变量input中。</p><p>于是，当组件完成mount之后，就可以通过this.input来访问那个input元素。这是一个DOM元素，可以使用任何DOM API访问元素内容，通过访问this.input.value就可以直接读取当前的用户输入。</p><p>使用this.input的onSubmit函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onSubmit(ev) &#123;</span><br><span class="line">  ev.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> input = <span class="keyword">this</span>.input;</span><br><span class="line">  <span class="keyword">if</span> (!input.value.trim()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.props.onAdd(input.value);</span><br><span class="line">  input.value = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HTML中，一个form表单被提交的默认行为会引发网页跳转，在React应用中当然不希望网页跳转发生，所以我们首先通过调用参数ev的preventDefault函数取消掉浏览器的默认提交行为。</p><p>通过this.input.value，可以判断出当前输入框里的文字内容。如果是空白，就应该忽略，因为创建一个空白的待办事项没有意义。否则，就调用通过属性onAdd传递进来的函数。最后，我们把input清空，让用户知道创建成功，而且方便创建下一条待办事项。</p><p>文件中的AddTodo组件是一个内部组件，按说应该是一个傻瓜组件，但是和我们之前例子中的傻瓜组件不一样，AddTodo不是一个只有一个render函数的组件，AddTodo甚至有一个逻辑比较复杂的onSubmit函数，为什么不把这部分逻辑提取到外面的容器组件呢？</p><p>其实我们可以把onSubmit的逻辑提取到mapDispatchToProps中。但是，让AddTodo组件外面的mapDispatchToProps访问到AddTodo组件里面的ref很困难，得不偿失。</p><p>使用ref实际上就是直接触及了DOM元素，与我们想远离DOM是非之地的想法相悖，虽然React提供了这个功能，但是还是要谨慎使用，如果要用，我们进尽量让ref不要跨越组件的边界。</p><p>所以，我们把通过ref访问input.value放在内部的AddTodo中，但是把调用dispatch派发action对象的逻辑放在mapDispatchToProps中，两者一个主内一个主外，各司其职，不要混淆。</p><blockquote><p>注意：并不是只有ref一种方法才能够访问input元素的value，我们在这里使用ref主要是展示一下React的这个功能，在后面的章节中我们会介绍更加可控的方法。</p></blockquote><p>注意，对于AddTodo，没有任何需要从Redux Store的状态衍生的属性，所以最后一行的connect函数第一个参数mapStateToProps是null，只是用了第二个参数mapDispatchToProps。</p><p>在src/todos/views/addTodo.js中表示AddTodo标识符代表的组件和src/todos/views/todos.js中AddTodo标识符代表的组件不一样，后者是前者用react-redux包裹之后的容器组件。</p><p>接下来看看待办事项列表组件，定义在src/todos/view/todoList.js中，在渲染TodoList时，我们的todos属性是一个数组，而数组元素的个数是不确定的，这就涉及如何渲染数量不确定子组件的问题，TodoList作为无状态组件代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TodoList = <span class="function">(<span class="params">&#123;todos, onToogleTodo, onRemoveTodo&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul className=<span class="string">"todo-list"</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      todos.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">        &lt;TodoItem</span><br><span class="line">          key=&#123;item.id&#125;</span><br><span class="line">          text=&#123;item.text&#125;</span><br><span class="line">          completed=&#123;item.completed&#125;</span><br><span class="line">          onToggle=&#123;() =&gt; onToggleTodo(item.id)&#125;</span><br><span class="line">          onRemove=&#123;() =&gt; onRemoveTodo(item.id)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这段代码中的TodoList真的就只是一个无状态的傻瓜组件了，对于传递进来的todos属性，预期是一个数组，通过一个数组的map函数转化为一个TodoItem组件的数组，这是我们第一次在JSX代码片段中创建动态数量的元素。</p><p>因为todos这个数组的元素数量并不确定，所以很自然想到要用一个循环来产生同样数量的TodoItem组件实例。但是，并不能在JSX中使用for或者while这样的循环语句。因为，JSX中可以使用任何形式的JavaScript表达式，只要JavaScript表达式出现在符号{}之间，但是也只能是JavaScript“表达式”，for或者while产生的是“语句”而不是“表达式”，所以不能出现for或者while。</p><p>归根到底，JSX最终会被babel转译成一个嵌套的函数调用，在这个函数调用中自然无法插入一个语句进去，所以，当我们想要在JSX中根据数组产生动态数量的组件实例，就应该用数组的map方法。</p><p>还有一点很重要，对于动态数量的子组件，每个子组件都必须要带上一个key属性，而且这个key属性的值一定要是能够唯一标示这个子组件的值。</p><p>当我们完成Todo应用之后，会回过头来再解释key值的作用。</p><p>TodoList的mapStateToProps方法需要根据Store上的filter状态决定todos状态上取哪些元素来显示，这个过程涉及对filter的switch判断。为了防止mapStateToProps方法过长，我们将这个逻辑提取到selectVisibleTodos函数中，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectVisibleTodos = <span class="function">(<span class="params">todos, filter</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (filter) &#123;</span><br><span class="line">    <span class="keyword">case</span> FilterTypes.ALL:</span><br><span class="line">      <span class="keyword">return</span> todos;</span><br><span class="line">    <span class="keyword">case</span> FilterTypes.COMPLETED:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.completed);</span><br><span class="line">    <span class="keyword">case</span> FilterTypes.UNCOMPLETED:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">item</span> =&gt;</span> !item.completed);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unsupported filter'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    todos: selectVisibleTodos(state.todos, state.filter)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们看TodoList的mapDispatchToProps方法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onToggleTodo: <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">      dispatch(toggleTodo(id));</span><br><span class="line">    &#125;,</span><br><span class="line">    onRemoveTodo: <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">      dispatch(removeTodo(id));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在TodoList空间中，看mapDispatchToProps函数产生的练个新属性onToggleTodo和onRemoveTodo的代码遵循一样的模式，都是把接收到的参数作为参数传递给一个action构造函数，然后用dispatch方法把产生的action对象派发出去，这看起来是重复代码。</p><p>实际上，Redux已经提供了一个bindActionCreators方法来消除这样的重复代码，显而易见很多mapDispatchToProps要做的事情只是把action构造函数和prop关联起来，所以直接以prop名为字段名，以action构造函数为对应字段值，把这样的对象传递给bindActionCreators就可以了，上面的mapDispatchToProps可以简写为这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;bindActionCreators&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> bindActionCreators(&#123;</span><br><span class="line">  onToggleTodo: toggleTodo,</span><br><span class="line">  onRemoveTodo: removeTodo</span><br><span class="line">&#125;, dispatch);</span><br></pre></td></tr></table></figure><p>更进一步，可以直接让mapDispatchToProps是一个prop到action构造函数的映射，这样连bindActionCreators函数都不用，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  onToggleTodo: toggleTodo,</span><br><span class="line">  onRemoveTodo: removeTodo</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面定义的mapDispatchToProps传给connect函数，产生的效果和之前的写法完全一样。</p><p>我们再看定义了TodoItem的src/todos/views/todoItem.js文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TodoItem = <span class="function">(<span class="params">&#123;onToggle, onRemove, completed, text&#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;li </span><br><span class="line">    className=<span class="string">"todo-item"</span> </span><br><span class="line">    style=&#123;&#123;</span><br><span class="line">      textDecoration: completed ? <span class="string">'line-through'</span>: <span class="string">'none'</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;input </span><br><span class="line">      className=<span class="string">"toggle"</span></span><br><span class="line">      type=<span class="string">"checkbox"</span></span><br><span class="line">      checked=&#123;completed ? <span class="string">"checked"</span>: <span class="string">""</span>&#125;</span><br><span class="line">      readOnly</span><br><span class="line">      onClick=&#123;onToggle&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;label className=<span class="string">"text"</span>&gt;&#123;text&#125;&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button className="remove" onClick=&#123;onRemove&#125;&gt;X&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>这里的TodoItem就是一个无状态的组件，把onToggle属性挂到checkbox的点击事件上，把onRemove属性挂到删除按钮的点击事件上。</p><p>每个待办事项都包含一个checkbox元素和一段文字内容，checkbox是否勾选并不依赖用户输入，而是根据completed属性来判断。同时，对于completed状态的待办事项，文字内容中间用横线代表完成。</p><ul><li>2) filter视图</li></ul><p>对于过滤器，我们有三个功能类似的链接，很自然就会想到把链接相关的功能提取出来，放在一个叫Link的组件中。</p><p>在src/filter/views/filter.js中，我们定义被导出的filter主视图，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Filter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;p className=<span class="string">"filters"</span>&gt;</span><br><span class="line">      &lt;Link filter=&#123;FilterTypes.ALL&#125;&gt;&#123;FilterTypes.ALL&#125;&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Link filter=&#123;FilterTypes.COMPLETED&#125;&gt;&#123;FilterTypes.COMPLETED&#125;&lt;/</span>Link&gt;</span><br><span class="line">      &lt;Link filter=&#123;FilterTypes.UNCOMPLETED&#125;&gt;&#123;FilterTypes.UNCOMPLETED&#125;&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>p&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个filter主视图很简单，是一个无状态的函数，列出了三个过滤器，把实际工作都交给了Link组件。</p><p>我们在src/filter/views/link.js中添加Link组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Link = <span class="function">(<span class="params">&#123;active, children, onClick&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (active) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;b className=<span class="string">"filter selected"</span>&gt;&#123;children&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">  &#125; else (</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;a href="#" className="filter no-selected" onClick=&#123;(ev) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        ev.preventDefault();</span></span><br><span class="line"><span class="regexp">        onClick();</span></span><br><span class="line"><span class="regexp">      &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &#123;children&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>a&gt;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为傻瓜组件的Link，当传入属性active为true时表示当前实例就是被选中的过滤器，不该被再次选择，所以不应该渲染超链接标签a。若否，则渲染一个超链接标签。</p><p>一个超链接标签的默认行为是跳转，即href属性是#，所以超链接标签的onClick事件处理器第一件事就是用preventDefault函数取消默认行为。实际上，我们把href设为“#”唯一的目的就是让浏览器给超链接显示出下划线，代表这是一个链接。</p><p>我们使用了一个特殊的属性children，对于任何一个React组件都可以访问这样一个属性，代表的是被包裹住的子组件，比如，对于下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Foo&gt;</span><br><span class="line">  &lt;Bar&gt;WhatEver&lt;<span class="regexp">/Bar&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Foo&gt;</span><br></pre></td></tr></table></figure><p>Foo组件实例的children就是<code>&lt;Bar&gt;WhatEver&lt;/Bar&gt;</code>，而Bar组件实例的children就是<code>WhatEver</code>。在render函数中把children属性渲染出来，是惯常的组合React组件的方法。</p><p>Link的mapStateToProps和mapDispatchToProps函数都很简单，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, ownProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    active: state.filter === ownProps.filter</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch, ownProps</span>) =&gt;</span> &#123;</span><br><span class="line">  onClick: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch(setFilter(ownProps.filter));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-样式"><a href="#5-样式" class="headerlink" title="5. 样式"></a>5. 样式</h4><p>我们终于完成了Todo应用，在浏览器中可以看到最终效果。</p><p><img src="/images/react-4/1.png" alt="无定制样式的Todo应用界面"></p><p>这个Todo应用功能已经完成，但是并没有定制样式，还是需要通过CSS来添加样式。我们在定义视图部分代码时，一些元素上通过className属性添加了CSS类，现在我们就利用这些类来定义CSS规则。</p><p>在src/todos/views/style.css中，我们定义了Todo空间中所有的样式，为了让定义的样式产生效果，在Todos组件的最顶层视图文件src/todos/views/todos.js中添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span>;</span><br></pre></td></tr></table></figure><p>在React应用中，通常使用webpack来完成对JavaScript的打包，create-react-app产生的应用也不例外，不过webpack不知能够处理JavaScript文件，它还能够处理css、scss甚至图片文件，因为在webpack眼里，一切文件都是“模块”，通过文件中的import语句或者require函数调用就可以找到文件之间的使用关系，只要被import就会被纳入最终打包的文件中，即使被import的是一个css文件。</p><p>如下图所示，Todo应用拥有样式了。</p><p><img src="/images/react-4/2.png" alt="完成定制样式的Todo应用界面"></p><p>把css文件用import语句导入，webpack默认的处理方式是将css文件的内容嵌入最终的打包文件bundle.js中，这毫无疑问会让打包文件变得更大，但是应用所有的逻辑都被包含在一个文件中了，便于部署。</p><p>当然，如果不希望将css和JavaScript混在一起，也可以在webpack中通过配置完成，在webpack的loader中使用extract-text-webpack-plugin，就可以让css文件在build时被放在独立的css文件中。</p><p>有意思的是，选择css和JavaScript打包在一起还是分开打包，和代码怎么写没有任何关系，这就是React的妙处。代码中只需要描述“想要什么”，至于最终“怎么做”，可以通过配置webpack获得多重选择。</p><p>如果使用scss语法，可以简化上面的样式代码，但是create-react-app产生的应用默认不支持scss，有兴趣的话可以通过eject方法直接编辑webpack配置，应用上scss加载器。</p><h4 id="6-不使用ref"><a href="#6-不使用ref" class="headerlink" title="6. 不使用ref"></a>6. 不使用ref</h4><p>在前面的例子中，代码通过React的ref功能来访问DOM元素，这种功能的需求往往来自于提交表单的操作，在提交表单的时候，需要读取当前表单中input元素的值。</p><p>毫无疑问，ref的用法非常脆弱，因为React的产生就是为了避免直接操作DOM元素，因为直接访问DOM元素很容易产生失控的情况，现在为了读取某个DOM元素的值，通过ref取得对元素的直接引用，不得不说，干的并不漂亮。</p><p>有没有更好的方法呢？</p><p>有，可以利用组件状态来同步记录DOM元素的值，这种方法可以控制住组件不使用ref。</p><p>Todo应用中的addTodo.js文件可以这样修改，首先是render函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"add-todo"</span>&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.onSubmit&#125;&gt;</span><br><span class="line">        &lt;input </span><br><span class="line">          className=<span class="string">"new-todo"</span> </span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.onInputChange&#125; </span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.value&#125; /&gt;</span><br><span class="line">        &lt;button className=<span class="string">"add-btn"</span> type=<span class="string">"submit"</span>&gt;</span><br><span class="line">          添加</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在这里我们不再使用ref来获取对input元素的直接访问，而是利用input元素上的onChange属性挂上一个事件处理函数onInputChange，这样每当input的值发生变化时，onInputChange函数就会被调用，这样我们总有机会记录下最新的input元素内容。</p><p>onInputChange函数的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onInputChange(event) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    value: event.target.value</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onInputChange函数中，通过传入的事件参数event可以访问事件发生的目标，读取到当前值，并把内容存在组件状态的value字段上。这样，组件状态上总能够获取最新的input元素内容。</p><p>然后看onSubmit函数的改变，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onSubmit(ev) &#123;</span><br><span class="line">  ev.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> inputValue = <span class="keyword">this</span>.state.value;</span><br><span class="line">  <span class="keyword">if</span> (!inputValue.trim()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.props.onAdd(inputValue);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="string">''</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要提交表单的时候，onSubmit函数被调用，只需要直接从组件状态上读取value字段的值就够了。</p><p>在产品开发中，应该尽量避免ref的使用，而换用这种状态绑定的方法来获取元素的值。</p><hr><h3 id="六、开发辅助工具"><a href="#六、开发辅助工具" class="headerlink" title="六、开发辅助工具"></a>六、开发辅助工具</h3><p>我们已经写了一个比较复杂的基于React和Redux的应用，将来还会遇到更复杂的应用，是时候引入一些开发辅助工具了，毕竟没有人能够一次把复杂代码写对，必要的工具能够大大提高我们的工作效率。</p><h4 id="1-Chrome扩展包"><a href="#1-Chrome扩展包" class="headerlink" title="1. Chrome扩展包"></a>1. Chrome扩展包</h4><p>Chrome是网页应用开发者群体最喜爱的浏览器，因为Chrome浏览器有丰富的扩展库来帮助网页开发，这里我们介绍三款Chrome扩展包，可以说是React和Redux应用开发必备之物。</p><ul><li><p>React Devtools，可以检视React组件的树形结构</p></li><li><p>Redux Devtools，可以检视Redux数据流，可以将Store状态跳跃到任何一个历史状态，也就是所谓的“时间旅行”功能</p></li><li><p>React Perf，可以发现React组件渲染的性能问题</p></li></ul><h4 id="2-redux-immutable-state-invariant辅助包"><a href="#2-redux-immutable-state-invariant辅助包" class="headerlink" title="2. redux-immutable-state-invariant辅助包"></a>2. redux-immutable-state-invariant辅助包</h4><p>我们曾经反复强调过，每一个reducer函数都必须是一个纯函数，不能修改传入的参数state和action，否则会让应用重新陷入状态不可预料的境地。</p><p>禁止reducer函数修改参数，这是一个规则，规则总是会被无心违反的，但是怎么避免开发者不小心违反这个规则呢？</p><p>有一个redux-immutable-state-invariant包，提供了一个Redux的中间件，能够让Redux在每次派发动作之后做一个检查。如果发现某个reducer违反了作为一个纯函数的规定擅自修改了参数state，就会给一个大大的错误警告，从而让开发者意识到自己犯了一个错误，必须要修正。</p><p>什么是Redux的中间件？我们在后面的章节会详细介绍，在这里我们只要理解中间件是可以增强Redux的Store实例功能的一种方法就可以。</p><p>很明显，对于redux-immutable-state-invariant的这种检查，在开发环境下很有用。但是在产品环境下，这样的出错提示意义不大，只是徒耗计算资源和增大JavaScript代码提及，所以我们通常在产品环境中不启用redux-immutable-state-invariant。</p><h4 id="3-工具应用"><a href="#3-工具应用" class="headerlink" title="3. 工具应用"></a>3. 工具应用</h4><p>上面我们介绍了辅助开发的Chrome扩展包和redux-immutable-state-variant库，对于React Devtools来说，启用只是安装一个Chrome扩展包的事，但是对于其余几个工具，我们的代码需要做一些修改才能配合浏览器使用。</p><p>因为Store是Redux应用的核心，所以所有的代码修改都集中在src/Store.js中。</p><p>首先需要从Redux引入多个函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore, combineReducers, applyMiddleware, compose&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br></pre></td></tr></table></figure><p>为了使用React Perf插件，需要添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Perf <span class="keyword">from</span> <span class="string">'react-addons-perf'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> win = <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">win.Perf - Perf;</span><br></pre></td></tr></table></figure><p>在这里把window赋值给模块级别变量win，是为了帮助代码缩小器（minifer），在webpack中缩小代码的插件叫UglifyJsPlugin，能够将局部变量名改成很短的变量名，这样功能不受影响但是代码的大小大大缩减。</p><p>不过，和所有的代码缩小器一样，UglifyJsPlugin不敢去改变全局变量名，因为改了就会影响程序的功能。所以当多次引用window这样的全局变量时，最好在模块开始将window赋值给一个变量，比如win，然后在代码其它部分只使用win，这样最终经过UglifyJsPlugin产生的缩小代码就只包含一个无法缩小的window变量。</p><p>我们给win上的Perf赋值了从react-addons-perf上导入的内容，这是为了帮助React Perf扩展包的使用，做了这个代码修改之后，React Perf上的Start按钮和Stop按钮才会起作用。</p><p>为了应用redux-immutable-state-invariant中间件和Redux Devtools，需要使用Redux的Store Enhancer功能，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  todos: todoReducer,</span><br><span class="line">  filter: filterReducer</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewares = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  middlewares.push(<span class="built_in">require</span>(<span class="string">'redux-immutable-state-invariant'</span>)());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storeEnhancers = compose(</span><br><span class="line">  applyMiddleware(...middlewares),</span><br><span class="line">  (win &amp;&amp; win.devToolsExtension) ? win.devToolExtension() : <span class="function">(<span class="params">f</span>) =&gt;</span> f</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(reducer, &#123;&#125;, storeEnhancers);</span><br></pre></td></tr></table></figure><p>代码修改的关键在于给createStore函数增加了第三个参数storeEnhancers，这个参数代表Store Enhancer的意思，能够让createStore函数产生的Store对象具有更多更强的功能。</p><p>因为Store Enhancer可能有多个，在我们的例子中就有两个，所以Redux提供了一个compose函数，用于把多个Store Enhancer组合在一起，我们分别来看这两个Store Enhancer是什么。</p><p>第一个Store Enhancer是一个函数applyMiddleware的执行结果，这个函数接受一个数组作为参数，每个元素都是一个Redux的中间件。虽然目前我们只应用了一个中间件，但是考虑到将来会扩展更多，所以我们用数组变量middlewares来存储所有的中间件，将来要扩展新的中间件只需要往这个数组中push新的元素就可以了。</p><p>目前，往middlewares中push的唯一一个中间件就是redux-immutable-state-invariant。如同上面解释过的，redux-immutable-state-invariant只有在开发环境下使用才有意义，所以只有当process.env.NODE_ENV不等于production时才加入这个中间件。</p><p>我们一直按照ES6的语法导入模块，也就是用import关键字导入模块，但是在这里却用了Node传统风格require，是因为import语句不能够存在于条件语句之中，只能出现在模块语句的顶层位置。</p><p>第二个Store Enhancer就是Redux Devtools，因为Redux Devtools的工作原理是截获所有应用中Redux Store的动作和状态变化，所以必须通过Store Enhancer在Redux Store中加入钩子。</p><p>如果浏览器中安装了Redux Devtools，在全局window对象上就有一个devToolsExtension代表Redux Devtools。但是，我们也要让没有安装这个扩展包的浏览器也能正常使用我们的应用，所以要根据window.devToolsExtension是否存在做一个判断，如果有就用，如果没有就插入一个什么都不做的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(win &amp;&amp; win.devToolsExtension) ? win.devToolsExtension() : <span class="function">(<span class="params">f</span>) =&gt;</span> f</span><br></pre></td></tr></table></figure><p>当所有的代码修改完毕，重新启动Todo应用，在浏览器的开发者工具中就可以使用所有关于React和Redux的工具了。</p><hr><h3 id="七、本章小结"><a href="#七、本章小结" class="headerlink" title="七、本章小结"></a>七、本章小结</h3><p>在这一章，我们学习了构建一个完整Redux应用的步骤和需要考虑的方面。</p><p>首先，要考虑代码文件的组织方式，对于可以高度模块化的Redux应用，使用“按功能组织”的方式要优于传统MVC框架下“按角色组织”的方式。</p><p>之后，要考虑Store上状态树的设计，因为状态树的结构直接决定了模块的划分，以及action类型、action构造函数和reducer的设计。可以说，开始写Redux应用第一行代码之前，首先要想好Store的状态树长得什么样子。</p><p>然后，我们实际构建了一个Todo应用，这个应用要比之前的ControlPanel应用复杂，利用划分模块的方法解决才是正道，从中我们也学习了React的ref功能，以及动态数量的子空间必须要包含key属性。</p><p>最后，我们了解了开发React和Redux应用必备的几样辅助工具，有了这几样工具，开发React和Redux应用就会如虎添翼。</p><p>这只是个起点，在接下来的章节中，我们会进一步深入了解React和Redux的精髓。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="/resources/深入浅出React和Redux.pdf">《深入浅出React和Redux —— 程墨》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在第一部分中，我们已经了解了React的基本工作方式，也知道了Redux在组合React组件中的作用，但是更多的只是了解其基本原理和使用方法，上手练习的也是一个简单的例子。&lt;/p&gt;
    
    </summary>
    
      <category term="React抄书笔记" scheme="http://www.xiaoleon.cn/categories/React%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.xiaoleon.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Web(7) 前端路由实现方法</title>
    <link href="http://www.xiaoleon.cn/2018/03/13/web-7/"/>
    <id>http://www.xiaoleon.cn/2018/03/13/web-7/</id>
    <published>2018-03-13T07:45:47.000Z</published>
    <updated>2018-03-13T14:27:42.743Z</updated>
    
    <content type="html"><![CDATA[<p>什么是路由？简单的来说，路由是 <strong><em>URL –&gt; 函数</em></strong> 的映射关系。</p><p>大部分复杂的网站，都会把业务解耦为模块进行处理。这些网站中又有很多的网站会把适合的部分应用Ajax进行数据交互，展现给用户，很明显处理这样的数据通信交互，不可避免的会涉及到跟URL打交道，让数据交互的变化反映到URL的变化上，进而可以给用户机会去通过保存的URL链接，还原刚才的页面内容板块的布局，这其中包括Ajax局部刷新的变化。</p><a id="more"></a><h3 id="一、router和route的区别"><a href="#一、router和route的区别" class="headerlink" title="一、router和route的区别"></a>一、<code>router</code>和<code>route</code>的区别</h3><p><code>route</code>是一条路由，它将一个 <strong><em>URL</em></strong> 路径和一个 <strong><em>函数</em></strong> 进行映射，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/users          --&gt;     getAllUsers()  </span><br><span class="line">/users/count    --&gt;     getUsersCount()</span><br></pre></td></tr></table></figure><p><code>router</code>可以理解为一个容器，或者一种机制，它管理了一组<code>route</code>。</p><p><code>router</code>是<code>route</code>的一组Map映射表，接收到一个URL后，由<code>router</code>来从映射表中查找相应的函数。</p><hr><h3 id="二、服务端路由"><a href="#二、服务端路由" class="headerlink" title="二、服务端路由"></a>二、服务端路由</h3><p>对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。</p><ul><li><p>静态资源，可以认为，URL的映射函数就是一个文件的读取操作。 </p></li><li><p>动态资源，映射函数可能是一个数据库的读取操作，也可能是一些数据处理等等。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.sendFile(<span class="string">'index'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/users'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = db.queryAllUsers();</span><br><span class="line">    res.send(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>router</code>匹配<code>route</code>的过程中，不仅会根据URL来匹配，还会根据请求的方法来匹配，如<code>POST</code>、<code>GET</code>、<code>PUT</code>、<code>DELETE</code>等等。</p><hr><h3 id="三、客户端路由"><a href="#三、客户端路由" class="headerlink" title="三、客户端路由"></a>三、客户端路由</h3><p>对于客户端来说，路由的映射函数通常是进行一些DOM元素的<strong>显示和隐藏</strong>操作。这样，当访问不同的路径的时候，会显示不同的页面组件。</p><p>客户端路由最常见的是下面两种实现方案：</p><h4 id="1-基于Hash（锚点）"><a href="#1-基于Hash（锚点）" class="headerlink" title="1. 基于Hash（锚点）"></a>1. 基于Hash（锚点）</h4><p>URL中 <code>#</code> 或者 <code>#!</code> 及其后面的部分为hash，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"><span class="keyword">var</span> a = url.parse(<span class="string">'http://example.com/a/b/#/foo/bar'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.has)</span><br><span class="line"><span class="comment">// =&gt; #/foo/bar</span></span><br></pre></td></tr></table></figure><p>H5中对has有一个<code>hashchange</code>事件，当页面的<code>hash</code>变化时，即会出发<code>hashchange</code>。</p><p>锚点<code>Hash</code>起到引导浏览器将这次记录推入<strong>历史记录栈顶</strong>的作用，<code>window.location</code>对象处理 <code>#</code> 的改变并不会重新加载页面，而是将之当成新页面，放入历史栈里。</p><p>当<code>前进(-&gt;)</code>或者<code>后退(&lt;-)</code>或者触发<code>hashchange</code>事件时，我们可以在对应的事件处理函数里注册ajax等操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash = <span class="built_in">window</span>.location.hash;</span><br><span class="line">    <span class="keyword">var</span> path = hash.substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (path) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            showHome();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/users'</span>:</span><br><span class="line">            showUsersList();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            show404NotFound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是hashchange这个事件并不是每个浏览器都有，地基浏览器需要用轮询检测URL是否在变化，来检测锚点的变化。  </p><p>当锚点内容 <code>location.hash</code> 被操作时，如果锚点内容发生改变浏览器才会将其放入历史栈中；否则历史栈并不会增加，并且也不会触发<code>hashchange</code>事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果浏览器不支持原生实现的事件，则开始模拟，否则退出。</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="string">"onhashchange"</span> <span class="keyword">in</span> <span class="built_in">window</span>.document.body ) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> location = <span class="built_in">window</span>.location,</span><br><span class="line">    oldURL = location.href,</span><br><span class="line">    oldHash = location.hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每隔100ms检查hash是否发生变化</span></span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newURL = location.href,</span><br><span class="line">        newHash = location.hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash发生变化且全局注册有onhashchange方法（这个名字是为了和模拟的事件名保持统一）；</span></span><br><span class="line">        <span class="keyword">if</span> ( newHash != oldHash &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span>.onhashchange === <span class="string">"function"</span>  ) &#123;</span><br><span class="line">            <span class="comment">// 执行方法</span></span><br><span class="line">            <span class="built_in">window</span>.onhashchange(&#123;</span><br><span class="line">                type: <span class="string">"hashchange"</span>,</span><br><span class="line">                oldURL: oldURL,</span><br><span class="line">                newURL: newURL</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            oldURL = newURL;</span><br><span class="line">            oldHash = newHash;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><h4 id="2-基于History"><a href="#2-基于History" class="headerlink" title="2. 基于History"></a>2. 基于History</h4><p>我们首先熟悉几个H5的 <code>History Api</code>，下面是<code>Mozilla</code>在H5中实现的<code>History Api</code>的官方文档描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Returns the number of entries in the joint session history.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.length</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Returns the current state object.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.state</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Goes back or forward the specified number of steps in the joint session history.A zero delta will reload the current page.If the delta is out of range, does nothing.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.go([delta])</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Goes back one step in the joint session history.If there is no previous page, does nothing.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.back()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Goes forward one step in the joint session history.If there is no next page, does nothing.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.forward()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Pushes the given data onto the session history, with the given title, and, if provided and not null, the given URL.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.pushState(data, title[url])</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Updates the current entry in the session history to have the given data, title, and,if provided and not null, URL.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.replaceState(data, title[url])</span><br></pre></td></tr></table></figure><p>其中最后的两个方法<code>history.pushState</code>和<code>history.replaceState</code>，为前端操控浏览器历史栈提供了可能性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*parameters</span></span><br><span class="line"><span class="comment">*@data &#123;object&#125; state对象，这是一个javascript对象，一般是JSON格式的对象</span></span><br><span class="line"><span class="comment">*字面量。</span></span><br><span class="line"><span class="comment">*@title &#123;string&#125; 可以理解为document.title，在这里是作为新页面传入参数的。</span></span><br><span class="line"><span class="comment">*@url &#123;string&#125; 增加或改变的记录，对应的url，可以是相对路径或者绝对路径，</span></span><br><span class="line"><span class="comment">*url的具体格式可以自定。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">history.pushState(data, title, url) <span class="comment">//向浏览器历史栈中增加一条记录。</span></span><br><span class="line">history.replaceState(data, title, url) <span class="comment">//替换历史栈中的当前记录。</span></span><br></pre></td></tr></table></figure><p>这两个Api都会操作浏览器的历史栈，而不会引起页面的刷新。不同的是，<code>pushState</code>会增加一条新的历史记录，而<code>replaceState</code>则会替换当前的历史记录。</p><p>在将新的历史记录存入栈后，会把传入的<code>data(即state对象)</code>同时存入，方便以后调用，存在用户的本地硬盘上，最大支持到640k。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentState = history.state; <span class="comment">//如果没有则为null</span></span><br></pre></td></tr></table></figure><p>同时，这俩api都会更新或者覆盖当前浏览器的title和url为对应传入的参数。</p><p>URL参数可以为绝对路径，也可以为相对路径，但是不能跨域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设当前网页URL为：http://tonylee.pw</span></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"http://tonylee.pw?name=tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw?name=tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"http://tonylee.pw/name/tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"?name=tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw?name=tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"name=tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name=tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"/name/tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"name/tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的用法：</span></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"http://www.tonylee.pw?name=tonylee"</span>);</span><br><span class="line"><span class="comment">//error: 由于跨域将产生错误</span></span><br></pre></td></tr></table></figure><p>可以看到，URL作为一个改变当前浏览器地址的参数，用法是非常灵活的。传入的URL默认以“<code>/</code>”相隔，也可以自己指定为“<code>?</code>”等。</p><p><strong><em>根据URL的变化 –&gt; 页面板块变化 –&gt; 页面发出XHR请求 –&gt; 页面没有reload</em></strong></p><p>这里我们可以看一下<code>mozilla</code>提供的一个<code>pushState</code>和<code>replaceState</code>的小demo，已经接近一个前端路由的雏形。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;!-- <span class="keyword">this</span> starts off <span class="keyword">as</span> http:<span class="comment">//example.com/line?x=5 --&gt;</span></span><br><span class="line">&lt;title&gt;Line Game - <span class="number">5</span>&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;You are at coordinate &lt;span id="coord"&gt;5&lt;/</span>span&gt; on the line.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;</span></span><br><span class="line"><span class="regexp">&lt;a href="?x=6" onclick="go(1); return false;"&gt;Advance to 6&lt;/</span>a&gt; or</span><br><span class="line">&lt;a href=<span class="string">"?x=4"</span> onclick=<span class="string">"go(-1); return false;"</span>&gt;retreat to <span class="number">4</span>&lt;<span class="regexp">/a&gt;?</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> currentPage = <span class="number">5</span>; <span class="comment">// prefilled by server！！！！</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    setupPage(currentPage + d);</span><br><span class="line">    history.pushState(currentPage, <span class="built_in">document</span>.title, <span class="string">'?x='</span> + currentPage);</span><br><span class="line">&#125;</span><br><span class="line">onpopstate = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    setupPage(event.state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupPage</span>(<span class="params">page</span>) </span>&#123;</span><br><span class="line">    currentPage = page;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">'Line Game - '</span> + currentPage;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'coord'</span>).textContent = currentPage;</span><br><span class="line">    <span class="built_in">document</span>.links[<span class="number">0</span>].href = <span class="string">'?x='</span> + (currentPage+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">document</span>.links[<span class="number">0</span>].textContent = <span class="string">'Advance to '</span> + (currentPage+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">document</span>.links[<span class="number">1</span>].href = <span class="string">'?x='</span> + (currentPage<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">document</span>.links[<span class="number">1</span>].textContent = <span class="string">'retreat to '</span> + (currentPage<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>从例子中我们看到一个<code>popstate</code>的事件，这里也看看<code>mozalla</code>官方文档</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">An event handler <span class="keyword">for</span> the popstate event on the window.</span><br><span class="line"></span><br><span class="line">A popstate event is dispatched to the window every <span class="built_in">time</span> the active history entry changes between two history entries <span class="keyword">for</span> the same document. <span class="keyword">If</span> the history entry being activated was created by a <span class="keyword">call</span> to history.pushState() or was affected by a <span class="keyword">call</span> to history.replaceState(), the popstateevent's state property contains a <span class="built_in">copy</span> of the history entry's state object.</span><br><span class="line"></span><br><span class="line">Note that just calling history.pushState() or history.replaceState() won't trigger apopstate event. The popstate event is only triggered by doing a browser action such as clicking on the back button (or calling history.back() <span class="keyword">in</span> JavaScript). And the event is only triggered when the user navigates between two history entries <span class="keyword">for</span> the same document.</span><br><span class="line"></span><br><span class="line">Browsers tend to handle the popstate event differently on page load. Chrome (prior to v34) and Safari always emit a popstate event on page load, but Firefox doesn't.</span><br><span class="line"></span><br><span class="line">Syntax</span><br><span class="line">    window.onpopstate = funcRef;</span><br><span class="line">    //funcRef is a handler function.</span><br></pre></td></tr></table></figure><p>简单来说，当同一个页面在历史记录间切换时，就会派发<code>popstate</code>事件。</p><p>正常情况下，用户点击后退按钮或者调用<code>history.back() or history.go()</code>，页面根本没有处理事件的机会，因为这些操作会使得页面<code>reload</code>，所以<code>popstate</code>只在不会让浏览器页面刷新的历史记录之间切换才能触发，这些历史记录一般由<code>pushState/replaceState</code>或者是由<code>hash</code>锚点等操作产生，并且在事件的句柄中可以访问state对象的引用副本！</p><p>单纯的调用<code>pushState/replaceState</code>并不会触发<code>popstate</code>事件。</p><p>页面初次加载时，是否会主动触发<code>popstate</code>事件，不同的浏览器实现不一样。下面是一个官方demo。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"location: "</span> + <span class="built_in">document</span>.location + <span class="string">", state: "</span> +   <span class="built_in">JSON</span>.stringify(event.state));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">1</span>&#125;, <span class="string">"title 1"</span>, <span class="string">"?page=1"</span>);</span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">2</span>&#125;, <span class="string">"title 2"</span>, <span class="string">"?page=2"</span>);</span><br><span class="line">history.replaceState(&#123;<span class="attr">page</span>: <span class="number">3</span>&#125;, <span class="string">"title 3"</span>, <span class="string">"?page=3"</span>);</span><br><span class="line">history.back(); <span class="comment">// alerts "location: http://example.com/example.html?page=1, state: &#123;"page":1&#125;"</span></span><br><span class="line">history.back(); <span class="comment">// alerts "location: http://example.com/example.html, state: null</span></span><br><span class="line">history.go(<span class="number">2</span>); <span class="comment">// alerts "location: http://example.com/example.html?page=3, state: &#123;"page":3&#125;</span></span><br></pre></td></tr></table></figure><p>兼容性测试脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"node_modules/jquery/dist/jquery.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(history &amp;&amp; history.pushState) &#123;</span><br><span class="line">        alert(<span class="string">"true"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">"false"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    $(<span class="built_in">window</span>).on(<span class="string">"hashchange"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"hashchange"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>兼容性概览：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">history &amp;&amp; history.pushState兼容如下：</span><br><span class="line">    chrome true；</span><br><span class="line">    Firefox true；</span><br><span class="line">    IE10 true;</span><br><span class="line">    IE &lt;= <span class="number">9</span> false;  </span><br><span class="line"><span class="function">    PS:<span class="title">IE</span> &lt;= 9既然不支持这些<span class="title">api</span>那就只能采用<span class="title">hash</span>方案，来实现路由系统的兼容了。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">hashchange</span>兼容如下：</span></span><br><span class="line"><span class="function">    <span class="title">IE9</span> <span class="title">true</span>;</span></span><br><span class="line"><span class="function">    <span class="title">IE8</span> <span class="title">true</span>;</span></span><br><span class="line"><span class="function">    <span class="title">IE7</span> <span class="title">false</span>;</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">页面<span class="title">load</span>时，<span class="title">onhashchange</span>默认触发情况：</span></span><br><span class="line"><span class="function">    <span class="title">chrome</span> 需主动<span class="title">trigger</span>才能触发</span></span><br><span class="line"><span class="function">    <span class="title">FF</span> 需主动<span class="title">trigger</span>才能触发</span></span><br><span class="line"><span class="function">    <span class="title">IE</span> 需主动<span class="title">trigger</span>才能触发</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">页面<span class="title">load</span>时，<span class="title">onpopstate</span>默认触发情况：</span></span><br><span class="line"><span class="function">    <span class="title">chrome</span> &lt; 34版本之前的默认触发 </span></span><br><span class="line"><span class="function">    <span class="title">FF</span> 默认不触发</span></span><br><span class="line"><span class="function">    <span class="title">IE</span> 默认不触发</span></span><br></pre></td></tr></table></figure><p>只有webkit内核浏览器才会默认触发<code>popstate</code>。</p><h4 id="3-两种实现的比较"><a href="#3-两种实现的比较" class="headerlink" title="3. 两种实现的比较"></a>3. 两种实现的比较</h4><ul><li><p>基于<code>Hash</code>的路由，兼容性更好</p></li><li><p>基于<code>History API</code>的路由，更加直观和正式</p></li></ul><p>有一点很大的区别是，基于<code>Hash</code>的路由不需要对服务器做改动，基于<code>History API</code>的路由需要对服务器做一些改造。</p><p>浏览器第一次打开某个链接时，首先会定向到<code>server</code>端进行路由解析。上边所说的前端路由系统，都是建立在页面已经打开的前提下，前端才可以通过<code>History API</code>进行URL拦截，确保这些URL变化不会发送给<code>server</code>端返回新页面。</p><p>但是需要考虑这种情况，链接时在一个新的浏览器tab中打开的，那么这个时候就无法拦截下这个URL，所以，这就要求server和前端制定好一个规则，区分URL中<strong><em>前端解析的部分</em></strong>和<strong><em>后端解析的部分</em></strong>，<code>server</code>端判断出这个URL的某个部分不属于自己的范围时，就应该把这部分URL定向到前端路由页面的<code>javascript</code>代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodejs</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req.path.indexOf(<span class="string">'/routeForServer'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        res.send(<span class="string">'这里返回的都是server端处理的路由'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.sendfile(<span class="string">'这里返回配置好路由的页面'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>正常情况下，URL中的“/”一般是server端路由采用的标记，而“?”或者“#”再或者“#!”，则一般是前端路由采用的开始标记，我们可以在这些符号后边，通过键值对的形式，描述一个页面具有哪些板块配置信息。也不乏有的网站为了美观，前后端共用“/”进行路由索引。</p><p>URL中采用“#”或者“#!”进行前后端的区分，是为了照顾到更多浏览器，因为利用hash方案，IE对这套路由系统有很好的支持性。</p><hr><h3 id="四、动态路由"><a href="#四、动态路由" class="headerlink" title="四、动态路由"></a>四、动态路由</h3><p>上面提到的例子都是静态路由，即路径都是固定的。但是我们经常会需要在路径中传入参数，例如或者某个用户的信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodejs</span></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">百度：</span><br><span class="line"><span class="function">    https://<span class="title">wenku.baidu.com</span>/<span class="title">album</span>/<span class="title">list</span>?<span class="title">cid</span>=197</span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">zhidao.baidu.com</span>/<span class="title">daily</span>/<span class="title">view</span>?<span class="title">id</span>=47009</span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新浪：</span><br><span class="line"><span class="function">    http://<span class="title">sz.sina.com.cn</span>/<span class="title">news</span>/<span class="title">yz</span>/2016-09-02/<span class="title">detail</span>-<span class="title">ifxvqcts9207231.shtml</span>?<span class="title">from</span>=<span class="title">sz_tttj</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">京东：</span><br><span class="line"><span class="function">    https://<span class="title">item.jd.com</span>/3995645.<span class="title">html</span>#<span class="title">crumb</span>-<span class="title">wrap</span></span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">list.jd.com</span>/<span class="title">list.html</span>?<span class="title">cat</span>=9987,653,655&amp;<span class="title">ev</span>=%40<span class="title">exbrand_14026</span>&amp;<span class="title">go</span>=0</span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Google Gmail</span><br><span class="line"><span class="function">    https://<span class="title">mail.google.com</span>/<span class="title">mail</span>/<span class="title">u</span>/1/#<span class="title">inbox</span></span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">mail.google.com</span>/<span class="title">mail</span>/<span class="title">u</span>/1/#<span class="title">starred</span></span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">mail.google.com</span>/<span class="title">mail</span>/<span class="title">u</span>/1/#<span class="title">sent</span></span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">mail.google.com</span>/<span class="title">mail</span>/<span class="title">u</span>/1/#<span class="title">drafts</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate" target="_blank" rel="noopener">MDN官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是路由？简单的来说，路由是 &lt;strong&gt;&lt;em&gt;URL –&amp;gt; 函数&lt;/em&gt;&lt;/strong&gt; 的映射关系。&lt;/p&gt;
&lt;p&gt;大部分复杂的网站，都会把业务解耦为模块进行处理。这些网站中又有很多的网站会把适合的部分应用Ajax进行数据交互，展现给用户，很明显处理这样的数据通信交互，不可避免的会涉及到跟URL打交道，让数据交互的变化反映到URL的变化上，进而可以给用户机会去通过保存的URL链接，还原刚才的页面内容板块的布局，这其中包括Ajax局部刷新的变化。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="前端路由" scheme="http://www.xiaoleon.cn/tags/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
    
      <category term="Hash" scheme="http://www.xiaoleon.cn/tags/Hash/"/>
    
      <category term="History" scheme="http://www.xiaoleon.cn/tags/History/"/>
    
  </entry>
  
  <entry>
    <title>Web(6) 浏览器页面的渲染过程</title>
    <link href="http://www.xiaoleon.cn/2018/03/12/web-6/"/>
    <id>http://www.xiaoleon.cn/2018/03/12/web-6/</id>
    <published>2018-03-12T02:52:44.000Z</published>
    <updated>2018-03-12T14:01:55.037Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器在下载好HTML、CSS、JS等文件后，是如何将这些内容组装成绚丽的页面呈现给用户呢？不同的浏览器渲染过程实际上并不相同，但是依旧存在相一致的部分。</p><a id="more"></a><h3 id="一、浏览器渲染页面"><a href="#一、浏览器渲染页面" class="headerlink" title="一、浏览器渲染页面"></a>一、浏览器渲染页面</h3><p>从浏览器地址栏的请求链接开始，浏览器通过DNS解析查到域名映射的IP地址，成功之后浏览器端向此IP地址取得连接。成功连接之后，浏览器端将请求头信息通过HTTP协议向此IP地址所在服务器发起请求。服务器接收到请求之后等待处理，最后向浏览器端发回响应，此时在HTTP协议下，浏览器从服务器接收到text/html类型的代码，浏览器开始显示此HTML，并获取其中内嵌资源文件，然后浏览器再发起请求来获取这些资源，并在浏览器的html中显示。</p><p>浏览器解析的大概的工作流程可以分为以下几个步骤：</p><ul><li><p>1) 用户输入网址（假设是HTML页面，第一次访问，无缓存情况），浏览器向服务器发出HTTP请求，服务器返回HTML文件</p><p>  优化方案：善用缓存，减少HTTP请求，减轻服务器压力</p></li><li><p>2) 浏览器载入HTML代码，发现head内有一个link引用外部css文件，则浏览器立即发送css文件请求，获取浏览器返回的css文件</p><p>  优化方案：css文件合并，减少HTTP请求</p></li><li><p>3) 浏览器继续载入HTML中body部分的代码，并且css文件已经拿到手了，可以开始渲染页面了</p><p>  优化方案：css文件要放在最上面，避免网页重新渲染</p></li><li><p>4) 浏览器在代码中发现一个img标签引用了一张图片，向服务器发出请求，此时浏览器不会等到图片下载完，而是继续渲染后面的代码</p><p>  优化方案：图片文件合并，减少HTTP请求</p></li><li><p>5) 服务器返回图片文件，由于占用了一定面积，影响后面段落的布局，因此浏览器需要回过头来重新渲染这部分代码</p><p>  优化方案：最好图片都设置尺寸，避免重新渲染</p></li><li><p>6) 浏览器发现一个包含一行JavaScript的script标签，会立即运行该js代码</p><p>  优化方案：script最好放在页面最下面</p></li><li><p>7) js脚本执行了语句，它令浏览器隐藏掉代码中的某个div，突然就少了一个元素，浏览器不得不重新渲染这部分代码</p><p>  优化方案：页面初始化样式不要使用js控制</p></li><li><p>8) 浏览器完成渲染，展示HTML页面</p></li></ul><hr><h3 id="二、重绘和回流"><a href="#二、重绘和回流" class="headerlink" title="二、重绘和回流"></a>二、重绘和回流</h3><h4 id="1-什么是重绘和回流"><a href="#1-什么是重绘和回流" class="headerlink" title="1. 什么是重绘和回流"></a>1. 什么是重绘和回流</h4><p>为什么页面会慢？那是因为浏览器需要花时间去渲染，尤其是当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，该过程称为回流（<code>reflow</code>）。</p><p><code>reflow</code>几乎是无法避免的，现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的<code>reflow</code>。鼠标滑过、点击等等，只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会<code>reflow</code>哪一部分的代码，它们都彼此相互影响着。</p><p>如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器的重绘（<code>repaint</code>）。</p><p><code>repaint</code>的速度明显快于<code>reflow</code>（在IE下需要换一下说法，<code>reflow</code>要比<code>repaint</code>更缓慢）。</p><p><code>repaint操</code>作触发时，元素的外观被改变，且在没有改变布局的情况下发生，如改变<code>outline</code>、<code>visibility</code>、<code>background-color</code>，不会影响到dom结构渲染。</p><p><code>reflow</code>与<code>repaint</code>区别就是它会影响到dom的结构渲染，同时它会触发<code>repaint</code>，它会改变它本身与所有父辈元素，这种开销是非常昂贵的，导致性能下降是必然的，页面元素越多效果越明显。</p><p>注意：回流必将引起重绘，重绘不一定引起回流。</p><h4 id="2-如何减少重绘和回流"><a href="#2-如何减少重绘和回流" class="headerlink" title="2. 如何减少重绘和回流"></a>2. 如何减少重绘和回流</h4><p><code>reflow</code>是不可避免的，只能将<code>reflow</code>对性能的影响减少到最小</p><ul><li><p>1) 不要一条一条地修改DOM样式，通过设置<code>style</code>属性改变节点样式的话，每设置一次都会导致一次<code>reflow</code>。所以最好通过设置<code>class</code>的方式，这样可以将多次改变样式属性的操作合并成一次操作</p></li><li><p>2) 让要操作的元素进行“离线处理”，处理完后一起更新</p><ul><li><p>使用<code>DocumentFragment</code>进行缓存操作，引发一次重绘与回流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">fragment.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Hello Zhang Xiao!'</span>));</span><br><span class="line"></span><br><span class="line">fragment.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'br'</span>));</span><br><span class="line"></span><br><span class="line">fragment.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Hello Leon!'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(fragment);</span><br></pre></td></tr></table></figure></li><li><p>使用<code>display: none</code>技术，只引发两次重绘与回流</p><p>原理：由于<code>display</code>属性为<code>none</code>的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样在隐藏和显示时触发2次重排。</p></li></ul></li><li><p>3) 设置元素的<code>position</code>为<code>absolute</code>或<code>fixed</code></p></li></ul><p>元素脱离标准文档流，也从DOM树结构中脱离出来，在需要<code>reflow</code>时只需要<code>reflow</code>自身与下级元素。</p><ul><li>4) 不要使用table布局</li></ul><p>table中某个元素一旦触发<code>reflow</code>就会导致table里所有的其他元素<code>reflow</code>。在适合用table的场合，可以设置<code>table-layout</code>为<code>auto</code>或<code>fixed</code>，这样可以让table一行一行的渲染，这种做法也是为了限制<code>reflow</code>的影响范围。</p><ul><li>5) 避免使用css的JavaScript表达式，如果css里有<code>expression</code>，每次都会重新计算一次。</li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://www.jianshu.com/p/7fbd239ca0e2?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">浏览器如何渲染页面</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器在下载好HTML、CSS、JS等文件后，是如何将这些内容组装成绚丽的页面呈现给用户呢？不同的浏览器渲染过程实际上并不相同，但是依旧存在相一致的部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="页面渲染" scheme="http://www.xiaoleon.cn/tags/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/"/>
    
      <category term="重绘" scheme="http://www.xiaoleon.cn/tags/%E9%87%8D%E7%BB%98/"/>
    
      <category term="回流" scheme="http://www.xiaoleon.cn/tags/%E5%9B%9E%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>React(3) 从Flux到Redux</title>
    <link href="http://www.xiaoleon.cn/2018/03/06/react-3/"/>
    <id>http://www.xiaoleon.cn/2018/03/06/react-3/</id>
    <published>2018-03-06T15:05:43.000Z</published>
    <updated>2018-03-19T13:15:53.841Z</updated>
    
    <content type="html"><![CDATA[<p>在前一章中我们已经感受到完全用React来管理应用数据的麻烦，在这一章中，我们将介绍Redux这种管理应用状态的框架</p><a id="more"></a><p>本章包含以下内容：</p><ul><li><p>单向数据流框架的始祖Flux</p></li><li><p>Flux理念的一个更强实现Redux</p></li><li><p>结合React和Redux</p></li></ul><h3 id="一、Flux"><a href="#一、Flux" class="headerlink" title="一、Flux"></a>一、Flux</h3><p>要了解Redux，首先要从Flux说起，可以认为Redux是Flux思想的另一种实现方式，通过了解Flux，我们可以知道Flux一族框架（其中就包括Redux）贯彻的最重要的观点——单向数据流，更重要的是，我们可以发现Flux框架的缺点，从而深刻地认识到Redux相对于Flux的改进之处。</p><p>让我们来看看Flux的历史，实际上，Flux是和React同时面世的，在2013年，Facebook公司让React亮相的同时，也推出了Flux框架，React和Flux相辅相成，Facebook认为两者结合在一起才能构建大型的JavaScript应用。</p><p>做一个容易理解的对比，React是用来替换jQuery的，那么Flux就是以替换Backbone.js、Ember.js等MVC一族框架为目的。</p><p>在MVC（Model-View-Controller）的世界里，React相当于V（View）的部分，只涉及页面的渲染，一旦涉及应用的数据管理部分，还是交给Model和Controller，不过，Flux并不是一个MVC框架，事实上，Flux认为MVC框架存在很大问题，它推翻了MVC框架，并用一个新的思维来管理数据流转。</p><h4 id="1-MVC框架的缺陷"><a href="#1-MVC框架的缺陷" class="headerlink" title="1. MVC框架的缺陷"></a>1. MVC框架的缺陷</h4><p>MVC框架是业界广泛接受的一种前端应用框架类型，这种框架把应用分成三个部分：</p><ul><li><p>Model（模型）：负责管理数据，大部分业务逻辑也应该放在Model中</p></li><li><p>View（视图）：负责渲染用户界面，应该避免在View中涉及业务逻辑</p></li><li><p>Controller（控制器）：负责接受用户输入，根据用户输入调用对应的Model部分逻辑，把产生的数据结果交给View部分，让View渲染出必要的输出。</p></li></ul><p>MVC框架的几个组成部分和请求的关系如图所示</p><p><img src="/images/react-3/1.png" alt="MVC框架"></p><p>这样的逻辑划分，实质上与把以一个应用划分为多个组件一样，就是“分而治之”。毫无疑问，相比把业务逻辑和界面渲染逻辑混在一起，MVC框架要先进得多。这种方式得到了广泛的认可，连Facebook最初也是用这种框架。</p><p>但是，Facebook的工程部门逐渐发现，对于非常巨大的代码库和庞大的组织，按照他们的原话说就是“MVC真的很快就变得非常复杂”。每当工程师想要增加一个新的功能时，对代码的修改很容易引入新的bug，因为不同模块之间的依赖关系让系统变得“脆弱而且不可预测”。对于刚刚加入团队的新手，更是举步维艰，因为不知道修改代码会造成什么样的后果。如果要保险，就会发现寸步难移；如果放手去干，就可能引发很多bug。</p><p>一句话，MVC根本不适合Facebook的需求。</p><p>为何被业界普遍认可的MVC框架在Facebook眼里却沦落到如此地步呢？</p><p>下图是Facebook描述的MVC框架，在图中我们可以看到，Model和View之间缠绕着蜘蛛网一样复杂的依赖关系，根据箭头的方向，我们知道有的是Model调用了View，有的是View调用了Model，很乱。</p><p><img src="/images/react-3/2.png" alt="MVC的缺点"></p><p>MVC框架提出的数据流很理想，用户请求先到达Controller，由Controller调用Model获得数据，然后把数据交给View，但是，在实际框架实现中，总是允许View和Model可以直接通信，从而出现上图的情况。越来越多的同行发现，在MVC中让View和Model直接对话就是灾难。</p><p>当我向以前没接触过Flux的朋友介绍Flux的时候，发现了一个有意思的现象。凡是只在服务器端使用过MVC框架的朋友，就很容易理解和接受Flux。而对于已经有很多浏览器端MVC框架经验的朋友，往往还要费一点劲才能明白MVC和Flux的差异。</p><p>造成这种认知差别的主要原因，就是服务器端MVC框架往往就是每个请求就只在Controller-Model-View三者之间走一圈，结果就返回给浏览器去渲染或者其他处理了，然后这个请求生命周期的Controller-Model-View就可以回收销毁了，这是一个严格意义的单向数据流；对于浏览器端MVC框架，存在用户的交互处理，界面渲染出来之后，Model和View依然处在于浏览器中，这时候就会诱惑开发者为了简便，让现存的Model和View直接对话。</p><p>对于MVC框架，为了让数据流可控，Controller应该是中心，当View要传递消息给Model时，应该调用Controller的方法，同样，当Model要更新View时，也应该通过Controller引发新的渲染。</p><p>当Facebook推出Flux时，招致了很多质疑。很多人都说，Flux只不过是一个对数据流管理更加严格的MVC框架而已。这种说法不完全准确，但是一定意义上也说明了Flux的一个特点：更严格的数据流控制。</p><p>Facebook无心在MVC框架上纠缠，他们用Flux框架来代替原有的MVC框架，他们提出的Flux框架大致结构如图所示</p><p><img src="/images/react-3/3.png" alt="Flux的单向数据流"></p><p>一个Flux应用包含四个部分，我们先粗略了解一下：</p><ul><li><p>Dispatcher：处理动作分发，维持Store之间的依赖关系</p></li><li><p>Store：负责存储数据和处理数据相关逻辑</p></li><li><p>Action：驱动Dispatcher的JavaScript对象</p></li><li><p>View：视图部分，负责显示用户界面</p></li></ul><p>如果非要把Flux和MVC做一个结构对比，那么，Flux的Dispatcher相当于MVC的Controller，Flux的Store相当于MVC的Model，Flux的View当然就对应MVC的View，至于多出来的这个Action，可以理解为对应MVC框架的用户请求。</p><p>在MVC框架中，系统能够提供什么样的服务，通过Controller暴露函数来实现。每增加一个功能，Controller往往就要增加一个函数；在Flux的世界里，新增加功能并不需要Dispatcher增加新的函数，实际上，Dispatcher自始至终只需要暴露一个函数Dispatch，当需要增加新的功能时，要做的是增加一种新的Action类型，Dispatcher的对外接口并不用改变。</p><p>当需要扩充应用所能处理的“请求”时，MVC方法就需要增加新的Controller，而对于Flux则只是增加新的Action。</p><p>下面我们看看怎么用Flux改进我们的React应用。</p><p><em>**</em> 2. Flux应用</p><p>让我们改进一下前面创造的ControlPanel应用，Flux提供了一些辅助工具类和函数，能够帮助创建Flux应用，但是需要一些学习曲线。在这里，我们只用Facebook官方的基本功能，目的是为了更清晰地看一看Flux的工作原理。</p><p>首先通过命令行在项目目录下安装Flux。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save flux</span><br></pre></td></tr></table></figure><p>利用Flux实现ControlPanel应用后的界面效果与前面创造的应用完全一样，通过同一界面不同实现方式的比对，我们可以体会每个方式的优劣。</p><ul><li>1) Dispatcher</li></ul><p>首先，我们要创造一个Dispatcher，几乎所有应用都只需要拥有一个Dispatcher，对于我们这个简单的应用更不例外。在src/AppDispatcher.js中，我们创造这个唯一的Dispatcher对象，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Dispatcher&#125; <span class="keyword">from</span> <span class="string">'flux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Dispatcher();</span><br></pre></td></tr></table></figure><p>非常简单，我们引入flux库中的Dispatcher类，然后创造一个新的对象作为这个文件的默认输出就足够了。在其他代码中，将会引用这个全局唯一的Dispatcher对象。</p><p>Dispatcher存在的作用，就是用来派发action，接下来我们就来定义应用中涉及的action。</p><ul><li>2) action</li></ul><p>action顾名思义代表一个“动作”，不过这个动作只是一个普通的JavaScript对象，代表一个动作的纯数据，类似于DOM API中的事件（event）。甚至，和事件相比，action其实还是更加纯粹的数据对象，因为事件往往还包含一些方法，比如点击事件就有preventDefault方法，但是action对象不自带方法，就是纯粹的数据。</p><p>作为管理，action对象必须有一个名为type的字段，代表这个action对象的类型，为了记录日志和debug方便，这个type应该是字符串类型。</p><p>定义action通常需要两个文件，一个定义action的类型，一个定义action的构造函数（也称为action creator）。分成两个文件的主要原因是Store中会根据action类型做不同操作，也就有单独导入action类型的需要。</p><p>在src/ActionTypes.js中，我们定义action的类型，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">'increment'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT = <span class="string">'decrement'</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，用户只能做两个动作，一个是点击“<code>+</code>”按钮，一个是点击“<code>-</code>”按钮，所以我们只有两个action类型INCREMENT和DECREMENT。</p><p>现在我们在src/Actions.js文件中定义action构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ActionTypes <span class="keyword">from</span> <span class="string">'./ActionTypes.js'</span>;</span><br><span class="line"><span class="keyword">import</span> AppDispatcher <span class="keyword">from</span> <span class="string">'./AppDispatcher.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function">(<span class="params">counterCaption</span>) =&gt;</span> &#123;</span><br><span class="line">  AppDispatcher.dispatch(&#123;</span><br><span class="line">    type: ActionTypes.INCREMENT,</span><br><span class="line">    counterCaption: counterCaption</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function">(<span class="params">counterCaption</span>) =&gt;</span> &#123;</span><br><span class="line">  AppDispatcher.dispatch(&#123;</span><br><span class="line">    type: ActionTypes.DECREMENT,</span><br><span class="line">    counterCaption: counterCaption</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然出于业界习惯，这个文件被命名为Actions.js，但是要注意里面定义的并不是action对象本身，而是能够产生并派发action对象的函数。</p><p>在Actions.js文件中，引入了ActionTypes和AppDispatcher，看得出来是要直接使用Dispatcher。</p><p>这个Actions.js导出了两个action构造函数increment和decrement，当这两个函数被调用的时候，创造了对应的action对象，并立即通过AppDispatcher.dispatch函数派发出去。</p><p>派发出去的action对象最后怎么样了呢？下面关于Store的部分可以看到。</p><ul><li>3) Store</li></ul><p>一个Store也是一个对象，这个对象存储应用状态，同时还要接受Dispatcher派发的动作，根据动作来决定是否要更新应用状态。</p><p>接下来我们创造Store相关的代码，因为使用Flux之后代码文件数量会增多，再把所有源代码文件都放在src目录下就不容易管理了。所以我们在src下创建一个子目录stores，在这个子目录里放置所有的Store代码。</p><p>在前面章节的ControlPanel应用例子里，有三个Counter组件，还有一个统计三个Counter计数值之和的功能，我们遇到的麻烦就是这两者之间的状态如何同步的问题，现在，我们创造两个Store，一个是为Counter组件服务的CounterStore，另一个就是为总数服务的SummaryStore。</p><p>我们首先添加CounterStore，放在src/stores/CounterStore.js文件中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterValues = &#123;</span><br><span class="line">  <span class="string">'First'</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">'Second'</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="string">'Third'</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CounterStore = <span class="built_in">Object</span>.assign(&#123;&#125;, EventEmitter.prototype, &#123;</span><br><span class="line">  getCounterValues: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> counterValues;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  emitChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.emit(CHANGE_EVENT);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addChangeListener: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.on(CHANGE_EVENT, callback);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  removeChangeListener: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.removeListener(CHANGE_EVENT, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当Store的状态发生变化的时候，需要通知应用的其它部分做必要的响应。在我们的应用中，做出响应的部分当然就是View部分，但是我们不应该硬编码这种联系，应该用消息的方式建立Store和View的联系。这就是为什么我们让CounterStore扩展了EventEmitter.prototype，等于让CounterStore成了EventEmitter对象，一个EventEmitter实例对象支持下列相关函数。</p><ul><li><p>emit函数，可以广播一个特定事件，第一个参数是字符串类型的事件名称</p></li><li><p>on函数，可以增加一个挂在这个EventEmitter对象特定事件上的处理函数，第一个参数是字符串类型的事件名称，第二个参数是处理函数</p></li><li><p>removeListener函数，和on函数做的事情相反，删除挂在这个EventEmitter对象特定事件上的处理函数，和on函数一样，第一个参数是事件名称，第二个参数是处理函数。要注意，如果要调用removeListener函数，就一定要保留对处理函数的引用</p></li></ul><p>对于CounterStore对象，emitChange、addChangeListener和removeChangeListener函数就是利用EventEmitter上述的三个函数完成对CounterStore状态更新的广播、添加监听函数和删除监听函数等操作。</p><p>CounterStore函数还提供一个getCounterValues函数，用于让应用中其他模块可以读取当前的计数值，当前的计数值存储在文件模块级的变量counterValues中。</p><p>上面实现的Store只有注册到Dispatcher实例上才能真正发挥作用，所以还需要增加下列代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AppDispatcher <span class="keyword">from</span> <span class="string">'../AppDispatcher.js'</span>;</span><br><span class="line"></span><br><span class="line">CounterStore.dispatchToken = AppDispatcher.register(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ActionTypes.INCREMENT) &#123;</span><br><span class="line">    counterValues[action.counterCaption]++;</span><br><span class="line">    CounterStore.emitChange();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === ActionTypes.DECREMENT) &#123;</span><br><span class="line">    counterValues[action.counterCaption]--;</span><br><span class="line">    CounterStore.emitChange();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是最重要的一个步骤，要把CounterStore注册到全局唯一的Dispatcher上去。Dispatcher有一个函数叫做register，接受一个回调函数作为参数。返回值是一个token，这个token可以用于Store之间的同步，我们在CounterStore中还用不上这个返回值，在稍后的SummaryStore中会用到，现在我们只是把register函数的返回值保存在CounterStore对象的dispatchToken字段上，待会就会用得到。</p><p>现在我们来仔细看看register接受的这个回调函数参数，这是Flux流程中最核心的部分，当通过register函数把一个回调函数注册到Dispatcher之后，所有派发给Dispatcher的action对象，都会传递到这个回调函数中来。</p><p>比如通过Dispatcher派发一个动作，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AppDispatcher.dispatch(&#123;</span><br><span class="line">  type: ActionTypes.INCREMENT,</span><br><span class="line">  counterCaption: <span class="string">'First'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那在CounterStore注册的回调函数就会被调用，唯一的一个参数就是那个action对象，回调函数要做的，就是根据action对象来决定如何更新自己的状态。</p><p>作为一个普遍接受的传统，action对象中必须要有一个type字段，类型是字符串，用于表示这个action对象是什么类型，比如上面派发的action对象，type为“increment”，表示是一个计数器“加一”的动作；如果有必要，一个action对象还可以包含其他的字段。上面的action对象中还有一个counterCaption字段值为“First”，标识名字为“First”的计数器。</p><p>在我们的例子中，action对象的type和counterCaption字段结合在一起，可以确定是哪个计数器应该做加一或者减一的动作，上面例子中的动作含义就是：“名字为First的计数器要做加一动作。”</p><p>根据不同的type，会有不同的操作，所以注册的回调函数很自然有一个模式，就是函数体是一串if-else条件语句或者switch条件语句，而条件语句的跳转条件，都是针对参数action对象的type字段:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CounterStore.dispatchToken = AppDispatcher.register(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ActionTypes.INCREMENT) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === ActionTypes.DECREMENT) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>无论是加一还是减一，最后都要调用counterStore.emitChange函数，假如有调用者通过Counter.addChangeListener关注了CounterStore的状态变化，这个emitChange函数调用就会引发监听函数的执行。</p><p>目前，CounterStore只关注INCREMENT和DECREMENT动作，所以if-else判断也只关注了这两种类型的动作，除此之外，其他action对象一律忽略。</p><p>接下来，我们再来看看另一个Store，也就是代表所有计数器计数值综合的Store，在src/stores/SummaryStore.js中。</p><p>SummaryStore也有emitChange、addChangeListener还有removeChangeListener函数，功能一样也是用于通知监听者状态变化，这几个函数的代码和CounterStore中完全重复，不同点是对获取状态函数的定义，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeSummary</span>(<span class="params">counterValues</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> summary = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> counterValues) &#123;</span><br><span class="line">    <span class="keyword">if</span> (counterValues.hasOwnProperty(key)) &#123;</span><br><span class="line">      summary += counterValues[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> summary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SummaryStore = <span class="built_in">Object</span>.assign(&#123;&#125;, EventEmitter.prototype, &#123;</span><br><span class="line">  getSummary: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> computeSummary(CounterStore.getCounterValues());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以注意到，SummaryStore并没有存储自己的状态，当getSummary被调用时，它是直接从CounterStore里获取状态计算的。</p><p>CounterStore提供了getCounterValues函数让其他模块能够获得所有计数器的值，SummaryStore也提供了getSummary让其他模块可以获得所有计数器当前的总和。不过，既然总可以通过CounterStore.getCounterValues函数获取最新鲜的数据，SummaryStore似乎也就没有必要把计数器总和存储到某个变量里。事实上，可以看到SummaryStore并不像CounterStore一样用一个变量counterValues存储数据，SummaryStore不存储数据，而是每次对getSummary的调用，都实时读取CounterStore.getCounterValues，然后实时计算总和返回给调用者。</p><p>可见，虽然名为Store，但并不表示一个Store必须要存储什么东西，Store只是提供获取数据的方法，而Store提供的数据完全可以另一个Store计算得来。</p><p>SummaryStore在Dispatcher上注册的回调函数也和CounterStore很不一样，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SummaryStore.dispatchToken = AppDispatcher.register(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((action.type === ActionTypes.INCREMENT) ||</span><br><span class="line">      (action.type === ActionTypes.DECREMENT)) &#123;</span><br><span class="line">        AppDispatcher.waitFor([CounterStore.dispatchToken]);</span><br><span class="line">        SummaryStore.emitChange();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>SummaryStore同样也通过AppDispatcher.register函数注册了一个回调函数，用于接受派发的action对象。在回调函数中，也只关注了INCREMENT和DECREMENT类型的action对象，并通过emitChange通知监听者，注意在这里使用了waitFor函数，这个函数解决的是下面描述的问题。</p><p>既然一个action对象会被派发给所有回调函数，这就产生了一个问题，到底是按照什么顺序调用各个回调函数呢？</p><p>即使Flux按照register调用的顺序去调用各个回调函数，我们也完全无法把握各个Store哪个先装载从而调用register函数。所以，可以认为Dispatcher调用回调函数的顺序完全是无法预期的，不要假设它会按照我们期望的顺序逐个调用。</p><p>怎么解决这个问题呢？这就要靠Dispatcher的waitFor函数了。在SummaryStore的回调函数中，之前在CounterStore中注册回调函数时保存下来的dispatchToken终于派上用场了。</p><p>Dispatcher的waitFor可以接受一个数组作为参数，数组中的每个元素都是一个Dispatcher.register函数的返回结果，也就是所谓的dispatchToken。这个waitFor函数告诉Dispatcher，当前的处理必须要暂停，直到dispatchToken代表的那些已注册回调函数执行结束才能继续。</p><p>我们知道，JavaScript是单线程语言，不可能有线程之间的等待这回事，这个waitFor函数当然不是用多线程实现的，只是在调用waitFor的时候，把控制权交给Dispatcher，让Dispatcher检查一下dispatchToken代表的回调函数有没有被执行，如果已经执行，那就直接继续，如果还没有执行，那就调用dispatchToken代表的回调函数之后waitFor才返回。</p><p>回到我们上面的例子，即使SummaryStore比CounterStore提前接收到了action对象，在emitChange中调用waitFor，也就能够保证emitChange函数被调用的时候，CounterStore也已经处理过这个action对象。</p><p>这里要注意一个事实，Dispatcher的register函数，只提供了一个回调函数的功能，但却不能让调用者在register时选择只监听某些action，换句话说，每个register的调用者只能这样请求：“当有任何动作被派发时，请调用我。”但不能够这么请求：“当这种类型还有那种类型的动作被派发的时候，请调用我。”</p><p>当一个动作被派发的时候，Dispatcher就是简单地把所有注册的回调函数全都调用一遍，至于这个动作是不是对方关心的，Flux的Dispatcher不关心，要求每个回调函数去鉴别。</p><p>看起来，这似乎是一种浪费，但是这个设计让Flux的Dispatcher逻辑最简单化，Dispatcher的责任越简单，就越不会出现问题。毕竟，由回调函数全权决定如何处理action对象，也是非常合理的。</p><ul><li>4) View</li></ul><p>首先要说明，Flux框架下，View并不是说必须要使用React，View本身是一个独立的部分，可以用任何一种UI库来实现。</p><p>不过，话说回来，既然我们都使用上Flux了，除非项目有大量历史遗留代码，否则实在没有理由不用React来实现View。</p><p>存在于Flux框架中的React组件需要实现以下几个功能：</p><ul><li><p>创建时要读取Store上状态来初始化组件内部状态</p></li><li><p>当Store上状态发生变化时，组件要立刻同步更新内部状态保持一致</p></li><li><p>View如果要改变Store状态，必须且只能派发action</p></li></ul><p>最后让我们来看看例子中的View部分，为了方便管理，所有View文件都放在src/views目录里。</p><p>先看src/views/ControlPanel.js中的ControlPanel组件，其中render函数的实现和上一章很不一样，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;style&#125;&gt;</span><br><span class="line">      &lt;Counter caption=<span class="string">'First'</span> /&gt;</span><br><span class="line">      &lt;Counter caption=<span class="string">'Second'</span> /&gt;</span><br><span class="line">      &lt;Counter caption=<span class="string">'Third'</span> /&gt;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &lt;Summary /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>可以注意到，和前面章节中的ControlPanel不同，Counter组件实例只有caption属性，没有initValue属性。因为我们把计数值包括初始值全都放到CounterStore中去了，所以在创造Counter组件实例的时候就没必要指定initValue了。</p><p>接着看src/views/Counter.js中定义的Counter组件，构造函数中初始化this.state的方式有了变化，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.onChange = <span class="keyword">this</span>.onChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.onClickIncrementButton = <span class="keyword">this</span>.onClickIncrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.onClickDecrementButton = <span class="keyword">this</span>.onClickDecrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    count: CounterStore.getCounterValues()[props.cpation]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中，CounterStore.getCounterValues函数获得了所有计数器的当前值，然后把this.state初始化为对应caption字段的值，也就是说Counter组件的store来源不再是prop，而是Flux的Store。</p><p>Counter组件中的state应该成为Flux Store上状态的一个同步镜像，为了保持两者一致，除了在构造函数中的初始化之外，在之后当CounterStore上状态变化时，Counter组件也要对应变化，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  CounterStore.addChangeListener(<span class="keyword">this</span>.onChange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  CounterStore.removeChangeListener(<span class="keyword">this</span>.onChange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onChange() &#123;</span><br><span class="line">  <span class="keyword">const</span> newCount = CounterStore.getCounterValues()[<span class="keyword">this</span>.props.caption];</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: newCount &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码所示，在componentDidMount函数中通过CounterStore.addChangeListener函数监听了CounterStore的变化之后，只要CounterStore发生变化，Counter组件的onChange函数就会被调用。与componentDidMount函数中监听事件对应，在componentWillUnmount函数中删除了这个监听。</p><p>接下来，要看React组件如何派发action，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">onClickIncrementButton() &#123;</span><br><span class="line">  Actions.increment(<span class="keyword">this</span>.props.action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onClickDecrementButton() &#123;</span><br><span class="line">  Actions.decrement(<span class="keyword">this</span>.props.action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;caption&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onClickIncrementButton&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onClickDecrementButton&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;caption&#125; count: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，在Counter组件中有两处用到CounterStore的getCounterValues函数的地方，第一处在构造函数中初始化this.state的时候，第二处是在响应CounterStore状态变化的onChange函数中，同样一个Store的状态，为了转换为React组件的状态，有两次重复的调用，这看起来似乎不是很好。但是，React组件的状态就是这样，在构造函数中要对this.state初始化，要更新它就要调用this.setState函数。</p><p>有没有更简洁的办法？比如说只使用CounterStore.getCounterValues一次？可惜，只要我们想用组件的状态来驱动组件的渲染，就不可避免要有这两步。那么如果我们不利用组件的状态呢？</p><p>如果不使用组件的状态，那么我们就可以逃出这个必须在代码中使用Store两次的宿命，在接下来的章节里，我们会遇到这种“无状态”组件。</p><p>Summary组件，存在于src/views/Summary.js中，和Counter类似，在constructor中初始化组件状态，通过在componentDidMount中添加对SummaryStore的监听来同步状态，因为这个View不会有任何交互功能，所以没有派发出任何action。</p><h4 id="3-Flux的优势"><a href="#3-Flux的优势" class="headerlink" title="3. Flux的优势"></a>3. Flux的优势</h4><p>本章的例子和上一章我们只用React的实现效果一样，但是工作方式有了大变化。</p><p>回顾一下完全只用React实现的版本，应用的状态数据只存在于React组件之中，每个组件都要维护驱动自己渲染的状态数据，单个组件的状态还好维护，但是如果多个组件之间的状态有关联，但就麻烦了。比如Counter组件和Summary组件，Summary组件就需要维护所有Counter组件计数值的总和，Counter组件和Summary组件分别维护自己的状态，如何同步Summary和Counter状态就成了问题，React只提供了props方法让组件之间通信，组件之间关系稍微复杂一点，这种方式就显得非常笨拙。</p><p>Flux架构下，应用的状态被放在了Store中，React组件只是扮演View的作用，被动根据Store的状态来渲染。在上面的例子中，React组件依然有自己的状态，但是已经完全沦为Store组件的一个映射，而不是主动变化的数据。</p><p>在完全只用React实现的版本里，用户的交互操作，比如点击“<code>+</code>”按钮，引发的事件处理函数直接通过this.setState改变组件的状态。在Flux的实现版本里，用户的操作引发的是一个“动作”的派发，这个派发的动作会发送给所有的Store对象，引起Store对象的状态改变，而不是直接引发组件的状态改变。因为组件的状态是Store状态的映射，所以改变了Store对象也就触发了React组件对象的状态改变，从而引发了界面的重新渲染。</p><p>Flux带来了哪些好处呢？最重要的就是“单向数据流”的管理方式。</p><p>在Flux的理念里，如果要改变界面，必须改变Store中的状态，如果要改变Store中的状态，就必须派发一个action对象，这就是规矩。在这个规矩之下，想要追溯一个应用的逻辑就变得非常容易。</p><p>我们已经讨论过MVC框架的缺点，MVC最大的问题就是无法禁绝View与Model之间的直接对话，对应于MVC中的View就是Flux中的View，对应于MVC中Model的就是Flux中的Store。在Flux中，Store只有get方法，没有set方法，根本不可能直接去修改其内部状态，View只能通过get方法获取Store的状态，无法直接去修改状态，如果View想要修改Store状态的话，只有派发一个action给Dispatcher。</p><p>这看起来是一个“限制”，但却是一个很好地“限制”，禁绝了数据流混乱的可能。</p><p>简单来说，Flux的体系下，驱动界面改变始于一个动作的派发，别无他法。</p><h4 id="4-Flux的不足"><a href="#4-Flux的不足" class="headerlink" title="4. Flux的不足"></a>4. Flux的不足</h4><p>任何工具不可能只有优点没有缺点，接下来让我们看看Flux的不足之处，只有了解了Flux的不足之处，才能理解为什么会出现Flux的改进框架Redux。</p><ul><li>1) Store之间的依赖关系</li></ul><p>在Flux的体系中，如果两个Store之间有逻辑依赖关系，就必须用上Dispatcher的waitFor函数。在上面的例子中我们已经使用过waitFor函数，SummaryStore对action的处理，依赖于CounterStore已经处理过了。所以，必须要通过waitFor函数告诉Dispatcher，先让CounterStore处理这些action对象，只有CounterStore搞定之后SummaryStore才继续。</p><p>那么，SummaryStore如何标识CounterStore呢？靠的是register函数的返回值dispatchToken，而dispatchToken的产生，当然是CounterStore控制的，换句话说，要这样设计：</p><ul><li><p>CounterStore必须要把注册回调函数时产生的dispatchToken公之于众</p></li><li><p>SummaryStore必须要在代码里建立对CounterStore的dispatchToken的依赖</p></li></ul><p>虽然Flux这个设计的确解决了Store之间的依赖关系，但是，这样明显的模块之间的一来，看着还是让人感觉不太舒服，毕竟最好的依赖管理是根本不让依赖产生。</p><ul><li>2) 难以进行服务器端渲染</li></ul><p>关于服务器端渲染，我们在后面会详细介绍，在这里，我们只需要知道，如果要在服务器端渲染，输出不是一个DOM树，而是一个字符串，准确来说就是一个全是HTML的字符串。</p><p>在Flux的体系中，有一个全局的Dispatcher，然后每一个Store都是一个全局唯一的对象，这对于浏览器端应用完全没有问题，但是如果放在服务器端，就会有大问题。</p><p>和一个浏览器网页只服务于一个用户不同，在服务器端要同时接受很多用户的请求，如果每个Store都是全局唯一对象，那不同请求的状态肯定就乱套了。</p><p>并不是说Flux不能做服务器端渲染，只是说让Flux做服务器端渲染很困难，实际上，Facebook也说得很清楚，Flux不是设计用作服务器端渲染的，他们也从来没有尝试过把Flux应用于服务器端。</p><ul><li>3) Store混杂了逻辑和状态</li></ul><p>Store封装了数据和处理数据的逻辑，用面向对象的思维来看，这是一件好事，毕竟对象就是这样定义的。但是，当我们需要动态替换一个Store的逻辑时，只能把这个Store整体替换掉，那也就无法保持Store中存储的状态。</p><p>在开发模式下，开发人员要不停地对代码进行修改，如果Store在某个状态下引发了bug，如果能在不毁掉状态的情况下替换Store的逻辑，那就最好了，开发人员就可以不断地改进逻辑来验证这个状态下bug是否被修复了。</p><p>还有一些应用，在生产环节下就要根据用户属性来动态加载不同的模块，而且动态加载模块还希望不要网页重新加载，这时候也希望能够在不修改应用状态的前提下重新加载应用逻辑，这就是热加载，后面章节会介绍如何实现热加载。</p><hr><h3 id="二、Redux"><a href="#二、Redux" class="headerlink" title="二、Redux"></a>二、Redux</h3><p>我们把Flux看作一个框架理念的话，Redux是Flux的一种实现，除了Redux之外，还有很多实现Flux的框架，比如Reflux、Fluxible等，毫无疑问Redux获得的关注最多，这不是偶然的，因为Redux有很多其他框架无法比拟的优势。</p><h4 id="1-Redux的基本原则"><a href="#1-Redux的基本原则" class="headerlink" title="1. Redux的基本原则"></a>1. Redux的基本原则</h4><p>2013年问世的Flux饱受争议，而2015年Dan Abramov提出了在Flux基础上的改进框架Redux，则是一鸣惊人，在所有Flux的变体中算是最受关注的框架，没有之一。</p><p>Flux的基本原则是“单向数据流”，Redux在此基础上强调三个原则：</p><ul><li><p>唯一数据源（Single Source of Truth）</p></li><li><p>保持状态只读（State is read-only）</p></li><li><p>数据改变只能通过纯函数完成（Changes are made with pure functions）</p></li></ul><p>让我们逐一解释这三条基本原则</p><ul><li>1) 唯一数据源</li></ul><p>唯一数据源指的是应用的状态数据应该只存储在唯一的一个Store上。</p><p>我们已经知道，在Flux中，应用可以拥有多个Store，往往根据功能把应用的状态数据划分给若干个Store分别存储管理。比如，在上面的ControlPanel中，我们创造了CounterStore和SummaryStore。</p><p>如果状态数据分散在多个Store中，容易造成数据冗余，这样数据一致性方面就会出问题。虽然利用Dispatcher的waitFor方法可以保证多个Store之间的更新顺序，但是这又产生了不同Store之间的显示依赖关系，这种依赖关系的存在增加了应用的复杂度，容易带来新的问题。</p><p>Redux对这个问题的解决方法就是，整个应用只保持一个Store，所有组件的数据源就是这个Store上的状态。</p><p>这个唯一Store上的状态，是一个树形的结构，每个组件往往只是用树形对象上一部分的数据，而如何设计Store上状态的结构，就是Redux应用的核心问题，我们接下来会描述细节。</p><ul><li>2) 保持状态只读</li></ul><p>保持状态只读，就是说不能去直接修改状态，要修改Store的状态，必须要通过派发一个action对象完成，这一点，和Flux的要求并没有什么区别。</p><p>如果只看这个原则的字面意思，可能会让我们有些费解，还记得那个公式吗？<code>UI=render(state)</code>，我们已经能够说过驱动用户界面更改的是状态，如果状态都是只读的不能修改，怎么可能引起用户界面的变化呢？</p><p>当然，要驱动用户界面渲染，就要改变应用的状态，但是改变状态的方法不是去修改状态的值，而是创建一个新的状态对象返回给Redux，由Redux完成新的状态的组装。</p><p>这就引出了下面的第三条原则。</p><ul><li>3) 数据改变只能通过纯函数完成</li></ul><p>这里所说的纯函数就是Reducer，Redux这个名字的前三个字母Red代表的就是Reducer。按照创作者Dan Abramov的说法，Redux名字的含义是Reducer+Flux。</p><p>Reducer不是一个Redux特定的术语，而是一个计算机科学中的通用概念，很多语言和框架都有对Reducer函数的支持。以JavaScript为例，数组类型就有reduce函数，接受的参数就是一个reducer，reduce做的事情就是把数组所有元素依次做“规约”，对每个元素都调用一次reducer，通过reducer函数完成规约所有元素的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">accumulation, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulation + item;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>上面的代码中，reducer函数接受两个参数，第一个参数是上一次规约的结果，第二个参数是这一次规约的元素，函数体是返回两者之和，所以这个规约的结果就是所有元素之和。</p><p>在Redux中，每个reducer的函数签名如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reducer(state, action)</span><br></pre></td></tr></table></figure><p>第一个参数state是当前的状态，第二个参数是接收到的action对象，而reducer函数要做的事情，就是根据state和action的值产生一个新的对象返回，注意reducer必须是纯函数，也就是说函数的返回结果必须完全由参数state和action决定，而且不产生任何副作用，也不能修改参数state和action对象。</p><p>让我们回顾一下Flux中的Store是如何处理函数的，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CounterStore.dispatchToken = AppDispatcher.register(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ActionTypes.INCREMENT) &#123;</span><br><span class="line">    counterValues[action.counterCaption]++;</span><br><span class="line">    CounterStore.emitChange();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === ActionTypes.DECREMENT) &#123;</span><br><span class="line">    counterValues[action.counterCaption]--;</span><br><span class="line">    CounterStore.emitChange();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Flux更新状态的函数只有一个参数action，因为状态是由Store直接管理的，所以处理函数中会看到代码直接更新state；在Redux中，一个实现同样功能的reducer代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) =&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;counterCaption&#125; = action;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.INCREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.DECREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到reducer函数不光接受action为参数，还接受state为参数。也就是说，Redux的reducer只负责计算状态，却并不负责存储状态。</p><p>我们在后面的实例中会详细解释这个reducer的构造。</p><p>读到这里，读者可能会有一个疑问，从Redux的基本原则来看，Redux并没有赋予我们强大的功能，反而是给开发者增加了很多限制，开发者丧失了想怎么写就怎么写的灵活度。</p><blockquote><p>“如果你愿意限制做事方式的灵活度，你几乎总会发现可以做得更好。” —— John Carmark</p></blockquote><p>作为制作出《Doom》《Quake》这样游戏的杰出开发者，John Carmark这句话道出了软件开发中的一个真谛。</p><p>在计算机编程的世界里，完成任何一件任务，可能都有一百种以上的方法，但是无节制的灵活度反而让软件难以维护，增加限制是提高软件质量的法门。</p><h4 id="2-Redux实例"><a href="#2-Redux实例" class="headerlink" title="2. Redux实例"></a>2. Redux实例</h4><p>前面我们用Flux实现了一个ControlPanel的应用，接下来让我们用Redux来重新实现一遍同样的功能，通过对比就能看出二者的差异。</p><p>React和Redux事实上是两个独立的产品，一个应用可以使用React而不是用Redux，也可以使用Redux而不是用React，但是，如果两者结合使用，没有理由不使用一个名叫react-redux的库，这个库能够大大简化代码的书写。</p><p>不过，如果一开始就使用react-redux，可能对其设计思路完全一头雾水，所以，我们的实例先不采用react-redux库，从最简单的Redux使用方法开始，初步改进，循序渐进地过渡到使用react-redux。</p><p>最基本的Redux实现，存在与本书对应Github的chapter-03/redux_basic目录中，在这里我们只关注使用Redux实现和使用Flux不同的地方。</p><p>首先看关于action对象的定义，和Flux一样，Redux应用习惯上把action类型和action构造函数分成两个文件定义，其中定义action类型的src/ActionTypes.js和Flux版本没有任何差别，但是src/Actions.js文件就不大一样了，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ActionTypes <span class="keyword">from</span> <span class="string">'./ActionTypes.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function">(<span class="params">counterCaption</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ActionTypes.INCREMENT,</span><br><span class="line">    counterCaption: counterCaption</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function">(<span class="params">counterCaption</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ActionTypes.DECREMENT,</span><br><span class="line">    counterCaption: counterCaption</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和Flux的src/Actions.js文件对比就会发现，Redux中每个action构造函数都返回一个action对象，而Flux版本中action构造函数并不返回什么，而是把构造的动作函数立刻通过调用Dispatcher的dispatch函数派发出去。</p><p>这是一个习惯上的差别，接下来我们会发现，在Redux中，很多函数都是这样不做什么产生副作用的动作，而是返回一个对象，把如何处理这个对象的工作交给调用者。</p><p>在Flux中我们要用到一个Dispatcher对象，但是在Redux中，就没有Dispatcher这个对象了，Dispatcher存在的作用就是把一个action对象分发给了多个注册了的Store，既然Redux让全局只有一个Store，那么再创造一个Dispatcher也的确意义不大。所以，Redux中“分发”这个功能，从一个Dispatcher对象简化为Store对象上的一个函数dispatch，毕竟只有一个Store，要分发也是分发给这个Store，就调用Store上一个表示分发的函数，合情合理。</p><p>我们创造一个src/Store.js文件，这个文件输出全局唯一的那个Store，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./Reducer.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initValues = &#123;</span><br><span class="line">  <span class="string">'First'</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">'Second'</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">'Third'</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, initValues);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p>在这里，我们接触到了Redux库提供的createStore函数，这个函数第一个参数代表更新状态的reducer，第二个参数是状态的初始值，第三个参数可选，代表Store Enhancer，在这个例子中用不上，后面章节会详细介绍。</p><p>确定Store状态，是设计好Redux应用的关键。从Store状态的初始值看得出来，我们的状态是这样一个格式：状态上每个字段名代表Counter组件的名（caption），字段的值就是这个组件当前的计数值，根据这些状态字段，足够支撑三个Counter组件。</p><p>那么，为什么没有状态来支持Summary组件呢？因为Summary组件的状态，完全可以通过把Counter状态数值加在一起得到，没有必要制造冗余数据存储，这也符合Redux“唯一数据源”的基本原则。记住：Redux的Store状态设计的一个主要原则：避免冗余数据。</p><p>接下来看src/Reducer.js中定义的reducer函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ActionTypes <span class="keyword">from</span> <span class="string">'./ActionTypes.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;counterCaption&#125; = action;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.INCREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.DECREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和Flux应用中每个Store注册的回调函数一样，reducer函数中往往包含以action.type为判断条件的if-else或者switch语句。</p><p>和Flux不同的是，多了一个参数state。在Flux的回调函数中，没有这个参数，因为state是由Store管理的，而不是由Flux管理的。Redux中把存储state的工作抽取出来交给Redux框架本身，让reducer只用关心如何更新state，而不要管state怎么存。</p><p>代码中使用了三个句号组成的扩展操作符，表示把state中所有字段扩展开，而后面对counterCaption值对应的字段会赋上新值，像下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] + <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>逻辑上等同于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newState = <span class="built_in">Object</span>.assign(&#123;&#125;, state);</span><br><span class="line">newState[counterCaption]++;</span><br><span class="line"><span class="keyword">return</span> newState;</span><br></pre></td></tr></table></figure><p>和Flux很不一样的是，在reducer中，绝对不能去修改参数中的state，如果我们直接修改state并返回false，代码如下，注意这不是正确写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;counterCaption&#125; = action;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.INCREMENT:</span><br><span class="line">      state[counterCaption]++;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.DECREMENT:</span><br><span class="line">      state[counterCaption]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这样写，似乎更简单直接，但实际上犯了大错，因为reducer应该是一个纯函数，纯函数不应该产生任何副作用。</p><p>接下来，我们看View部分，View部分代码都在src/views目录下。看看src/views/ControlPanel.js，作为这个应用最顶层的组件ControlPanel，内容和Flux例子中没有任何区别。然后是Counter组件，存在于src/views/Counter.js中，这就和Flux不大一样了，首先是构造函数中初始化this.state的来源不同，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../Store.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">this</span>.getOwnState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getOwnState() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: store.getState()[<span class="keyword">this</span>.props.caption]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和Flux例子一样，在这个视图文件中我们要引入Store，只不过这次我们引入的Store不叫CounterStore，而是一个唯一的Redux Store，所以名字就叫store，通过store.getState()能够获得store上存储的所有状态，不过每个组件往往只需要使用返回状态的一部分数据。为了避免重复代码，我们把从store获得状态的逻辑放在getOwnState函数中，这样任何关联Store状态的地方都可以重用这个函数。</p><p>和Flux实现的例子一样，仅仅在构造函数时根据store来初始化this.state还不够，要保持store上状态和this.state的同步，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onChange() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="keyword">this</span>.getOwnState());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  store.subscribe(<span class="keyword">this</span>.onChange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  store.unsubscribe(<span class="keyword">this</span>.onChange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在componentDidMount函数中，我们通过Store的subscribe监听其变化，只要Store状态发生变化，就会调用这个组件的onChange方法；在componentWillUnmount函数中，我们把这个监听注销掉，这个清理动作和componentDidMount中的动作对应。</p><p>其实，这个增加监听函数的语句也可以写在构造函数里，但是为了让mount和unmount的对应看起来更清晰，在所有的例子中我们都把加载监听的函数放在componentDidMount中。</p><p>除了从store同步状态，视图中可能会想要改变store中的状态，和Flux一样，改变store中状态唯一的方法就是派发action，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onIncrement() &#123;</span><br><span class="line">  store.dispatch(Actions.increment(<span class="keyword">this</span>.props.caption));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onDecrement() &#123;</span><br><span class="line">  store.dispatch(Actions.decrement(<span class="keyword">this</span>.props.caption));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了onIncrement和onDecrement方法，在render函数中的JSX中需要使用这两种函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">this</span>.state.value;</span><br><span class="line">  <span class="keyword">const</span> &#123;caption&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onIncrement&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onDecrement&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;caption&#125; count: &#123;value&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在render函数中，对于点击“<code>+</code>”按钮和“<code>-</code>”按钮的onClick事件，被分别挂上了onIncrement函数和onDecrement函数，所做的事情就是派发对应的action对象出去。注意和Flux例子的区别，在Redux中，action构造函数只负责创建对象，要派发action就需要调用store.dispatch函数。</p><p>组件的render函数所显示的动态内容，要么来自于props，要么来自于自身状态。</p><p>然后再来看看src/views/Summary.js中的Summary组件，其中getOwnState函数的实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getOwnState() &#123;</span><br><span class="line">  <span class="keyword">const</span> state = store.getState();</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> state) &#123;</span><br><span class="line">    sum += state[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">sum</span>: sum &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Summary组件的套路和Counter组件差不多，唯一值得一提的就是getOwnState函数的实现。因为Store的状态中只记录了各个Counter组件的计数值，所以需要在getOwnState状态中自己计算出所有计数值总和出来。</p><h4 id="3-容器组件和傻瓜组件"><a href="#3-容器组件和傻瓜组件" class="headerlink" title="3. 容器组件和傻瓜组件"></a>3. 容器组件和傻瓜组件</h4><p>分析一下上面的Redux例子中的Counter组件和Summary组件部分，可以发现一个规律，在Redux框架下，一个React组件基本上就是要完成以下两个功能：</p><ul><li><p>和Redux Store打交道，读取Store的状态，用于初始化组件的状态，同时还要监听Store的状态改变；当Store状态发生变化时，需要更新组件状态，从而驱动组件重新渲染；当需要更新Store状态时，就要派发action对象</p></li><li><p>根据当前props和state，渲染出用户界面</p></li></ul><p>还记得那句话吗？让一个组件只专注做一件事，如果发现一个组件做的事情太多了，就可以把这个组件拆分成多个组件，让每个组件依然只专注于一件事。</p><p>如果React组件都是要包办上面说的两个任务，似乎做的事情也的确稍微多了一点。我们可以考虑拆分，拆分为两个组件，分别承担一个任务，然后把两个组件嵌套起来，完成原本一个组件完成的所有任务。</p><p>这样的关系里，两个组件是父子组件的关系。业界对于这样的拆分有多种叫法，承担第一个任务的组件，也就是负责和Redux Store打交道的组件，处于外层，所以被称为容器组件（Container Component）；对于承担第二个任务的组件，也就是只专心负责渲染界面的组件，处于内层，叫做展示组件（Presentational Component）。</p><p>外层的容器组件又叫聪明组件（Smart Component），内层的展示组件又叫傻瓜组件（Dumb Component），所谓“聪明”还是“傻瓜”只是相对而言，并没有褒贬的含义。</p><p><img src="/images/react-3/4.png" alt="容器组件和傻瓜组件的分工"></p><p>傻瓜组件就是一个纯函数，根据props产生结果。说是“傻瓜”，这种纯函数实现反而体现了计算机编程中的大智慧，大智若愚。</p><p>而容器组件，只是做的事情涉及一些状态转换，虽然名字里有“聪明”，其实做的事情都有套路，我们很容易就能抽取出共同之处，复用代码完成任务，并不需要开发者极其聪明才能掌握。</p><p>在我们把一个组件拆分为容器组件和傻瓜组件的时候，不只是功能分离，还有一个比较大的变化，那就是傻瓜组件不再需要有状态了。</p><p>实际上，让傻瓜组件无状态，是我们拆分的主要目的之一，傻瓜组件只需要根据props来渲染结果，不需要state。</p><p>那么，状态哪里去了呢？全都交给容器组件去打点，这是它的责任。容器组件如何把状态传递给傻瓜组件呢？通过props。</p><p>值得一提的是，拆分容器组件和傻瓜组件，是设计React组件的一种模式，和Redux没有直接关系。在Flux或者任何一种其他框架下都可以使用这种模式，只不过为了引出后面的react-redux，我们才在这里开始介绍罢了。</p><p>我们还是通过例子来感受一下容器组件和傻瓜组件如何协同工作，对应的代码在chapter-03/redux_smart_dumb目录下，是前面chapter-03/redux_basic的改进，只有视图部分代码有改变。</p><p>在视图代码src/views/Counter.js中定义了两个组件，一个是Counter，这是傻瓜组件，另一个是CounterContainer，这是容器组件。</p><p>傻瓜组件Counter代码的逻辑前所未有的简单，只有一个render函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;caption, onIncrement, onDecrement, value&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button style=&#123;buttonStyle&#125; onClick=&#123;onIncrement&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;button style=&#123;buttonStyle&#125; onClick=&#123;onDecrement&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;span&gt;&#123;caption&#125; count: &#123;value&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Counter组件完全没有state，只有一个render方法，所有的数据都来自于props，这种组件叫做“无状态”组件。</p><p>而CounterContainer组件承担了所有的和Store关联的工作，它的render函数所做的就是渲染傻瓜组件Counter而已，只负责传递必要的prop，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> <span class="attr">caption</span>=<span class="string">&#123;this.props.caption&#125;</span> </span></span></span><br><span class="line"><span class="xml">            onIncrement=&#123;this.onIncrement&#125;</span></span><br><span class="line"><span class="xml">            onDecrement=&#123;this.onDecrement&#125;</span></span><br><span class="line"><span class="xml">            value=&#123;this.state.value&#125; /&gt;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default CounterContainer;</span></span><br></pre></td></tr></table></figure><p>可以看到，这个文件export导出的不再是Counter组件，而是CounterContainer组件，也就是对于使用这个视图的模块来说，根本不会感受到傻瓜组件的存在，从外部看到的就只是容器组件。</p><p>对于无状态组件，其实我们可以进一步缩减代码，React支持只用一个函数代表的无状态组件，所以，Counter组件可以进一步简化，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;caption, onIncrement, onDecrement, value&#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;onIncrement&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;onDecrement&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;caption&#125; count: &#123;value&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为没有状态，不需要用对象表示，所以连类都不要了，对于一个只有render方法的组件，缩略为一个函数足矣。</p><p>注意，改为这种写法，获取props就不能用this.props，而是通过函数的参数props获得，无状态组件的props参数和有状态组件的this.props内容和结构完全一样。</p><p>还有一种惯常写法，就是把解构赋值直接放在参数部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;caption, onIncrement, onDecrement, value&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数体中可以直接使用caption、onIncrement等变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看src/views/Summary.js中，内容也被分解为了傻瓜组件Summary和SummaryContainer，方式和Counter差不多，不再赘述。</p><p>重新审阅代码，我们可以看到CounterContainer和SummaryContainer代码有很多相同之处，写两份实在是重复，既然都是套路，完全可以抽取出来，后面的章节会讲如何应用react-redux来减少重复代码。</p><h4 id="4-组件Context"><a href="#4-组件Context" class="headerlink" title="4. 组件Context"></a>4. 组件Context</h4><p>在介绍react-redux之前，我们重新看一看现在的Counter和Summary组件文件，发现它们都直接导入Redux Store。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./Store.js'</span>;</span><br></pre></td></tr></table></figure><p>虽然Redux应用全局就一个Store，这样的直接导入依然有问题。</p><p>在实际工作中，一个应用的规模会很大，不会所有的组件都放在一个代码库里，有时候还要通过npm方式引入第三方的组件。想想看，当开发一个独立的组件的时候，都不知道自己这个组件会存在于哪个应用中，当然不可能预先知道定义唯一Redux Store的文件位置了，所以，在组件中直接导入Store是非常不利于组件复用的。</p><p>一个应用中，最好只有一个地方需要直接导入Store，这个位置当然应该是在调用最顶层React组件的位置。在我们的ControlPanel例子中，就是应用的入口文件src/index.js中，其余组件应该避免直接导入Store。</p><p>不让组件直接导入Store，那就只能让组件的上层组件把Store传递下来了。首先想到的当然是用props，毕竟，React组件就是用props来传递父子组件之间的数据的。不过，这种方法有一个很大的缺陷，就是从上到下，所有的组件都要帮助传递这个props。</p><p>设想在一个嵌套多层的组件结构中，只有最里层的组件才需要使用Store，但是为了把Store从外层传递到最里层，就要求中间所有的组件都需要增加对这个store prop的支持，即使根本不使用它，这无疑很麻烦。</p><p>还是来看ControlPanel这个例子，最顶层的组件ControlPanel根本就不使用Store，如果仅仅为了让它传递一个prop给子组件Counter和Summary就要求它支持state prop，显然非常不合理。所以，用prop传递store不是一个好方法。</p><p>React提供了一个叫Context的功能，能够完美地解决这个问题。</p><p><img src="/images/react-3/5.png" alt="React的Context"></p><p>所谓Context，就是“上下文环境”，让一个树状组件上所有组件都能访问一个共同的对象，为了完成这个任务，需要上级组件和下级组件配合。</p><p>首先，上级组件要宣称自己支持context，并且提供一个函数来返回代表Context的对象。</p><p>然后，这个上级组件之下的所有下级组件，只要宣称自己需要这个Context，就可以通过this.context访问到这个共同的环境对象。</p><p>我们尝试给ControlPanel程序加上context功能来优化，相关代码在chapter-3/redux_with_context目录中，这个应用是对前面redux_smart_dumb的改进。</p><p>因为Redux应用中只有一个Store，因此所有组件如果要使用Store的话，只能访问这唯一的Store。很自然，希望顶层的组件来扮演这个Context提供者的角色，只要顶层组件提供包含store的context，那就覆盖了整个应用的所有组件，简单而且够用。</p><p>不过，每个应用的顶层组件不同，在我们的ControlPanel例子里顶层组件是ControlPanel，在另一个应用里会有另一个组件。而且，ControlPanel有它自己的职责，我们没有理由把它复杂化，没必要非要让它扮演context提供者的功能。</p><p>我们来创建一个特殊的React组件，它将是一个通用的context提供者，可以应用在任何一个应用中，我们把这个组件叫做Provider。在src/Provider.js中，首先定义一个名为Provider的React组件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;PropTypes, Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      store: <span class="keyword">this</span>.props.store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Provider也是一个React组件，不过它的render函数就是简单地把子组件渲染出来，在渲染上，Provider不做任何附加的事情。</p><p>每个React组件的props中都可以包含一个特殊属性children，代表的是子组件，比如这样的代码，在Provider的render函数中this.props.children就是两个Provider标签之间的<code>&lt;ControlPanel /&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider&gt;</span><br><span class="line">  &lt;ControlPanel /&gt;</span><br><span class="line">&lt;<span class="regexp">/Provider&gt;</span></span><br></pre></td></tr></table></figure><p>除了把渲染工作完全交给子组件，Provider还要提供一个函数getChildContext，这个函数返回的就是代表Context的对象。我们的Context中只有一个字段store，而且我们也希望Provider足够通用，所以并不在这个文件中导入store，而是要求Provider的使用者通过prop传递进来store。</p><p>为了让Provider能够被React认可为一个Context的提供者，还需要指定Provider的childContextTypes属性，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Provider.childContextTypes = &#123;</span><br><span class="line">  store: ProTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Provider还需要定义类的childContextTypes，必须和getChildContext对应，只有这两者都齐备，Provider的子组件才有可能访问到context。</p><p>有了Provider，我们就可以改进一下应用的入口src/index.js文件了，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./Store.js'</span>;</span><br><span class="line"><span class="keyword">import</span> Provider <span class="keyword">from</span> <span class="string">'./Provider.js'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;ControlPanel /&gt;</span><br><span class="line">  &lt;<span class="regexp">/provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>在前面所有的例子中，React.render的第一个参数就是顶层组件ControlPanel。现在，这个ControlPanel作为子组件被Provider包住了，Provider成为了顶层组件。当然，如同我们上面看到的，Provider只是把渲染工作完全交给子组件，它扮演的角色只是提供Context，包住了最顶层的ControlPanel，也就让context覆盖了整个应用中的所有组件。</p><p>至此，我们完成了提供Context的工作，接下来我们看底层组件如何使用Context。</p><p>我们可以顺便看一眼src/views/ControlPanel.js，这个文件和前面的例子没有任何变化，它做的工作只是搭建应用框架，把子组件Counter和Summary渲染出来，和Store一点关系都没有，这个文件既没有导入Store，也没有支持关于store的props。</p><p>在src/views/Counter.js中，我们可以看到对context的使用。作为傻瓜组件的Counter是一个无状态组件，它也不需要和Store牵扯什么关系，和之前的代码一模一样，有变化的是CounterContainer部分。</p><p>为了让CounterContainer能够访问context，必须给CounterContainer类的contextTypes赋值和Provider.childContextTypes一样的值，两者必须一致，不然就无法访问到context，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CounterContainer.contextTypes = &#123;</span><br><span class="line">  store: PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CounterContainer中，所有对store的访问，都是通过this.context.store完成的，因为this.context就是Provider提供的context对象，所以getOwnState函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getOwnState() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: <span class="keyword">this</span>.context.store.getState()[<span class="keyword">this</span>.props.caption]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一点，因为我们自己定义了构造函数，所以要用上第二个参数context，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props, context);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用super的时候，一定要带上context参数，这样才能让React组件初始化实例中的context，不然组件的其它部分就无法使用this.context。</p><p>要求constructor显式声明props和context两个参数然后又传递给super看起来很麻烦，我们的代码似乎只是一个参数的搬运工，而且将来可能有新的参数出现那样又要修改这部分代码，我们可以用下面的方法一劳永逸地解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">  <span class="keyword">super</span>(...arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不能直接使用arguments，因为在JavaScript中arguments表现得像是一个数组而不是分开的一个个参数，但是我们通过扩展标识符就能把arguments彻底变成传递给super的参数。</p><p>在结束之前，让我们重新审视一下Context这个功能，Context这个功能相当于提供了一个全局可以访问的对象，但是全局对象或者说全局变量肯定是我们应该避免的用法，只要有一个地方改变了全局对象的值，应用中其它部分就会受影响，那样整个程序的运行结果就完全不可预测了。</p><p>所以，单纯来看React的这个Context功能的话，必须强调这个功能要谨慎使用，只有对那些每个组件都可能使用，但是中间组件又可能不使用的对象才有必要使用Context，千万不要滥用。</p><p>对于Redux，因为Redux的Store封装得很好，没有提供直接修改状态的功能，就是说一个组件虽然能够访问全局唯一的Store，却不可能直接修改Store中的状态，这样部分克服了作为全局对象的缺点。而且，一个应用只有一个Store，这个Store是Context里唯一需要的东西，并不算滥用，所以，使用Context来传递Store是一个不错的选择。</p><h4 id="5-React-Redux"><a href="#5-React-Redux" class="headerlink" title="5. React-Redux"></a>5. React-Redux</h4><p>在上面两节中，我们了解了改进React应用的两个方法，第一是把一个组件拆分为容器组件和傻瓜组件，第二是使用React的Context来提供一个所有组件都可以直接访问的Context，也不难发现，这两种方法都有套路，完全可以把套路部分抽取出来复用，这样每个组件的开发只需要关注于不同的部分就可以了。</p><p>实际上，已经有这样的一个库来完成这些工作了，这个库就是react-redux。</p><p>在本书的chapter-03/react-redux目录下，可以看到利用react-redux实现的ControlPanel版本，因为使用了react-redux，所以它是所有实现方式中代码最精简的一个例子。</p><p>我们只看不同的部分，在src/index.js中，代码几乎和react_with_context一模一样，唯一的区别就是我们不再使用自己实现的Provider，而是从react-redux库导入Provider，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br></pre></td></tr></table></figure><p>有了react-redux，视图文件src/views/Counter.js和src/Summary.js中的代码可以变得相当简洁。</p><p>在前面的redux_smart_dumb和redux_with_context例子中，我们实际上分别实现了react-redux的两个最主要的功能：</p><ul><li><p>connect：连接容器组件和傻瓜组件</p></li><li><p>Provider：提供包含store的context</p></li></ul><p>现在我们直接使用react-redux提供的这两个功能了，让我们分别来详细介绍。</p><ul><li>1) connect</li></ul><p>以Counter组件为例，和redux_with_context中的代码不同，react-redux的例子中没有定义CounterContainer这样命名的容器组件，而是直接导出了这样一个语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Counter);</span><br></pre></td></tr></table></figure><p>第一眼看去，会让人觉得这不是正常的JavaScript语法。其实，connect是react-redux提供的一个方法，这个方法接收两个参数mapStateToProps和mapDispatchToProps，执行结果依然是一个函数，所以才可以在后面又加一个圆括号，把connect函数执行的结果立刻执行，这一次参数是Counter这个傻瓜组件。</p><p>这里有两次函数执行，第一次是connect函数的执行，第二次是把connect函数返回的函数再次执行，最后产生的就是容器组件，功能相当于redux_smart_dumb中的CounterContainer。</p><p>当然，我们也可以把connect的结果赋值给一个变量CounterContainer，然后再export这个CounterContainer，只是connect已经大大简化了代码，习惯上可以直接导出函数执行结果，也不用纠结如何命名这个变量。</p><p>这个connect函数具体做了什么工作呢？</p><p>作为容器组件，要做的工作无外乎两件事：</p><ul><li><p>把Store上的状态转化为内层傻瓜组件的props</p></li><li><p>把内层傻瓜组件中的用户动作转化为派送给store的动作</p></li></ul><p>这两个工作一个是内层傻瓜对象的输入，一个是内层傻瓜对象的输出。</p><p>这两个工作的套路也很明显，把Store上的状态转化为内层组件的props，其实就是一个映射关系，去掉框架，最后就是一个mapStateToProps函数该做的事情。这个函数命名是业界习惯，因为它只是一个模块内的函数，所以实际上叫什么函数都行，如果觉得mapStateToProps这个函数名太长，也可以叫mapState，也是业界惯常的做法。</p><p>Counter组件对应的mapStateToProps函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state, ownProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: state[ownProps.caption]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把内层傻瓜组件中用户动作转化为派送给Store的动作，也就是把内层傻瓜组件暴露出来的函数类型的prop关联上dispatch函数的调用，每个prop代表的回调函数的主要区别就是dispatch函数的参数不同，这就是mapDispatchToProps函数做的事情，和mapStateToProps一样，这么长的函数名只是习惯问题，mapDispatchToProps也可以叫作mapDispatch。</p><p>Counter组件对应的mapDispathToProps函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch, ownProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onIncrement: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(Actions.increment(ownProps.caption));</span><br><span class="line">    &#125;,</span><br><span class="line">    onDecrement: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(Actions.decrement(ownProps.caption));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapStateToProps和mapDispatchToProps都可以包含第二个参数，代表ownProps，也就是直接传递给外层容器组件的props，在ControlPanel的例子中没有用到，我们在后续章节中会有详细介绍。</p><ul><li>2) Provider</li></ul><p>我们在redux_with_context中已经完整实现了一个Provider，react-redux和我们例子中的Provider几乎一样，但是更加严谨，比如我们只要求store属性是一个object，而react-redux要求store不光是一个object，而且是必须包含三个函数的object，这三个函数分别是：</p><ul><li><p>subscribe</p></li><li><p>dispatch</p></li><li><p>getState</p></li></ul><p>拥有上述三个函数的对象，才能称之为一个Redux的store。</p><p>另外，react-redux定义了Provider的componentWillReceiveProps函数，在React组件的生命周期中，componentWillReceiveProps函数在每次重新渲染时都会调用到，react-redux在componentWillReceiveProps函数中会检查这一次渲染时代表store的prop和上一次的是否一样。如果不一样，就会给出警告，这样做是为了避免多次渲染用了不同的Redux Store。每个Redux应用只能有一个Redux Store，在整个Redux的生命周期中都应该保持Store的唯一性。</p><hr><h3 id="三、本章小结"><a href="#三、本章小结" class="headerlink" title="三、本章小结"></a>三、本章小结</h3><p>在这一章中，我们首先从Redux的鼻祖Flux框架出发，通过创造一个ControlPanel的例子，了解了Flux“单向数据流”的原则。如果只由React来管理数据流，就很难管理拥有很多组件的大型应用，传统的MVC框架也有其缺陷，很容易写乱套，所以Flux是应用架构的一个巨大改进，但是Flux也有其缺点。</p><p>Redux是Flux框架的一个巨大改进，Redux强调单一数据源、保持状态只读和数据改变只能通过纯函数完成的基本原则，和React的<code>UI=render(state)</code>思想完全契合。我们在这一章中用不同方法，循序渐进的改进了ControlPanel这个应用的例子，为的就是更清晰地理解每个改进背后的动因，最后，我们终于通过react-redux完成了React和Redux的融合。</p><p>但是，这只是一个开始。接下来，我们将看到更加深入的React和Redux实践知识。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="/resources/深入浅出React和Redux.pdf">《深入浅出React和Redux —— 程墨》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前一章中我们已经感受到完全用React来管理应用数据的麻烦，在这一章中，我们将介绍Redux这种管理应用状态的框架&lt;/p&gt;
    
    </summary>
    
      <category term="React抄书笔记" scheme="http://www.xiaoleon.cn/categories/React%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.xiaoleon.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(2) 设计高质量的React组件</title>
    <link href="http://www.xiaoleon.cn/2018/03/04/react-2/"/>
    <id>http://www.xiaoleon.cn/2018/03/04/react-2/</id>
    <published>2018-03-04T13:29:25.000Z</published>
    <updated>2018-03-19T13:15:53.841Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个合格的开发者，不能只满足于编写出可以运行的代码，而要了解代码背后的工作原理；不能只满足于自己编写的程序能够运行，还要让自己的代码可读而且易于维护。这样才能开发出高质量的软件。</p><a id="more"></a><p>本文中，我们将深入介绍构建高质量React组件的原则和方法，包括以下内容</p><ul><li><p>划分组件边界的原则</p></li><li><p>React组件的数据种类</p></li><li><p>React组件的生命周期</p></li></ul><h3 id="一、易于维护组件的设计要素"><a href="#一、易于维护组件的设计要素" class="headerlink" title="一、易于维护组件的设计要素"></a>一、易于维护组件的设计要素</h3><p>任何一个复杂的应用，都是由一个简单的应用发展而来的，当应用还很简单的时候，因为功能很少，可能只有一个组件就足够了，但是，随着功能的增加，把越来越多的功能放在一个组件里就会显得臃肿和难以管理。</p><p>就和一个人最好一次只专注做一件事一样，也应该尽量保持一个组件只做一件事。当开发者发现一个组件功能太多代码量太大的时候，就要考虑拆分这个组件，用多个小的组件来代替。每个小的组件只关注实现单个功能，但是这些功能组合起来，也能满足复杂的实际需求。</p><p>这就是“分而治之”的策略，把问题分解为多个小问题，这样极容易解决也方便维护，虽然“分而治之”是一个好策略，但是不要滥用，只有必要的时候才去拆分组件，不然可能得不偿失。</p><p>拆分组件最关键的就是确定组件的边界，每个组件都应该是可以独立存在的，如果两个组件逻辑太紧密，无法清晰定义各自的责任，那也许这两个组件本身就不该被拆开，作为同一个组件也许更合理。</p><p>虽然组件是应该独立存在的，但是并不是说组件就是孤岛一样的存在，不同组件之间总会有通信交流，这样才可能组合起来完成更大的功能。</p><p>作为软件设计的通则，组件的划分要满足<strong>高内聚（High Cohesion）</strong>和<strong>低耦合（Low Coupling）</strong>的原则。</p><p><strong>高内聚</strong>指的是把逻辑紧密相关的内容放在一个组件中。用户界面无外乎内容、交互行为和样式。传统上，内容由HTML表示，交互行为放在JavaScript代码文件中，样式放在CSS文件中定义。这虽然满足一个功能模块的需要，却要放在三个不同的文件中，这其实不满足高内聚的原则，React却不是这样，展示内容的JSX、定义行为的JavaScript，甚至定义样式的CSS，都可以放在一个JavaScript文件中，因为它们本来就是为了实现一个目的而存在的，所以说React天生具有高内聚的特点。</p><p><strong>低耦合</strong>指的是不同组件之间的依赖关系要尽量弱化，也就是每个组件要尽量独立。保持整个系统的低耦合度，需要对系统中的功能有充分的认识，然后根据功能点划分模块，让不同的组件去实现不同的功能，这个功夫还在开发者身上，不过，React组件的对外结构非常规范，方便开发者设计低耦合的系统。</p><hr><h3 id="二、React组件的数据"><a href="#二、React组件的数据" class="headerlink" title="二、React组件的数据"></a>二、React组件的数据</h3><p>毫无疑问，如何组织数据是程序的最重要问题。</p><p>React组件的数据分为两种，prop和state，无论prop或者state的改变，都可能引发组件的重新渲染，那么，设计一个组件的时候，什么时候选择用prop什么时候选择用state呢？其实原则很简单，prop是组件的对外接口，state是组件的内部状态，对外用prop，内部用state。</p><p>为了演示属性的使用，我们构造一个应用包含两个组件，Counter组件和ControlPanel组件，其中ControlPanel组件是父组件，包含若干个Counter组件。</p><p><img src="/images/react-2/1.png" alt="ControlPanel应用效果图"></p><p>可以看到三个Counter组件有了不同的初始计数值，点击网页中的“<code>+</code>”按钮可以看到对应一行的计数增加，点击“<code>-</code>”按钮可以看到对应一行的计数减少。</p><h4 id="1-React的prop"><a href="#1-React的prop" class="headerlink" title="1. React的prop"></a>1. React的prop</h4><p>在React中，prop（property的简写）是从外部传递给组件的数据，一个React组件通过定义自己能够接受的prop就定义了自己的对外公共接口。</p><p>每个React组件都是独立存在的模块，组件之外的一切都是外部世界，外部世界就是通过prop来和组件对话的。</p><ul><li>1) 给prop赋值</li></ul><p>我们先从外部世界来看，prop是如何使用的，在下面的JSX代码片段中，就使用了prop</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SampleButton id=<span class="string">"sample"</span> borderWidgh=&#123;<span class="number">2</span>&#125; onClick=&#123;onButtonClick&#125; style=&#123;&#123;<span class="attr">color</span>: <span class="string">"red"</span>&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>在上面的例子中，创建了名为SampleButton的组件实例，使用了名字分别为id、borderWidth、onClick和style的prop，看起来，React组件的prop很像是HTML元素的属性，不过，HTML组件属性的值都是字符串类型，即使是内嵌JavaScript，也依然是字符串形式表示代码。React组件的prop所能支持的类型则丰富得多，除了字符串，可以是任何一种JavaScript语言支持的数据类型。</p><p>比如在上面的SampleButton中，borderWidth就是数字类型，onClick是函数类型，style的值是一个包含color字段的对象，当prop的类型不是字符串类型时，在JSX中必须用花括号<code>{}</code>把prop值包住，所以style的值有两层花括号，外层花括号代表的是JSX的语法，内层的花括号代表这是一个对象常量。</p><p>当外部世界要传递一些数据给React组件，一个最直接的方式就是通过prop；同样，React组件要反馈数据给外部世界，也可以用prop，因为prop的类型不限于纯数据，也可以是函数，函数类型的prop等于让父组件交给了子组件一个回调函数，子组件在恰当的时机调用函数类型的prop，可以带上必要的参数，这样就可以反过来把信息传递给外部世界。</p><p>对于Counter组件，父组件的ControlPanel就是外部世界，我们看ControlPanel是如何用prop传递信息给Counter的，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ControlPanel</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Counter caption=<span class="string">"First"</span> initValue=&#123;<span class="number">0</span>&#125; /&gt;</span><br><span class="line">        &lt;Counter caption=<span class="string">"Second"</span> initValue=&#123;<span class="number">10</span>&#125; /&gt;</span><br><span class="line">        &lt;Counter caption=<span class="string">"Third"</span> initValue=&#123;<span class="number">20</span>&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>ControlPanel组件包含三个Counter组件实例，在ControlPanel的render函数中将这三个子组件实例用div包起来，因为React要求render函数只能返回一个元素。</p><p>在每个Counter组件实例中，都使用了caption和initValue这两个prop。通过名为caption的prop，ControlPanel传递给Counter组件实例说明文字。通过initValue的prop传递给Counter组件一个初始的计数值。</p><ul><li>2) 读取prop值</li></ul><p>我们再来看Counter组件内部是如何接收传入的prop的，首先是构造函数，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.onClickIncrementButton = <span class="keyword">this</span>.onClickIncrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.onClickDecrementButton = <span class="keyword">this</span>.onClickDecrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: props.initValue || <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个组件需要定义自己的构造函数，一定要记得在构造函数的第一行通过super调用父类也就是React.Component的构造函数。如果在构造函数中没有调用super(props)，那么组件实例被构造之后，类实例的所有成员函数就无法通过this.props访问到父组件传递过来的props值。很明显，给this.props赋值是React.Component构造函数的工作之一。</p><p>在Counter的构造函数中还给两个成员函数绑定了当前this的执行环境，因为ES6方法创造的React组建类并不自动给我们绑定this到当前实例对象。</p><p>在构造函数的最后，我们可以看到读取传入prop的方法，在构造函数中可以通过参数props获得传入的prop值，在其他函数中则可以通过this.props访问传入的prop的值，比如在Counter组件的render函数中，我们就是通过this.props获得传入的caption，render代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; caption &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onClickIncrementButton&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onClickDecrementButton&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;caption&#125; count: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用了ES6的解构赋值（destructuring assignment）语法从this.props中获得了名为caption的prop值。</p><ul><li>3) propTypes检查</li></ul><p>既然prop是组件的对外接口，那么就应该有某种方式让组件声明自己的接口规范。简单说，一个组件应该可以规范以下这些方面：</p><ul><li><p>这个组件支持哪些prop</p></li><li><p>每个prop应该是什么样的格式</p></li></ul><p>React通过propTypes来支持这些功能。</p><p>在ES6方法定义的组件类中，可以通过增加类的propTypes属性来定义prop规格，这不只是声明，而且是一种限制，在运行时和静态代码检查时，都可以根据propTypes判断外部世界是否正确地使用了组件的属性。</p><p>比如，对于Counter组件的propTypes定义代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Counter.propTypes = &#123;</span><br><span class="line">  caption: PropTypes.string.isRequired,</span><br><span class="line">  initValue: PropTypes.number</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中要求caption必须是string类型，initValue必须是number类型。可以看到，两者除了类型不同之外，还有一个区别：caption带上了isRequired，这表示使用Counter组件必须要指定caption；而initValue因为没有isRequired，则表示如果没有也没关系。</p><p>为了验证propTypes的作用，可以尝试故意违反propTypes的规定使用Counter实例，比如在ControlPanel的render函数中增加下列的代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Counter caption=&#123;<span class="number">123</span>&#125; initValue=&#123;<span class="number">20</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>我们在Chrome浏览器中，可以看到console中的红色警告</p><p><img src="/images/react-2/2.png" alt="错误prop类型的错误提示"></p><p>这段出错的含义是，caption属性预期是字符串类型，得到的却是一个数字类型。我们尝试删掉这个Counter实例的caption属性，代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Counter initValue=&#123;<span class="number">20</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>这是可以看到Console中依然有红色警告信息</p><p><img src="/images/react-2/3.png" alt="缺失必须存在prop的错误提示"></p><p>提示的含义是，caption是Counter必需的属性，但是却没有赋值。</p><p>很明显，有了propTypes的检查，可以很容易发现对prop的不正确使用方法，可尽早发现代码中的错误。</p><p>如果组件根本没有定义propTypes会怎么样呢？可以尝试在<code>src/Counter.js</code>文件中删除掉propTypes赋值的语句，在浏览器Console中红色警告不再出现。可见，没有propTypes定义，组件依然能够正常工作，而且，即使在上面propTypes检查出错的情况下，组件依旧能够工作。也就是说propTypes检查只是一个辅助开发的功能，并不会改变组件的行为。</p><p>propTypes虽然能够在开发阶段发现代码中的问题，但是放在产品环境中就不大合适了。</p><p>首先，定义类的propTypes属性，无疑是要占用一些代码空间，而且propTypes检查也是要消耗CPU计算资源的。其次，在产品环境下做propTypes检查没有什么帮助，毕竟，propTypes产生的这些错误信息只有开发者才能看得懂，放在产品环境下，在最终用户的浏览器Console中输出这些错误信息没什么意义。</p><p>所以，最好的方式是，开发者在代码中定义propTypes，在开发过程中避免犯错，但是在发布产品代码时，用一种自动的方式将propTypes去掉，这样最终部署到产品环境的代码就会更优。现有的babel-react-optimize就具有这个功能，可以通过npm安装，但是应该确保只在发布产品时使用它。</p><h4 id="2-React的state"><a href="#2-React的state" class="headerlink" title="2. React的state"></a>2. React的state</h4><p>驱动组件渲染过程的除了prop，还有state，state代表组件的内部状态。由于React组件不能修改传入的prop，所以需要记录自身数据变化，就要使用state。</p><p>在Counter组件中，最初显示初始计数，可以通过initValue这个prop来定制，在Counter已经被显示之后，用户会点击“<code>+</code>”和“<code>-</code>”按钮改变这个计数，这个变化的数据就要Counter组件自己通过state来存储了。</p><ul><li>1) 初始化state</li></ul><p>通常在组件类的构造函数结尾处初始化state，在Counter构造函数中，通过对this.state的赋值完成了对组件state的初始化，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    count: props.initValue || <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为initValue是一个可选的props，要考虑到父组件没有指定这个props值的情况，我们优先使用传入属性的initValue，如果没有，就是用默认值0。</p><p>组件的state必须是一个JavaScript对象，不能是string或者number这样的简单数据类型，即使我们需要存储的只是一个数字类型的数据，也只能把它存作state某个字段对应的值，Counter组件里，我们的唯一数据就存在count字段里。</p><p>由于在PropType声明中没有用isRequired要求必须有值的prop，例如上面的initValue，我们需要在代码中判断所给的prop值是否存在，如果不存在，就给一个默认的初始值。不过，让这样的判断逻辑充斥在我们组件的构造函数之中并不是一件美观的事情，而且容易有遗漏。我们可以用React的defaultProps功能，让代码更加容易读懂。</p><p>给Counter组件添加defaultProps代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Counter.defaultProps = &#123;</span><br><span class="line">  initValue: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了这样的设定，Counter构造函数中的this.state初始化中可以省去判断条件，可以认为代码执行到这里，必有initValue属性值，代码可以简化为这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  count: props.initValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，即使Counter的使用者没有指定initValue，在组件中就会收到一个默认的属性值0。</p><ul><li>2) 读取和更新state</li></ul><p>通过给button的onClick属性挂载点击事件处理函数，我们可以改变组件的state，以点击“<code>+</code>”按钮的响应函数为例，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onClickIncrementButton() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，通过this.state可以读取到组件的当前state。值得注意的是，我们改变组件state必须要使用this.setState函数，而不能直接去修改this.state。</p><p>直接修改this.state的值，虽然事实上改变了组件的内部状态，但只是野蛮地修改了state，却没有驱动组件进行重新渲染，既然组件没有重新渲染，当然不会反应this.state值的变化；而this.setState()函数所做的事情，首先是改变this.state的值，然后驱动组件经历更新过程，这样才有机会让this.state里新的值出现在界面上。</p><h4 id="3-prop和state的对比"><a href="#3-prop和state的对比" class="headerlink" title="3. prop和state的对比"></a>3. prop和state的对比</h4><p>总结一下prop和state的区别：</p><ul><li><p>prop用于定义外部接口，state用于记录内部状态</p></li><li><p>prop的赋值在外部世界使用组件时，state的赋值在组件内部</p></li><li><p>组件不应该改变prop的值，而state存在的目的就是让组件来改变的</p></li></ul><p>组件的state，就相当于组件的记忆，其存在意义就是被修改，每一次通过this.setState函数修改state就改变了组件的状态，然后通过渲染过程把这种变化体现出来。</p><p>但是，组件是绝不应该去修改传入的props值的，我们设想一下，假如父组件包含多个子组件，然后把一个JavaScript对象作为props值传给这几个子组件，而某个子组件居然改变了这个对象的内部值，那么，接下来其他子组件读取这个对象会得到什么值呢？当时读取了修改过的值，但是其他子组件是每次渲染都读取这个props的值呢？还是只读一次以后就用那个最初值呢？一切皆有可能，完全不可预料。也就是说，一个子组件去修改props中的值，可能让程序陷入一团混乱之中，这就完全违背了React设计的初衷。</p><p>严格来说，React并没有办法阻止我们去修改传入的props对象。所以，每个开发者就把这当做一个规矩，在编码中一定不要踩这道红线，不然最后可能遇到不可预料的bug。</p><hr><h3 id="三、组件的生命周期"><a href="#三、组件的生命周期" class="headerlink" title="三、组件的生命周期"></a>三、组件的生命周期</h3><p>为了理解React的工作过程，我们就必须要了解React组件的生命周期，如同人有生老病死，自然界有日月更替，每个组件在网页中也会被创建、更新和删除，如同有生命的机体一样。</p><p>React严格定义了组件的生命周期，会经理如下三个过程：</p><ul><li><p>装载过程（Mount），也就是把组件第一次在DOM树中渲染的过程</p></li><li><p>更新过程（Update），当组件被重新渲染的过程</p></li><li><p>卸载过程（Unmount），组件从DOM中删除的过程</p></li></ul><p>三种不同的过程，React库会依次调用组件的一些成员函数，这些函数称为生命周期函数。所以，要定制一个React组件，实际上就是定制这些生命周期函数。</p><h4 id="1-装载过程"><a href="#1-装载过程" class="headerlink" title="1. 装载过程"></a>1. 装载过程</h4><p>我们先来看装载过程，当组件第一次被渲染的时候，依次调用的函数是如下这些：</p><ul><li><p>constructor</p></li><li><p>getInitialState</p></li><li><p>getDefaultProps</p></li><li><p>componentWillMount</p></li><li><p>render</p></li><li><p>componentDidMount</p></li></ul><p>我们逐个详细解释这些函数的功能</p><ul><li>1) constructor</li></ul><p>我们先来看constructor，也就是ES6中每个类的构造函数，要创造一个组件类的实例，当然会调用对应的构造函数。</p><p>要注意，并不是每个组件都需要定义自己的构造函数。在后文中我们可以看到，无状态的React组件往往就不需要定义构造函数，一个React组件需要构造函数，往往是为了下面的目的：</p><ul><li><p>初始化state，因为组件生命周期中任何函数都可能要访问state，那么整个生命周期中第一个被调用的构造函数自然是初始化state最理想的地方</p></li><li><p>绑定成员函数的this环境</p></li></ul><p>在ES6语法下，类的每个成员函数在执行时的this并不是和类实例自动绑定的。而在构造函数中，this就是当前组件实例，所以，为了方便将来的调用，往往在构造函数中将这个实例的特定函数绑定this为当前实例。</p><p>以Counter组件为例，我们的构造函数有这样如下的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.onClickIncrementButton = <span class="keyword">this</span>.onClickIncrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.onClickDecrementButton = <span class="keyword">this</span>.onClickDecrementButton.bind(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这两句的作用，就是通过bind方法让当前实例中onClickIncrementButton和onClickDecrementButton函数被调用时，this始终是指向当前组件实例。</p><ul><li>2) getInitialState和getDefaultProps</li></ul><p>getInitialState这个函数的返回值用来初始化组件的this.state，但是，这个方法只有用React.createClass方法创造的组件类才会发生作用，本文中使用ES6语法，所以这个函数根本不会产生作用。</p><p>getDefaultProps函数的返回值可以作为props的初始值，和getInitialState一样，这个函数不会产生作用。</p><ul><li>3) render</li></ul><p>render函数无疑是React组件中最重要的函数，一个React组件可以忽略其他所有函数都不实现，但是一定要实现render函数，因为所有React组件的父类React.Component类对除render之外的生命周期函数都有默认实现。</p><p>通常一个组件要发挥作用，总是要渲染一些东西，render函数并不做实际的渲染动作，它只是返回一个JSX描述的结构，最终由React来操作渲染过程。</p><p>当然，某些特殊组件的作用不是渲染界面，或者，组件在某些情况下选择没有东西可画，那就让render函数返回一个null或者false，等于告诉React，这个组件这次不需要渲染任何DOM元素。</p><p>需要注意的时，render函数应该是一个纯函数，是完全根据this.state和this.props来决定返回的结果，而且不要产生任何副作用。在render函数中去调用this.setState毫无疑问是错误的，因为一个纯函数不应该引起状态的改变。</p><ul><li>4) componentWillMount和componentDidMount</li></ul><p>在装在过程中，componentWillMount会在调用render函数之前被调用，componentDidMount会在调用render函数之后被调用，这两个函数就像是render函数的前哨和后卫，一前一后，把render函数夹住，正好分别做render前后必要的工作。</p><p>不过，我们通常不用定义componentWillMount函数，顾名思义，componentWillMount发生在“将要装载”的时候，这个时候没有任何渲染出来的结果，即使调用this.setState修改状态也不会引发重新绘制，一切都迟了。换句话说，所有可以在这个componentWillMount中做的事情，都可以提前到constructor中去做，可以认为这个函数存在的主要目的就是为了和componentDidMount对称。</p><p>而componentDidMount作用就大了，需要注意的是，render函数被调用完之后，componentDidMount函数并不是会被立刻调用，componentDidMount被调用的时候，render函数返回的东西已经引发了渲染，组件已经被装载到了DOM树上。</p><p>我们还是以ControlPanel为例，在ControlPanel中有三个Counter组件，我们稍微修改Counter的代码，让装在过程中所有生命周期函数都用console.log输出函数名和caption的值，比如，componentWillMount函数的内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'enter componentWillMount '</span> + <span class="keyword">this</span>.props.caption);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器的console里我们能够看见：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enter constructor: First</span><br><span class="line">enter componentWillMount First</span><br><span class="line">enter render First</span><br><span class="line">enter constructor: Second</span><br><span class="line">enter componentWillMount Second</span><br><span class="line">enter render Second</span><br><span class="line">enter constructor: Third</span><br><span class="line">enter componentWillMount Third</span><br><span class="line">enter render Third</span><br><span class="line">enter componentDidMount First</span><br><span class="line">enter componentDidMount Second</span><br><span class="line">enter componentDidMount Third</span><br></pre></td></tr></table></figure><p>可以清楚的看到，虽然componentWillMount都是紧贴着自己组件的render函数之前被调用，componentDidMount可不是紧跟着render函数被调用，当所有三个组建的render函数都被调用之后，三个组件的componentDidMount才连在一起被调用。</p><p>之所以会有上面的现象，是因为render函数本身并不往DOM树上渲染或者装载内容，它只是返回一个JSX表示的对象，然后由React库来根据返回对象决定如何渲染。而React库肯定是要把所有的组件返回的结果综合起来，才能知道如何产生对应的DOM修改。所以，只有React库调用三个Counter组件的render函数之后，才有可能完成装载，这时候才会依次调用各个组件的componentDidMount函数作为装载过程的收尾。</p><p>componentWillMount和componentDidMount这对兄弟函数还有一个区别，就是componentWillMount可以在服务器端被调用，也可以在浏览器端被调用；而componentDidMount只能在浏览器端被调用，在服务器端使用React的时候不会被调用。</p><p>目前为止，我们构造的React应用例子都只是在浏览器端使用React，所以看不出区别，在后面关于“同构”应用的介绍时，我们会探讨在服务器端使用React的情况。</p><p>至于为什么只有componentDidMount仅在浏览器端执行，这是一个实现上的决定，而不是设计时刻有意而为之。不过，如果非要有个解释的话，可以这么说，既然“装载”是一个创建组件并放到DOM树上的过程，那么，真正的“装载”是不可能在服务器端完成的，因为服务器端渲染并不会产生DOM树，通过React组件产生的只是一个纯粹的字符串而已。</p><p>不管怎样，componentDidMount只在浏览器端执行，倒是给了我们开发者一个很好地位置去做只有浏览器端才做的逻辑，比如通过Ajax获取数据来填充组件的内容。</p><p>在componentDidMount被调用的时候，组件已经被装载到DOM树上了，可以放心获取渲染出来的任何DOM。</p><p>在实际开发过程中，可能会需要让React和其他UI库配合使用，比如，因为项目前期已经用jQuery开发了很多功能，需要继续使用这些基于jQuery的代码，有时候其他的UI库做某些功能比React更合适，比如d3.js已经支持了丰富的绘制图表的功能，在这些情况下，我们不得不考虑如何让React和其他UI库和平共处。</p><p>以和jQuery配合为例，我们知道，React是用来取代jQuery的，但如果真的要让React和jQuery配合，就需要利用componentDidMount函数，当componentDidMount被执行时，React组件对应的DOM已经存在，所有的事件处理函数也已经设置好，这时候就可以调用jQuery的代码，让jQuery在已经绘制的DOM基础上增强新的功能。</p><p>在componentDidMount中调用jQuery代码只处理了装载过程，要和jQuery完全结合，又要考虑React的更新过程，就需要使用下面要讲的componentDidUpdate函数。</p><h4 id="2-更新过程"><a href="#2-更新过程" class="headerlink" title="2. 更新过程"></a>2. 更新过程</h4><p>当组件被装载到DOM树上之后，用户在网页上可以看到组件的第一印象，但是要提供更好的交互体验，就要让该组件可以随着用户操作改变展现的内容，当props或者state修改的时候，就会引发组件的更新过程。</p><p>更新过程会依次调用下面的生命周期函数，其中render函数和装载过程一样，没有差别。</p><ul><li><p>componentWillReceiveProps</p></li><li><p>shouldComponentUpdate</p></li><li><p>componentWillUpdate</p></li><li><p>render</p></li><li><p>componentDidUpdate</p></li></ul><p>有意思的是，并不是所有的更新过程都会执行全部函数，下面会介绍到各种特例。</p><ul><li>1) componentWillReceiveProps(nextProps)</li></ul><p>关于这个componentWillReceiveProps存在一些误解。在网上有些教材声称这个函数只有当组件的props发生改变的时候才会被调用，其实是不正确的。实际上，只要是父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程，不管父组件传给子组件的props有没有改变，都会触发子组件的componentWillReceiveProps函数。</p><p>注意，通过this.setState方法触发的更新过程不会调用这个函数，这是因为这个函数适合根据新的props值（也就是参数nextProps）来计算出是不是要更新内部状态state。更新组件内部状态的方法就是this.setState，如果this.setState的调用导致componentWillReceiveProps再一次被调用，那就是一个死循环了。</p><p>让我们对ControlPanel做一些小的改进，来体会一下上面提到的规则。</p><p>我们首先在Counter组件类里增加函数定义，让这个函数componentWillReceiveProps在console上输出一些文字，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'enter componentWillReceiveProps '</span> + <span class="keyword">this</span>.props.caption);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ControlPanel组件的render函数中，我们也做如下修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'enter ControlPanel render'</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;style&#125;&gt;</span><br><span class="line">      ...</span><br><span class="line">      &lt;button onClick=&#123; () =&gt; <span class="keyword">this</span>.forceUpdate() &#125;&gt;</span><br><span class="line">        Click me to repaint!</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了在ControlPanel的render函数入口处增加console输出，我们还增加了一个按钮，这个按钮的onClick事件引发了一个匿名函数，当这个函数被点击的时候，调用this.forceUpdate，每个React组件都可以通过forceUpdate函数强行引发一次重新绘制。</p><p>在网页中，我们去点击那个新增加的按钮，可以看到浏览器的console中有如下输出：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enter ControlPanel render</span><br><span class="line">enter componentWillReceiveProps First</span><br><span class="line">enter render First</span><br><span class="line">enter componentWillReceiveProps Second</span><br><span class="line">enter render Second</span><br><span class="line">enter componentWillReceiveProps Third</span><br><span class="line">enter render Third</span><br></pre></td></tr></table></figure><p>可以看到，引发forceUpdate之后，首先是ControlPanel的render函数被调用，随后第一个Counter组件的componentWillReceiveProps函数被调用，然后Counter组件的render函数被调用，随后第二个第三个组件的这两个函数也依次被调用。</p><p>然而，ControlPanel在渲染三个子组件的时候，提供的props值一直就没有变化，可见componentWillReceiveProps并不是当props值变化的时候才被调用，所以，这个函数有必要把传入参数nextProps和this.props做必要对比。nextProps代表的是这一次渲染传入的props值，this.props代表的上一次渲染时的props值，只有两者有变化的时候才有必要调用this.setState更新内部状态。</p><p>在网页中，我们再次尝试点击第一个Counter组件的“<code>+</code>”按钮，可以看到浏览器的console输出如下：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enter render First</span><br></pre></td></tr></table></figure><p>明显，只有第一个组件的Counter的render函数被调用，函数componentWillReceiveProps没有被调用。因为点击“<code>+</code>”按钮引发的是第一个Counter组件的this.setState函数的调用，就像上面说过的一样，this.setState不会引发这个函数componentWillReceiveProps被调用。</p><p>从这个例子我们也会发现，在React的组件组合中，完全可以只渲染一个子组件，而其它组件完全不需要渲染，这是提高React性能的重要方式。</p><ul><li>2) shouldComponentUpdate(nextProps, nextState)</li></ul><p>除了render函数，shouldComponentUpdate可能是React组件生命周期中最重要的一个函数了。</p><p>说render函数重要，是因为render函数决定了该渲染什么，而说shouldComponentUpdate函数重要，是因为它决定了一个组件什么时候不需要渲染。</p><p>render和shouldComponentUpdate函数，也是React生命周期函数中唯二两个要求有返回结果的函数。render函数的返回结果将用于构造DOM对象，而shouldComponentUpdate函数返回一个布尔值，告诉React库这个组件在这次更新过程中是否要继续。</p><p>在更新过程中，React库首先调用shouldComponentUpdate函数，如果这个函数返回true，那就会继续更新过程，接下来调用render函数；反之，如果得到一个false，那就立刻停止更新过程，也就不会引发后续的渲染了。</p><p>说shouldComponentUpdate重要，就是因为只要使用恰当，它就能够大大提高React组件的性能，虽然React的渲染性能已经很不错了，但是，不管渲染有多快，如果发现没必要重新渲染，那就干脆不用渲染好了，速度会更快。</p><p>我们知道render函数应该是一个纯函数，这个纯函数的逻辑输入就是组件的props和state。所以，shouldComponentUpdate的参数就是接下来的props和state值。如果我们要定义shouldComponentUpdate，那就根据这两个参数，外加this.props和this.state来判断出返回true还是返回false。</p><p>如果我们给组件添加shouldComponentUpdate函数，那就沿用所有React组件父类React.Component中的默认实现方式，默认实现方式就是简单地返回true，也就是每次更新过程都要重新渲染。当然，这是最稳妥的方式，大不了浪费一点，但是绝对不会出错。不过若我们要追求更高的性能，就不能满足于默认实现，需要定制这个函数shouldComponentUpdate。</p><p>让我们尝试来给Counter组件增加一个shouldComponentUpdate函数。先来看看props，Counter组件支持两个props，一个叫caption，一个叫initValue。很明显，只有caption这个prop改变的时候，才有必要重新渲染。对于initValue，只是创建Counter组件实例时用于初始化计数值，在组件实例创建之后，无论怎么改，都不应该让Counter组件重新渲染。</p><p>再来看看state，Counter组件的state只有一个值count，如果count发生了变化，那肯定应该重新渲染，如果count没变化，那就没必要了。</p><p>现在，让我们给Counter组件类增加shouldComponentUpdate函数的定义，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="keyword">return</span> (nextProps.caption !== <span class="keyword">this</span>.props.caption) ||</span><br><span class="line">    (nextState.count !== <span class="keyword">this</span>.state.count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，只有当caption改变，或者state中的count值改变，shouldComponentUpdate才会返回true。</p><p>值得一提的是，通过this.setState函数引发更新过程，并不是立刻更新组件的state值，在执行到函数shouldComponentUpdate的时候，this.state依然是this.setState函数执行之前的值，所以我们要做的实际上就是在nextProps、nextState、this.props和this.state中互相比对。</p><p>我们在网页中引发一次ControlPanel的重新绘制，可以看到浏览器的console中输出这样：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enter ControlPanel render</span><br><span class="line">enter componentWillReceiveProps First</span><br><span class="line">enter componentWillReceiveProps Second</span><br><span class="line">enter componentWillReceiveProps Third</span><br></pre></td></tr></table></figure><p>可以看到，三个Counter组件的render函数都没有被调用，因为这个刷新没有改变caption的值，更没有引发组件内状态的改变，所以完全没有必要重新绘制counter。</p><p>对于Counter这个简单的组件，我们无法感觉到性能的提高，但是，实际开发中会遇到更复杂更庞大的组件，这种情况下避免没必要的重新渲染，就会大大提高性能。</p><ul><li>3) componentWillUpdate和componentDidUpdate</li></ul><p>如果组件的shouldComponentUpdate函数返回true，React接下来就会依次调用对应组件的componentWillUpdate、render和componentDidUpdate函数。</p><p>componentWillMount和componentDidMount，componentWillUpdate和componentDidUpdate，这两对函数一前一后地把render函数夹在中间。</p><p>和装载过程不同的是，当在服务器端使用React渲染时，这一对函数中的Did函数，也就是componentDidUpdate函数，并不是只在浏览器端才执行的，无论更新过程发生在服务器端还是浏览器端，该函数都会被调用。</p><p>在介绍componentDidMount函数时，我们说到可以利用componentDidMount函数执行其他UI库的代码，比如jQuery代码。当React组件被更新时，原有的内容被重新绘制，这时候就需要在componentDidUpdate函数再次调用jQuery代码。</p><p>那么，componentDidUpdate函数不是可能会在服务器端也被执行吗？在服务器端怎么能够使用jQuery呢？实际上，使用React做服务器端渲染时，基本不会经历更新过程，因为服务器端只需要产出HTML字符串，一个装载过程就足够产出HTML了，所以正常情况下服务器端不会调用componentDidUpdate函数，如果调用了，说明我们的程序有错误，需要改进。</p><h4 id="3-卸载过程"><a href="#3-卸载过程" class="headerlink" title="3. 卸载过程"></a>3. 卸载过程</h4><p>React组件的卸载过程只涉及一个函数componentWillUnmount，当React组件要从DOM树上删除掉之前，对应的componentWillUnmount函数会被调用，所以这个函数适合做一些清理性的工作。</p><p>和装载过程和更新过程不一样，这个函数没有配对的Did函数，就一个函数，因为卸载完就完了，没有“卸载完再做的事情”。</p><p>不过，componentWillUnmount中的工作往往和componentDidMount有关，比如，在componentDidMount中用非React的方法创造一些DOM元素，如果撒手不管可能会造成内存的泄漏，那就需要在componentWillUnmount中把这些创造的DOM元素清理掉。</p><hr><h3 id="四、组件向外传递数据"><a href="#四、组件向外传递数据" class="headerlink" title="四、组件向外传递数据"></a>四、组件向外传递数据</h3><p>通过构造ControlPanel和Counter，现在我们已经知道了如何通过props从父组件传递数据给子组件，但是，组件之间的交流是相互的，子组件某些情况下也需要把数据传递给父组件，我们接下来看看在React中如何实现这个功能。</p><p>在ControlPanel中，包含三个Control子组件实例，每个Counter都有一个可以动态改变的计数值，我们希望ControlPanel能够即时显示出这三个子组件当前计数值之和。</p><p>这个功能看起来很简单，但是要解决一个问题，就是要让ControlPanel“知道”三个子组件当前的计数值，而且是每次改变都要立刻知道，而Counter组件的当前值是组件的内部状态，如何让外部世界知道这个值呢？</p><p>解决这个问题的方法，依然是利用prop。组件的prop可以是任何JavaScript对象，而在JavaScript中，函数是一等公民，函数本身就可以被看作一种对象，既可以像其他对象一样作为prop的值从父组件传递给子组件，又可以被子组件作为函数调用，这样事情就好办了。</p><h4 id="1-应用实例"><a href="#1-应用实例" class="headerlink" title="1. 应用实例"></a>1. 应用实例</h4><p>我们看到修改后的功能图如图所示</p><p><img src="/images/react-2/5.png" alt="包含总数的ControlPanel应用效果图"></p><p>点击任何一个Counter的“<code>+</code>”按钮或者“<code>-</code>”按钮，可以看见除了所属Counter的计数变化，底部的总计数也会随之变化，这是因为Counter能够把自己状态改变的信息传递给外层的组件。</p><p>接下来看实现这个功能的关键代码。</p><p>在Counter组件中，对于点击“<code>+</code>”和“<code>-</code>”按钮的事件处理方法做了改动，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">onClickIncrementButton() &#123;</span><br><span class="line">  <span class="keyword">this</span>.updateCount(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onCLickDecrementButton() &#123;</span><br><span class="line">  <span class="keyword">this</span>.updateCount(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateCount(isIncrement) &#123;</span><br><span class="line">  <span class="keyword">const</span> previousValue = <span class="keyword">this</span>.state.count;</span><br><span class="line">  <span class="keyword">const</span> newValue = isIncrement ? previousValue + <span class="number">1</span> : previousValue - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: newValue &#125;);</span><br><span class="line">  <span class="keyword">this</span>.props.onUpdate(newValue, previousValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，onClickIncrementButton函数和onClickDecrementButton函数的任务除了调用this.setState改变内部状态，还要调用this.props.onUpdate这个函数，为了避免重复代码，我们对原有代码做一下重构，提取了共同部分到updateCount函数里。</p><p>对应的，Counter组件的propTypes和defaultProps就要增加onUpdate的定义，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Counter.propTypes = &#123;</span><br><span class="line">  caption: PropTypes.string.isRequires,</span><br><span class="line">  initValue: PropTypes.number,</span><br><span class="line">  onUpdate: PropTypes.func</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Counter.defaultProps = &#123;</span><br><span class="line">  initValue: <span class="number">0</span>,</span><br><span class="line">  onUpdate: <span class="function"><span class="params">f</span> =&gt;</span> f</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>新增加的prop叫做onUpdate，类型是一个函数，当Counter的状态改变的时候，就会调用这个给定的函数，从而达到通知父组件的作用。</p><p>这样，Counter的onUpdate就成了作为子组件的Counter向父组件ControlPanel传递数据的渠道，我们先约定这个函数的第一个参数是Counter更新之后的值，第二个参数是更新之前的值，至于如何使用这两个参数的值，是父组件ControlPanel的逻辑，Counter不用操心，而且根据两个参数的值足够推导出数值是增加还是减少。</p><p>从使用Counter组件的角度，在ControlPanel组件中也要做一些修改，现在ControlPanel需要包含自己的state，首先是构造函数部分，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.onCounterUpdate = <span class="keyword">this</span>.onCounterUpdate.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.initValues = [<span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line">  <span class="keyword">const</span> initSum = <span class="keyword">this</span>.initValues.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    sum: initSum</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ControlPanel组件被第一次渲染的时候，就需要显示三个计数器数值的综合，所以我们在构造函数中使用initValues数组记录所有的Counter的初始值，在初始化this.state之前，将initValues数组中所有值加在一起，作为this.state中sum字段的初始值。</p><p>ControlPanel传递给Counter组件的onUpdate这个prop的值是onCounterUpdate函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onCounterUpdate(newValue, previousValue) &#123;</span><br><span class="line">  <span class="keyword">const</span> valueChange = newValue - previousValue;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    sum: <span class="keyword">this</span>.state.sum + valueChange</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onCounterUpdate函数的参数和Counter中调用的onUpdate prop的参数规格一致，第一个参数为新值，第二个参数为之前的值，两者之差就是改变值，将这个改变作用到this.state.sum上就是sum的新状态。</p><p>遗憾的是，React虽然有PropType能够检查prop的类型，却没有任何机制来限制prop的参数规格，参数的一致性只能靠开发者来保证。</p><p>ControlPanel组件的render函数中需要增加对this.state.sum和onCountUpdate的使用，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;style&#125;&gt;</span><br><span class="line">      &lt;Counter onUpdate=&#123;<span class="keyword">this</span>.onCountUpdate&#125; caption=<span class="string">"First"</span> /&gt;</span><br><span class="line">      &lt;Count onUpdate=&#123;<span class="keyword">this</span>.onCountUpdate&#125; caption=<span class="string">"Second"</span> initValue=&#123;<span class="keyword">this</span>.initValues[<span class="number">1</span>]&#125; /&gt;</span><br><span class="line">      &lt;Count onUpdate=&#123;<span class="keyword">this</span>.onCountUpdate&#125; caption=<span class="string">"Third"</span> initValue=&#123;<span class="keyword">this</span>.initValues[<span class="number">2</span>]&#125; /&gt;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &lt;div&gt;Total Count: &#123;<span class="keyword">this</span>.state.sum&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="五、React组件state和prop的局限"><a href="#五、React组件state和prop的局限" class="headerlink" title="五、React组件state和prop的局限"></a>五、React组件state和prop的局限</h3><p>是时候重新思考一下多个组件之间的数据管理问题了。在上面修改的代码中，不难发现其实实现得并不精妙，每个Count组件有自己的状态记录当前计数，而父组件ControlPanel也有一个状态来存储所有Counter计数总和，也就是说，数据发生了重复。</p><p>数据如果出现重复，带来的一个问题就是如何保证重复的数据一致，如果数据存多份而且不一致，那就很难决定到底使用哪个数据作为正确结果了。</p><p>在上面的例子中，ControlPanel通过onUpdate回调函数传递的新值和旧值来计算新的计数总和，设想一下，由于某种bug的原因，某个按钮的点击更新没有通知到ControlPanel，就会让ControlPanel中的sum状态和所有子组件Counter的count状态之和不一致，这时候，是应该相信ControlPanel还是Count呢？</p><p>如图所示，逻辑上应该相同的状态，分别存放在不同组件中，就会导致这种困局。</p><p><img src="/images/react-2/6.png" alt="组件状态不一致的困惑"></p><p>对于上面所说的问题，一个直观的解决方法是以某一个组件的状态为准，这个组件是状态的“领头羊”，其余组件都保持和“领头羊”的状态同步，但是在实际情况下这种方法可能很难实施。比如上面的例子中，每个Counter记录自己的计数值是很自然的，但是有三个Counter组件，也就有三只“领头羊”，让ControlPanel跟着三只“领头羊”走，似乎不是一个好主意。</p><p>另一种思路，就是干脆不要让任何一个React组件扮演“领头羊”的角色，把数据源放在React组件之外形成全局状态，如下图所示，让各个组件保持和全局状态的一致，这样更容易控制。</p><p><img src="/images/react-2/7.png" alt="React中提取出来"></p><p>图中全局状态就是唯一可靠的数据源，下一章我们会介绍，这就是Flux和Redux中Store的概念。</p><p>除了state，利用prop在组件之间传递信息也会遇到问题。设想一下，在一个应用中，包含三级或者三级以上的组件结构，顶层的祖父级组件想要传递一个数据给最底层的子组件，用prop的方式，就只能通过父组件中转，而中间那一层父组件可能根本用不上这个prop，但是依然要支持这个prop，扮演好搬运工的角色，只因为子组件用得上，这明显违反了低耦合的设计要求。</p><p><img src="/images/react-2/8.png" alt="跨级传递prop的困局"></p><hr><h3 id="六、本章小结"><a href="#六、本章小结" class="headerlink" title="六、本章小结"></a>六、本章小结</h3><p>本章中，我们学习了构建高质量组件的原则，应用React一样要以构建高内聚低耦合的组件为目标，而保证组件高质量的一个重要工作就是保持组件对外接口清晰简洁。</p><p>React利用prop来定义组件的对外接口，用state来代表内部的状态，某个数据选择用prop还是用state表示，取决于这个数据是对内还是对外。</p><p>我们还介绍了React的生命周期，了解了装载过程、更新过程和卸载过程涉及的所有生命周期函数。</p><p>在本章中我们利用ControlPanel和Counter两个组件演示了组件之间的通信方式，包括子组件向父组件传递信息的方式，同时也看出了使用React的state来存储状态的一个缺点，那就是数据的冗余和重复，这就是我们接下来要解决的问题。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="/resources/深入浅出React和Redux.pdf">《深入浅出React和Redux —— 程墨》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个合格的开发者，不能只满足于编写出可以运行的代码，而要了解代码背后的工作原理；不能只满足于自己编写的程序能够运行，还要让自己的代码可读而且易于维护。这样才能开发出高质量的软件。&lt;/p&gt;
    
    </summary>
    
      <category term="React抄书笔记" scheme="http://www.xiaoleon.cn/categories/React%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.xiaoleon.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(1) 新的前端思维方式</title>
    <link href="http://www.xiaoleon.cn/2018/03/04/react-1/"/>
    <id>http://www.xiaoleon.cn/2018/03/04/react-1/</id>
    <published>2018-03-04T01:51:31.000Z</published>
    <updated>2018-03-19T13:15:53.821Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来只管认识React，对任何一种工具，只有使用才能够熟练掌握，React也不例外。通过对React快速上手，我们会解析React的工作原理，并通过与功能相同的jQuery程序对比，从而看出React的特点。</p><a id="more"></a><h3 id="一、初始化一个React项目"><a href="#一、初始化一个React项目" class="headerlink" title="一、初始化一个React项目"></a>一、初始化一个React项目</h3><p>React是一个JavaScript语言的工具库，我们需要安装Node.js，React本身并不依赖于Node.js，但是我们开发中用到的诸多工具需要Node.js的支持。</p><p>在Node.js的官网（<a href="https://nodejs.org" target="_blank" rel="noopener">https://nodejs.org</a>）可以找到合适的安装方式，安装Node.js的同时也就安装了npm，npm是Node.js的安装包管理工具，因为我们不可能自己开发所有功能，会大量使用现有的安装包，就需要npm的帮助。</p><h4 id="1-create-react-app工具"><a href="#1-create-react-app工具" class="headerlink" title="1. create-react-app工具"></a>1. create-react-app工具</h4><p>React技术依赖于一个很庞大的技术栈，比如，转译JavaScript代码需要使用Babel，模块打包工具又要使用Webpack，定制build过程需要grunt或者gulp，这些技术栈都需要各自的配置文件，还没有开始写一行React相关代码，我们就已经被各种技术名词淹没。</p><p>针对这种情况，React的创建者Facebook提供了一个快速开发React应用的工具，名叫<code>create-react-app</code>，这个工具的目的是将开发人员从配置工作中解脱出来，无需过早关注这些技术栈细节，通过创建一个已经完成基本配置的应用，让开发者快速开始React应用的开发。</p><p><code>create-react-app</code>是一个通过npm发布的安装包，在确认Node.js和npm安装好之后，命令行中执行下面的命令安装<code>create-react-app</code>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure><p>安装结束后，我们可以通过如下命令创建react项目：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app first_react_app</span><br></pre></td></tr></table></figure><p>这个命令会在当前目录创建一个名为first_react_app的目录，在这个目录中会自动添加一个应用的框架，随后我们只需要在这个框架的基础上修改文件就可以开发React应用，避免了大量的手工配置工作。</p><p>在<code>create-react-app</code>命令一大段文字输出之后，根据提示，输入下面的命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> first_react_app</span><br><span class="line">npm <span class="built_in">start</span></span><br></pre></td></tr></table></figure><p>这个命令会启动一个开发模式的服务器，同时也会让浏览器自动打开一个网页，指向本机地址<code>http://localhost:3000</code>。</p><p><img src="/images/react-1/1.png" alt="第一个React应用"></p><p>接下来，我们会用React开发一个简单的功能。</p><hr><h3 id="二、增加一个新的React组件"><a href="#二、增加一个新的React组件" class="headerlink" title="二、增加一个新的React组件"></a>二、增加一个新的React组件</h3><p>React的首要思想是通过组件（<code>Component</code>）来开发应用。所谓组件，简单说，指的是能完成某个特定功能的独立的、可重用的代码。</p><p>基于组件的应用开发是广泛使用的软件开发模式，用分而治之的方法，把一个大的应用分解成若干小的组件，每个组件只关注于某个小范围的特定功能，但是把组件组合起来，就能构成一个功能庞大的应用。如果分解功能的过程足够巧妙，那么每个组件可以在不同场景下重用，那么不光可以构建庞大的应用，还可以构建出灵活的应用。打个比方，每个组件是一块砖，而一个应用是一座楼，想要一次锻造就创建一座楼是不现实的。实际上，总是先锻造出很多砖，通过排列组合这些砖，才能构建伟大的建筑。</p><p>我们先看看<code>create-react-app</code>给我们自动产生的代码，在first_react_app目录下包含如下文件和目录。</p><p><img src="/images/react-1/2.png" alt="文件目录"></p><p>在开发过程中，我们主要关注src目录中的内容，这个目录中是所有的源代码。</p><p>create-react-app所创建的应用的入口是<code>src/index.js</code>文件，我们看看中间的内容，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个应用所做的事情，只是渲染一个名叫<code>App</code>的组件，<code>App</code>组件在同目录下的<code>App.js</code>文件中定义，渲染出来的效果就是在上图中看到的界面。</p><p>我们要定义一个新的能够计算点击数组件，名叫<code>ClickCounter</code>，所以我们修改<code>index.js</code>文件如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> ClickCounter <span class="keyword">from</span> <span class="string">'./ClickCounter'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ClickCounter /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>接下来我们会介绍代码的含义。现在我们先来看看如何添加一个新组件，在<code>src</code>目录下添加一个新的代码文件<code>ClickCounter.js</code>，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.onClickButton = <span class="keyword">this</span>.onClickButton.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onClickButton() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.onClickButton&#125;&gt;Click Me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          Click Count: &#123; this.state.count &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default ClickCounter;</span></span><br></pre></td></tr></table></figure><p>我们可以在网页中看到，其中内容已经发生改变，如下图所示</p><p><img src="/images/react-1/3.png" alt="ClickCounter组件界面效果"></p><p>点击“Click Me”按钮，可以看到“Click Count”后面的数字会随之增加，每点击一次加1.</p><p>现在让我们来逐步详细解释代码中各部分的要义。</p><p>在<code>index.js</code>文件中，使用<code>import</code>导入了<code>ClickCounter</code>组件，代替了之前的<code>App</code>组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ClickCounter <span class="keyword">from</span> <span class="string">'./ClickCounter'</span>;</span><br></pre></td></tr></table></figure><p><code>import</code>是ES6语法中导入文件模块的方式，ES6语法是一个大集合，大部分功能都被最新浏览器支持。不过这个<code>import</code>方法却不在广泛支持之列，这没有关系，ES6语法的JavaScript会被webpack和babel转译成所有浏览器支持的ES5语法，而这一切都无需开发人员配置，<code>create-react-app</code>已经替我们完成了这些工作。</p><p>在<code>ClickCounter.js</code>文件的第一行，我们从react库中引入了<code>React</code>和<code>Component</code>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br></pre></td></tr></table></figure><p><code>Component</code>作为所有组件的基类，提供了很多组建共有的功能，下面这行代码，使用的是ES6语法来创建一个叫<code>ClickCounter</code>的组建类，<code>ClickCounter</code>的父类就是<code>Component</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>在React出现之初，使用的是<code>React.createClass</code>方式来创造组件类，这种方法已经被废弃了。在本文中，我们只使用ES6的语法来构建组件类。</p><p>虽然我们导入的<code>Component</code>类在<code>ClickCounter</code>组件定义中使用了，可是导入的React却没有被使用，难道这里引入React没有必要吗？</p><p>事实上，引入React非常必要，我们可以尝试删掉第一行中的React，在网页中立刻会出现错误信息。</p><p><img src="/images/react-1/4.png" alt="缺失React的错误"></p><p>这个错误的含义是：“在使用JSX的范围内必须要有React。”</p><p>也就是说，在使用JSX的代码文件中，即使代码中并没有直接使用React，也一定要导入React，这是因为JSX最终会被转译成依赖于React的表达式。</p><h4 id="1-JSX"><a href="#1-JSX" class="headerlink" title="1. JSX"></a>1. JSX</h4><p>所谓JSX，是JavaScript的语法扩展（eXtension），让我们在JavaScript中可以编写像HTML一样的代码。在<code>ClickCounter.js</code>的<code>render</code>函数中，就出现了类似这样的HTML代码，在<code>index.js</code>中，<code>ReactDOM.render</code>的第一个参数<code>&lt;App /&gt;</code>也是一段JSX代码。</p><p>JSX中的这几段代码看起来和HTML几乎一模一样，都可以使用<code>&lt;div&gt;</code>、<code>&lt;button&gt;</code>之类的元素，所以只要熟悉HTML，学习JSX完全不成问题，但是，我们一定要明白两者的不同之处。</p><p>首先，在JSX中使用的“元素”不局限于HTML元素，可以是任何一个React组件，在App.js中可以看到，我们创建的<code>ClickCounter</code>组件被直接应用在JSX中，使用方法和其他元素一样，这一点是传统的HTML做不到的。</p><p>React判断一个元素是HTML元素还是React元素的原则就是看第一个字母是否大写，如果在JSX中我们不用<code>ClickCounter</code>而是用<code>clickCounter</code>，那就得不到我们想要的结果。</p><p>其次，在JSX中可以通过<code>onClick</code>的方式给一个元素添加一个事件处理函数，当然，在HTML中也可以使用<code>onclick</code>（注意和<code>onClick</code>拼写有区别），但在HTML中直接书写<code>onclick</code>一直就是为人诟病的写法，网页应用开发界一直倡导的是用jQuery的方法添加事件处理函数，直接写<code>onclick</code>会带来代码混乱的问题。</p><p>这就带来一个问题，既然长期以来一直不提倡在HTML中使用<code>onclick</code>，为什么在React的JSX中我们却要使用<code>onClick</code>这样的方式来添加事件处理函数呢？</p><h4 id="2-JSX是进步还是倒退"><a href="#2-JSX是进步还是倒退" class="headerlink" title="2. JSX是进步还是倒退"></a>2. JSX是进步还是倒退</h4><p>在React出现之初，很多人对React这样的设计非常反感，因为React把类似HTML的标记语言和JavaScript混在一起了，但是，随着时间的推移，业界逐渐认可了这种方式，因为大家都发现，以前用HTML来代表内容，CSS代笔样式，Javascript来定义交互行为，这三种语言分在三种不同的文件里面，实际上是把不同技术分开管理了，而不是逻辑上的“分而治之”。</p><p>根据做同一件事的代码应该有高耦合性的设计原则，既然我们要实现一个<code>ClickCounter</code>，那为什么不把实现这个功能的所有代码集中在一个文件里呢？</p><p>那么，在JSX中使用<code>onClick</code>添加事件处理函数，是否代表网页应用开发兜了一个大圈，最终回到了起点呢？</p><p>不是这样，JSX的<code>onClick</code>事件处理方式和HTML的<code>onclick</code>有很大不同。</p><p>即使现在，我们还是要说在HTML中直接使用<code>onclick</code>很不专业，原因如下：</p><ul><li><p><code>onclick</code>添加的事件处理函数是在全局环境下执行的，这污染了全局环境，很容易产生意料不到的后果</p></li><li><p>给很多Dom元素添加<code>click</code>事件，可能会影响网页的性能，毕竟，网页需要的事件处理函数越多，性能就会越低</p></li><li><p>对于使用<code>onclick</code>的Dom元素，如果要动态地从DOM树中删掉的话，需要把对应的事件处理器注销，假如忘了注销，就可能造成内存泄漏，这样的bug很难被发现</p></li></ul><p>上面说的这些问题，在JSX中都不存在。</p><p>首先，<code>onClick</code>挂载的每个函数，都可以控制在组建范围内，不会污染全局空间。</p><p>我们在JSX中看到一个组件使用了<code>onClick</code>，但并没有产生直接使用<code>onclick</code>的HTML，而是使用了事件委托（event delegation）的方式处理点击事件，无论有多少个<code>onClick</code>出现，其实最后都只在DOM树上添加了一个事件处理函数，挂在最顶层的DOM节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组建分配给特定函数，使用事件委托的性能当然要比为每个<code>onClick</code>都挂载一个事件处理函数要高。</p><p>因为React控制了组件的生命周期，在<code>unmount</code>的时候自然能够清除相关的所有事件处理函数，内存泄漏也不再是一个问题。</p><p>除了在组件中定义交互行为，我们还可以在React组件中定义样式，我们可以修改<code>ClickCounter.js</code>中的<code>render</code>函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> counterStyle = &#123;</span><br><span class="line">    margin: <span class="string">'16px'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;counterStyle&#125;&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.onClickButton&#125;&gt;Click Me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      Click Count: &lt;span id="clickCount"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在JavaScript代码中定义一个<code>counterStyle</code>对象，然后在JSX中赋值给顶层div的style属性，可以在网页中看到这个部分的margin真的变大了。</p><p>这样，React的组件可以把JavaScript、HTML和CSS的功能写在一个文件中，实现真正的组件封装。</p><hr><h3 id="三、分解React应用"><a href="#三、分解React应用" class="headerlink" title="三、分解React应用"></a>三、分解React应用</h3><p>前面我们提到过，React应用实际上依赖于一个很大很复杂的技术栈，我们使用<code>create-react-app</code>避免在一开始就费太多精力配置技术栈，不过现在是时候了解一下这个技术栈了。</p><p>我们启动React应用的命令是<code>npm start</code>，看看<code>package.json</code>中对<code>start</code>脚本的定义。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "react-scripts start",</span><br><span class="line">  "build": "react-scripts build",</span><br><span class="line">  "test": "react-scripts test --env=jsdom",</span><br><span class="line">  "eject": "react-scripts eject"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，start命令实际上是调用了react-scripts命令，<code>react-scripts</code>是<code>create-react-app</code>添加的一个npm包，所有的配置文件都藏在<code>node_modules/react-scripts</code>目录下，我们当然可以钻进这个目录去一探究竟，但是也可以使用eject方法来看清楚背后的原理。</p><p>这个eject（弹射）命令做的事情，就是把潜藏在<code>react-scripts</code>中的一系列技术栈配置都“弹射”到应用的顶层，然后我们就可以研究这些配置细节了，而且可以更灵活地定制应用的配置。</p><blockquote><p>eject命令是不可逆的，就好像战斗机飞行员选择“弹射”出驾驶舱，等于是放弃了这架战斗机，是不可能再飞回驾驶舱的。所以，当你执行eject之前，最好做一下备份。</p></blockquote><p>我们在命令行下执行下面的命令，完成“弹射”操作：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run eject</span><br></pre></td></tr></table></figure><p>这个命令会改变一些文件，也会添加一些文件。</p><p>当前目录下会增加两个目录，一个是scripts，另一个是config，同时，<code>package.json</code>文件中的scripts部分也发生了变化：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "node scripts/start.js",</span><br><span class="line">  "build": "node scripts/build.js",</span><br><span class="line">  "test": "node scripts/test.js --env=jsdom"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从此以后，start脚本将使用scripts目录下的<code>start.js</code>，而不是node_modules目录下的<code>react-scripts</code>，弹射成功，再也回不去了。</p><p>在config目录下的<code>webpack.config.dev.js</code>文件，定制的就是npm start所做的构造过程，其中有一段关于babel的定义：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test"</span>: /\.(js|jsx)$/,</span><br><span class="line">  <span class="attr">"include"</span>: paths.appSrc,</span><br><span class="line">  <span class="attr">"loader"</span>: <span class="string">"babel"</span>,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    // This is a feature of 'babel-loader' for webpack (not Babel itself).</span><br><span class="line">    // It enables caching results in ./node_modules/.cache/babel-loader/</span><br><span class="line">    // directory for faster rebuilds.</span><br><span class="line">    "cacheDirectory": true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的<code>paths.appSrc</code>的值就是<code>src</code>，所以这段配置的含义指的是所有以js或者jsx为扩展名的文件，都会由babel所处理。</p><p>并不是所有的浏览器都支持所有的ES6语法，但是有了babel，我们就可以不用顾忌太多，因为babel会把ES6语法的JavaScript代码转译为浏览器普遍支持的JavaScript代码，实际上，在React社区中，不使用ES6语法写代码才显得奇怪。</p><hr><h3 id="四、React的工作方式"><a href="#四、React的工作方式" class="headerlink" title="四、React的工作方式"></a>四、React的工作方式</h3><p>在继续深入学习React的其他知识之前，我们先就这个简单的<code>ClickCounter</code>组件思考一下React的工作方式，要了解一样东西的特点，最好的方法当然是拿这个东西和另一样东西做比较。我们就拿React和jQuery来比较。</p><h4 id="1-jQuery如何工作"><a href="#1-jQuery如何工作" class="headerlink" title="1. jQuery如何工作"></a>1. jQuery如何工作</h4><p>假设我们用jQuery来实现<code>ClickCounter</code>的功能，该怎么做呢？首先，我们要产生一个网页的HTML，写一个<code>index.html</code>文件如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"ClickMe"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        Click Count: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"clickCount"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./clickCounter.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实际产品中，产生这样的HTML可以用PHP、Java、Ruby或者任何一种服务器端语言和框架来做，也可以在浏览器中用Mustache、Hogan这样的模板来产生，这里我们只是把问题简化，直接书写HTML。</p><p>上面的HTML只是展示样式，并没有任何交互功能，现在我们用jQuery来实现交互功能，和jQuery的传统一样，我们把JavaScript写在一个独立的文件<code>clickCounter.js</code>中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#clickMe'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clickCounter = $(<span class="string">'#clickCount'</span>);</span><br><span class="line">    <span class="keyword">var</span> count = <span class="built_in">parseInt</span>(clickCounter.text(), <span class="number">10</span>);</span><br><span class="line">    clickCounter.text(count + <span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>用浏览器打开上面创造的<code>index.html</code>，可以看到实际效果和我们写的React应用一模一样，但是对比这两段程序可以看出差异。</p><p>在jQuery解决方案中，首先根据CSS规则找到id为<code>clickCount</code>的按钮，挂上一个匿名事件处理函数，在事件处理函数中，选中那个需要被修改的DOM元素，读取其中的文本值，加以修改，然后修改这个DOM元素。</p><p>选中一些DOM元素，然后对这些元素做一些操作，这是一种最容易理解的开发模式。jQuery的发明人John Resig就是发现了网页应用开发者的这种编程模式，才创造出了jQuery，其一问世就得到普遍认可，因为这种模式直观易懂。但是，对于庞大的项目，这种模式会造成代码结构复杂，难以维护，每个jQuery的使用者都会有这种体会。</p><h4 id="2-React的理念"><a href="#2-React的理念" class="headerlink" title="2. React的理念"></a>2. React的理念</h4><p>与jQuery不同，用React开发应用是另一种体验，我们回顾一下，用React开发的<code>ClickCounter</code>组件好像没有像jQuery那样做“选中一些DOM元素然后做一些事情”的动作。</p><p>打一个比方，React是一个聪明的建筑工人，而jQuery是一个比较傻的建筑工人，开发者你就是一个建筑的设计师，如果是jQuery这个建筑工人为你工作，你不得不事无巨细地告诉jQuery“如何去做”，要告诉他这面墙要拆掉重建，那面墙上要新开一个窗户。反之，如果是React这个建筑工人为你工作，你所要做的就是告诉这个工人“我想要什么样子”，只要把图纸递给React这个工人，他就会替你搞定一切，当然他不会把整个建筑拆掉重建，而是很聪明地把这次的图纸和上次的图纸做一个对比，发现不同之处，然后只去做适当的修改就完成任务了。</p><p>显而易见，React的工作方式把开发者从繁琐的操作中解放出来，开发者只需要着重“我想要显示什么”，而不用操心“怎样去做”。</p><p>这种新的思维方式，对于一个简单的例子也要编写不少代码，感觉像是用高射炮打蚊子，但是对于一个大型的项目，这种方式编写的代码会更容易管理，因为整个React应用要做的就是渲染，开发者关注的是渲染成什么样子，而不用关心如何实现增量渲染。</p><p>React的理念，归结为一个公式，就像下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UI = render(data)</span><br></pre></td></tr></table></figure><p>让我们来看看这个公示表达的含义，用户看到的界面（<code>UI</code>），应该是一个函数（在这里叫<code>render</code>）的执行结果，只接受数据（<code>data</code>）作为参数。这个函数是一个纯函数，所谓纯函数，指的是没有任何副作用，输出完全依赖于输入的函数，两次函数调用如果输入相同，得到的结果也绝对相同。如此一来，最终的用户界面，在<code>render</code>函数确定的情况下完全取决于输入数据。</p><p>对于开发者来说，重要的是区分开哪些属于<code>data</code>，哪些属于<code>render</code>，想要更新用户界面，要做的就是更新<code>data</code>，用户界面自然会做出响应，所以React实践的也是“响应式编程”（<code>Reactive Programming</code>）的思想，这也就是React为什么叫做React的原因。</p><h4 id="3-Virtual-DOM"><a href="#3-Virtual-DOM" class="headerlink" title="3. Virtual DOM"></a>3. Virtual DOM</h4><p>既然React应用就是通过重复渲染实现用户交互，我们可能会有一个疑虑：这样的重复渲染会不会效率太低了呢？毕竟，在jQuery的实现方式中，我们可以清楚地看到每次只有需要变化的那一个DOM元素被修改了；可是，在React的实现方式中，看起来每次render函数被调用，都要把整个组件重新绘制一次，这样看起来有点浪费。</p><p>事实并不是这样，React利用Virtual DOM，让每次渲染都重新渲染最少的DOM元素。</p><p>要了解Virtual DOM，就要先了解DOM，DOM是结构化文本的抽象表达形式，特定于Web环境中，这个结构化文本就是HTML文本，HTML中的每个元素都对应DOM中的某个节点，这样，因为HTML元素的逐级包含关系，DOM节点自然就构成了一个树形结构，称为DOM树。</p><p>浏览器为了渲染HTML格式的网页，会先将HTML文本解析以构建DOM树，然后根据DOM树渲染出用户看到的界面，当要改变界面内容的时候，就去改变DOM树上的节点。</p><p>Web前端开发关于性能优化有一个原则：尽量减少DOM操作。虽然DOM操作也只是一些简单的JavaScript语句，但是DOM操作会引起浏览器对网页进行重新布局，重新绘制，这就是一个比JavaScript语句执行慢很多的过程。</p><p>如果使用mustache或者hogan这样的模板工具，那就是生成HTML字符串塞到网页中，浏览器又要做一次解析产生新的DOM节点，然后替换DOM树上对应的子树部分，这个过程肯定效率不高。虽然JSX看起来很像是一个模板，但是最终会被Babel解析为一条条创建React组件或者HTML元素的语句，神奇之处在于，React并不是通过这些语句直接构建DOM树，而是首先构建Virtual DOM。</p><p>既然DOM树是对HTML的抽象，那Virtual DOM就是对DOM树的抽象。Virtual DOM不会触及浏览器的部分，只是存在于JavaScript空间的树形结构，每次自上而下渲染React组件时，会对比这一次产生的Virtual DOM和上一次渲染的Virtual DOM，对比就会发现差别，然后修改真正的DOM树时就只需要触及差别中的部分就行。</p><p>以<code>ClickCounter</code>为例，一开始点击计数为0，用户点击按钮让点击计数变成1，这一次重新渲染，React通过Virtual DOM的对比发现其实只是id为<code>clickCounter</code>的span元素中内容从0变成了1而已：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"clickCounter"</span>&gt;</span>&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React发现这次渲染要做的事情只是更换span元素的内容而已，其他DOM元素都不需要触及，于是执行类似下面的语句，就完成了任务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'clickCounter'</span>).innerHTML = <span class="string">"1"</span>;</span><br></pre></td></tr></table></figure><h4 id="4-React工作方式的优点"><a href="#4-React工作方式的优点" class="headerlink" title="4. React工作方式的优点"></a>4. React工作方式的优点</h4><p>毫无疑问，jQuery的方式直观易懂，对于初学者十分适用，但是当项目逐渐变得庞大时，用jQuery写出的代码往往互相纠缠，形成类似下图的状况，难以维护。</p><p><img src="/images/react-1/5.png" alt="jQuery方式造成的纠缠代码结构"></p><p>使用React的方式，就可以避免构建这样复杂的程序结构，无论何种事件，引发的都是React组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发者并不需要关心，程序的流程简化为如下方式。</p><p><img src="/images/react-1/6.png" alt="React的程序流程"></p><p>React利用函数式编程的思维来解决用户界面渲染的问题，最大的优势是开发者的效率会大大提高，开发出来的代码可维护性和可阅读性也大大增强。</p><p>React等于强制所有组件都按照这种由数据驱动渲染的模式来工作，无论应用的规模多大，都能让程序处于可控范围内。</p><hr><h3 id="五、本文小结"><a href="#五、本文小结" class="headerlink" title="五、本文小结"></a>五、本文小结</h3><p>在本文中，我们用<code>create-react-app</code>创造了一个简单的React应用，在一开始，我们就按照组件的思想来开发应用，React的主要理念之一就是基于组件来开发应用。</p><p>通过和同样功能的jQuery实现方式对比，我们了解了React的工作方式，React利用声明式的语法，让开发者专注于描述用户界面“显示成什么样子”，而不是重复思考“如何去显示”，这样可以大大提高开发效率，也让代码更加容易管理。</p><p>虽然React是通过重复渲染来实现动态更新效果，但是借助Virtual DOM技术，实际上这个过程并不牵涉太多的DOM操作，所以渲染效率很高。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="/resources/深入浅出React和Redux.pdf">《深入浅出React和Redux —— 程墨》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们先来只管认识React，对任何一种工具，只有使用才能够熟练掌握，React也不例外。通过对React快速上手，我们会解析React的工作原理，并通过与功能相同的jQuery程序对比，从而看出React的特点。&lt;/p&gt;
    
    </summary>
    
      <category term="React抄书笔记" scheme="http://www.xiaoleon.cn/categories/React%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.xiaoleon.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Web(5) HTTP与HTTPS</title>
    <link href="http://www.xiaoleon.cn/2018/03/02/web-5/"/>
    <id>http://www.xiaoleon.cn/2018/03/02/web-5/</id>
    <published>2018-03-02T02:15:50.000Z</published>
    <updated>2018-03-12T14:04:54.242Z</updated>
    
    <content type="html"><![CDATA[<p>超文本传输协议HTTP被用于Web浏览器和网站服务器之间传递信息，HTTP以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><a id="more"></a><p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h3 id="一、TCP-IP、HTTP、HTTPS"><a href="#一、TCP-IP、HTTP、HTTPS" class="headerlink" title="一、TCP/IP、HTTP、HTTPS"></a>一、TCP/IP、HTTP、HTTPS</h3><ul><li><p>TCP/IP：传输层协议，主要解决数据如何在网络中传输，Web服务器将HTTP封装好的文本信息，通过TCP/IP协议发送到网络上。</p></li><li><p>HTTP：应用层协议，用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p></li><li><p>HTTPS：以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p></li></ul><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><p>下面的图表显示OSI（Open System Interconnect）模型中的各项协议：</p><table><thead><tr><th>OSI层</th><th>协议名称</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP</td></tr><tr><td>表示层</td><td>XDR、ASN.1、SMB、AFP、NCP</td></tr><tr><td>会话层</td><td>ASAP、TLS、SSH、ISO 8327 / CCITT X.255、RPC、NetBIOS、ASP、Winsock、BSD sockets</td></tr><tr><td>传输层</td><td>TCP、UDP、RTP、SCTP、SPX、ATP、IL</td></tr><tr><td>网络层</td><td>IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25</td></tr><tr><td>数据链路层</td><td>以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP</td></tr><tr><td>物理层</td><td>线路、无线电、光钎、信鸽</td></tr></tbody></table><hr><h3 id="二、HTTP与HTTPS有什么区别"><a href="#二、HTTP与HTTPS有什么区别" class="headerlink" title="二、HTTP与HTTPS有什么区别"></a>二、HTTP与HTTPS有什么区别</h3><p>HTTP传输的数据都是未加密的，也就是明文的，因此使用HTTP传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTPS构建的可进行传输加密、身份认证的网络协议，要比HTTP安全。</p><p>HTTPS和HTTP的主要区别如下：</p><ul><li><p>1) HTTPS协议需要到CA申请证书，一般免费证书较少，因而需要一定费用</p></li><li><p>2) HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议</p></li><li><p>3) HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，HTTP是80，HTTPS是443</p></li><li><p>4) HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP构建的可进行加密传输、身份认证的网络协议，比HTTP更安全</p></li></ul><hr><h3 id="三、HTTP三次握手"><a href="#三、HTTP三次握手" class="headerlink" title="三、HTTP三次握手"></a>三、HTTP三次握手</h3><p><img src="/images/web-5/1.png" alt="HTTP三次握手时序图"></p><p>TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p><ul><li><p>1) 第一次握手：客户端发送syn包（syn=j）到服务器，并进入SYN_SEND状态，等待服务器确认</p></li><li><p>2) 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态</p></li><li><p>3) 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p></li></ul><hr><h3 id="四、HTTP四次挥手"><a href="#四、HTTP四次挥手" class="headerlink" title="四、HTTP四次挥手"></a>四、HTTP四次挥手</h3><p><img src="/images/web-5/2.png" alt="HTTP四次挥手时序图"></p><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>HTTP的关闭需要发送四个包，因此称为四次挥手（four-way handshake）。客户端或服务端均可主动发起挥手操作，在socket中，任何一方执行close()操作即可产生挥手操作。</p><ul><li><p>1) 客户端发送一个FIN，用来关闭客户端到服务端的数据传送</p></li><li><p>2) 服务端收到这个FIN，返回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号</p></li><li><p>3) 服务端关闭与客户端的连接，发送一个FIN到客户端</p></li><li><p>4) 客户端发挥ACK报文确认，并将确认序号设置为收到序号加1</p></li></ul><hr><h3 id="五、HTTPS的工作原理"><a href="#五、HTTPS的工作原理" class="headerlink" title="五、HTTPS的工作原理"></a>五、HTTPS的工作原理</h3><p><img src="/images/web-5/3.png" alt="HTTPS通信"></p><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><ul><li><p>1) 客户使用HTTPS的URL访问Web服务器，要求与Web服务器建立SSL连接</p></li><li><p>2) Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端</p></li><li><p>3) 客户端解析证书，首先验证公钥是否有效，比如颁发机构、过期时间等，如果发现异常，则会弹出警告框，提示证书存在问题</p></li><li><p>4) 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级</p></li><li><p>5) 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给Web服务器</p></li><li><p>6) Web服务器利用字迹的私钥解密出会话密钥</p></li><li><p>7) Web服务器利用会话密钥加密与客户端之间的通信</p></li></ul><p><img src="/images/web-5/4.png" alt="HTTPS连接时序图"></p><hr><h3 id="六、HTTPS的优点"><a href="#六、HTTPS的优点" class="headerlink" title="六、HTTPS的优点"></a>六、HTTPS的优点</h3><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是当前架构下最安全的解决方案，主要有以下几个好处：</p><ul><li><p>1) 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户端和服务器</p></li><li><p>2) HTTPS协议是由SSL+HTTP构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性</p></li><li><p>3) HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本</p></li><li><p>4) Google曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”</p></li></ul><hr><h3 id="七、HTTPS的缺点"><a href="#七、HTTPS的缺点" class="headerlink" title="七、HTTPS的缺点"></a>七、HTTPS的缺点</h3><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><ul><li><p>1) HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%-20%的耗电</p></li><li><p>2) HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响</p></li><li><p>3) SSL整数需要收费，功能越强大的整数费用越高，个人网站、小网站没有必要一般不会用</p></li><li><p>4) SSL整数通常需要绑定IP，不能再同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗</p></li><li><p>5) HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务供给、服务器劫持等方面几乎起不到什么作用。最关键的，SSL整数的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="https://www.cnblogs.com/wqhwe/p/5407468.html" target="_blank" rel="noopener">HTTP与HTTPS的区别</a></p></li><li><p><a href="https://www.cnblogs.com/lovesong/p/5186200.html" target="_blank" rel="noopener">HTTP与HTTPS握手的那些事</a></p></li><li><p><a href="https://www.cnblogs.com/Jessy/p/3535612.html" target="_blank" rel="noopener">TCP的三次握手（建立连接）和四次挥手（关闭连接）</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;超文本传输协议HTTP被用于Web浏览器和网站服务器之间传递信息，HTTP以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HTTP" scheme="http://www.xiaoleon.cn/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="http://www.xiaoleon.cn/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>其他(1) 软考论文经验</title>
    <link href="http://www.xiaoleon.cn/2018/03/01/ruankao-1/"/>
    <id>http://www.xiaoleon.cn/2018/03/01/ruankao-1/</id>
    <published>2018-03-01T05:43:29.000Z</published>
    <updated>2018-03-05T14:35:56.004Z</updated>
    
    <content type="html"><![CDATA[<p>17年下半年的信息系统项目管理师考试，前前后后间断复习了大概3个月，没想到最后一次过了，挺意外的。</p><a id="more"></a><p>由于上班比较忙，所以也没有很系统的进行相关复习，都是零碎时间看点真题，然后上信管网来看看案例分析。这里客观题和主观题就不作经验分享了，感觉自己能拿这个分数纯属巧合，主要介绍一下自己论文的一点经验。</p><h3 id="一、练字"><a href="#一、练字" class="headerlink" title="一、练字"></a>一、练字</h3><p>论文属于纯手写考试，评卷老师的第一感官便是我们的卷面整洁及清晰程度，我们至少应当做到字迹清晰工整，这样可以给评卷老师留下一个好的第一印象，同时节省评卷的时间。如果字迹优雅、布局工整，相信评卷老师也会从内心里当作是一副书法作品来阅读。</p><p>另外，我们需要做到在2个小时的考试时间内，保持字迹大体一致，减少评卷老师在字迹上的心理变化。从字迹的变化上能够很容易反映出考生的心理状态，比如没有提前做好论文的前期准备，就容易出现大量的划痕；或者后期时间不够了，容易出现心里焦躁，字迹越来越乱的情况。</p><p>我在写论文的时候，就出现了最后半小时发现时间不够用的情况，最后的500-600字由于时间特别赶，导致字迹开始越来越乱，最后写完大概只剩下了不到3分钟。从卷面上，能够很明显的感觉到我当时慌乱的心境，也是没有准备充分的体现。现在想想，如果提前有充足的准备，应该不至于在这方面出现差错，分数可能也会比当前的49要高一些吧。</p><hr><h3 id="二、提速"><a href="#二、提速" class="headerlink" title="二、提速"></a>二、提速</h3><p>论文考试是2个小时内，需要书写2500到3000字。如果没有经过提前练习，加上现在生活中提笔写字的机会接近于零，几乎是一个不可能完成的任务。因此，考前一定需要花上一段时间，每天练习写字速度，在保证文笔工整的前提下，尽量提高论文的行文速度。</p><p>这里给一个小建议，考前我们可以从网上下载一些模版论文，先完整地抄写几遍模板论文。这样可以计算出自己在完全不思考的情况下，写完一整篇论文的速度，然后再根据情况进行提速训练。</p><p>我考前大概抄写了9篇模板论文，取平均数的话，大概抄写完整篇文章需要1小时30分钟到1小时40分钟。也就是说，如果在考试过程中还需要构思，那思考时间最多只能控制在20分钟到30分钟内。这个时间可以说非常紧张，也正是因为在考试中，我还需要边写边思考后面的内容，所以才导致了最后的时间非常紧张。</p><hr><h3 id="三、模拟"><a href="#三、模拟" class="headerlink" title="三、模拟"></a>三、模拟</h3><p>由于论文考试需要书写在特定的答题纸上，因此我们可以利用这个答题纸的样式来进行提前练习。论文答题纸分为6页，摘要部分从第一页的中间到第二页的前几行，然后剩余的5页为正文部分。我们可以从信管网上下载答题纸模版pdf，然后打印出来，直接在上面抄写模板论文或书写准备的论文。</p><p>这样模拟练习后，我们就能够有个大概的概念，摘要第一部分应该写到哪一行，第二部分应该写到哪一行，总结的字数应该控制在多少。</p><p>我们把论文正文分为三大块：开头、正文、结尾。其中开头部分一般从第二页的前几行，书写到第三页的中间；正文部分从第三页的中间，书写到第五页的下方；结尾部分，从第五页的下方，书写到第六页的下方。</p><p>我们还可以划分时间节点，比如摘要大概花费20分钟，开头大概花费20分钟，正文大概花费60分钟，结尾大概花费20分钟。</p><p>这样经过模拟训练后，考场上我们就可以有条不紊的执行我们的考试规划，在指定时间和指定地点完整对应的书写工作。</p><hr><h3 id="四、模板"><a href="#四、模板" class="headerlink" title="四、模板"></a>四、模板</h3><p>由于信管考试论文的特殊性，9大类论点必考一题，使得我们可以针对这9项进行提前准备。</p><h4 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h4><p>摘要是整篇文章的内容浓缩，这里建议参考信管网或者各论坛的摘要写作指导，我建议在模拟练习中，将9大类的摘要都仔细思考并行文一遍，经过多次修改后，形成最后的模版。</p><p>考场上不太可能有足够的时间来思考摘要应该怎么写，时间是非常宝贵的，我们更应当花费时间去判断论题是否跟往年有所出入，如果题目要求与其他方面进行结合，应当怎么样在摘要模板中进行修改并点题。</p><p>可以说摘要是非常重要的，阅卷老师从摘要就能得出全文的第一印象，而且阅卷的特殊性，可能只有一两分钟的阅读时间，所以前期准备过程中需要好好斟酌。</p><p>我在考试过程中，发卷到开考前，思考了下论题是否和准备的模版有出入。开考后，直接落笔写摘要，大约10分钟写完摘要，把时间尽量多的留给正文部分。</p><h4 id="2-开头"><a href="#2-开头" class="headerlink" title="2. 开头"></a>2. 开头</h4><p>开头也是我们可以提前准备的部分，虽然9大类论题各不相同，但是论文要求我们与实际项目相结合，那么开头我们可以相对统一，比如介绍项目的背景、需求、技术等等，先提前准备好一个项目，把这个项目中涉及到的相关具体内容整理成文，同时借用一下网上模板论文中的一些好的语句进行串联，修改得到大约600-800字的开头。最后，多在准备过程中写几遍，把内容背下来，减少考试过程中的思考时间。</p><p>我在考试过程中，大约花了20分钟写论文开头，写到预先设计的第三页中间后，正好结束开头部分，开始写正文部分。</p><h4 id="3-正文"><a href="#3-正文" class="headerlink" title="3. 正文"></a>3. 正文</h4><p>正文是全文耗时最长，也最为重要的部分。这部分建议准备过程中，能够完整地把9大类论题，都思考成文一遍，考前再阅读记忆几次，这样考试过程中可以较为顺利的进行书写，从而减少构思的时间。</p><p>我在正文部分准备的不够充分，考前只思考和列举了9大类需要书写的提纲，以及能够用在这些提纲内的案例与项目结合点。在真正考试的时候，很明显的感觉到，有时候写完提纲要点，发现不知道具体的阐述内容应该如何落笔行文，还需要停下来花时间构思，这样非常浪费时间。</p><p>至于正文结构，建议采用如下格式（具体提纲忘了，请勿参考示例提纲）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">结合具体参与的项目，成本管理大概分为以下几点：</span><br><span class="line"></span><br><span class="line">1. 成本估算</span><br><span class="line"></span><br><span class="line">// 第一段，对成本估算的概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明是怎么完成成本估算过程的</span><br><span class="line"></span><br><span class="line">2. 成本预算</span><br><span class="line"></span><br><span class="line">// 第一段，对成本预算的概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明是怎么完成成本预算过程的</span><br><span class="line"></span><br><span class="line">3. 成本控制计划编制</span><br><span class="line"></span><br><span class="line">// 第一段，对成本控制计划编制进行概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明是怎么完成计划编制的</span><br><span class="line"></span><br><span class="line">4. 成本控制</span><br><span class="line"></span><br><span class="line">// 第一段，对成本控制进行概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明成本控制过程中出现了哪些问题，是怎么处理的</span><br></pre></td></tr></table></figure><p>我们可以提前准备一些项目中出现的案例，在合适的时机插入到正文当中，比如</p><ul><li><p>项目某个里程碑阶段，对项目的EV、AC、PV、SPI、CPI等进行分析，得出当前项目处于成本超支/节约，进度超前/落后，然后怎么样进行管理变化，使项目正常运行</p></li><li><p>项目某个时间点，有突发情况发生（项目组成员离开等等），我们是怎么应变调节的</p></li><li><p>项目计划编制中，我们采用了头脑风暴，技术专家评审等等方式，完成编制过程等等</p></li><li><p>分析项目的最长路径、总时差、自由时差等等</p></li></ul><h4 id="4-结尾"><a href="#4-结尾" class="headerlink" title="4. 结尾"></a>4. 结尾</h4><p>结尾部分同样可以采用提前准备的方式，9大类采用统一风格，当正文部分写到预定的区域后，即可开始书写提前准备的结尾部分。基本上按照既定的思路，写到文章结尾的时候，如果时间还比较充裕，那基本上离论文合格也就不远了。</p><p><img src="/images/ruankao-1/信管征文.jpg" alt="信管网获奖"></p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;17年下半年的信息系统项目管理师考试，前前后后间断复习了大概3个月，没想到最后一次过了，挺意外的。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://www.xiaoleon.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="软考" scheme="http://www.xiaoleon.cn/tags/%E8%BD%AF%E8%80%83/"/>
    
      <category term="信息系统项目管理师" scheme="http://www.xiaoleon.cn/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(11) 用Transition实现过渡动画</title>
    <link href="http://www.xiaoleon.cn/2018/02/27/css3-11/"/>
    <id>http://www.xiaoleon.cn/2018/02/27/css3-11/</id>
    <published>2018-02-27T08:09:00.000Z</published>
    <updated>2018-02-28T13:32:42.299Z</updated>
    
    <content type="html"><![CDATA[<p><code>transition</code>是网页上的过渡动画，在CSS3出现之前，网页上的动画大多是用flash实现的，但flash动画会产生很大的弊端，比如操作不便等等。</p><a id="more"></a><h3 id="一、定义和用法"><a href="#一、定义和用法" class="headerlink" title="一、定义和用法"></a>一、定义和用法</h3><p><code>transition</code>属性是一个简写属性，用于设置四个过渡属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">property</span> <span class="selector-tag">duration</span> <span class="selector-tag">timing-function</span> <span class="selector-tag">delay</span>;</span><br></pre></td></tr></table></figure><h4 id="1-transition-property"><a href="#1-transition-property" class="headerlink" title="1. transition-property"></a>1. <code>transition-property</code></h4><p><code>transition-property</code>属性规定应用过渡效果的CSS属性的名称。（当指定的CSS属性改变时，过渡效果将开始）。</p><blockquote><p>过渡效果通常在用户将鼠标指针浮动到元素上时发生。</p></blockquote><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>none</code></td><td>没有属性会获得过渡效果</td></tr><tr><td><code>all</code></td><td>所有属性都将获得过渡效果</td></tr><tr><td><code>property</code></td><td>定义应用过渡效果的css属性名称列表，列表以逗号分隔</td></tr></tbody></table><h4 id="2-transition-duration"><a href="#2-transition-duration" class="headerlink" title="2. transition-duration"></a>2. <code>transition-duration</code></h4><p><code>transition-duration</code>属性规定完成过渡效果需要多少秒或毫秒。需要始终设置该属性，否则时长为0，就不会产生过渡效果。</p><h4 id="3-transition-timing-function"><a href="#3-transition-timing-function" class="headerlink" title="3. transition-timing-function"></a>3. <code>transition-timing-function</code></h4><p><code>transition-timing-function</code>属性规定过渡效果的速度曲线。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>linear</code></td><td>规定以相同速度开始至结束的过渡效果（等于<code>cubic-bezier(0, 0, 1, 1)</code>）</td></tr><tr><td><code>ease</code></td><td>规定慢速开始，然后变快，然后慢速结束的过渡效果（<code>cubic-bezier(0.25, 0.1, 0.25, 1)</code>）</td></tr><tr><td><code>ease-in</code></td><td>规定以慢速开始的过渡效果（等于<code>cubic-bezier(0.42, 0.1, 1)</code>）</td></tr><tr><td><code>ease-out</code></td><td>规定以慢速结束的过渡效果（等于<code>cubic-bezier(0, 0, 0.58, 1)</code>）</td></tr><tr><td><code>ease-in-out</code></td><td>规定以慢速开始和结束的过渡效果（等于<code>cubic-bezier(0.42, 0, 0.58, 1)</code>）</td></tr><tr><td><code>cubic-bezier(n, n, n, n)</code></td><td>在<code>cubic-bezier</code>函数中定义自己的值。可能的值是0至1之间的数值</td></tr></tbody></table><h4 id="4-transition-delay"><a href="#4-transition-delay" class="headerlink" title="4. transition-delay"></a>4. <code>transition-delay</code></h4><p><code>transition-delay</code>规定在过渡效果开始之前需要等待的时间，以秒或毫秒计。</p><hr><h3 id="二、使用案例"><a href="#二、使用案例" class="headerlink" title="二、使用案例"></a>二、使用案例</h3><p>首先我们写一个字体出来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    div &#123;</span></span><br><span class="line"><span class="undefined">        width: 300px;</span></span><br><span class="line"><span class="undefined">        height: 100px;</span></span><br><span class="line"><span class="undefined">        padding-top: 20px;</span></span><br><span class="line"><span class="undefined">        line-height: 100px;</span></span><br><span class="line"><span class="undefined">        margin: 200px auto 0;</span></span><br><span class="line"><span class="undefined">        text-align: center;</span></span><br><span class="line"><span class="undefined">        font-size: 40px;</span></span><br><span class="line"><span class="undefined">        font-weight: bold;</span></span><br><span class="line"><span class="undefined">        font-family: '华文行楷';</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#ff6600</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>超炫火焰字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如图</p><p><img src="/images/css3-11/1.png" alt="效果图"></p><p>然后，我们给div加上hover效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">text-shadow</span>: 0<span class="selector-tag">px</span> 0<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> <span class="selector-id">#fff</span>,</span></span><br><span class="line"><span class="css">                0<span class="selector-tag">px</span> <span class="selector-tag">-3px</span> 3<span class="selector-tag">px</span> <span class="selector-id">#1eb</span>,</span></span><br><span class="line"><span class="css">                0<span class="selector-tag">px</span> <span class="selector-tag">-6px</span> 4<span class="selector-tag">px</span> <span class="selector-id">#01defd</span>,</span></span><br><span class="line"><span class="css">                0<span class="selector-tag">px</span> <span class="selector-tag">-12px</span> 6<span class="selector-tag">px</span> <span class="selector-id">#08f</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们会发现当鼠标进入这个div时，文字阴影一瞬间出现</p><p><img src="/images/css3-11/2.png" alt="效果图"></p><p>接着，我们修改hover效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    div &#123;</span></span><br><span class="line"><span class="undefined">        transition: all 1s liner 0s;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，鼠标进入div时，背景阴影经过了1s的过渡过程。</p><p><img src="/images/css3-11/3.gif" alt="效果图"></p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://blog.csdn.net/JianXingDeFeng/article/details/78708274" target="_blank" rel="noopener">用css3的transition实现过渡动画</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;transition&lt;/code&gt;是网页上的过渡动画，在CSS3出现之前，网页上的动画大多是用flash实现的，但flash动画会产生很大的弊端，比如操作不便等等。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS小技巧" scheme="http://www.xiaoleon.cn/categories/CSS%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="transition" scheme="http://www.xiaoleon.cn/tags/transition/"/>
    
  </entry>
  
  <entry>
    <title>算法(1) 斐波那契数列</title>
    <link href="http://www.xiaoleon.cn/2018/02/09/algorithm-1/"/>
    <id>http://www.xiaoleon.cn/2018/02/09/algorithm-1/</id>
    <published>2018-02-09T06:22:54.000Z</published>
    <updated>2018-05-15T12:09:54.565Z</updated>
    
    <content type="html"><![CDATA[<p>本文针对斐波那契数列的求值方法，分别采用递归法、尾递归法和迭代法进行分析，并提供其相关的代码实现。</p><a id="more"></a><p>今天看到公司笔试的一道算法题，题目如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">存在如下斐波那契数列： </span><br><span class="line"></span><br><span class="line">0, 1, 1, 2, 3, 5, 8, 13, 21...</span><br><span class="line"></span><br><span class="line">请编写函数，计算数列中第n项的值。</span><br></pre></td></tr></table></figure><h3 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h3><p>经过简单思考后，我们可以很容易的想到，可以采用递归的方式进行代码编写，因为第<code>n</code>项的值等于第<code>n-1</code>项和第<code>n-2</code>项的和，实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fib(n - <span class="number">2</span>) + Fib(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>.callee(n - <span class="number">1</span>) + <span class="built_in">arguments</span>.callee(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、尾递归"><a href="#二、尾递归" class="headerlink" title="二、尾递归"></a>二、尾递归</h3><p>然而，这种方式进行<code>n</code>值较大的计算时，非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（<code>stack overflow</code>）。这时，我们可以考虑采用<strong>尾递归</strong>的模式，实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fib</span>(<span class="params">n, ret1 = <span class="number">0</span>, ret2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> ret1;</span><br><span class="line">    <span class="keyword">return</span> Fib(n - <span class="number">1</span>, ret2, ret1 + ret2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过尾递归的方式，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。前面的代码需要保存<code>2n</code>个数据记录，复杂度<code>O(n)</code>。如果改成尾递归，只保留<code>3</code>个数据记录，复杂度<code>O(1)</code>。</p><p>尾递归实现的方式，在思路上采用了从前往后计算的方法，等效于使用了一个正向的<code>while</code>循环。而前面的递归采用的是从后往前倒推的方式。</p><h3 id="三、迭代法"><a href="#三、迭代法" class="headerlink" title="三、迭代法"></a>三、迭代法</h3><p>我们还可以采用一个迭代的方法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> [num1, num2, num3] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        [num3, num1, num2] = [num1 + num2, num2, num1 + num2];</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代实现的方法其实与尾递归是一个道理，迭代法比较通俗易懂，而且和尾递归比较起来，因为不用开辟栈空间，所以相对而言，迭代法的效率是最高的。</p><h3 id="四、生成器"><a href="#四、生成器" class="headerlink" title="四、生成器"></a>四、生成器</h3><p>学习了Generator生成器后，发现还可以采用生成器的方案来完成，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Fib</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [pre, cur] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        [pre, cur] = [cur, pre + cur];</span><br><span class="line">        <span class="keyword">yield</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> Fib()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://es6.ruanyifeng.com/#docs/function#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%EF%BC%9F" target="_blank" rel="noopener">ESMAScript 6 入门 —— 阮一峰</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文针对斐波那契数列的求值方法，分别采用递归法、尾递归法和迭代法进行分析，并提供其相关的代码实现。&lt;/p&gt;
    
    </summary>
    
      <category term="算法分析" scheme="http://www.xiaoleon.cn/categories/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
    
      <category term="斐波那契数列" scheme="http://www.xiaoleon.cn/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    
      <category term="递归" scheme="http://www.xiaoleon.cn/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="尾递归" scheme="http://www.xiaoleon.cn/tags/%E5%B0%BE%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>微信(1) 小程序初体验</title>
    <link href="http://www.xiaoleon.cn/2018/02/01/wx-1/"/>
    <id>http://www.xiaoleon.cn/2018/02/01/wx-1/</id>
    <published>2018-02-01T07:50:13.000Z</published>
    <updated>2018-02-02T12:48:52.132Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开。这也体现了“用完即走”的理念，用户无需担心安装应用过多的问题。应用将无处不在，随时可用，但又无须安装卸载。</p><a id="more"></a><p>本文对微信小程序的架构进行了简要的介绍，让我们尽可能对小程序有个全局的认知，包括小程序的框架、目录结构、开发步骤等等。</p><p>小程序的开发实际上就是不同页面的展示（视图），以及实现“页面上用户交互事件”、“页面间切换逻辑”、“数据存储及网络调用”等事务和逻辑处理的过程。</p><hr><h3 id="一、小程序执行的生命周期"><a href="#一、小程序执行的生命周期" class="headerlink" title="一、小程序执行的生命周期"></a>一、小程序执行的生命周期</h3><p>一个完整的小程序执行的生命周期如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.onLaunch -&gt; app.onShow -&gt; page1.onLoad -&gt; page1.onShow -&gt; page1.onReady</span><br><span class="line">(打开程序，第一个页面page1加载完成)</span><br><span class="line">-&gt; page1.onHide -&gt; page2.onLoad -&gt; page2.onShow -&gt; page2.onReady</span><br><span class="line">(从第一个页面新打开page2)</span><br><span class="line">-&gt; page2.onUnload -&gt; page1.onShow -&gt; ... -&gt; app.onUnload</span><br><span class="line">(关闭page2，返回page1，...退出小程序)</span><br></pre></td></tr></table></figure><p>一个page的生命周期从<code>onLoad</code>开始，整个生命周期内<code>onLoad</code>、<code>onReady</code>、<code>onUnload</code>这三个事件仅执行一次，而<code>onHide</code>和<code>onShow</code>在每次页面隐藏和显示时都会触发。当用户手动触发退出时，小程序仅触发<code>app.onHide</code>，下次进入小程序时会触发<code>app.onShow</code>以及当前<code>page.onShow</code>。仅当小程序在后台运行超过一定时间未被唤醒、或者用户手动在小程序的控制栏里点击退出程序、或者小程序内存占用过大被关闭时，小程序将被销毁，会触发<code>app.onUnload</code>事件。</p><hr><h3 id="二、小程序的线程架构"><a href="#二、小程序的线程架构" class="headerlink" title="二、小程序的线程架构"></a>二、小程序的线程架构</h3><p>每个小程序分为两个线程，<code>view</code>和<code>appServer</code>。其中<code>view</code>负责解析渲染页面（<code>wxml</code>和<code>wxss</code>），而<code>appServer</code>线程负责运行<code>js</code>。<code>appServer</code>线程运行在<code>jsCore</code>中（安卓下运行在<code>X5</code>中，开发工具中运行在<code>nwjs</code>中）。由于js不跑在<code>web-view</code>里，就不能直接操纵DOM和BOM，这就是小程序没有window全局变量的原因。</p><ul><li><p>view线程</p><p>  wxss + wxml</p><p>  ios：safari</p><p>  Android：X5浏览器</p><p>  开发工具：chrome</p></li><li><p>appServer线程</p><p>  JS</p><p>  ios：JavaScriptCore</p><p>  Android：X5内核</p><p>  开发工具：nwjs</p></li></ul><hr><h3 id="三、小程序开发步骤"><a href="#三、小程序开发步骤" class="headerlink" title="三、小程序开发步骤"></a>三、小程序开发步骤</h3><p>理解小程序的线程架构后，我们可以归纳出一个小程序开发的主要步骤，涉及两大步骤：</p><ul><li><p>创建小程序实例（定义、配置及页面执行关联）。即编写3个app前缀的文件，它们共同描述了整个小程序主体逻辑、生命周期及页面构成、样式等。小程序实例将由<code>appServer</code>线程执行。</p></li><li><p>创建页面（页面结构和事务处理逻辑）。在小程序中一个完整的页面（page）是由<code>.js</code>、<code>.json</code>、<code>.wxml</code>、<code>.wxss</code>这四个文件组成，每个界面<code>.js</code>和<code>.wxml</code>是必选项，其他两项是可选项。小程序页面由<code>view</code>线程执行。</p></li></ul><hr><h3 id="四、MINA框架"><a href="#四、MINA框架" class="headerlink" title="四、MINA框架"></a>四、MINA框架</h3><p>微信团队为小程序提供的框架命名为MINA应用框架。MINA框架通过封装微信客户端提供的文件系统、网络通信、任务管理、数据安全等基础功能，对上层提供一整套JavaScript API，让开发者能够非常方便地使用微信客户端提供的各种基础功能与能力，快速构建一个应用。</p><p>小程序框架示意图如下</p><p><img src="/images/wx-1/mina.jpg" alt="小程序MINA框架示意图"></p><p>通过框架图我们可以看到两大部分：在页面视图层，wxml是MINA提供的一套类似html标签的语言以及一系列基础组件。开发者使用wxml文件来搭建页面的基本视图结构，使用wxss文件来控制页面的展现样式。AppService应用逻辑层时MINA的服务中心，由微信客户端启用异步线程单独加载运行。页面渲染所需的数据、页面交互处理逻辑都在AppService中实现。MINA框架中的AppService使用JavaScript来编写交互逻辑、网络请求、数据处理，但不能使用JavaScript中的DOM操作。小程序中的各个页面可以通过AppService实现数据管理、网络通信、应用生命周期管理和页面路由。</p><p>MINA框架为页面组件提供了<code>bindtap</code>、<code>bindtouchstart</code>等事件监听相关的属性，来与AppService中的事件处理函数绑定在一起，实现页面向AppService层同步用户交互数据。MINA框架同时提供了很多方法将AppService中的数据与页面进行单向绑定，当AppService中的数据变更时，会主动触发对应页面组件的重新渲染。MINA使用<code>virtual-dom</code>技术，加快了页面的渲染效率。</p><p>框架的核心是一个响应的数据绑定系统，它让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。我们通过下面的例子来看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- This is our View --&gt;</span><br><span class="line">&lt;view&gt; Hello &#123;&#123; name &#125;&#125;!&lt;/view&gt;</span><br><span class="line">&lt;button bindtap=&quot;changeName&quot;&gt;Click Me!&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">// This is out App Service</span><br><span class="line">// This is our data.</span><br><span class="line">var helloData = &#123;</span><br><span class="line">    name: &apos;WeChat&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">    data: helloData,</span><br><span class="line">    changeName: function(e) &#123;</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">            name: &apos;MINA&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>开发者通过框架将逻辑层数据中的<code>name</code>与视图层的<code>name</code>进行了绑定，所以在页面一打开的时候会显示“<code>Hello WeChat!</code>”。</p><p>当点击按钮的时候，视图层会发送<code>changeName</code>的事件给逻辑层，逻辑层找到对应的事件处理函数。</p><p>逻辑层执行了<code>setData</code>的操作，将<code>name</code>从<code>WeChat</code>变为<code>MINA</code>，因为该数据和视图层已经绑定了，从而视图层会自动改变为“<code>Hello MINA!</code>”。</p><p>微信小程序不仅在底层架构的运行机制上做了大量的优化，还在重功能（如page切换、tab切换、多媒体、网络连接等）上使用接近于native的组件承载。</p><p>综上所述，微信小程序MINA有着接近原生App的运行速度，做了大量的框架层面的优化设计，对Android端和IOS端做出了高度一致的呈现，并且准备了完备的开发和调试工具。</p><hr><h3 id="五、逻辑层"><a href="#五、逻辑层" class="headerlink" title="五、逻辑层"></a>五、逻辑层</h3><p>对于微信小程序而言，逻辑层就是所有<code>.js</code>脚本文件的集合。微信小程序在逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。</p><p>微信小程序开发框架的逻辑层是由JavaScript编写，在JavaScript的基础上，微信团队做了一些适当的修改，以便更高效地开发小程序。主要的修改包括：</p><ul><li><p>增加<code>app</code>和<code>page</code>方法，进行程序和页面的注册</p></li><li><p>提供丰富的API，如扫一扫、支付等微信特有能力</p></li><li><p>每个页面有独立的作用域，并提供模块化能力</p></li></ul><p>小程序逻辑层由js编写，但并非运行在浏览器中，所以JavaScript在Web中的一些能力都将无法使用，比如<code>document</code>、<code>window</code>等，这也给我们的开发带来相应的挑战。</p><p>开发者编写的所有代码最终将会打包成一份JavaScript，并在小程序启动时运行，直到小程序销毁。这类似于ServiceWorker或Webpack，所以逻辑层也称之为AppService。</p><hr><h3 id="六、视图层"><a href="#六、视图层" class="headerlink" title="六、视图层"></a>六、视图层</h3><p>框架的视图层由WXML（WeiXin Markup Language）与WXSS（WeiXin Style Sheet）编写，由组件来进行展示。对于微信小程序而言，视图层就是所有的<code>.wxml</code>文件与<code>.wxss</code>文件的集合：</p><ul><li><p><code>.wxml</code>文件用于描述页面的结构</p></li><li><p><code>.wxss</code>文件用于描述页面的样式</p></li></ul><p>微信小程序在逻辑层将数据进行处理后发送给视图层展现出来，同时接受视图层的事件反馈。</p><p>视图层以给定的样式展现数据并反馈给逻辑层，而数据展现是以组件来进行的。组件（Component）是视图的基本组成单元。</p><hr><h3 id="七、数据层"><a href="#七、数据层" class="headerlink" title="七、数据层"></a>七、数据层</h3><p>数据层包括临时数据或缓存、文件存储、网络存储与调用。</p><h4 id="1-页面临时数据或缓存"><a href="#1-页面临时数据或缓存" class="headerlink" title="1. 页面临时数据或缓存"></a>1. 页面临时数据或缓存</h4><p>在<code>Page()</code>中，我们要使用<code>setData</code>函数来将数据从逻辑层发送到视图层，同时改变对应的<code>this.data</code>的值。</p><p><strong>注意</strong></p><ul><li><p>直接修改<code>this.data</code>无效，无法改变页面的状态，还会造成数据不一致</p></li><li><p>单次设置的数据不能超过1024KB，请尽量避免一次设置过多的数据</p></li></ul><p><code>setData()</code>函数的参数接受一个对象。以<code>key</code>，<code>value</code>的形式表示将<code>this.data</code>中的<code>key</code>对应的值改变成<code>value</code>。其中<code>key</code>可以非常灵活，包括以数据路径的形式给出，如<code>array[2].message</code>，<code>a.b.c.d</code>，并且无须在<code>this.data</code>中预先定义。</p><h4 id="2-文件存储（本地存储）"><a href="#2-文件存储（本地存储）" class="headerlink" title="2. 文件存储（本地存储）"></a>2. 文件存储（本地存储）</h4><p>使用数据API接口，如下所示：</p><ul><li><p><code>wx.getStorage</code>：获取本地数据缓存</p></li><li><p><code>wx.setStorage</code>：设置本地数据缓存</p></li><li><p><code>wx.clearStorage</code>：清理本地数据缓存</p></li></ul><h4 id="3-网络存储或调用"><a href="#3-网络存储或调用" class="headerlink" title="3. 网络存储或调用"></a>3. 网络存储或调用</h4><p>上传或下载文件API接口如下：</p><ul><li><p><code>wx.request</code>：发起网络请求</p></li><li><p><code>wx.uploadFile</code>：上传文件</p></li><li><p><code>wx.downloadFile</code>：下载文件</p></li></ul><p>调用URL的API接口如下：</p><ul><li><p><code>wx.navigateTo</code>：新窗口打开页面</p></li><li><p><code>wx.redirectTo</code>：原窗口打开页面</p></li></ul><hr><h3 id="八、小程序加载运行"><a href="#八、小程序加载运行" class="headerlink" title="八、小程序加载运行"></a>八、小程序加载运行</h3><p>整个微信小程序、用户使用加载的流程示意图如下所示：</p><p><img src="/images/wx-1/1.png" alt="小程序发布与运行加载的流程"></p><p>小程序通过微信团队审核发布后，会同步到微信云端。最终用户通过某个入口，关注到该小程序。第一次运行时要经过短暂的代码下载过程（将所有资源下载到本地），即可在用户的微信中运行。</p><p>小程序在用户的微信中启动，相当于开启一个<code>webview</code>，这与HTML5不一样，在一定的时间内除非手动关闭，即使返回打开另一个小程序，原来的小程序也一直以后台的形式运行在内存里，即在后台运行。</p><p>小程序的版本更新将在启动时进行。首先与微信客户端版本进行对比是否有新版本，若有则小程序更新后再运行；否则，直接使用本地资源运行。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《小程序，巧应用（微信小程序开发实战）——熊普江 谢宇华》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开。这也体现了“用完即走”的理念，用户无需担心安装应用过多的问题。应用将无处不在，随时可用，但又无须安装卸载。&lt;/p&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="http://www.xiaoleon.cn/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://www.xiaoleon.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="MINA" scheme="http://www.xiaoleon.cn/tags/MINA/"/>
    
  </entry>
  
  <entry>
    <title>Web(4) Nginx设置动态Proxy_Pass</title>
    <link href="http://www.xiaoleon.cn/2018/02/01/web-4/"/>
    <id>http://www.xiaoleon.cn/2018/02/01/web-4/</id>
    <published>2018-02-01T02:48:29.000Z</published>
    <updated>2018-02-01T12:41:24.418Z</updated>
    
    <content type="html"><![CDATA[<p>前端开发过程中，我们为了避免与后端进行接口联调时反复修改请求地址，通常会采用服务器地址相对路径的方法，以<code>../rest/api/</code>的模式请求前端文件所在服务器的<code>http://192.168.1.100/rest/api</code>接口。这样可以规避开发阶段（<code>develop</code>）和生产阶段（<code>production</code>）代码不一致的问题，但是在接口联调阶段（<code>debug</code>），特别是前后端由不同的人开发的情况下，则需要使用代理服务器进行转发。</p><a id="more"></a><hr><h3 id="一、问题所在"><a href="#一、问题所在" class="headerlink" title="一、问题所在"></a>一、问题所在</h3><p>通常情况下我们的nginx配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest/api/ &#123;</span><br><span class="line">        proxy_pass  http://192.168.1.100/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接口复杂的情况下，我们的<code>location</code>匹配地址可能会出现较多个。而且因为工作需要，我们可能会同时与多个后台开发者进行接口联调，那么可能会出现如下的nginx配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest/api/ &#123;</span><br><span class="line">        proxy_pass  http://192.168.1.100/rest/api/;</span><br><span class="line">        #proxy_pass  http://192.168.1.101/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest2/api2/ &#123;</span><br><span class="line">        proxy_pass  http://192.168.1.100/rest2/api2/;</span><br><span class="line">        #proxy_pass  http://192.168.1.101/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest3/api3/ &#123;</span><br><span class="line">        proxy_pass  http://192.168.1.100/rest3/api3/;</span><br><span class="line">        #proxy_pass  http://192.168.1.101/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、修改方法"><a href="#二、修改方法" class="headerlink" title="二、修改方法"></a>二、修改方法</h3><p>为了工作方便，我们可能会将不同后台开发人员的地址以注释的方式记录在nginx配置文件内，需要切换后台服务器时，修改配置项中的注释内容，然后执行<code>nginx -s reload</code>来重启nginx服务。</p><p>那么，既然配置文件中有大量的重复地址信息，比如<code>http://192.168.1.100</code>，我们是不是可以把它提取出来作为nginx变量呢？然后<code>proxy_pass</code>读取它，这样在修改文件时只需要修改一个地方即可。</p><p>按照如下方式进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    set $host &apos;192.168.1.100&apos;;</span><br><span class="line">    #set $host &apos;192.168.1.101&apos;;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest/api/ &#123;</span><br><span class="line">        proxy_pass  http://$host/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest2/api2/ &#123;</span><br><span class="line">        proxy_pass  http://$host/rest2/api2/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest3/api3/ &#123;</span><br><span class="line">        proxy_pass  http://$host/rest3/api3/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务后，<strong>nginx不报错，但是代理无效</strong>，无法访问。接着使用<code>geo</code>、<code>map</code>，<strong>均无法正常进行代理转发</strong>。</p><p>最后发现可以使用<code>upstream</code>模式实现此项功能，修改后的配置文件如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">upstream host &#123;</span><br><span class="line">    server  192.168.1.100;</span><br><span class="line">    #server  192.168.1.101;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest/api/ &#123;</span><br><span class="line">        proxy_pass  http://host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest2/api2/ &#123;</span><br><span class="line">        proxy_pass  http://host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest3/api3/ &#123;</span><br><span class="line">        proxy_pass  http://host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次精简一点，采用正则匹配的方式进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">upstream host &#123;</span><br><span class="line">    server  192.168.1.100;</span><br><span class="line">    #server  192.168.1.101;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ /rest(.*)/api(.*)/ &#123;</span><br><span class="line">        rewrite /rest(.*)/api(.*)/ /rest$1/api$2/ break;</span><br><span class="line">        proxy_pass  http://host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样采用正则匹配方式后，不仅可以匹配原有的<code>/rest1/api1/</code>、<code>/rest2/api2/</code>、<code>/rest3/api3/</code>，还可以匹配诸如<code>/project/rest1/api1/</code>等等前面含有项目文件路径的<code>location</code>。</p><p>等后期有时间，再研究一下nginx的<code>rewrite</code>、<code>upstream</code>详细使用方法。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="http://blog.csdn.net/a19860903/article/details/49914131" target="_blank" rel="noopener">proxy_set_header设置Host为$proxy_host，$host与$local_host的区别</a></p></li><li><p><a href="https://www.cnblogs.com/luxianghao/p/6807081.html" target="_blank" rel="noopener">Nginx中的proxy_pass和rewrite</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端开发过程中，我们为了避免与后端进行接口联调时反复修改请求地址，通常会采用服务器地址相对路径的方法，以&lt;code&gt;../rest/api/&lt;/code&gt;的模式请求前端文件所在服务器的&lt;code&gt;http://192.168.1.100/rest/api&lt;/code&gt;接口。这样可以规避开发阶段（&lt;code&gt;develop&lt;/code&gt;）和生产阶段（&lt;code&gt;production&lt;/code&gt;）代码不一致的问题，但是在接口联调阶段（&lt;code&gt;debug&lt;/code&gt;），特别是前后端由不同的人开发的情况下，则需要使用代理服务器进行转发。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Nginx配置" scheme="http://www.xiaoleon.cn/tags/Nginx%E9%85%8D%E7%BD%AE/"/>
    
      <category term="proxy_pass" scheme="http://www.xiaoleon.cn/tags/proxy-pass/"/>
    
  </entry>
  
  <entry>
    <title>Web(3) GraphQL深入理解</title>
    <link href="http://www.xiaoleon.cn/2018/01/31/web-3/"/>
    <id>http://www.xiaoleon.cn/2018/01/31/web-3/</id>
    <published>2018-01-31T03:44:38.000Z</published>
    <updated>2018-03-12T14:11:22.827Z</updated>
    
    <content type="html"><![CDATA[<p>在前一篇文章中我们对GraphQL有了基础的了解，我们直到GraphQL使用<code>Schema</code>来描述数据，并通过指定和实现GraphQL规范定义了支持<code>Schema</code>查询的<code>DSQL （Domain Specific Query Language，领域特定查询语言）</code>。<code>Schema</code>帮助将复杂的业务模型数据抽象拆分成细粒度的基础数据结构，而<code>DSQL</code>的实现则赋予了前端开发者自由组织和定制请求数据的能力。</p><a id="more"></a><p>如果以一张图来表示的话，可以将GraphQL看做一条以<strong>通用基础业务数据模型</strong>为基础、将传统后端服务和前端页面紧密且自由地联系在一起的纽带。</p><p><img src="/images/web-3/1.png" alt="GraphQL"></p><p>为什么GraphQL的<code>Schema</code>能够表示出服务器所支持的复杂业务模型数据，GraphQL的Query又是怎样赋予前端开发者对数据的定制能力，本文将通过分析和理解GraphQL的设计来解答这些问题。</p><hr><h3 id="一、GraphQL的设计"><a href="#一、GraphQL的设计" class="headerlink" title="一、GraphQL的设计"></a>一、GraphQL的设计</h3><p>GraphQL由以下组件构成</p><ul><li><p>类型系统（<code>Type System</code>）</p></li><li><p>查询语言（<code>Query Language</code>）</p></li><li><p>执行语义（<code>Execution Semantics</code>）</p></li><li><p>静态验证（<code>Static Validation</code>）</p></li><li><p>类型检查（<code>Type Introspection</code>）</p></li></ul><p>作为将数据模型和具体接口实现解耦的<code>DSL</code>，GraphQL的基础组件，也是它最重要的组件之一就是类型系统。</p><hr><h3 id="二、类型系统"><a href="#二、类型系统" class="headerlink" title="二、类型系统"></a>二、类型系统</h3><p>可以将GraphQL的类型系统分为标量类型（<code>Scalar Types</code>，标量类型）和其他高级数据类型，标量类型即可以表示最细粒度数据结构的数据类型，可以和JavaScript的原始类型对应。</p><p>GraphQL规范目前规定支持的标量类型有</p><ul><li><p><code>Int</code>：整数，对应JavaScript的<code>Number</code></p></li><li><p><code>Float</code>：浮点数，对应JavaScript的<code>Number</code></p></li><li><p><code>String</code>：字符串，对应JavaScript的<code>String</code></p></li><li><p><code>Boolean</code>：布尔值，对应JavaScript的<code>Boolean</code></p></li><li><p><code>ID</code>：ID值，是一个序列化后值唯一的字符串，可以视作对应ES6新增的<code>Symbol</code></p></li></ul><p>其他高级数据类型包括</p><h4 id="1-对象（Object）"><a href="#1-对象（Object）" class="headerlink" title="1. 对象（Object）"></a>1. 对象（Object）</h4><p>用于描述层级或者树形数据结构。对于树形数据结构来说，叶子字段的类型都是标量数据类型。几乎所有的GraphQL类型都是对象类型。<code>Object</code>类型有一个<code>name</code>字段，以及一个很重要的<code>fields</code>字段。<code>fields</code>字段可以描述出一个完整的数据结构。例如一个表示地址数据机构的GraphQL对象为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AddressType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'Address'</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">        street: &#123;</span><br><span class="line">            type: GraphQLString</span><br><span class="line">        &#125;,</span><br><span class="line">        number: &#123;</span><br><span class="line">            type: GraphQLInt</span><br><span class="line">        &#125;,</span><br><span class="line">        formatted: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            resolve(obj) &#123;</span><br><span class="line">                <span class="keyword">return</span> obj.name + <span class="string">' '</span> + obj.street;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-接口（Interface）"><a href="#2-接口（Interface）" class="headerlink" title="2. 接口（Interface）"></a>2. 接口（Interface）</h4><p>接口用于描述多个类型的通用字段，例如一个表示实体数据结构的GraphQL接口为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EntityType = <span class="keyword">new</span> GraphQLInterfaceType(&#123;</span><br><span class="line">    name: <span class="string">'Entity'</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">        name: &#123;</span><br><span class="line">            type: GraphQLString</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-联合（Union）"><a href="#3-联合（Union）" class="headerlink" title="3. 联合（Union）"></a>3. 联合（Union）</h4><p>联合类型用于描述某个字段能够支持的所有返回类型以及具体请求真正的返回类型，例如一个表示宠物（可以是猫或者狗）的GraphQL联合类型为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PetType = <span class="keyword">new</span> GraphQLUnionType(&#123;</span><br><span class="line">    name: <span class="string">'Pet'</span>,</span><br><span class="line">    types: [DogType, CatType],</span><br><span class="line">    resolveType(value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="keyword">return</span> DogType;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            <span class="keyword">return</span> CatType;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-枚举（Enum）"><a href="#4-枚举（Enum）" class="headerlink" title="4. 枚举（Enum）"></a>4. 枚举（Enum）</h4><p>用于表示可枚举数据结构的类型，例如表示RGB色值的GraphQL枚举类型为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RGBType = <span class="keyword">new</span> GraphQLEnumType(&#123;</span><br><span class="line">    name: <span class="string">'RGB'</span>,</span><br><span class="line">    values: &#123;</span><br><span class="line">        RED: &#123;</span><br><span class="line">            value: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        GREEN: &#123;</span><br><span class="line">            value: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        BLUE: &#123;</span><br><span class="line">            value: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="5-输入对象（Input-Object）"><a href="#5-输入对象（Input-Object）" class="headerlink" title="5. 输入对象（Input Object）"></a>5. 输入对象（Input Object）</h4><p>是为了查询（<code>query</code>）而定义的数据类型，不直接重用<code>Object</code>类型是因为<code>Object</code>的字段可能存在循环引用，或者字段引用了不能作为查询输入对象的接口和联合类型。参考实现中的<code>Input Object</code>的定义代码为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type GraphQLInputType = </span><br><span class="line">    GraphQLScalarType |</span><br><span class="line">    GraphQLEnumType |</span><br><span class="line">    GraphQLInputObjectType |</span><br><span class="line">    GraphQLList&lt;GraphQLInputType&gt; |</span><br><span class="line">    GraphQLNonNull&lt;</span><br><span class="line">        GraphQLScalarType |</span><br><span class="line">        GraphQLEnumType |</span><br><span class="line">        GraphQLInputObjectType |</span><br><span class="line">        GraphQLList&lt;GraphQLInputType&gt;</span><br><span class="line">    &gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isInputType</span>(<span class="params">type: ?GraphQLType</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> namedType = getNamedType(type);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        namedType <span class="keyword">instanceof</span> GraphQLScalarType ||</span><br><span class="line">        namedType <span class="keyword">instanceof</span> GraphQLEnumType ||</span><br><span class="line">        namedType <span class="keyword">instanceof</span> GraphQLInputObjectType</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>Object</code>、<code>Interface</code>和<code>Union</code>三种类型是不能作为输入对象类型的。</p><h4 id="6-列表（List）"><a href="#6-列表（List）" class="headerlink" title="6. 列表（List）"></a>6. 列表（List）</h4><p>列表是其它类型的封装，通常用于对象字段的描述。例如下面<code>PersonType</code>类型数据的<code>parents</code>和<code>children</code>字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PersonType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'Person'</span>,</span><br><span class="line">    fields: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">        parents: &#123;</span><br><span class="line">            type: <span class="keyword">new</span> GraphQLList(Person)</span><br><span class="line">        &#125;,</span><br><span class="line">        children: &#123;</span><br><span class="line">            type: <span class="keyword">new</span> GraphQLList(Person)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="7-不能为Null（Non-Null）"><a href="#7-不能为Null（Non-Null）" class="headerlink" title="7. 不能为Null（Non-Null）"></a>7. 不能为Null（Non-Null）</h4><p><code>Non-Null</code>强制类型的值不能为<code>null</code>，并且在请求出错时一定会报错。可以用于必须保证值不能为<code>null</code>的字段。例如数据库的id字段不能为<code>null</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RowType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'Row'</span>,</span><br><span class="line">    fields: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">        id: &#123;</span><br><span class="line">            type: <span class="keyword">new</span> GraphQLNonNull(GraphQLString)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>还有一种重要的数据类型，即<code>schema</code>类型，它描述了后端服务器能够提供的数据支持。</p><hr><h3 id="三、查询语言"><a href="#三、查询语言" class="headerlink" title="三、查询语言"></a>三、查询语言</h3><p>类型系统对应我们开头提到的<code>Schema</code>，是对服务器端数据的描述，而查询语言则解耦了前端开发者与后端接口的依赖。前端开发者利用查询语言可以自由地组织和定制系统能够提供的业务数据。</p><p>GraphQL的一个查询请求被称为一份<code>query</code>文档（<code>query document</code>），即GraphQL服务能够解析验证并执行的一串请求字符串。<code>query</code>由操作（<code>Operation</code>）和片段（<code>Fragments</code>）组成。一个<code>query</code>可以包含多个操作和片段。只有包含操作的<code>query</code>才会被GraphQL服务执行。但是不包含操作，只包含<code>query</code>也会被GraphQL服务解析验证，这样一份片段就可以在多个<code>query</code>文档内使用。</p><p>只包含一个操作的<code>query</code>可以不带操作名称或者使用简写形式（即<code>query</code>关键字加名）。<code>query</code>包含多个操作时，所有操作都必须带上名称。</p><h4 id="1-操作（Operation）"><a href="#1-操作（Operation）" class="headerlink" title="1. 操作（Operation）"></a>1. 操作（Operation）</h4><p>GraphQL规范支持两种操作</p><ul><li><p><code>query</code>：仅获取数据（<code>fetch</code>）的只读请求</p></li><li><p><code>mutation</code>：获取数据后还有写操作的请求</p></li></ul><p>在官方提供的参考实现中我们会发现还有一种操作<code>subscription</code>，这是为了处理订阅更新这种比较复杂的实时数据更新场景而设计的操作，不过目前这种操作还处于试验阶段，不建议在生产环境使用。</p><p>查询请求的模型可以用下面的图来表示</p><p><img src="/images/web-3/2.svg" alt="查询请求模型"></p><h4 id="2-选择集合（Selection-Sets）"><a href="#2-选择集合（Selection-Sets）" class="headerlink" title="2. 选择集合（Selection Sets）"></a>2. 选择集合（Selection Sets）</h4><p>选择集合表示当前选中的数据内容，格式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Field               // 字段名</span><br><span class="line">    FragmentSpread      // 片段展开</span><br><span class="line">    InlineFragment      // 内联片段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-字段（Field）"><a href="#3-字段（Field）" class="headerlink" title="3. 字段（Field）"></a>3. 字段（Field）</h4><p>字段格式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias:name(argument:value)</span><br></pre></td></tr></table></figure><p>其中<code>alias</code>是字段的别名，即结果中显示的字段名称。</p><p><code>name</code>为字段名称，对应<code>schema</code>中定义的<code>fields</code>字段名。</p><p><code>argument</code>为参数名称，对应<code>schema</code>中定义的<code>fields</code>字段的参数名称。</p><p><code>value</code>为参数值，值的类型对应标量类型的值。</p><p>例如这样的请求：<code>http://example.taobao.com/?query={banner{backgroundURL:bg,biaoti:slogan}}</code>，其中<code>backgroundURL</code>就是<code>bg</code>字段的别名。</p><h4 id="4-片段（Fragment）"><a href="#4-片段（Fragment）" class="headerlink" title="4. 片段（Fragment）"></a>4. 片段（Fragment）</h4><p>片段时GraphQL的主要组合数据结构，通过片段可以重用重复的字段选择，减少<code>query</code>中的重复内容。片段又分为<code>FragmentSpread</code>和<code>InlineFragment</code>。例如没有片段时需要这样编写<code>query</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">query noFragments &#123;</span><br><span class="line">    user(id: 4) &#123;</span><br><span class="line">        friends(first: 10) &#123;</span><br><span class="line">            id</span><br><span class="line">            name</span><br><span class="line">            profilePic(size: 50)</span><br><span class="line">        &#125;</span><br><span class="line">        mutualFriends(first: 10) &#123;</span><br><span class="line">            id</span><br><span class="line">            name</span><br><span class="line">            profilePic(size: 50)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>query</code>中存在下列重复的选择集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    profilePic(size: 50)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用片段化简为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">query withFragments &#123;</span><br><span class="line">    user(id: 4) &#123;</span><br><span class="line">        friends(first: 10) &#123;</span><br><span class="line">            ...friendFields</span><br><span class="line">        &#125;</span><br><span class="line">        mutualFriends(first: 10) &#123;</span><br><span class="line">            ...friendFields</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment friendFields on User &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    profilePic(size: 50)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用片段时需要加上<code>...</code>操作符表示展开片段内容。</p><p>内联片段示例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">query inlineFragmentTyping &#123;</span><br><span class="line">    profiles(handles: [&quot;zuck&quot;, &quot;cocacola&quot;]) &#123;</span><br><span class="line">        handle</span><br><span class="line">        ... on User &#123;</span><br><span class="line">            friends &#123;</span><br><span class="line">                count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ... on Page &#123;</span><br><span class="line">            likers &#123;</span><br><span class="line">                count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-指令（Directives）"><a href="#5-指令（Directives）" class="headerlink" title="5. 指令（Directives）"></a>5. 指令（Directives）</h4><p>指令要解决的是<code>query</code>执行时字段参数无法覆盖的情况，例如引入或者忽略某个字段。指令为GraphQL执行添加了更多的信息。</p><p>指令实例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query hasConditionalFragment($condition: Boolean) &#123;</span><br><span class="line">    ...maybeFragment @include(if: $condition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment maybeFragment on Query &#123;</span><br><span class="line">    me &#123;</span><br><span class="line">        name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>include</code>指令表示只有在<code>if</code>参数为true时才引入片段表示的字段。</p><p><code>skip</code>指令表示在<code>if</code>参数为true时忽略片段中的字段。</p><p>熟悉了<strong>类型系统</strong>和<strong>查询语言</strong>，我们就可以用GraphQL来实现应用层的数据请求了。</p><p>其他三个GraphQL组件更偏向于DSL的实现和原理，本文不再做详细介绍。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="http://graphql.cn/" target="_blank" rel="noopener">GraphQL | 一种为你的API而生的查询语言</a></p></li><li><p><a href="http://taobaofed.org/blog/2016/03/10/graphql-in-depth/" target="_blank" rel="noopener">深入理解GraphQL</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前一篇文章中我们对GraphQL有了基础的了解，我们直到GraphQL使用&lt;code&gt;Schema&lt;/code&gt;来描述数据，并通过指定和实现GraphQL规范定义了支持&lt;code&gt;Schema&lt;/code&gt;查询的&lt;code&gt;DSQL （Domain Specific Query Language，领域特定查询语言）&lt;/code&gt;。&lt;code&gt;Schema&lt;/code&gt;帮助将复杂的业务模型数据抽象拆分成细粒度的基础数据结构，而&lt;code&gt;DSQL&lt;/code&gt;的实现则赋予了前端开发者自由组织和定制请求数据的能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="GraphQL" scheme="http://www.xiaoleon.cn/tags/GraphQL/"/>
    
      <category term="网络接口" scheme="http://www.xiaoleon.cn/tags/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Web(2) GraphQL简要介绍</title>
    <link href="http://www.xiaoleon.cn/2018/01/31/web-2/"/>
    <id>http://www.xiaoleon.cn/2018/01/31/web-2/</id>
    <published>2018-01-31T01:27:52.000Z</published>
    <updated>2018-03-12T14:11:39.042Z</updated>
    
    <content type="html"><![CDATA[<p>GraphQL是什么？GraphQL是一种既用于API的查询语言，也满足数据查询的运行时语言。GraphQL对你的API中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获取它需要的数据，而且没有任何冗余，也让API更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p><a id="more"></a><p>GraphQL is a query language created by Facebook in 2012 which provides a common interface between the client and the server for data fetching and manipulations.</p><p>The client ask for various data from the GraphQL server via queries. The response format is described in the query and defined by the client instead of the server: they are called client-specified queries. The structure of the data is not hardcoded as in traditional REST APIs - this makes retrieving data from the server more efficient for the client.</p><hr><h3 id="一、场景分析"><a href="#一、场景分析" class="headerlink" title="一、场景分析"></a>一、场景分析</h3><p>现有的数据业务场景一般是这样的，业务方提出需求，然后寻找开发资源，由后端提供数据，让前端实现各种不同的业务视图。这样的做法存在很多的重复劳动，如果能够将其中通用的内容抽取出来提供给各个业务方反复使用，必然能够节省宝贵的开发时间和开发人力。</p><p>前端的解决方案时将视图组件化，各个业务线既可以是组件的使用者，也可以是组件的生产者。那么问题来了，前端通过组件实现了跨业务的复用，后端接口如何相应地提高开发效率呢？</p><p>我们假设某个业务需要以下数据内容a：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    user(id: 3500401) &#123;</span><br><span class="line">        id,</span><br><span class="line">        name,</span><br><span class="line">        isViewerFriend</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显这不是一个JSON，但是我们仍然可以看懂它表示的是查询<code>id</code>为3500401用户的<code>id</code>、<code>name</code>和<code>isViewerFriend</code>信息。用户信息对于各个业务都是通用的，假设另外一个业务需要这样的用户信息b：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    user(id: 3500401) &#123;</span><br><span class="line">        name,</span><br><span class="line">        profilePicture(size: 50) &#123;</span><br><span class="line">            uri,</span><br><span class="line">            width,</span><br><span class="line">            height</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下，我们发现只是少了两个字段，多了一个字段而已。如果要实现我们的目标，即复用同一个接口来支持这两种业务的话，会有以下几种做法：</p><ul><li><p>用同一个接口，这个接口提供了所有数据。这样做的好处是实现起来简单，但缺点是对业务做判断的逻辑会增多，而且对于业务来说，响应内容中有些数据根本用不到</p></li><li><p>使用参数来区分不同的业务方并返回相应的数据。好处仍然是实现简单，虽然不会有用不到的数据返回，但是仍然需要增加业务逻辑判断，会造成以后维护的困难。</p></li></ul><p>此外，这样还会造成不同业务之间的强依赖，每次发布都需要各个业务线一起测试和回归。不重用接口则没法提高开发效率，重用接口则会有这些问题。</p><hr><h3 id="二、GraphQL解决方案"><a href="#二、GraphQL解决方案" class="headerlink" title="二、GraphQL解决方案"></a>二、GraphQL解决方案</h3><p>我们知道，用户信息对应的数据模型是固定的，每次请求其实是对这些数据做了过滤和筛选。对应到数据库操作，就是数据的查询操作。如果客户端也能够像“查询”一样发送请求，那不就可以从后端接口这个大的“大数据库”去过滤筛选业务需要的数据了吗？</p><p>GraphQL就是基于这样的思想来设计的。上面提到的（a）和（b）类型的数据结构就是GraphQL的查询内容。使用上面的查询，GraphQL服务器会分别返回如下响应内容。</p><p>a查询对应的响应</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">3500401</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Jing Chen"</span>,</span><br><span class="line">        <span class="attr">"isViewerFriend"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b查询对应的响应</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Jing Chen"</span>,</span><br><span class="line">        <span class="attr">"profilePicture"</span>: &#123;</span><br><span class="line">            <span class="attr">"uri"</span>: <span class="string">"http://example/pic.jpg"</span>,</span><br><span class="line">            <span class="attr">"width"</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="attr">"height"</span>: <span class="number">50</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要改变查询内容，前端就能定制服务器返回的响应内容，这就是GraphQL的客户端制定查询（<code>Client Specified Queries</code>）。</p><hr><h3 id="三、使用NodeJS实现GraphQL服务器"><a href="#三、使用NodeJS实现GraphQL服务器" class="headerlink" title="三、使用NodeJS实现GraphQL服务器"></a>三、使用NodeJS实现GraphQL服务器</h3><p>我们先按照官方文档搭建一个GraphQL服务器</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> graphql-intro &amp;&amp; <span class="built_in">cd</span> ./graphql-intro</span><br><span class="line">npm init</span><br><span class="line">npm install express --save</span><br><span class="line">npm install babel --save</span><br><span class="line">npm install babel-register --save</span><br><span class="line"><span class="built_in">type</span> <span class="built_in">nul</span>&gt; ./server.js</span><br><span class="line"><span class="built_in">type</span> <span class="built_in">nul</span>&gt; ./index.js</span><br></pre></td></tr></table></figure><p><code>index.js</code>的内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel-register'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./server.js'</span>);</span><br></pre></td></tr></table></figure><p><code>server.js</code>的内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="keyword">let</span> PORT = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/graphql'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">'Hello'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = app.listen(PORT, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> host = server.address().address;</span><br><span class="line">    <span class="keyword">let</span> port = server.address().port;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`GraphQL listening at http:<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后执行代码</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon index.js</span><br></pre></td></tr></table></figure><p>测试是否有效</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:<span class="number">3000</span>/graphql           // =&gt; 'Hello'</span><br></pre></td></tr></table></figure><p>接着编写<code>GraphQL Schema</code>（<code>Schema</code>是GraphQL请求的入口，用户的GraphQL请求会对应到具体的<code>Schema</code>），首先回忆一下GraphQL请求是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query getHightScore &#123; score &#125;</span><br></pre></td></tr></table></figure><p>上面的请求是获取<code>getHightScore</code>的<code>score</code>值。也可以加上查询条件，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query getHightScore(limit: 10) &#123; score &#125;</span><br></pre></td></tr></table></figure><p>这样的请求格式就是GraphQL中的<code>schema</code>。通过<code>schema</code>可以定义服务器的响应内容。</p><p>接下来我们在项目中使用graphql</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install graphql --save</span><br><span class="line">npm install body-parser --save</span><br></pre></td></tr></table></figure><p>graphql的npm包会负责组装服务器<code>schema</code>并处理GraphQL请求。</p><h4 id="1-创建schema"><a href="#1-创建schema" class="headerlink" title="1. 创建schema"></a>1. 创建schema</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">nul</span>&gt; ./schema.js</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    GraphQLObjectType,</span><br><span class="line">    GraphQLSchema,</span><br><span class="line">    GraphQLInt</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'graphql'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> schema = <span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    query: <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">        name: <span class="string">'RootQueryType'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            count: &#123;</span><br><span class="line">                type: GraphQLInt,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> schema;</span><br></pre></td></tr></table></figure><p>这段代码创建了一个<code>GraphQL Schema</code>实例。这个<code>schema</code>的顶级查询对象会返回一个<code>RootQueryType</code>对象，这个<code>RootQueryType</code>对象有一个整数类型的<code>count</code>域。GraphQL除了支持整数（<code>Interger</code>），还支持字符串（<code>String</code>）、列表（<code>List</code>）等多种类型的数据。</p><h4 id="2-连接schema"><a href="#2-连接schema" class="headerlink" title="2. 连接schema"></a>2. 连接schema</h4><p>下面将<code>GraphQL Schema</code>和服务器连接起来，我们需要修改<code>server.js</code>为如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> schema <span class="keyword">from</span> <span class="string">'./schema'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">'graphql'</span>;</span><br><span class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">'body-parser'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="keyword">let</span> PORT = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.text(&#123; <span class="attr">text</span>: <span class="string">'application/graphql'</span> &#125;));</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/graphql'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    graphql(schema, req.body)</span><br><span class="line">        .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">            res.send(<span class="built_in">JSON</span>.stringify(result, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = app.listen(PORT, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> host = server.address().address;</span><br><span class="line">    <span class="keyword">let</span> port = server.address().port;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`GraphQL listening at http:<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>验证下效果</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "query RootQueryType &#123; count &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p>结果如下图所示</p><p><img src="/images/web-2/1.png" alt="验证效果"></p><p>GraphQL查询还可以省略掉<code>queryRootQueryType</code>前缀</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "&#123; count &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p><img src="/images/web-2/2.png" alt="验证效果"></p><h4 id="3-检查服务器"><a href="#3-检查服务器" class="headerlink" title="3. 检查服务器"></a>3. 检查服务器</h4><p>GraphQL最让人感兴趣的是可以编写GraphQL查询来让GraphQL服务器告诉我们它支持哪些查询，即官方文档提到的自检性（<code>introspection</code>）。</p><p>例如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "&#123; __schema &#123; queryType &#123; name, fields &#123; name, description &#125; &#125; &#125; &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p><img src="/images/web-2/3.png" alt="验证效果"></p><p>而我们实际的GraphQL查询请求内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    __schema &#123;</span><br><span class="line">        queryType &#123;</span><br><span class="line">            name,</span><br><span class="line">            fields &#123;</span><br><span class="line">                name,</span><br><span class="line">                description</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上每个GraphQL根域都会自动加上一个<code>__schema</code>域，这个域有一个子域叫<code>queryType</code>。我们可以通过查询这些域来了解GraphQL服务器支持哪些查询。我们可以修改<code>schema.js</code>来为<code>count</code>域加上<code>description</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> schema = <span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    query = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">        name: <span class="string">'RootQueryType'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            count: &#123;</span><br><span class="line">                type: GraphQLInt,</span><br><span class="line">                description: <span class="string">'The count!'</span>,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>验证一下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "&#123; __schema &#123; queryType &#123; name, fields &#123; name, description &#125; &#125; &#125; &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p><img src="/images/web-2/4.png" alt="验证效果"></p><h4 id="4-变异（mutation）"><a href="#4-变异（mutation）" class="headerlink" title="4. 变异（mutation）"></a>4. 变异（mutation）</h4><p>GraphQL中将对数据的修改操作称为<code>mutation</code>，在GraphQL Schema中按照如下形式来定义一个<code>mutation</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let schema = new GraphQLSchema(&#123;</span><br><span class="line">    query: ...</span><br><span class="line">    mutation: //TODO</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>mutation</code>查询和普通查询请求（<code>query</code>）的重要区别在于<code>mutation</code>操作是序列化执行的。例如GraphQL规范中给出的示例，服务器一定会序列化下面的<code>mutation</code>请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    first: changeTheNumber(newNumber: 1) &#123;</span><br><span class="line">        theNumber</span><br><span class="line">    &#125;,</span><br><span class="line">    second: changeTheNumber(newNumber: 3) &#123;</span><br><span class="line">        theNumber</span><br><span class="line">    &#125;,</span><br><span class="line">    third: changeTheNumber(newNumber: 2) &#123;</span><br><span class="line">        theNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求结束时<code>theNumber</code>的值会是<code>2</code>。下面为我们的服务器添加一个<code>mutation</code>查询，修改<code>schema.js</code>为如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    GraphQLObjectType,</span><br><span class="line">    GraphQLSchema,</span><br><span class="line">    GraphQLInt</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'graphql'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> schema = <span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    query: <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">        name: <span class="string">'RootQueryType'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            count: &#123;</span><br><span class="line">                type: GraphQLInt,</span><br><span class="line">                <span class="comment">// Add description</span></span><br><span class="line">                description: <span class="string">'The count!'</span>,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// Note: this is the newly added mutation query</span></span><br><span class="line">    mutation: <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">        name: <span class="string">'RootMutationType'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            updateCount: &#123;</span><br><span class="line">                type: GraphQLInt,</span><br><span class="line">                description: <span class="string">'Update the count'</span>,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> schema;</span><br></pre></td></tr></table></figure><p>验证一下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "mutation RootMutationType &#123; updateCount &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p><img src="/images/web-2/5.png" alt="验证效果"></p><hr><h3 id="四、业务场景模拟"><a href="#四、业务场景模拟" class="headerlink" title="四、业务场景模拟"></a>四、业务场景模拟</h3><p>搭建好GraphQL服务器后，我们来模拟下业务场景的实际需求，对于电商平台来说，最常用的就是商品信息，假设目前的商品数据模型可以用下面的<code>GraphQLObject</code>来表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ItemType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'item'</span>,</span><br><span class="line">    descriptions: <span class="string">'item'</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">        id: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item id'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        title: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item title'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        price: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item price'</span>,</span><br><span class="line">            resolve: <span class="function"><span class="keyword">function</span>(<span class="params">root, param, context</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (root.price / <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        pic: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item pic url'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>查询商品的<code>schema</code>如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ItemSchema = <span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    query: &#123;</span><br><span class="line">        name: <span class="string">'ItemQuery'</span>,</span><br><span class="line">        description: <span class="string">'query item'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            item: &#123;</span><br><span class="line">                type: ItemType,</span><br><span class="line">                description: <span class="string">'item'</span>,</span><br><span class="line">                args: &#123;</span><br><span class="line">                    id: &#123;</span><br><span class="line">                        type: GraphQLInt,</span><br><span class="line">                        required: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params">root, obj, ctx</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">yield</span> ItemService(obj[<span class="string">'id'</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过如下<code>query</code>可以查询id为12345的商品信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query ItemQuery(id: 12345) &#123;</span><br><span class="line">    id</span><br><span class="line">    title</span><br><span class="line">    price</span><br><span class="line">    pic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>商品详情页展示时需要加上优惠价格信息，我们可以修改<code>ItemType</code>，为它加上一个<code>promotion</code>字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ItemType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'item'</span>,</span><br><span class="line">    description: <span class="string">'item'</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">        id: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item id'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        title: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item title'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        price: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item price'</span>,</span><br><span class="line">            resolve: <span class="function"><span class="keyword">function</span>(<span class="params">root, param, context</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (root.price / <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        pic: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item pic url'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        promotion: &#123;</span><br><span class="line">            type: GraphQLInt,</span><br><span class="line">            description: <span class="string">'promotion price'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>商品详情页的查询为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query ItemQuery(id: 12345) &#123;</span><br><span class="line">    id</span><br><span class="line">    title</span><br><span class="line">    price</span><br><span class="line">    pic</span><br><span class="line">    promotion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ItemSchema</code>无需修改，只要在<code>ItemService</code>的返回结果中加上<code>promotion</code>就可以了。这样接口的修改对于原有业务是透明的，而新的业务也能基于已有的代码快速开发和迭代。</p><p>再假设有一个新的页面，只需要用到宝贝的图片信息，业务方可以使用下面的查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query ItemQuery(id: 12345) &#123;</span><br><span class="line">    id</span><br><span class="line">    pic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器代码不用做任何修改。</p><p>至此我们已经实现了一个GraphQL基础服务器。在实际业务中数据模型肯定会更加复杂，而GraphQL也提供了强大的类型系统（<code>Type System</code>）让我们能够轻松地描述各种数据类型，它提供的抽象层能够为依赖同一套数据模型的不同业务方提供灵活的数据支持。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="http://graphql.cn/" target="_blank" rel="noopener">GraphQL | 一种为你的API而生的查询语言</a></p></li><li><p><a href="https://www.jianshu.com/p/0343b83e0cbb" target="_blank" rel="noopener">GraphQL 初体验：GraphQL + Node.js</a></p></li><li><p><a href="http://taobaofed.org/blog/2015/11/26/graphql-basics-server-implementation/" target="_blank" rel="noopener">Node.js服务端实践之GraphQL初探</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GraphQL是什么？GraphQL是一种既用于API的查询语言，也满足数据查询的运行时语言。GraphQL对你的API中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获取它需要的数据，而且没有任何冗余，也让API更容易地随着时间推移而演进，还能用于构建强大的开发者工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="GraphQL" scheme="http://www.xiaoleon.cn/tags/GraphQL/"/>
    
      <category term="网络接口" scheme="http://www.xiaoleon.cn/tags/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
</feed>
