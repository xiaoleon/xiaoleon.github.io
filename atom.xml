<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张啸</title>
  
  <subtitle>世界上最快乐的事，莫过于为理想而奋斗。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaoleon.cn/"/>
  <updated>2018-03-04T15:01:16.626Z</updated>
  <id>http://www.xiaoleon.cn/</id>
  
  <author>
    <name>Leon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React(2) 设计高质量的React组件</title>
    <link href="http://www.xiaoleon.cn/2018/03/04/react-2/"/>
    <id>http://www.xiaoleon.cn/2018/03/04/react-2/</id>
    <published>2018-03-04T13:29:25.000Z</published>
    <updated>2018-03-04T15:01:16.626Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个合格的开发者，不能只满足于编写出可以运行的代码，而要了解代码背后的工作原理；不能只满足于自己编写的程序能够运行，还要让自己的代码可读而且易于维护。这样才能开发出高质量的软件。</p><a id="more"></a><p>本文中，我们将深入介绍构建高质量React组件的原则和方法，包括以下内容</p><ul><li><p>划分组件边界的原则</p></li><li><p>React组件的数据种类</p></li><li><p>React组件的生命周期</p></li></ul><h3 id="一、易于维护组件的设计要素"><a href="#一、易于维护组件的设计要素" class="headerlink" title="一、易于维护组件的设计要素"></a>一、易于维护组件的设计要素</h3><p>任何一个复杂的应用，都是由一个简单的应用发展而来的，当应用还很简单的时候，因为功能很少，可能只有一个组件就足够了，但是，随着功能的增加，把越来越多的功能放在一个组件里就会显得臃肿和难以管理。</p><p>就和一个人最好一次只专注做一件事一样，也应该尽量保持一个组件只做一件事。当开发者发现一个组件功能太多代码量太大的时候，就要考虑拆分这个组件，用多个小的组件来代替。每个小的组件只关注实现单个功能，但是这些功能组合起来，也能满足复杂的实际需求。</p><p>这就是“分而治之”的策略，把问题分解为多个小问题，这样极容易解决也方便维护，虽然“分而治之”是一个好策略，但是不要滥用，只有必要的时候才去拆分组件，不然可能得不偿失。</p><p>拆分组件最关键的就是确定组件的边界，每个组件都应该是可以独立存在的，如果两个组件逻辑太紧密，无法清晰定义各自的责任，那也许这两个组件本身就不该被拆开，作为同一个组件也许更合理。</p><p>虽然组件是应该独立存在的，但是并不是说组件就是孤岛一样的存在，不同组件之间总会有通信交流，这样才可能组合起来完成更大的功能。</p><p>作为软件设计的通则，组件的划分要满足<strong>高内聚（High Cohesion）</strong>和<strong>低耦合（Low Coupling）</strong>的原则。</p><p><strong>高内聚</strong>指的是把逻辑紧密相关的内容放在一个组件中。用户界面无外乎内容、交互行为和样式。传统上，内容由HTML表示，交互行为放在JavaScript代码文件中，样式放在CSS文件中定义。这虽然满足一个功能模块的需要，却要放在三个不同的文件中，这其实不满足高内聚的原则，React却不是这样，展示内容的JSX、定义行为的JavaScript，甚至定义样式的CSS，都可以放在一个JavaScript文件中，因为它们本来就是为了实现一个目的而存在的，所以说React天生具有高内聚的特点。</p><p><strong>低耦合</strong>指的是不同组件之间的依赖关系要尽量弱化，也就是每个组件要尽量独立。保持整个系统的低耦合度，需要对系统中的功能有充分的认识，然后根据功能点划分模块，让不同的组件去实现不同的功能，这个功夫还在开发者身上，不过，React组件的对外结构非常规范，方便开发者设计低耦合的系统。</p><hr><h3 id="二、React组件的数据"><a href="#二、React组件的数据" class="headerlink" title="二、React组件的数据"></a>二、React组件的数据</h3><p>毫无疑问，如何组织数据是程序的最重要问题。</p><p>React组件的数据分为两种，prop和state，无论prop或者state的改变，都可能引发组件的重新渲染，那么，设计一个组件的时候，什么时候选择用prop什么时候选择用state呢？其实原则很简单，prop是组件的对外接口，state是组件的内部状态，对外用prop，内部用state。</p><p>为了演示属性的使用，我们构造一个应用包含两个组件，Counter组件和ControlPanel组件，其中ControlPanel组件是父组件，包含若干个Counter组件。</p><p><img src="/images/react-2/1.png" alt="ControlPanel应用效果图"></p><p>可以看到三个Counter组件有了不同的初始计数值，点击网页中的“<code>+</code>”按钮可以看到对应一行的计数增加，点击“<code>-</code>”按钮可以看到对应一行的计数减少。</p><h4 id="1-React的prop"><a href="#1-React的prop" class="headerlink" title="1. React的prop"></a>1. React的prop</h4><p>在React中，prop（property的简写）是从外部传递给组件的数据，一个React组件通过定义自己能够接受的prop就定义了自己的对外公共接口。</p><p>每个React组件都是独立存在的模块，组件之外的一切都是外部世界，外部世界就是通过prop来和组件对话的。</p><ul><li>1) 给prop赋值</li></ul><p>我们先从外部世界来看，prop是如何使用的，在下面的JSX代码片段中，就使用了prop</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SampleButton id=<span class="string">"sample"</span> borderWidgh=&#123;<span class="number">2</span>&#125; onClick=&#123;onButtonClick&#125; style=&#123;&#123;<span class="attr">color</span>: <span class="string">"red"</span>&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>在上面的例子中，创建了名为SampleButton的组件实例，使用了名字分别为id、borderWidth、onClick和style的prop，看起来，React组件的prop很像是HTML元素的属性，不过，HTML组件属性的值都是字符串类型，即使是内嵌JavaScript，也依然是字符串形式表示代码。React组件的prop所能支持的类型则丰富得多，除了字符串，可以是任何一种JavaScript语言支持的数据类型。</p><p>比如在上面的SampleButton中，borderWidth就是数字类型，onClick是函数类型，style的值是一个包含color字段的对象，当prop的类型不是字符串类型时，在JSX中必须用花括号<code>{}</code>把prop值包住，所以style的值有两层花括号，外层花括号代表的是JSX的语法，内层的花括号代表这是一个对象常量。</p><p>当外部世界要传递一些数据给React组件，一个最直接的方式就是通过prop；同样，React组件要反馈数据给外部世界，也可以用prop，因为prop的类型不限于纯数据，也可以是函数，函数类型的prop等于让父组件交给了子组件一个回调函数，子组件在恰当的时机调用函数类型的prop，可以带上必要的参数，这样就可以反过来把信息传递给外部世界。</p><p>对于Counter组件，父组件的ControlPanel就是外部世界，我们看ControlPanel是如何用prop传递信息给Counter的，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ControlPanel</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Counter caption=<span class="string">"First"</span> initValue=&#123;<span class="number">0</span>&#125; /&gt;</span><br><span class="line">        &lt;Counter caption=<span class="string">"Second"</span> initValue=&#123;<span class="number">10</span>&#125; /&gt;</span><br><span class="line">        &lt;Counter caption=<span class="string">"Third"</span> initValue=&#123;<span class="number">20</span>&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>ControlPanel组件包含三个Counter组件实例，在ControlPanel的render函数中将这三个子组件实例用div包起来，因为React要求render函数只能返回一个元素。</p><p>在每个Counter组件实例中，都使用了caption和initValue这两个prop。通过名为caption的prop，ControlPanel传递给Counter组件实例说明文字。通过initValue的prop传递给Counter组件一个初始的计数值。</p><ul><li>2) 读取prop值</li></ul><p>我们再来看Counter组件内部是如何接收传入的prop的，首先是构造函数，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.onClickIncrementButton = <span class="keyword">this</span>.onClickIncrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.onClickDecrementButton = <span class="keyword">this</span>.onClickDecrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: props.initValue || <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个组件需要定义自己的构造函数，一定要记得在构造函数的第一行通过super调用父类也就是React.Component的构造函数。如果在构造函数中没有调用super(props)，那么组件实例被构造之后，类实例的所有成员函数就无法通过this.props访问到父组件传递过来的props值。很明显，给this.props赋值是React.Component构造函数的工作之一。</p><p>在Counter的构造函数中还给两个成员函数绑定了当前this的执行环境，因为ES6方法创造的React组建类并不自动给我们绑定this到当前实例对象。</p><p>在构造函数的最后，我们可以看到读取传入prop的方法，在构造函数中可以通过参数props获得传入的prop值，在其他函数中则可以通过this.props访问传入的prop的值，比如在Counter组件的render函数中，我们就是通过this.props获得传入的caption，render代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; caption &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onClickIncrementButton&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onClickDecrementButton&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;span&gt;&#123;caption&#125; count: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用了ES6的解构赋值（destructuring assignment）语法从this.props中获得了名为caption的prop值。</p><ul><li>3) propTypes检查</li></ul><p>既然prop是组件的对外接口，那么就应该有某种方式让组件声明自己的接口规范。简单说，一个组件应该可以规范以下这些方面：</p><ul><li><p>这个组件支持哪些prop</p></li><li><p>每个prop应该是什么样的格式</p></li></ul><p>React通过propTypes来支持这些功能。</p><p>在ES6方法定义的组件类中，可以通过增加类的propTypes属性来定义prop规格，这不只是声明，而且是一种限制，在运行时和静态代码检查时，都可以根据propTypes判断外部世界是否正确地使用了组件的属性。</p><p>比如，对于Counter组件的propTypes定义代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Counter.propTypes = &#123;</span><br><span class="line">  caption: PropTypes.string.isRequired,</span><br><span class="line">  initValue: PropTypes.number</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中要求caption必须是string类型，initValue必须是number类型。可以看到，两者除了类型不同之外，还有一个区别：caption带上了isRequired，这表示使用Counter组件必须要指定caption；而initValue因为没有isRequired，则表示如果没有也没关系。</p><p>为了验证propTypes的作用，可以尝试故意违反propTypes的规定使用Counter实例，比如在ControlPanel的render函数中增加下列的代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Counter caption=&#123;<span class="number">123</span>&#125; initValue=&#123;<span class="number">20</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>我们在Chrome浏览器中，可以看到console中的红色警告</p><p><img src="/images/react-2/2.png" alt="错误prop类型的错误提示"></p><p>这段出错的含义是，caption属性预期是字符串类型，得到的却是一个数字类型。我们尝试删掉这个Counter实例的caption属性，代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Counter initValue=&#123;<span class="number">20</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>这是可以看到Console中依然有红色警告信息</p><p><img src="/images/react-2/3.png" alt="缺失必须存在prop的错误提示"></p><p>提示的含义是，caption是Counter必需的属性，但是却没有赋值。</p><p>很明显，有了propTypes的检查，可以很容易发现对prop的不正确使用方法，可尽早发现代码中的错误。</p><p>如果组件根本没有定义propTypes会怎么样呢？可以尝试在<code>src/Counter.js</code>文件中删除掉propTypes赋值的语句，在浏览器Console中红色警告不再出现。可见，没有propTypes定义，组件依然能够正常工作，而且，即使在上面propTypes检查出错的情况下，组件依旧能够工作。也就是说propTypes检查只是一个辅助开发的功能，并不会改变组件的行为。</p><p>propTypes虽然能够在开发阶段发现代码中的问题，但是放在产品环境中就不大合适了。</p><p>首先，定义类的propTypes属性，无疑是要占用一些代码空间，而且propTypes检查也是要消耗CPU计算资源的。其次，在产品环境下做propTypes检查没有什么帮助，毕竟，propTypes产生的这些错误信息只有开发者才能看得懂，放在产品环境下，在最终用户的浏览器Console中输出这些错误信息没什么意义。</p><p>所以，最好的方式是，开发者在代码中定义propTypes，在开发过程中避免犯错，但是在发布产品代码时，用一种自动的方式将propTypes去掉，这样最终部署到产品环境的代码就会更优。现有的babel-react-optimize就具有这个功能，可以通过npm安装，但是应该确保只在发布产品时使用它。</p><h4 id="2-React的state"><a href="#2-React的state" class="headerlink" title="2. React的state"></a>2. React的state</h4><p>驱动组件渲染过程的除了prop，还有state，state代表组件的内部状态。由于React组件不能修改传入的prop，所以需要记录自身数据变化，就要使用state。</p><p>在Counter组件中，最初显示初始计数，可以通过initValue这个prop来定制，在Counter已经被显示之后，用户会点击“<code>+</code>”和“<code>-</code>”按钮改变这个计数，这个变化的数据就要Counter组件自己通过state来存储了。</p><ul><li>1) 初始化state</li></ul><p>通常在组件类的构造函数结尾处初始化state，在Counter构造函数中，通过对this.state的赋值完成了对组件state的初始化，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    count: props.initValue || <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为initValue是一个可选的props，要考虑到父组件没有指定这个props值的情况，我们优先使用传入属性的initValue，如果没有，就是用默认值0。</p><p>组件的state必须是一个JavaScript对象，不能是string或者number这样的简单数据类型，即使我们需要存储的只是一个数字类型的数据，也只能把它存作state某个字段对应的值，Counter组件里，我们的唯一数据就存在count字段里。</p><p>由于在PropType声明中没有用isRequired要求必须有值的prop，例如上面的initValue，我们需要在代码中判断所给的prop值是否存在，如果不存在，就给一个默认的初始值。不过，让这样的判断逻辑充斥在我们组件的构造函数之中并不是一件美观的事情，而且容易有遗漏。我们可以用React的defaultProps功能，让代码更加容易读懂。</p><p>给Counter组件添加defaultProps代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Counter.defaultProps = &#123;</span><br><span class="line">  initValue: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了这样的设定，Counter构造函数中的this.state初始化中可以省去判断条件，可以认为代码执行到这里，必有initValue属性值，代码可以简化为这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  count: props.initValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，即使Counter的使用者没有指定initValue，在组件中就会收到一个默认的属性值0。</p><ul><li>2) 读取和更新state</li></ul><p>通过给button的onClick属性挂载点击事件处理函数，我们可以改变组件的state，以点击“<code>+</code>”按钮的响应函数为例，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onClickIncrementButton() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，通过this.state可以读取到组件的当前state。值得注意的是，我们改变组件state必须要使用this.setState函数，而不能直接去修改this.state。</p><p>直接修改this.state的值，虽然事实上改变了组件的内部状态，但只是野蛮地修改了state，却没有驱动组件进行重新渲染，既然组件没有重新渲染，当然不会反应this.state值的变化；而this.setState()函数所做的事情，首先是改变this.state的值，然后驱动组件经历更新过程，这样才有机会让this.state里新的值出现在界面上。</p><h4 id="3-prop和state的对比"><a href="#3-prop和state的对比" class="headerlink" title="3. prop和state的对比"></a>3. prop和state的对比</h4><p>总结一下prop和state的区别：</p><ul><li><p>prop用于定义外部接口，state用于记录内部状态</p></li><li><p>prop的赋值在外部世界使用组件时，state的赋值在组件内部</p></li><li><p>组件不应该改变prop的值，而state存在的目的就是让组件来改变的</p></li></ul><p>组件的state，就相当于组件的记忆，其存在意义就是被修改，每一次通过this.setState函数修改state就改变了组件的状态，然后通过渲染过程把这种变化体现出来。</p><p>但是，组件是绝不应该去修改传入的props值的，我们设想一下，假如父组件包含多个子组件，然后把一个JavaScript对象作为props值传给这几个子组件，而某个子组件居然改变了这个对象的内部值，那么，接下来其他子组件读取这个对象会得到什么值呢？当时读取了修改过的值，但是其他子组件是每次渲染都读取这个props的值呢？还是只读一次以后就用那个最初值呢？一切皆有可能，完全不可预料。也就是说，一个子组件去修改props中的值，可能让程序陷入一团混乱之中，这就完全违背了React设计的初衷。</p><p>严格来说，React并没有办法阻止我们去修改传入的props对象。所以，每个开发者就把这当做一个规矩，在编码中一定不要踩这道红线，不然最后可能遇到不可预料的bug。</p><hr><h3 id="三、组件的生命周期"><a href="#三、组件的生命周期" class="headerlink" title="三、组件的生命周期"></a>三、组件的生命周期</h3><p>为了理解React的工作过程，我们就必须要了解React组件的生命周期，如同人有生老病死，自然界有日月更替，每个组件在网页中也会被创建、更新和删除，如同有生命的机体一样。</p><p>React严格定义了组件的生命周期，会经理如下三个过程：</p><ul><li><p>装载过程（Mount），也就是把组件第一次在DOM树中渲染的过程</p></li><li><p>更新过程（Update），当组件被重新渲染的过程</p></li><li><p>卸载过程（Unmount），组件从DOM中删除的过程</p></li></ul><p>三种不同的过程，React库会依次调用组件的一些成员函数，这些函数称为生命周期函数。所以，要定制一个React组件，实际上就是定制这些生命周期函数。</p><h4 id="1-装载过程"><a href="#1-装载过程" class="headerlink" title="1. 装载过程"></a>1. 装载过程</h4><p>我们先来看装载过程，当组件第一次被渲染的时候，依次调用的函数是如下这些：</p><ul><li><p>constructor</p></li><li><p>getInitialState</p></li><li><p>getDefaultProps</p></li><li><p>componentWillMount</p></li><li><p>render</p></li><li><p>componentDidMount</p></li></ul><p>我们逐个详细解释这些函数的功能</p><ul><li>1) constructor</li></ul><p>我们先来看constructor，也就是ES6中每个类的构造函数，要创造一个组件类的实例，当然会调用对应的构造函数。</p><p>要注意，并不是每个组件都需要定义自己的构造函数。在后文中我们可以看到，无状态的React组件往往就不需要定义构造函数，一个React组件需要构造函数，往往是为了下面的目的：</p><ul><li><p>初始化state，因为组件生命周期中任何函数都可能要访问state，那么整个生命周期中第一个被调用的构造函数自然是初始化state最理想的地方</p></li><li><p>绑定成员函数的this环境</p></li></ul><p>在ES6语法下，类的每个成员函数在执行时的this并不是和类实例自动绑定的。而在构造函数中，this就是当前组件实例，所以，为了方便将来的调用，往往在构造函数中将这个实例的特定函数绑定this为当前实例。</p><p>以Counter组件为例，我们的构造函数有这样如下的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.onClickIncrementButton = <span class="keyword">this</span>.onClickIncrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.onClickDecrementButton = <span class="keyword">this</span>.onClickDecrementButton.bind(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这两句的作用，就是通过bind方法让当前实例中onClickIncrementButton和onClickDecrementButton函数被调用时，this始终是指向当前组件实例。</p><ul><li>2) getInitialState和getDefaultProps</li></ul><p>getInitialState这个函数的返回值用来初始化组件的this.state，但是，这个方法只有用React.createClass方法创造的组件类才会发生作用，本文中使用ES6语法，所以这个函数根本不会产生作用。</p><p>getDefaultProps函数的返回值可以作为props的初始值，和getInitialState一样，这个函数不会产生作用。</p><ul><li>3) render</li></ul><p>render函数无疑是React组件中最重要的函数，一个React组件可以忽略其他所有函数都不实现，但是一定要实现render函数，因为所有React组件的父类React.Component类对除render之外的生命周期函数都有默认实现。</p><p>通常一个组件要发挥作用，总是要渲染一些东西，render函数并不做实际的渲染动作，它只是返回一个JSX描述的结构，最终由React来操作渲染过程。</p><p>当然，某些特殊组件的作用不是渲染界面，或者，组件在某些情况下选择没有东西可画，那就让render函数返回一个null或者false，等于告诉React，这个组件这次不需要渲染任何DOM元素。</p><p>需要注意的时，render函数应该是一个纯函数，是完全根据this.state和this.props来决定返回的结果，而且不要产生任何副作用。在render函数中去调用this.setState毫无疑问是错误的，因为一个纯函数不应该引起状态的改变。</p><ul><li>4) componentWillMount和componentDidMount</li></ul><p>在装在过程中，componentWillMount会在调用render函数之前被调用，componentDidMount会在调用render函数之后被调用，这两个函数就像是render函数的前哨和后卫，一前一后，把render函数夹住，正好分别做render前后必要的工作。</p><p>不过，我们通常不用定义componentWillMount函数，顾名思义，componentWillMount发生在“将要装载”的时候，这个时候没有任何渲染出来的结果，即使调用this.setState修改状态也不会引发重新绘制，一切都迟了。换句话说，所有可以在这个componentWillMount中做的事情，都可以提前到constructor中去做，可以认为这个函数存在的主要目的就是为了和componentDidMount对称。</p><p>而componentDidMount作用就大了，需要注意的是，render函数被调用完之后，componentDidMount函数并不是会被立刻调用，componentDidMount被调用的时候，render函数返回的东西已经引发了渲染，组件已经被装载到了DOM树上。</p><p>我们还是以ControlPanel为例，在ControlPanel中有三个Counter组件，我们稍微修改Counter的代码，让装在过程中所有生命周期函数都用console.log输出函数名和caption的值，比如，componentWillMount函数的内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'enter componentWillMount '</span> + <span class="keyword">this</span>.props.caption);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器的console里我们能够看见：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enter constructor: First</span><br><span class="line">enter componentWillMount First</span><br><span class="line">enter render First</span><br><span class="line">enter constructor: Second</span><br><span class="line">enter componentWillMount Second</span><br><span class="line">enter render Second</span><br><span class="line">enter constructor: Third</span><br><span class="line">enter componentWillMount Third</span><br><span class="line">enter render Third</span><br><span class="line">enter componentDidMount First</span><br><span class="line">enter componentDidMount Second</span><br><span class="line">enter componentDidMount Third</span><br></pre></td></tr></table></figure><p>可以清楚的看到，虽然componentWillMount都是紧贴着自己组件的render函数之前被调用，componentDidMount可不是紧跟着render函数被调用，当所有三个组建的render函数都被调用之后，三个组件的componentDidMount才连在一起被调用。</p><hr><h3 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h3><!-- Todo --><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《Todo》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个合格的开发者，不能只满足于编写出可以运行的代码，而要了解代码背后的工作原理；不能只满足于自己编写的程序能够运行，还要让自己的代码可读而且易于维护。这样才能开发出高质量的软件。&lt;/p&gt;
    
    </summary>
    
      <category term="React抄书笔记" scheme="http://www.xiaoleon.cn/categories/React%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.xiaoleon.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(1) 新的前端思维方式</title>
    <link href="http://www.xiaoleon.cn/2018/03/04/react-1/"/>
    <id>http://www.xiaoleon.cn/2018/03/04/react-1/</id>
    <published>2018-03-04T01:51:31.000Z</published>
    <updated>2018-03-04T13:28:11.578Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来只管认识React，对任何一种工具，只有使用才能够熟练掌握，React也不例外。通过对React快速上手，我们会解析React的工作原理，并通过与功能相同的jQuery程序对比，从而看出React的特点。</p><a id="more"></a><h3 id="一、初始化一个React项目"><a href="#一、初始化一个React项目" class="headerlink" title="一、初始化一个React项目"></a>一、初始化一个React项目</h3><p>React是一个JavaScript语言的工具库，我们需要安装Node.js，React本身并不依赖于Node.js，但是我们开发中用到的诸多工具需要Node.js的支持。</p><p>在Node.js的官网（<a href="https://nodejs.org" target="_blank" rel="noopener">https://nodejs.org</a>）可以找到合适的安装方式，安装Node.js的同时也就安装了npm，npm是Node.js的安装包管理工具，因为我们不可能自己开发所有功能，会大量使用现有的安装包，就需要npm的帮助。</p><h4 id="1-create-react-app工具"><a href="#1-create-react-app工具" class="headerlink" title="1. create-react-app工具"></a>1. create-react-app工具</h4><p>React技术依赖于一个很庞大的技术栈，比如，转译JavaScript代码需要使用Babel，模块打包工具又要使用Webpack，定制build过程需要grunt或者gulp，这些技术栈都需要各自的配置文件，还没有开始写一行React相关代码，我们就已经被各种技术名词淹没。</p><p>针对这种情况，React的创建者Facebook提供了一个快速开发React应用的工具，名叫<code>create-react-app</code>，这个工具的目的是将开发人员从配置工作中解脱出来，无需过早关注这些技术栈细节，通过创建一个已经完成基本配置的应用，让开发者快速开始React应用的开发。</p><p>create-react-app是一个通过npm发布的安装包，在确认Node.js和npm安装好之后，命令行中执行下面的命令安装create-react-app：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure><p>安装结束后，我们可以通过如下命令创建react项目：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app first_react_app</span><br></pre></td></tr></table></figure><p>这个命令会在当前目录创建一个名为first_react_app的目录，在这个目录中会自动添加一个应用的框架，随后我们只需要在这个框架的基础上修改文件就可以开发React应用，避免了大量的手工配置工作。</p><p>在create-react-app命令一大段文字输出之后，根据提示，输入下面的命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> first_react_app</span><br><span class="line">npm <span class="built_in">start</span></span><br></pre></td></tr></table></figure><p>这个命令会启动一个开发模式的服务器，同时也会让浏览器自动打开一个网页，指向本机地址<code>http://localhost:3000</code>。</p><p><img src="/images/react-1/1.png" alt="第一个React应用"></p><p>接下来，我们会用React开发一个简单的功能。</p><hr><h3 id="二、增加一个新的React组件"><a href="#二、增加一个新的React组件" class="headerlink" title="二、增加一个新的React组件"></a>二、增加一个新的React组件</h3><p>React的首要思想是通过组件（Component）来开发应用。所谓组件，简单说，指的是能完成某个特定功能的独立的、可重用的代码。</p><p>基于组件的应用开发是广泛使用的软件开发模式，用分而治之的方法，把一个大的应用分解成若干小的组件，每个组件只关注于某个小范围的特定功能，但是把组件组合起来，就能构成一个功能庞大的应用。如果分解功能的过程足够巧妙，那么每个组件可以在不同场景下重用，那么不光可以构建庞大的应用，还可以构建出灵活的应用。打个比方，每个组件是一块砖，而一个应用是一座楼，想要一次锻造就创建一座楼是不现实的。实际上，总是先锻造出很多砖，通过排列组合这些砖，才能构建伟大的建筑。</p><p>我们先看看create-react-app给我们自动产生的代码，在first_react_app目录下包含如下文件和目录。</p><p><img src="/images/react-1/2.png" alt="文件目录"></p><p>在开发过程中，我们主要关注src目录中的内容，这个目录中是所有的源代码。</p><p>create-react-app所创建的应用的入口是<code>src/index.js</code>文件，我们看看中间的内容，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个应用所做的事情，只是渲染一个名叫App的组件，App组件在同目录下的App.js文件中定义，渲染出来的效果就是在上图中看到的界面。</p><p>我们要定义一个新的能够计算点击数组件，名叫<code>ClickCounter</code>，所以我们修改index.js文件如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> ClickCounter <span class="keyword">from</span> <span class="string">'./ClickCounter'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ClickCounter /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>接下来我们会介绍代码的含义。现在我们先来看看如何添加一个新组建，在src目录下添加一个新的代码文件<code>ClickCounter.js</code>，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.onClickButton = <span class="keyword">this</span>.onClickButton.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onClickButton() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.onClickButton&#125;&gt;Click Me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          Click Count: &#123; this.state.count &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default ClickCounter;</span></span><br></pre></td></tr></table></figure><p>我们可以在网页中看到，其中内容已经发生改变，如下图所示</p><p><img src="/images/react-1/3.png" alt="ClickCounter组件界面效果"></p><p>点击“Click Me”按钮，可以看到“Click Count”后面的数字会随之增加，每点击一次加1.</p><p>现在让我们来逐步详细解释代码中各部分的要义。</p><p>在index.js文件中，使用import导入了ClickCounter组件，代替了之前的App组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ClickCounter <span class="keyword">from</span> <span class="string">'./ClickCounter'</span>;</span><br></pre></td></tr></table></figure><p><code>import</code>是ES6语法中导入文件模块的方式，ES6语法是一个大集合，大部分功能都被最新浏览器支持。不过这个import方法却不在广泛支持之列，这没有关系，ES6语法的JavaScript会被webpack和babel转译成所有浏览器支持的ES5语法，而这一切都无需开发人员配置，create-react-app已经替我们完成了这些工作。</p><p>在ClickCounter.js文件的第一行，我们从react库中引入了React和Component，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br></pre></td></tr></table></figure><p>Component作为所有组件的基类，提供了很多组建共有的功能，下面这行代码，使用的是ES6语法来创建一个叫ClickCounter的组建类，ClickCounter的父类就是Component：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>在React出现之初，使用的是React.createClass方式来创造组件类，这种方法已经被废弃了。在本文中，我们只使用ES6的语法来构建组件类。</p><p>虽然我们导入的Component类在ClickCounter组件定义中使用了，可是导入的React却没有被使用，难道这里引入React没有必要吗？</p><p>事实上，引入React非常必要，我们可以尝试删掉第一行中的React，在网页中立刻会出现错误信息。</p><p><img src="/images/react-1/4.png" alt="缺失React的错误"></p><p>这个错误的含义是：“在使用JSX的范围内必须要有React。”</p><p>也就是说，在使用JSX的代码文件中，即使代码中并没有直接使用React，也一定要导入React，这是因为JSX最终会被转译成依赖于React的表达式。</p><h4 id="1-JSX"><a href="#1-JSX" class="headerlink" title="1. JSX"></a>1. JSX</h4><p>所谓JSX，是JavaScript的语法扩展（eXtension），让我们在JavaScript中可以编写像HTML一样的代码。在ClickCounter.js的render函数中，就出现了类似这样的HTML代码，在index.js中，ReactDOM.render的第一个参数<code>&lt;App /&gt;</code>也是一段JSX代码。</p><p>JSX中的这几段代码看起来和HTML几乎一模一样，都可以使用<code>&lt;div&gt;</code>、<code>&lt;button&gt;</code>之类的元素，所以只要熟悉HTML，学习JSX完全不成问题，但是，我们一定要明白两者的不同之处。</p><p>首先，在JSX中使用的“元素”不局限于HTML元素，可以是任何一个React组件，在App.js中可以看到，我们创建的ClickCounter组件被直接应用在JSX中，使用方法和其他元素一样，这一点是传统的HTML做不到的。</p><p>React判断一个元素是HTML元素还是React元素的原则就是看第一个字母是否大写，如果在JSX中我们不用ClickCounter而是用clickCounter，那就得不到我们想要的结果。</p><p>其次，在JSX中可以通过onClick的方式给一个元素添加一个事件处理函数，当然，在HTML中也可以使用onclick（注意和onClick拼写有区别），但在HTML中直接书写onclick一直就是为人诟病的写法，网页应用开发界一直倡导的是用jQuery的方法添加事件处理函数，直接写onclick会带来代码混乱的问题。</p><p>这就带来一个问题，既然长期以来一直不提倡在HTML中使用onclick，为什么在React的JSX中我们却要使用onClick这样的方式来添加事件处理函数呢？</p><h4 id="2-JSX是进步还是倒退"><a href="#2-JSX是进步还是倒退" class="headerlink" title="2. JSX是进步还是倒退"></a>2. JSX是进步还是倒退</h4><p>在React出现之初，很多人对React这样的设计非常反感，因为React把类似HTML的标记语言和JavaScript混在一起了，但是，随着时间的推移，业界逐渐认可了这种方式，因为大家都发现，以前用HTML来代表内容，CSS代笔样式，Javascript来定义交互行为，这三种语言分在三种不同的文件里面，实际上是把不同技术分开管理了，而不是逻辑上的“分而治之”。</p><p>根据做同一件事的代码应该有高耦合性的设计原则，既然我们要实现一个ClickCounter，那为什么不把实现这个功能的所有代码集中在一个文件里呢？</p><p>那么，在JSX中使用onClick添加事件处理函数，是否代表网页应用开发兜了一个大圈，最终回到了起点呢？</p><p>不是这样，JSX的onClick事件处理方式和HTML的onclick有很大不同。</p><p>即使现在，我们还是要说在HTML中直接使用onclick很不专业，原因如下：</p><ul><li><p>onclick添加的事件处理函数是在全局环境下执行的，这污染了全局环境，很容易产生意料不到的后果</p></li><li><p>给很多Dom元素添加click时间，可能会影响网页的性能，毕竟，网页需要的事件处理函数越多，性能就会越低</p></li><li><p>对于使用onclick的Dom元素，如果要动态地从DOM树中删掉的话，需要把对应的事件处理器注销，假如忘了注销，就可能造成内存泄漏，这样的bug很难被发现</p></li></ul><p>上面说的这些问题，在JSX中都不存在。</p><p>首先，onClick挂载的每个函数，都可以控制在组建范围内，不会污染全局空间。</p><p>我们在JSX中看到一个组件使用了onClick，但并没有产生直接使用onclick的HTML，而是使用了事件委托（event delegation）的方式处理点击事件，无论有多少个onClick出现，其实最后都只在DOM树上添加了一个事件处理函数，挂在最顶层的DOM节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组建分配给特定函数，使用事件委托的性能当然要比为每个onClick都挂载一个事件处理函数要高。</p><p>因为React控制了组件的生命周期，在unmount的时候自然能够清除相关的所有事件处理函数，内存泄漏也不再是一个问题。</p><p>除了在组件中定义交互行为，我们还可以在React组件中定义样式，我们可以修改ClickCounter.js中的render函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> counterStyle = &#123;</span><br><span class="line">    margin: <span class="string">'16px'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;counterStyle&#125;&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.onClickButton&#125;&gt;Click Me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      Click Count: &lt;span id="clickCount"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在JavaScript代码中定义一个counterStyle对象，然后在JSX中赋值给顶层div的style属性，可以在网页中看到这个部分的margin真的变大了。</p><p>这样，React的组件可以把JavaScript、HTML和CSS的功能写在一个文件中，实现真正的组件封装。</p><hr><h3 id="三、分解React应用"><a href="#三、分解React应用" class="headerlink" title="三、分解React应用"></a>三、分解React应用</h3><p>前面我们提到过，React应用实际上依赖于一个很大很复杂的技术栈，我们使用create-react-app避免在一开始就费太多精力配置技术栈，不过现在是时候了解一下这个技术栈了。</p><p>我们启动React应用的命令是<code>npm start</code>，看看package.json中对start脚本的定义。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "react-scripts start",</span><br><span class="line">  "build": "react-scripts build",</span><br><span class="line">  "test": "react-scripts test --env=jsdom",</span><br><span class="line">  "eject": "react-scripts eject"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，start命令实际上是调用了react-scripts命令，react-scripts是create-react-app添加的一个npm包，所有的配置文件都藏在node_modules/react-scripts目录下，我们当然可以钻进这个目录去一探究竟，但是也可以使用eject方法来看清楚背后的原理。</p><p>这个eject（弹射）命令做的事情，就是把潜藏在react-scripts中的一系列技术栈配置都“弹射”到应用的顶层，然后我们就可以研究这些配置细节了，而且可以更灵活地定制应用的配置。</p><blockquote><p>eject命令是不可逆的，就好像战斗机飞行员选择“弹射”出驾驶舱，等于是放弃了这架战斗机，是不可能再飞回驾驶舱的。所以，当你执行eject之前，最好做一下备份。</p></blockquote><p>我们在命令行下执行下面的命令，完成“弹射”操作：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run eject</span><br></pre></td></tr></table></figure><p>这个命令会改变一些文件，也会添加一些文件。</p><p>当前目录下会增加两个目录，一个是scripts，另一个是config，同时，package.json文件中的scripts部分也发生了变化：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "node scripts/start.js",</span><br><span class="line">  "build": "node scripts/build.js",</span><br><span class="line">  "test": "node scripts/test.js --env=jsdom"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从此以后，start脚本将使用scripts目录下的start.js，而不是node_modules目录下的react-scripts，弹射成功，再也回不去了。</p><p>在config目录下的webpack.config.dev.js文件，定制的就是npm start所做的构造过程，其中有一段关于babel的定义：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test"</span>: /\.(js|jsx)$/,</span><br><span class="line">  <span class="attr">"include"</span>: paths.appSrc,</span><br><span class="line">  <span class="attr">"loader"</span>: <span class="string">"babel"</span>,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    // This is a feature of 'babel-loader' for webpack (not Babel itself).</span><br><span class="line">    // It enables caching results in ./node_modules/.cache/babel-loader/</span><br><span class="line">    // directory for faster rebuilds.</span><br><span class="line">    "cacheDirectory": true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的paths.appSrc的值就是src，所以这段配置的含义指的是所有以js或者jsx为扩展名的文件，都会由babel所处理。</p><p>并不是所有的浏览器都支持所有的ES6语法，但是有了babel，我们就可以不用顾忌太多，因为babel会把ES6语法的JavaScript代码转译为浏览器普遍支持的JavaScript代码，实际上，在React社区中，不使用ES6语法写代码才显得奇怪。</p><hr><h3 id="四、React的工作方式"><a href="#四、React的工作方式" class="headerlink" title="四、React的工作方式"></a>四、React的工作方式</h3><p>在继续深入学习React的其他知识之前，我们先就这个简单的ClickCounter组件思考一下React的工作方式，要了解一样东西的特点，最好的方法当然是拿这个东西和另一样东西做比较。我们就拿React和jQuery来比较。</p><h4 id="1-jQuery如何工作"><a href="#1-jQuery如何工作" class="headerlink" title="1. jQuery如何工作"></a>1. jQuery如何工作</h4><p>假设我们用jQuery来实现ClickCounter的功能，该怎么做呢？首先，我们要产生一个网页的HTML，写一个index.html文件如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"ClickMe"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        Click Count: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"clickCount"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./clickCounter.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实际产品中，产生这样的HTML可以用PHP、Java、Ruby或者任何一种服务器端语言和框架来做，也可以在浏览器中用Mustache、Hogan这样的模板来产生，这里我们只是把问题简化，直接书写HTML。</p><p>上面的HTML只是展示样式，并没有任何交互功能，现在我们用jQuery来实现交互功能，和jQuery的传统一样，我们把JavaScript写在一个独立的文件clickCounter.js中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#clickMe'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clickCounter = $(<span class="string">'#clickCount'</span>);</span><br><span class="line">    <span class="keyword">var</span> count = <span class="built_in">parseInt</span>(clickCounter.text(), <span class="number">10</span>);</span><br><span class="line">    clickCounter.text(count + <span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>用浏览器打开上面创造的index.html，可以看到实际效果和我们写的React应用一模一样，但是对比这两段程序可以看出差异。</p><p>在jQuery解决方案中，首先根据CSS规则找到id为clickCount的按钮，挂上一个匿名事件处理函数，在事件处理函数中，选中那个需要被修改的DOM元素，读取其中的文本值，加以修改，然后修改这个DOM元素。</p><p>选中一些DOM元素，然后对这些元素做一些操作，这是一种最容易理解的开发模式。jQuery的发明人John Resig就是发现了网页应用开发者的这种编程模式，才创造出了jQuery，其一问世就得到普遍认可，因为这种模式直观易懂。但是，对于庞大的项目，这种模式会造成代码结构复杂，难以维护，每个jQuery的使用者都会有这种体会。</p><h4 id="2-React的理念"><a href="#2-React的理念" class="headerlink" title="2. React的理念"></a>2. React的理念</h4><p>与jQuery不同，用React开发应用是另一种体验，我们回顾一下，用React开发的ClickCounter组件好像没有像jQuery那样做“选中一些DOM元素然后做一些事情”的动作。</p><p>打一个比方，React是一个聪明的建筑工人，而jQuery是一个比较傻的建筑工人，开发者你就是一个建筑的设计师，如果是jQuery这个建筑工人为你工作，你不得不事无巨细地告诉jQuery“如何去做”，要告诉他这面墙要拆掉重建，那面墙上要新开一个窗户。反之，如果是React这个建筑工人为你工作，你所要做的就是告诉这个工人“我想要什么样子”，只要把图纸递给React这个工人，他就会替你搞定一切，当然他不会把整个建筑拆掉重建，而是很聪明地把这次的图纸和上次的图纸做一个对比，发现不同之处，然后只去做适当的修改就完成任务了。</p><p>显而易见，React的工作方式把开发者从繁琐的操作中解放出来，开发者只需要着重“我想要显示什么”，而不用操心“怎样去做”。</p><p>这种新的思维方式，对于一个简单的例子也要编写不少代码，感觉像是用高射炮打蚊子，但是对于一个大型的项目，这种方式编写的代码会更容易管理，因为整个React应用要做的就是渲染，开发者关注的是渲染成什么样子，而不用关心如何实现增量渲染。</p><p>React的理念，归结为一个公式，就像下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UI = render(data)</span><br></pre></td></tr></table></figure><p>让我们来看看这个公示表达的含义，用户看到的界面（UI），应该是一个函数（在这里叫render）的执行结果，只接受数据（data）作为参数。这个函数是一个纯函数，所谓纯函数，指的是没有任何副作用，输出完全依赖于输入的函数，两次函数调用如果输入相同，得到的结果也绝对相同。如此一来，最终的用户界面，在render函数确定的情况下完全取决于输入数据。</p><p>对于开发者来说，重要的是区分开哪些属于data，哪些属于render，想要更新用户界面，要做的就是更新data，用户界面自然会做出响应，所以React实践的也是“响应式编程”（Reactive Programming）的思想，这也就是React为什么叫做React的原因。</p><h4 id="3-Virtual-DOM"><a href="#3-Virtual-DOM" class="headerlink" title="3. Virtual DOM"></a>3. Virtual DOM</h4><p>既然React应用就是通过重复渲染实现用户交互，我们可能会有一个疑虑：这样的重复渲染会不会效率太低了呢？毕竟，在jQuery的实现方式中，我们可以清楚地看到每次只有需要变化的那一个DOM元素被修改了；可是，在React的实现方式中，看起来每次render函数被调用，都要把整个组件重新绘制一次，这样看起来有点浪费。</p><p>事实并不是这样，React利用Virtual DOM，让每次渲染都重新渲染最少的DOM元素。</p><p>要了解Virtual DOM，就要先了解DOM，DOM是结构化文本的抽象表达形式，特定于Web环境中，这个结构化文本就是HTML文本，HTML中的每个元素都对应DOM中的某个节点，这样，因为HTML元素的逐级包含关系，DOM节点自然就构成了一个树形结构，称为DOM树。</p><p>浏览器为了渲染HTML格式的网页，会先将HTML文本解析以构建DOM树，然后根据DOM树渲染出用户看到的界面，当要改变界面内容的时候，就去改变DOM树上的节点。</p><p>Web前端开发关于性能优化有一个原则：尽量减少DOM操作。虽然DOM操作也只是一些简单的JavaScript语句，但是DOM操作会引起浏览器对网页进行重新布局，重新绘制，这就是一个比JavaScript语句执行慢很多的过程。</p><p>如果使用mustache或者hogan这样的模板工具，那就是生成HTML字符串塞到网页中，浏览器又要做一次解析产生新的DOM节点，然后替换DOM树上对应的子树部分，这个过程肯定效率不高。虽然JSX看起来很像是一个模板，但是最终会被Babel解析为一条条创建React组件或者HTML元素的语句，神奇之处在于，React并不是通过这些语句直接构建DOM树，而是首先构建Virtual DOM。</p><p>既然DOM树是对HTML的抽象，那Virtual DOM就是对DOM树的抽象。Virtual DOM不会触及浏览器的部分，只是存在于JavaScript空间的树形结构，每次自上而下渲染React组件时，会对比这一次产生的Virtual DOM和上一次渲染的Virtual DOM，对比就会发现差别，然后修改真正的DOM树时就只需要触及差别中的部分就行。</p><p>以ClickCounter为例，一开始点击计数为0，用户点击按钮让点击计数变成1，这一次重新渲染，React通过Virtual DOM的对比发现其实只是id为clickCounter的span元素中内容从0变成了1而已：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"clickCounter"</span>&gt;</span>&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React发现这次渲染要做的事情只是更换span元素的内容而已，其他DOM元素都不需要触及，于是执行类似下面的语句，就完成了任务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'clickCounter'</span>).innerHTML = <span class="string">"1"</span>;</span><br></pre></td></tr></table></figure><h4 id="4-React工作方式的优点"><a href="#4-React工作方式的优点" class="headerlink" title="4. React工作方式的优点"></a>4. React工作方式的优点</h4><p>毫无疑问，jQuery的方式直观易懂，对于初学者十分适用，但是当项目逐渐变得庞大时，用jQuery写出的代码往往互相纠缠，形成类似下图的状况，难以维护。</p><p><img src="/images/react-1/5.png" alt="jQuery方式造成的纠缠代码结构"></p><p>使用React的方式，就可以避免构建这样复杂的程序结构，无论何种事件，引发的都是React组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发者并不需要关心，程序的流程简化为如下方式。</p><p><img src="/images/react-1/6.png" alt="React的程序流程"></p><p>React利用函数式编程的思维来解决用户界面渲染的问题，最大的优势是开发者的效率会大大提高，开发出来的代码可维护性和可阅读性也大大增强。</p><p>React等于强制所有组件都按照这种由数据驱动渲染的模式来工作，无论应用的规模多大，都能让程序处于可控范围内。</p><hr><h3 id="五、本文小结"><a href="#五、本文小结" class="headerlink" title="五、本文小结"></a>五、本文小结</h3><p>在本文中，我们用create-react-app创造了一个简单的React应用，在一开始，我们就按照组件的思想来开发应用，React的主要理念之一就是基于组件来开发应用。</p><p>通过和同样功能的jQuery实现方式对比，我们了解了React的工作方式，React利用声明式的语法，让开发者专注于描述用户界面“显示成什么样子”，而不是重复思考“如何去显示”，这样可以大大提高开发效率，也让代码更加容易管理。</p><p>虽然React是通过重复渲染来实现动态更新效果，但是借助Virtual DOM技术，实际上这个过程并不牵涉太多的DOM操作，所以渲染效率很高。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《深入浅出React和Redux —— 程墨》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们先来只管认识React，对任何一种工具，只有使用才能够熟练掌握，React也不例外。通过对React快速上手，我们会解析React的工作原理，并通过与功能相同的jQuery程序对比，从而看出React的特点。&lt;/p&gt;
    
    </summary>
    
      <category term="React抄书笔记" scheme="http://www.xiaoleon.cn/categories/React%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.xiaoleon.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Web(5) HTTP与HTTPS</title>
    <link href="http://www.xiaoleon.cn/2018/03/02/web-5/"/>
    <id>http://www.xiaoleon.cn/2018/03/02/web-5/</id>
    <published>2018-03-02T02:15:50.000Z</published>
    <updated>2018-03-02T12:57:37.783Z</updated>
    
    <content type="html"><![CDATA[<p>超文本传输协议HTTP被用于Web浏览器和网站服务器之间传递信息，HTTP以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><a id="more"></a><h3 id="一、TCP-IP、HTTP、HTTPS"><a href="#一、TCP-IP、HTTP、HTTPS" class="headerlink" title="一、TCP/IP、HTTP、HTTPS"></a>一、TCP/IP、HTTP、HTTPS</h3><ul><li><p>TCP/IP：传输层协议，主要解决数据如何在网络中传输，Web服务器将HTTP封装好的文本信息，通过TCP/IP协议发送到网络上。</p></li><li><p>HTTP：应用层协议，用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p></li><li><p>HTTPS：以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p></li></ul><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><p>下面的图表显示OSI（Open System Interconnect）模型中的各项协议：</p><table><thead><tr><th>OSI层</th><th>协议名称</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP</td></tr><tr><td>表示层</td><td>XDR、ASN.1、SMB、AFP、NCP</td></tr><tr><td>会话层</td><td>ASAP、TLS、SSH、ISO 8327 / CCITT X.255、RPC、NetBIOS、ASP、Winsock、BSD sockets</td></tr><tr><td>传输层</td><td>TCP、UDP、RTP、SCTP、SPX、ATP、IL</td></tr><tr><td>网络层</td><td>IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25</td></tr><tr><td>数据链路层</td><td>以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP</td></tr><tr><td>物理层</td><td>线路、无线电、光钎、信鸽</td></tr></tbody></table><hr><h3 id="二、HTTP与HTTPS有什么区别"><a href="#二、HTTP与HTTPS有什么区别" class="headerlink" title="二、HTTP与HTTPS有什么区别"></a>二、HTTP与HTTPS有什么区别</h3><p>HTTP传输的数据都是未加密的，也就是明文的，因此使用HTTP传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTPS构建的可进行传输加密、身份认证的网络协议，要比HTTP安全。</p><p>HTTPS和HTTP的主要区别如下：</p><ul><li><p>1) HTTPS协议需要到CA申请证书，一般免费证书较少，因而需要一定费用</p></li><li><p>2) HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议</p></li><li><p>3) HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，HTTP是80，HTTPS是443</p></li><li><p>4) HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP构建的可进行加密传输、身份认证的网络协议，比HTTP更安全</p></li></ul><hr><h3 id="三、HTTP三次握手"><a href="#三、HTTP三次握手" class="headerlink" title="三、HTTP三次握手"></a>三、HTTP三次握手</h3><p><img src="/images/web-5/1.png" alt="HTTP三次握手时序图"></p><p>TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p><ul><li><p>1) 第一次握手：客户端发送syn包（syn=j）到服务器，并进入SYN_SEND状态，等待服务器确认</p></li><li><p>2) 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态</p></li><li><p>3) 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p></li></ul><hr><h3 id="四、HTTP四次挥手"><a href="#四、HTTP四次挥手" class="headerlink" title="四、HTTP四次挥手"></a>四、HTTP四次挥手</h3><p><img src="/images/web-5/2.png" alt="HTTP四次挥手时序图"></p><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>HTTP的关闭需要发送四个包，因此称为四次挥手（four-way handshake）。客户端或服务端均可主动发起挥手操作，在socket中，任何一方执行close()操作即可产生挥手操作。</p><ul><li><p>1) 客户端发送一个FIN，用来关闭客户端到服务端的数据传送</p></li><li><p>2) 服务端收到这个FIN，返回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号</p></li><li><p>3) 服务端关闭与客户端的连接，发送一个FIN到客户端</p></li><li><p>4) 客户端发挥ACK报文确认，并将确认序号设置为收到序号加1</p></li></ul><hr><h3 id="五、HTTPS的工作原理"><a href="#五、HTTPS的工作原理" class="headerlink" title="五、HTTPS的工作原理"></a>五、HTTPS的工作原理</h3><p><img src="/images/web-5/3.png" alt="HTTPS通信"></p><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><ul><li><p>1) 客户使用HTTPS的URL访问Web服务器，要求与Web服务器建立SSL连接</p></li><li><p>2) Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端</p></li><li><p>3) 客户端解析证书，首先验证公钥是否有效，比如颁发机构、过期时间等，如果发现异常，则会弹出警告框，提示证书存在问题</p></li><li><p>4) 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级</p></li><li><p>5) 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给Web服务器</p></li><li><p>6) Web服务器利用字迹的私钥解密出会话密钥</p></li><li><p>7) Web服务器利用会话密钥加密与客户端之间的通信</p></li></ul><p><img src="/images/web-5/4.png" alt="HTTPS连接时序图"></p><hr><h3 id="六、HTTPS的优点"><a href="#六、HTTPS的优点" class="headerlink" title="六、HTTPS的优点"></a>六、HTTPS的优点</h3><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是当前架构下最安全的解决方案，主要有以下几个好处：</p><ul><li><p>1) 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户端和服务器</p></li><li><p>2) HTTPS协议是由SSL+HTTP构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性</p></li><li><p>3) HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本</p></li><li><p>4) Google曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”</p></li></ul><hr><h3 id="七、HTTPS的缺点"><a href="#七、HTTPS的缺点" class="headerlink" title="七、HTTPS的缺点"></a>七、HTTPS的缺点</h3><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><ul><li><p>1) HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%-20%的耗电</p></li><li><p>2) HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响</p></li><li><p>3) SSL整数需要收费，功能越强大的整数费用越高，个人网站、小网站没有必要一般不会用</p></li><li><p>4) SSL整数通常需要绑定IP，不能再同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗</p></li><li><p>5) HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务供给、服务器劫持等方面几乎起不到什么作用。最关键的，SSL整数的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="https://www.cnblogs.com/wqhwe/p/5407468.html" target="_blank" rel="noopener">HTTP与HTTPS的区别</a></p></li><li><p><a href="https://www.cnblogs.com/lovesong/p/5186200.html" target="_blank" rel="noopener">HTTP与HTTPS握手的那些事</a></p></li><li><p><a href="https://www.cnblogs.com/Jessy/p/3535612.html" target="_blank" rel="noopener">TCP的三次握手（建立连接）和四次挥手（关闭连接）</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;超文本传输协议HTTP被用于Web浏览器和网站服务器之间传递信息，HTTP以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。&lt;/p&gt;
&lt;p&gt;为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HTTP" scheme="http://www.xiaoleon.cn/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="http://www.xiaoleon.cn/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>其他(1) 软考论文经验</title>
    <link href="http://www.xiaoleon.cn/2018/03/01/ruankao-1/"/>
    <id>http://www.xiaoleon.cn/2018/03/01/ruankao-1/</id>
    <published>2018-03-01T05:43:29.000Z</published>
    <updated>2018-03-05T14:35:56.004Z</updated>
    
    <content type="html"><![CDATA[<p>17年下半年的信息系统项目管理师考试，前前后后间断复习了大概3个月，没想到最后一次过了，挺意外的。</p><a id="more"></a><p>由于上班比较忙，所以也没有很系统的进行相关复习，都是零碎时间看点真题，然后上信管网来看看案例分析。这里客观题和主观题就不作经验分享了，感觉自己能拿这个分数纯属巧合，主要介绍一下自己论文的一点经验。</p><h3 id="一、练字"><a href="#一、练字" class="headerlink" title="一、练字"></a>一、练字</h3><p>论文属于纯手写考试，评卷老师的第一感官便是我们的卷面整洁及清晰程度，我们至少应当做到字迹清晰工整，这样可以给评卷老师留下一个好的第一印象，同时节省评卷的时间。如果字迹优雅、布局工整，相信评卷老师也会从内心里当作是一副书法作品来阅读。</p><p>另外，我们需要做到在2个小时的考试时间内，保持字迹大体一致，减少评卷老师在字迹上的心理变化。从字迹的变化上能够很容易反映出考生的心理状态，比如没有提前做好论文的前期准备，就容易出现大量的划痕；或者后期时间不够了，容易出现心里焦躁，字迹越来越乱的情况。</p><p>我在写论文的时候，就出现了最后半小时发现时间不够用的情况，最后的500-600字由于时间特别赶，导致字迹开始越来越乱，最后写完大概只剩下了不到3分钟。从卷面上，能够很明显的感觉到我当时慌乱的心境，也是没有准备充分的体现。现在想想，如果提前有充足的准备，应该不至于在这方面出现差错，分数可能也会比当前的49要高一些吧。</p><hr><h3 id="二、提速"><a href="#二、提速" class="headerlink" title="二、提速"></a>二、提速</h3><p>论文考试是2个小时内，需要书写2500到3000字。如果没有经过提前练习，加上现在生活中提笔写字的机会接近于零，几乎是一个不可能完成的任务。因此，考前一定需要花上一段时间，每天练习写字速度，在保证文笔工整的前提下，尽量提高论文的行文速度。</p><p>这里给一个小建议，考前我们可以从网上下载一些模版论文，先完整地抄写几遍模板论文。这样可以计算出自己在完全不思考的情况下，写完一整篇论文的速度，然后再根据情况进行提速训练。</p><p>我考前大概抄写了9篇模板论文，取平均数的话，大概抄写完整篇文章需要1小时30分钟到1小时40分钟。也就是说，如果在考试过程中还需要构思，那思考时间最多只能控制在20分钟到30分钟内。这个时间可以说非常紧张，也正是因为在考试中，我还需要边写边思考后面的内容，所以才导致了最后的时间非常紧张。</p><hr><h3 id="三、模拟"><a href="#三、模拟" class="headerlink" title="三、模拟"></a>三、模拟</h3><p>由于论文考试需要书写在特定的答题纸上，因此我们可以利用这个答题纸的样式来进行提前练习。论文答题纸分为6页，摘要部分从第一页的中间到第二页的前几行，然后剩余的5页为正文部分。我们可以从信管网上下载答题纸模版pdf，然后打印出来，直接在上面抄写模板论文或书写准备的论文。</p><p>这样模拟练习后，我们就能够有个大概的概念，摘要第一部分应该写到哪一行，第二部分应该写到哪一行，总结的字数应该控制在多少。</p><p>我们把论文正文分为三大块：开头、正文、结尾。其中开头部分一般从第二页的前几行，书写到第三页的中间；正文部分从第三页的中间，书写到第五页的下方；结尾部分，从第五页的下方，书写到第六页的下方。</p><p>我们还可以划分时间节点，比如摘要大概花费20分钟，开头大概花费20分钟，正文大概花费60分钟，结尾大概花费20分钟。</p><p>这样经过模拟训练后，考场上我们就可以有条不紊的执行我们的考试规划，在指定时间和指定地点完整对应的书写工作。</p><hr><h3 id="四、模板"><a href="#四、模板" class="headerlink" title="四、模板"></a>四、模板</h3><p>由于信管考试论文的特殊性，9大类论点必考一题，使得我们可以针对这9项进行提前准备。</p><h4 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h4><p>摘要是整篇文章的内容浓缩，这里建议参考信管网或者各论坛的摘要写作指导，我建议在模拟练习中，将9大类的摘要都仔细思考并行文一遍，经过多次修改后，形成最后的模版。</p><p>考场上不太可能有足够的时间来思考摘要应该怎么写，时间是非常宝贵的，我们更应当花费时间去判断论题是否跟往年有所出入，如果题目要求与其他方面进行结合，应当怎么样在摘要模板中进行修改并点题。</p><p>可以说摘要是非常重要的，阅卷老师从摘要就能得出全文的第一印象，而且阅卷的特殊性，可能只有一两分钟的阅读时间，所以前期准备过程中需要好好斟酌。</p><p>我在考试过程中，发卷到开考前，思考了下论题是否和准备的模版有出入。开考后，直接落笔写摘要，大约10分钟写完摘要，把时间尽量多的留给正文部分。</p><h4 id="2-开头"><a href="#2-开头" class="headerlink" title="2. 开头"></a>2. 开头</h4><p>开头也是我们可以提前准备的部分，虽然9大类论题各不相同，但是论文要求我们与实际项目相结合，那么开头我们可以相对统一，比如介绍项目的背景、需求、技术等等，先提前准备好一个项目，把这个项目中涉及到的相关具体内容整理成文，同时借用一下网上模板论文中的一些好的语句进行串联，修改得到大约600-800字的开头。最后，多在准备过程中写几遍，把内容背下来，减少考试过程中的思考时间。</p><p>我在考试过程中，大约花了20分钟写论文开头，写到预先设计的第三页中间后，正好结束开头部分，开始写正文部分。</p><h4 id="3-正文"><a href="#3-正文" class="headerlink" title="3. 正文"></a>3. 正文</h4><p>正文是全文耗时最长，也最为重要的部分。这部分建议准备过程中，能够完整地把9大类论题，都思考成文一遍，考前再阅读记忆几次，这样考试过程中可以较为顺利的进行书写，从而减少构思的时间。</p><p>我在正文部分准备的不够充分，考前只思考和列举了9大类需要书写的提纲，以及能够用在这些提纲内的案例与项目结合点。在真正考试的时候，很明显的感觉到，有时候写完提纲要点，发现不知道具体的阐述内容应该如何落笔行文，还需要停下来花时间构思，这样非常浪费时间。</p><p>至于正文结构，建议采用如下格式（具体提纲忘了，请勿参考示例提纲）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">结合具体参与的项目，成本管理大概分为以下几点：</span><br><span class="line"></span><br><span class="line">1. 成本估算</span><br><span class="line"></span><br><span class="line">// 第一段，对成本估算的概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明是怎么完成成本估算过程的</span><br><span class="line"></span><br><span class="line">2. 成本预算</span><br><span class="line"></span><br><span class="line">// 第一段，对成本预算的概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明是怎么完成成本预算过程的</span><br><span class="line"></span><br><span class="line">3. 成本控制计划编制</span><br><span class="line"></span><br><span class="line">// 第一段，对成本控制计划编制进行概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明是怎么完成计划编制的</span><br><span class="line"></span><br><span class="line">4. 成本控制</span><br><span class="line"></span><br><span class="line">// 第一段，对成本控制进行概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明成本控制过程中出现了哪些问题，是怎么处理的</span><br></pre></td></tr></table></figure><p>我们可以提前准备一些项目中出现的案例，在合适的时机插入到正文当中，比如</p><ul><li><p>项目某个里程碑阶段，对项目的EV、AC、PV、SPI、CPI等进行分析，得出当前项目处于成本超支/节约，进度超前/落后，然后怎么样进行管理变化，使项目正常运行</p></li><li><p>项目某个时间点，有突发情况发生（项目组成员离开等等），我们是怎么应变调节的</p></li><li><p>项目计划编制中，我们采用了头脑风暴，技术专家评审等等方式，完成编制过程等等</p></li><li><p>分析项目的最长路径、总时差、自由时差等等</p></li></ul><h4 id="4-结尾"><a href="#4-结尾" class="headerlink" title="4. 结尾"></a>4. 结尾</h4><p>结尾部分同样可以采用提前准备的方式，9大类采用统一风格，当正文部分写到预定的区域后，即可开始书写提前准备的结尾部分。基本上按照既定的思路，写到文章结尾的时候，如果时间还比较充裕，那基本上离论文合格也就不远了。</p><p><img src="/images/ruankao-1/信管征文.jpg" alt="信管网获奖"></p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;17年下半年的信息系统项目管理师考试，前前后后间断复习了大概3个月，没想到最后一次过了，挺意外的。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://www.xiaoleon.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="软考" scheme="http://www.xiaoleon.cn/tags/%E8%BD%AF%E8%80%83/"/>
    
      <category term="信息系统项目管理师" scheme="http://www.xiaoleon.cn/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(11) 用Transition实现过渡动画</title>
    <link href="http://www.xiaoleon.cn/2018/02/27/css3-11/"/>
    <id>http://www.xiaoleon.cn/2018/02/27/css3-11/</id>
    <published>2018-02-27T08:09:00.000Z</published>
    <updated>2018-02-28T13:32:42.299Z</updated>
    
    <content type="html"><![CDATA[<p><code>transition</code>是网页上的过渡动画，在CSS3出现之前，网页上的动画大多是用flash实现的，但flash动画会产生很大的弊端，比如操作不便等等。</p><a id="more"></a><h3 id="一、定义和用法"><a href="#一、定义和用法" class="headerlink" title="一、定义和用法"></a>一、定义和用法</h3><p><code>transition</code>属性是一个简写属性，用于设置四个过渡属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">property</span> <span class="selector-tag">duration</span> <span class="selector-tag">timing-function</span> <span class="selector-tag">delay</span>;</span><br></pre></td></tr></table></figure><h4 id="1-transition-property"><a href="#1-transition-property" class="headerlink" title="1. transition-property"></a>1. <code>transition-property</code></h4><p><code>transition-property</code>属性规定应用过渡效果的CSS属性的名称。（当指定的CSS属性改变时，过渡效果将开始）。</p><blockquote><p>过渡效果通常在用户将鼠标指针浮动到元素上时发生。</p></blockquote><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>none</code></td><td>没有属性会获得过渡效果</td></tr><tr><td><code>all</code></td><td>所有属性都将获得过渡效果</td></tr><tr><td><code>property</code></td><td>定义应用过渡效果的css属性名称列表，列表以逗号分隔</td></tr></tbody></table><h4 id="2-transition-duration"><a href="#2-transition-duration" class="headerlink" title="2. transition-duration"></a>2. <code>transition-duration</code></h4><p><code>transition-duration</code>属性规定完成过渡效果需要多少秒或毫秒。需要始终设置该属性，否则时长为0，就不会产生过渡效果。</p><h4 id="3-transition-timing-function"><a href="#3-transition-timing-function" class="headerlink" title="3. transition-timing-function"></a>3. <code>transition-timing-function</code></h4><p><code>transition-timing-function</code>属性规定过渡效果的速度曲线。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>linear</code></td><td>规定以相同速度开始至结束的过渡效果（等于<code>cubic-bezier(0, 0, 1, 1)</code>）</td></tr><tr><td><code>ease</code></td><td>规定慢速开始，然后变快，然后慢速结束的过渡效果（<code>cubic-bezier(0.25, 0.1, 0.25, 1)</code>）</td></tr><tr><td><code>ease-in</code></td><td>规定以慢速开始的过渡效果（等于<code>cubic-bezier(0.42, 0.1, 1)</code>）</td></tr><tr><td><code>ease-out</code></td><td>规定以慢速结束的过渡效果（等于<code>cubic-bezier(0, 0, 0.58, 1)</code>）</td></tr><tr><td><code>ease-in-out</code></td><td>规定以慢速开始和结束的过渡效果（等于<code>cubic-bezier(0.42, 0, 0.58, 1)</code>）</td></tr><tr><td><code>cubic-bezier(n, n, n, n)</code></td><td>在<code>cubic-bezier</code>函数中定义自己的值。可能的值是0至1之间的数值</td></tr></tbody></table><h4 id="4-transition-delay"><a href="#4-transition-delay" class="headerlink" title="4. transition-delay"></a>4. <code>transition-delay</code></h4><p><code>transition-delay</code>规定在过渡效果开始之前需要等待的时间，以秒或毫秒计。</p><hr><h3 id="二、使用案例"><a href="#二、使用案例" class="headerlink" title="二、使用案例"></a>二、使用案例</h3><p>首先我们写一个字体出来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    div &#123;</span></span><br><span class="line"><span class="undefined">        width: 300px;</span></span><br><span class="line"><span class="undefined">        height: 100px;</span></span><br><span class="line"><span class="undefined">        padding-top: 20px;</span></span><br><span class="line"><span class="undefined">        line-height: 100px;</span></span><br><span class="line"><span class="undefined">        margin: 200px auto 0;</span></span><br><span class="line"><span class="undefined">        text-align: center;</span></span><br><span class="line"><span class="undefined">        font-size: 40px;</span></span><br><span class="line"><span class="undefined">        font-weight: bold;</span></span><br><span class="line"><span class="undefined">        font-family: '华文行楷';</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#ff6600</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>超炫火焰字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如图</p><p><img src="/images/css3-11/1.png" alt="效果图"></p><p>然后，我们给div加上hover效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">text-shadow</span>: 0<span class="selector-tag">px</span> 0<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> <span class="selector-id">#fff</span>,</span></span><br><span class="line"><span class="css">                0<span class="selector-tag">px</span> <span class="selector-tag">-3px</span> 3<span class="selector-tag">px</span> <span class="selector-id">#1eb</span>,</span></span><br><span class="line"><span class="css">                0<span class="selector-tag">px</span> <span class="selector-tag">-6px</span> 4<span class="selector-tag">px</span> <span class="selector-id">#01defd</span>,</span></span><br><span class="line"><span class="css">                0<span class="selector-tag">px</span> <span class="selector-tag">-12px</span> 6<span class="selector-tag">px</span> <span class="selector-id">#08f</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们会发现当鼠标进入这个div时，文字阴影一瞬间出现</p><p><img src="/images/css3-11/2.png" alt="效果图"></p><p>接着，我们修改hover效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    div &#123;</span></span><br><span class="line"><span class="undefined">        transition: all 1s liner 0s;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，鼠标进入div时，背景阴影经过了1s的过渡过程。</p><p><img src="/images/css3-11/3.gif" alt="效果图"></p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://blog.csdn.net/JianXingDeFeng/article/details/78708274" target="_blank" rel="noopener">用css3的transition实现过渡动画</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;transition&lt;/code&gt;是网页上的过渡动画，在CSS3出现之前，网页上的动画大多是用flash实现的，但flash动画会产生很大的弊端，比如操作不便等等。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS小技巧" scheme="http://www.xiaoleon.cn/categories/CSS%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="transition" scheme="http://www.xiaoleon.cn/tags/transition/"/>
    
  </entry>
  
  <entry>
    <title>算法(1) 斐波那契数列</title>
    <link href="http://www.xiaoleon.cn/2018/02/09/algorithm-1/"/>
    <id>http://www.xiaoleon.cn/2018/02/09/algorithm-1/</id>
    <published>2018-02-09T06:22:54.000Z</published>
    <updated>2018-02-27T13:36:40.181Z</updated>
    
    <content type="html"><![CDATA[<p>本文针对斐波那契数列的求值方法，分别采用递归法、尾递归法和迭代法进行分析，并提供其相关的代码实现。</p><a id="more"></a><p>今天看到公司笔试的一道算法题，题目如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">存在如下斐波那契数列： </span><br><span class="line"></span><br><span class="line">0, 1, 1, 2, 3, 5, 8, 13, 21...</span><br><span class="line"></span><br><span class="line">请编写函数，计算数列中第n项的值。</span><br></pre></td></tr></table></figure><h3 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h3><p>经过简单思考后，我们可以很容易的想到，可以采用递归的方式进行代码编写，因为第<code>n</code>项的值等于第<code>n-1</code>项和第<code>n-2</code>项的和，实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fib(n - <span class="number">2</span>) + Fib(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>.callee(n - <span class="number">1</span>) + <span class="built_in">arguments</span>.callee(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、尾递归"><a href="#二、尾递归" class="headerlink" title="二、尾递归"></a>二、尾递归</h3><p>然而，这种方式进行<code>n</code>值较大的计算时，非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（<code>stack overflow</code>）。这时，我们可以考虑采用<strong>尾递归</strong>的模式，实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fib</span>(<span class="params">n, ret1 = <span class="number">0</span>, ret2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> ret1;</span><br><span class="line">    <span class="keyword">return</span> Fib(n - <span class="number">1</span>, ret2, ret1 + ret2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过尾递归的方式，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。前面的代码需要保存<code>2n</code>个数据记录，复杂度<code>O(n)</code>。如果改成尾递归，只保留<code>3</code>个数据记录，复杂度<code>O(1)</code>。</p><p>尾递归实现的方式，在思路上采用了从前往后计算的方法，等效于使用了一个正向的<code>while</code>循环。而前面的递归采用的是从后往前倒推的方式。</p><h3 id="三、迭代法"><a href="#三、迭代法" class="headerlink" title="三、迭代法"></a>三、迭代法</h3><p>我们还可以采用一个迭代的方法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> [num1, num2, num3] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        [num3, num1, num2] = [num1 + num2, num2, num1 + num2];</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代实现的方法其实与尾递归是一个道理，迭代法比较通俗易懂，而且和尾递归比较起来，因为不用开辟栈空间，所以相对而言，迭代法的效率是最高的。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://es6.ruanyifeng.com/#docs/function#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%EF%BC%9F" target="_blank" rel="noopener">ESMAScript 6 入门 —— 阮一峰</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文针对斐波那契数列的求值方法，分别采用递归法、尾递归法和迭代法进行分析，并提供其相关的代码实现。&lt;/p&gt;
    
    </summary>
    
      <category term="算法分析" scheme="http://www.xiaoleon.cn/categories/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
    
      <category term="斐波那契数列" scheme="http://www.xiaoleon.cn/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    
      <category term="递归" scheme="http://www.xiaoleon.cn/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="尾递归" scheme="http://www.xiaoleon.cn/tags/%E5%B0%BE%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>微信(1) 小程序初体验</title>
    <link href="http://www.xiaoleon.cn/2018/02/01/wx-1/"/>
    <id>http://www.xiaoleon.cn/2018/02/01/wx-1/</id>
    <published>2018-02-01T07:50:13.000Z</published>
    <updated>2018-02-02T12:48:52.132Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开。这也体现了“用完即走”的理念，用户无需担心安装应用过多的问题。应用将无处不在，随时可用，但又无须安装卸载。</p><a id="more"></a><p>本文对微信小程序的架构进行了简要的介绍，让我们尽可能对小程序有个全局的认知，包括小程序的框架、目录结构、开发步骤等等。</p><p>小程序的开发实际上就是不同页面的展示（视图），以及实现“页面上用户交互事件”、“页面间切换逻辑”、“数据存储及网络调用”等事务和逻辑处理的过程。</p><hr><h3 id="一、小程序执行的生命周期"><a href="#一、小程序执行的生命周期" class="headerlink" title="一、小程序执行的生命周期"></a>一、小程序执行的生命周期</h3><p>一个完整的小程序执行的生命周期如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.onLaunch -&gt; app.onShow -&gt; page1.onLoad -&gt; page1.onShow -&gt; page1.onReady</span><br><span class="line">(打开程序，第一个页面page1加载完成)</span><br><span class="line">-&gt; page1.onHide -&gt; page2.onLoad -&gt; page2.onShow -&gt; page2.onReady</span><br><span class="line">(从第一个页面新打开page2)</span><br><span class="line">-&gt; page2.onUnload -&gt; page1.onShow -&gt; ... -&gt; app.onUnload</span><br><span class="line">(关闭page2，返回page1，...退出小程序)</span><br></pre></td></tr></table></figure><p>一个page的生命周期从<code>onLoad</code>开始，整个生命周期内<code>onLoad</code>、<code>onReady</code>、<code>onUnload</code>这三个事件仅执行一次，而<code>onHide</code>和<code>onShow</code>在每次页面隐藏和显示时都会触发。当用户手动触发退出时，小程序仅触发<code>app.onHide</code>，下次进入小程序时会触发<code>app.onShow</code>以及当前<code>page.onShow</code>。仅当小程序在后台运行超过一定时间未被唤醒、或者用户手动在小程序的控制栏里点击退出程序、或者小程序内存占用过大被关闭时，小程序将被销毁，会触发<code>app.onUnload</code>事件。</p><hr><h3 id="二、小程序的线程架构"><a href="#二、小程序的线程架构" class="headerlink" title="二、小程序的线程架构"></a>二、小程序的线程架构</h3><p>每个小程序分为两个线程，<code>view</code>和<code>appServer</code>。其中<code>view</code>负责解析渲染页面（<code>wxml</code>和<code>wxss</code>），而<code>appServer</code>线程负责运行<code>js</code>。<code>appServer</code>线程运行在<code>jsCore</code>中（安卓下运行在<code>X5</code>中，开发工具中运行在<code>nwjs</code>中）。由于js不跑在<code>web-view</code>里，就不能直接操纵DOM和BOM，这就是小程序没有window全局变量的原因。</p><ul><li><p>view线程</p><p>  wxss + wxml</p><p>  ios：safari</p><p>  Android：X5浏览器</p><p>  开发工具：chrome</p></li><li><p>appServer线程</p><p>  JS</p><p>  ios：JavaScriptCore</p><p>  Android：X5内核</p><p>  开发工具：nwjs</p></li></ul><hr><h3 id="三、小程序开发步骤"><a href="#三、小程序开发步骤" class="headerlink" title="三、小程序开发步骤"></a>三、小程序开发步骤</h3><p>理解小程序的线程架构后，我们可以归纳出一个小程序开发的主要步骤，涉及两大步骤：</p><ul><li><p>创建小程序实例（定义、配置及页面执行关联）。即编写3个app前缀的文件，它们共同描述了整个小程序主体逻辑、生命周期及页面构成、样式等。小程序实例将由<code>appServer</code>线程执行。</p></li><li><p>创建页面（页面结构和事务处理逻辑）。在小程序中一个完整的页面（page）是由<code>.js</code>、<code>.json</code>、<code>.wxml</code>、<code>.wxss</code>这四个文件组成，每个界面<code>.js</code>和<code>.wxml</code>是必选项，其他两项是可选项。小程序页面由<code>view</code>线程执行。</p></li></ul><hr><h3 id="四、MINA框架"><a href="#四、MINA框架" class="headerlink" title="四、MINA框架"></a>四、MINA框架</h3><p>微信团队为小程序提供的框架命名为MINA应用框架。MINA框架通过封装微信客户端提供的文件系统、网络通信、任务管理、数据安全等基础功能，对上层提供一整套JavaScript API，让开发者能够非常方便地使用微信客户端提供的各种基础功能与能力，快速构建一个应用。</p><p>小程序框架示意图如下</p><p><img src="/images/wx-1/mina.jpg" alt="小程序MINA框架示意图"></p><p>通过框架图我们可以看到两大部分：在页面视图层，wxml是MINA提供的一套类似html标签的语言以及一系列基础组件。开发者使用wxml文件来搭建页面的基本视图结构，使用wxss文件来控制页面的展现样式。AppService应用逻辑层时MINA的服务中心，由微信客户端启用异步线程单独加载运行。页面渲染所需的数据、页面交互处理逻辑都在AppService中实现。MINA框架中的AppService使用JavaScript来编写交互逻辑、网络请求、数据处理，但不能使用JavaScript中的DOM操作。小程序中的各个页面可以通过AppService实现数据管理、网络通信、应用生命周期管理和页面路由。</p><p>MINA框架为页面组件提供了<code>bindtap</code>、<code>bindtouchstart</code>等事件监听相关的属性，来与AppService中的事件处理函数绑定在一起，实现页面向AppService层同步用户交互数据。MINA框架同时提供了很多方法将AppService中的数据与页面进行单向绑定，当AppService中的数据变更时，会主动触发对应页面组件的重新渲染。MINA使用<code>virtual-dom</code>技术，加快了页面的渲染效率。</p><p>框架的核心是一个响应的数据绑定系统，它让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。我们通过下面的例子来看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- This is our View --&gt;</span><br><span class="line">&lt;view&gt; Hello &#123;&#123; name &#125;&#125;!&lt;/view&gt;</span><br><span class="line">&lt;button bindtap=&quot;changeName&quot;&gt;Click Me!&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">// This is out App Service</span><br><span class="line">// This is our data.</span><br><span class="line">var helloData = &#123;</span><br><span class="line">    name: &apos;WeChat&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">    data: helloData,</span><br><span class="line">    changeName: function(e) &#123;</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">            name: &apos;MINA&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>开发者通过框架将逻辑层数据中的<code>name</code>与视图层的<code>name</code>进行了绑定，所以在页面一打开的时候会显示“<code>Hello WeChat!</code>”。</p><p>当点击按钮的时候，视图层会发送<code>changeName</code>的事件给逻辑层，逻辑层找到对应的事件处理函数。</p><p>逻辑层执行了<code>setData</code>的操作，将<code>name</code>从<code>WeChat</code>变为<code>MINA</code>，因为该数据和视图层已经绑定了，从而视图层会自动改变为“<code>Hello MINA!</code>”。</p><p>微信小程序不仅在底层架构的运行机制上做了大量的优化，还在重功能（如page切换、tab切换、多媒体、网络连接等）上使用接近于native的组件承载。</p><p>综上所述，微信小程序MINA有着接近原生App的运行速度，做了大量的框架层面的优化设计，对Android端和IOS端做出了高度一致的呈现，并且准备了完备的开发和调试工具。</p><hr><h3 id="五、逻辑层"><a href="#五、逻辑层" class="headerlink" title="五、逻辑层"></a>五、逻辑层</h3><p>对于微信小程序而言，逻辑层就是所有<code>.js</code>脚本文件的集合。微信小程序在逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。</p><p>微信小程序开发框架的逻辑层是由JavaScript编写，在JavaScript的基础上，微信团队做了一些适当的修改，以便更高效地开发小程序。主要的修改包括：</p><ul><li><p>增加<code>app</code>和<code>page</code>方法，进行程序和页面的注册</p></li><li><p>提供丰富的API，如扫一扫、支付等微信特有能力</p></li><li><p>每个页面有独立的作用域，并提供模块化能力</p></li></ul><p>小程序逻辑层由js编写，但并非运行在浏览器中，所以JavaScript在Web中的一些能力都将无法使用，比如<code>document</code>、<code>window</code>等，这也给我们的开发带来相应的挑战。</p><p>开发者编写的所有代码最终将会打包成一份JavaScript，并在小程序启动时运行，直到小程序销毁。这类似于ServiceWorker或Webpack，所以逻辑层也称之为AppService。</p><hr><h3 id="六、视图层"><a href="#六、视图层" class="headerlink" title="六、视图层"></a>六、视图层</h3><p>框架的视图层由WXML（WeiXin Markup Language）与WXSS（WeiXin Style Sheet）编写，由组件来进行展示。对于微信小程序而言，视图层就是所有的<code>.wxml</code>文件与<code>.wxss</code>文件的集合：</p><ul><li><p><code>.wxml</code>文件用于描述页面的结构</p></li><li><p><code>.wxss</code>文件用于描述页面的样式</p></li></ul><p>微信小程序在逻辑层将数据进行处理后发送给视图层展现出来，同时接受视图层的事件反馈。</p><p>视图层以给定的样式展现数据并反馈给逻辑层，而数据展现是以组件来进行的。组件（Component）是视图的基本组成单元。</p><hr><h3 id="七、数据层"><a href="#七、数据层" class="headerlink" title="七、数据层"></a>七、数据层</h3><p>数据层包括临时数据或缓存、文件存储、网络存储与调用。</p><h4 id="1-页面临时数据或缓存"><a href="#1-页面临时数据或缓存" class="headerlink" title="1. 页面临时数据或缓存"></a>1. 页面临时数据或缓存</h4><p>在<code>Page()</code>中，我们要使用<code>setData</code>函数来将数据从逻辑层发送到视图层，同时改变对应的<code>this.data</code>的值。</p><p><strong>注意</strong></p><ul><li><p>直接修改<code>this.data</code>无效，无法改变页面的状态，还会造成数据不一致</p></li><li><p>单次设置的数据不能超过1024KB，请尽量避免一次设置过多的数据</p></li></ul><p><code>setData()</code>函数的参数接受一个对象。以<code>key</code>，<code>value</code>的形式表示将<code>this.data</code>中的<code>key</code>对应的值改变成<code>value</code>。其中<code>key</code>可以非常灵活，包括以数据路径的形式给出，如<code>array[2].message</code>，<code>a.b.c.d</code>，并且无须在<code>this.data</code>中预先定义。</p><h4 id="2-文件存储（本地存储）"><a href="#2-文件存储（本地存储）" class="headerlink" title="2. 文件存储（本地存储）"></a>2. 文件存储（本地存储）</h4><p>使用数据API接口，如下所示：</p><ul><li><p><code>wx.getStorage</code>：获取本地数据缓存</p></li><li><p><code>wx.setStorage</code>：设置本地数据缓存</p></li><li><p><code>wx.clearStorage</code>：清理本地数据缓存</p></li></ul><h4 id="3-网络存储或调用"><a href="#3-网络存储或调用" class="headerlink" title="3. 网络存储或调用"></a>3. 网络存储或调用</h4><p>上传或下载文件API接口如下：</p><ul><li><p><code>wx.request</code>：发起网络请求</p></li><li><p><code>wx.uploadFile</code>：上传文件</p></li><li><p><code>wx.downloadFile</code>：下载文件</p></li></ul><p>调用URL的API接口如下：</p><ul><li><p><code>wx.navigateTo</code>：新窗口打开页面</p></li><li><p><code>wx.redirectTo</code>：原窗口打开页面</p></li></ul><hr><h3 id="八、小程序加载运行"><a href="#八、小程序加载运行" class="headerlink" title="八、小程序加载运行"></a>八、小程序加载运行</h3><p>整个微信小程序、用户使用加载的流程示意图如下所示：</p><p><img src="/images/wx-1/1.png" alt="小程序发布与运行加载的流程"></p><p>小程序通过微信团队审核发布后，会同步到微信云端。最终用户通过某个入口，关注到该小程序。第一次运行时要经过短暂的代码下载过程（将所有资源下载到本地），即可在用户的微信中运行。</p><p>小程序在用户的微信中启动，相当于开启一个<code>webview</code>，这与HTML5不一样，在一定的时间内除非手动关闭，即使返回打开另一个小程序，原来的小程序也一直以后台的形式运行在内存里，即在后台运行。</p><p>小程序的版本更新将在启动时进行。首先与微信客户端版本进行对比是否有新版本，若有则小程序更新后再运行；否则，直接使用本地资源运行。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《小程序，巧应用（微信小程序开发实战）——熊普江 谢宇华》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开。这也体现了“用完即走”的理念，用户无需担心安装应用过多的问题。应用将无处不在，随时可用，但又无须安装卸载。&lt;/p&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="http://www.xiaoleon.cn/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://www.xiaoleon.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="MINA" scheme="http://www.xiaoleon.cn/tags/MINA/"/>
    
  </entry>
  
  <entry>
    <title>Web(4) Nginx设置动态Proxy_Pass</title>
    <link href="http://www.xiaoleon.cn/2018/02/01/web-4/"/>
    <id>http://www.xiaoleon.cn/2018/02/01/web-4/</id>
    <published>2018-02-01T02:48:29.000Z</published>
    <updated>2018-02-01T12:41:24.418Z</updated>
    
    <content type="html"><![CDATA[<p>前端开发过程中，我们为了避免与后端进行接口联调时反复修改请求地址，通常会采用服务器地址相对路径的方法，以<code>../rest/api/</code>的模式请求前端文件所在服务器的<code>http://192.168.1.100/rest/api</code>接口。这样可以规避开发阶段（<code>develop</code>）和生产阶段（<code>production</code>）代码不一致的问题，但是在接口联调阶段（<code>debug</code>），特别是前后端由不同的人开发的情况下，则需要使用代理服务器进行转发。</p><a id="more"></a><hr><h3 id="一、问题所在"><a href="#一、问题所在" class="headerlink" title="一、问题所在"></a>一、问题所在</h3><p>通常情况下我们的nginx配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest/api/ &#123;</span><br><span class="line">        proxy_pass  http://192.168.1.100/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接口复杂的情况下，我们的<code>location</code>匹配地址可能会出现较多个。而且因为工作需要，我们可能会同时与多个后台开发者进行接口联调，那么可能会出现如下的nginx配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest/api/ &#123;</span><br><span class="line">        proxy_pass  http://192.168.1.100/rest/api/;</span><br><span class="line">        #proxy_pass  http://192.168.1.101/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest2/api2/ &#123;</span><br><span class="line">        proxy_pass  http://192.168.1.100/rest2/api2/;</span><br><span class="line">        #proxy_pass  http://192.168.1.101/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest3/api3/ &#123;</span><br><span class="line">        proxy_pass  http://192.168.1.100/rest3/api3/;</span><br><span class="line">        #proxy_pass  http://192.168.1.101/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、修改方法"><a href="#二、修改方法" class="headerlink" title="二、修改方法"></a>二、修改方法</h3><p>为了工作方便，我们可能会将不同后台开发人员的地址以注释的方式记录在nginx配置文件内，需要切换后台服务器时，修改配置项中的注释内容，然后执行<code>nginx -s reload</code>来重启nginx服务。</p><p>那么，既然配置文件中有大量的重复地址信息，比如<code>http://192.168.1.100</code>，我们是不是可以把它提取出来作为nginx变量呢？然后<code>proxy_pass</code>读取它，这样在修改文件时只需要修改一个地方即可。</p><p>按照如下方式进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    set $host &apos;192.168.1.100&apos;;</span><br><span class="line">    #set $host &apos;192.168.1.101&apos;;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest/api/ &#123;</span><br><span class="line">        proxy_pass  http://$host/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest2/api2/ &#123;</span><br><span class="line">        proxy_pass  http://$host/rest2/api2/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest3/api3/ &#123;</span><br><span class="line">        proxy_pass  http://$host/rest3/api3/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务后，<strong>nginx不报错，但是代理无效</strong>，无法访问。接着使用<code>geo</code>、<code>map</code>，<strong>均无法正常进行代理转发</strong>。</p><p>最后发现可以使用<code>upstream</code>模式实现此项功能，修改后的配置文件如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">upstream host &#123;</span><br><span class="line">    server  192.168.1.100;</span><br><span class="line">    #server  192.168.1.101;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest/api/ &#123;</span><br><span class="line">        proxy_pass  http://host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest2/api2/ &#123;</span><br><span class="line">        proxy_pass  http://host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest3/api3/ &#123;</span><br><span class="line">        proxy_pass  http://host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次精简一点，采用正则匹配的方式进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">upstream host &#123;</span><br><span class="line">    server  192.168.1.100;</span><br><span class="line">    #server  192.168.1.101;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ /rest(.*)/api(.*)/ &#123;</span><br><span class="line">        rewrite /rest(.*)/api(.*)/ /rest$1/api$2/ break;</span><br><span class="line">        proxy_pass  http://host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样采用正则匹配方式后，不仅可以匹配原有的<code>/rest1/api1/</code>、<code>/rest2/api2/</code>、<code>/rest3/api3/</code>，还可以匹配诸如<code>/project/rest1/api1/</code>等等前面含有项目文件路径的<code>location</code>。</p><p>等后期有时间，再研究一下nginx的<code>rewrite</code>、<code>upstream</code>详细使用方法。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="http://blog.csdn.net/a19860903/article/details/49914131" target="_blank" rel="noopener">proxy_set_header设置Host为$proxy_host，$host与$local_host的区别</a></p></li><li><p><a href="https://www.cnblogs.com/luxianghao/p/6807081.html" target="_blank" rel="noopener">Nginx中的proxy_pass和rewrite</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端开发过程中，我们为了避免与后端进行接口联调时反复修改请求地址，通常会采用服务器地址相对路径的方法，以&lt;code&gt;../rest/api/&lt;/code&gt;的模式请求前端文件所在服务器的&lt;code&gt;http://192.168.1.100/rest/api&lt;/code&gt;接口。这样可以规避开发阶段（&lt;code&gt;develop&lt;/code&gt;）和生产阶段（&lt;code&gt;production&lt;/code&gt;）代码不一致的问题，但是在接口联调阶段（&lt;code&gt;debug&lt;/code&gt;），特别是前后端由不同的人开发的情况下，则需要使用代理服务器进行转发。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Nginx配置" scheme="http://www.xiaoleon.cn/tags/Nginx%E9%85%8D%E7%BD%AE/"/>
    
      <category term="proxy_pass" scheme="http://www.xiaoleon.cn/tags/proxy-pass/"/>
    
  </entry>
  
  <entry>
    <title>Web(3) GraphQL深入理解</title>
    <link href="http://www.xiaoleon.cn/2018/01/31/web-3/"/>
    <id>http://www.xiaoleon.cn/2018/01/31/web-3/</id>
    <published>2018-01-31T03:44:38.000Z</published>
    <updated>2018-01-31T13:00:47.937Z</updated>
    
    <content type="html"><![CDATA[<p>在前一篇文章中我们对GraphQL有了基础的了解，我们直到GraphQL使用<code>Schema</code>来描述数据，并通过指定和实现GraphQL规范定义了支持<code>Schema</code>查询的<code>DSQL （Domain Specific Query Language，领域特定查询语言）</code>。<code>Schema</code>帮助将复杂的业务模型数据抽象拆分成细粒度的基础数据结构，而<code>DSQL</code>的实现则赋予了前端开发者自由组织和定制请求数据的能力。</p><a id="more"></a><p>如果以一张图来表示的话，可以将GraphQL看做一条以<strong>通用基础业务数据模型</strong>为基础、将传统后端服务和前端页面紧密且自由地联系在一起的纽带。</p><p><img src="/images/web-3/1.png" alt="GraphQL"></p><p>为什么GraphQL的<code>Schema</code>能够表示出服务器所支持的复杂业务模型数据，GraphQL的Query又是怎样赋予前端开发者对数据的定制能力，本文将通过分析和理解GraphQL的设计来解答这些问题。</p><hr><h3 id="一、GraphQL的设计"><a href="#一、GraphQL的设计" class="headerlink" title="一、GraphQL的设计"></a>一、GraphQL的设计</h3><p>GraphQL由以下组件构成</p><ul><li><p>类型系统（<code>Type System</code>）</p></li><li><p>查询语言（<code>Query Language</code>）</p></li><li><p>执行语义（<code>Execution Semantics</code>）</p></li><li><p>静态验证（<code>Static Validation</code>）</p></li><li><p>类型检查（<code>Type Introspection</code>）</p></li></ul><p>作为将数据模型和具体接口实现解耦的<code>DSL</code>，GraphQL的基础组件，也是它最重要的组件之一就是类型系统。</p><hr><h3 id="二、类型系统"><a href="#二、类型系统" class="headerlink" title="二、类型系统"></a>二、类型系统</h3><p>可以将GraphQL的类型系统分为标量类型（<code>Scalar Types</code>，标量类型）和其他高级数据类型，标量类型即可以表示最细粒度数据结构的数据类型，可以和JavaScript的原始类型对应。</p><p>GraphQL规范目前规定支持的标量类型有</p><ul><li><p><code>Int</code>：整数，对应JavaScript的<code>Number</code></p></li><li><p><code>Float</code>：浮点数，对应JavaScript的<code>Number</code></p></li><li><p><code>String</code>：字符串，对应JavaScript的<code>String</code></p></li><li><p><code>Boolean</code>：布尔值，对应JavaScript的<code>Boolean</code></p></li><li><p><code>ID</code>：ID值，是一个序列化后值唯一的字符串，可以视作对应ES6新增的<code>Symbol</code></p></li></ul><p>其他高级数据类型包括</p><h4 id="1-对象（Object）"><a href="#1-对象（Object）" class="headerlink" title="1. 对象（Object）"></a>1. 对象（Object）</h4><p>用于描述层级或者树形数据结构。对于树形数据结构来说，叶子字段的类型都是标量数据类型。几乎所有的GraphQL类型都是对象类型。<code>Object</code>类型有一个<code>name</code>字段，以及一个很重要的<code>fields</code>字段。<code>fields</code>字段可以描述出一个完整的数据结构。例如一个表示地址数据机构的GraphQL对象为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AddressType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'Address'</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">        street: &#123;</span><br><span class="line">            type: GraphQLString</span><br><span class="line">        &#125;,</span><br><span class="line">        number: &#123;</span><br><span class="line">            type: GraphQLInt</span><br><span class="line">        &#125;,</span><br><span class="line">        formatted: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            resolve(obj) &#123;</span><br><span class="line">                <span class="keyword">return</span> obj.name + <span class="string">' '</span> + obj.street;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-接口（Interface）"><a href="#2-接口（Interface）" class="headerlink" title="2. 接口（Interface）"></a>2. 接口（Interface）</h4><p>接口用于描述多个类型的通用字段，例如一个表示实体数据结构的GraphQL接口为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EntityType = <span class="keyword">new</span> GraphQLInterfaceType(&#123;</span><br><span class="line">    name: <span class="string">'Entity'</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">        name: &#123;</span><br><span class="line">            type: GraphQLString</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-联合（Union）"><a href="#3-联合（Union）" class="headerlink" title="3. 联合（Union）"></a>3. 联合（Union）</h4><p>联合类型用于描述某个字段能够支持的所有返回类型以及具体请求真正的返回类型，例如一个表示宠物（可以是猫或者狗）的GraphQL联合类型为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PetType = <span class="keyword">new</span> GraphQLUnionType(&#123;</span><br><span class="line">    name: <span class="string">'Pet'</span>,</span><br><span class="line">    types: [DogType, CatType],</span><br><span class="line">    resolveType(value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="keyword">return</span> DogType;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            <span class="keyword">return</span> CatType;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-枚举（Enum）"><a href="#4-枚举（Enum）" class="headerlink" title="4. 枚举（Enum）"></a>4. 枚举（Enum）</h4><p>用于表示可枚举数据结构的类型，例如表示RGB色值的GraphQL枚举类型为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RGBType = <span class="keyword">new</span> GraphQLEnumType(&#123;</span><br><span class="line">    name: <span class="string">'RGB'</span>,</span><br><span class="line">    values: &#123;</span><br><span class="line">        RED: &#123;</span><br><span class="line">            value: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        GREEN: &#123;</span><br><span class="line">            value: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        BLUE: &#123;</span><br><span class="line">            value: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="5-输入对象（Input-Object）"><a href="#5-输入对象（Input-Object）" class="headerlink" title="5. 输入对象（Input Object）"></a>5. 输入对象（Input Object）</h4><p>是为了查询（<code>query</code>）而定义的数据类型，不直接重用<code>Object</code>类型是因为<code>Object</code>的字段可能存在循环引用，或者字段引用了不能作为查询输入对象的接口和联合类型。参考实现中的<code>Input Object</code>的定义代码为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type GraphQLInputType = </span><br><span class="line">    GraphQLScalarType |</span><br><span class="line">    GraphQLEnumType |</span><br><span class="line">    GraphQLInputObjectType |</span><br><span class="line">    GraphQLList&lt;GraphQLInputType&gt; |</span><br><span class="line">    GraphQLNonNull&lt;</span><br><span class="line">        GraphQLScalarType |</span><br><span class="line">        GraphQLEnumType |</span><br><span class="line">        GraphQLInputObjectType |</span><br><span class="line">        GraphQLList&lt;GraphQLInputType&gt;</span><br><span class="line">    &gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isInputType</span>(<span class="params">type: ?GraphQLType</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> namedType = getNamedType(type);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        namedType <span class="keyword">instanceof</span> GraphQLScalarType ||</span><br><span class="line">        namedType <span class="keyword">instanceof</span> GraphQLEnumType ||</span><br><span class="line">        namedType <span class="keyword">instanceof</span> GraphQLInputObjectType</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>Object</code>、<code>Interface</code>和<code>Union</code>三种类型是不能作为输入对象类型的。</p><h4 id="6-列表（List）"><a href="#6-列表（List）" class="headerlink" title="6. 列表（List）"></a>6. 列表（List）</h4><p>列表是其它类型的封装，通常用于对象字段的描述。例如下面<code>PersonType</code>类型数据的<code>parents</code>和<code>children</code>字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PersonType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'Person'</span>,</span><br><span class="line">    fields: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">        parents: &#123;</span><br><span class="line">            type: <span class="keyword">new</span> GraphQLList(Person)</span><br><span class="line">        &#125;,</span><br><span class="line">        children: &#123;</span><br><span class="line">            type: <span class="keyword">new</span> GraphQLList(Person)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="7-不能为Null（Non-Null）"><a href="#7-不能为Null（Non-Null）" class="headerlink" title="7. 不能为Null（Non-Null）"></a>7. 不能为Null（Non-Null）</h4><p><code>Non-Null</code>强制类型的值不能为<code>null</code>，并且在请求出错时一定会报错。可以用于必须保证值不能为<code>null</code>的字段。例如数据库的id字段不能为<code>null</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RowType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'Row'</span>,</span><br><span class="line">    fields: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">        id: &#123;</span><br><span class="line">            type: <span class="keyword">new</span> GraphQLNonNull(GraphQLString)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>还有一种重要的数据类型，即<code>schema</code>类型，它描述了后端服务器能够提供的数据支持。</p><hr><h3 id="三、查询语言"><a href="#三、查询语言" class="headerlink" title="三、查询语言"></a>三、查询语言</h3><p>类型系统对应我们开头提到的<code>Schema</code>，是对服务器端数据的描述，而查询语言则解耦了前端开发者与后端接口的依赖。前端开发者利用查询语言可以自由地组织和定制系统能够提供的业务数据。</p><p>GraphQL的一个查询请求被称为一份<code>query</code>文档（<code>query document</code>），即GraphQL服务能够解析验证并执行的一串请求字符串。<code>query</code>由操作（<code>Operation</code>）和片段（<code>Fragments</code>）组成。一个<code>query</code>可以包含多个操作和片段。只有包含操作的<code>query</code>才会被GraphQL服务执行。但是不包含操作，只包含<code>query</code>也会被GraphQL服务解析验证，这样一份片段就可以在多个<code>query</code>文档内使用。</p><p>只包含一个操作的<code>query</code>可以不带操作名称或者使用简写形式（即<code>query</code>关键字加名）。<code>query</code>包含多个操作时，所有操作都必须带上名称。</p><h4 id="1-操作（Operation）"><a href="#1-操作（Operation）" class="headerlink" title="1. 操作（Operation）"></a>1. 操作（Operation）</h4><p>GraphQL规范支持两种操作</p><ul><li><p><code>query</code>：仅获取数据（<code>fetch</code>）的只读请求</p></li><li><p><code>mutation</code>：获取数据后还有写操作的请求</p></li></ul><p>在官方提供的参考实现中我们会发现还有一种操作<code>subscription</code>，这是为了处理订阅更新这种比较复杂的实时数据更新场景而设计的操作，不过目前这种操作还处于试验阶段，不建议在生产环境使用。</p><p>查询请求的模型可以用下面的图来表示</p><p><img src="/images/web-3/2.svg" alt="查询请求模型"></p><h4 id="2-选择集合（Selection-Sets）"><a href="#2-选择集合（Selection-Sets）" class="headerlink" title="2. 选择集合（Selection Sets）"></a>2. 选择集合（Selection Sets）</h4><p>选择集合表示当前选中的数据内容，格式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Field               // 字段名</span><br><span class="line">    FragmentSpread      // 片段展开</span><br><span class="line">    InlineFragment      // 内联片段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-字段（Field）"><a href="#3-字段（Field）" class="headerlink" title="3. 字段（Field）"></a>3. 字段（Field）</h4><p>字段格式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias:name(argument:value)</span><br></pre></td></tr></table></figure><p>其中<code>alias</code>是字段的别名，即结果中显示的字段名称。</p><p><code>name</code>为字段名称，对应<code>schema</code>中定义的<code>fields</code>字段名。</p><p><code>argument</code>为参数名称，对应<code>schema</code>中定义的<code>fields</code>字段的参数名称。</p><p><code>value</code>为参数值，值的类型对应标量类型的值。</p><p>例如这样的请求：<code>http://example.taobao.com/?query={banner{backgroundURL:bg,biaoti:slogan}}</code>，其中<code>backgroundURL</code>就是<code>bg</code>字段的别名。</p><h4 id="4-片段（Fragment）"><a href="#4-片段（Fragment）" class="headerlink" title="4. 片段（Fragment）"></a>4. 片段（Fragment）</h4><p>片段时GraphQL的主要组合数据结构，通过片段可以重用重复的字段选择，减少<code>query</code>中的重复内容。片段又分为<code>FragmentSpread</code>和<code>InlineFragment</code>。例如没有片段时需要这样编写<code>query</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">query noFragments &#123;</span><br><span class="line">    user(id: 4) &#123;</span><br><span class="line">        friends(first: 10) &#123;</span><br><span class="line">            id</span><br><span class="line">            name</span><br><span class="line">            profilePic(size: 50)</span><br><span class="line">        &#125;</span><br><span class="line">        mutualFriends(first: 10) &#123;</span><br><span class="line">            id</span><br><span class="line">            name</span><br><span class="line">            profilePic(size: 50)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>query</code>中存在下列重复的选择集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    profilePic(size: 50)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用片段化简为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">query withFragments &#123;</span><br><span class="line">    user(id: 4) &#123;</span><br><span class="line">        friends(first: 10) &#123;</span><br><span class="line">            ...friendFields</span><br><span class="line">        &#125;</span><br><span class="line">        mutualFriends(first: 10) &#123;</span><br><span class="line">            ...friendFields</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment friendFields on User &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    profilePic(size: 50)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用片段时需要加上<code>...</code>操作符表示展开片段内容。</p><p>内联片段示例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">query inlineFragmentTyping &#123;</span><br><span class="line">    profiles(handles: [&quot;zuck&quot;, &quot;cocacola&quot;]) &#123;</span><br><span class="line">        handle</span><br><span class="line">        ... on User &#123;</span><br><span class="line">            friends &#123;</span><br><span class="line">                count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ... on Page &#123;</span><br><span class="line">            likers &#123;</span><br><span class="line">                count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-指令（Directives）"><a href="#5-指令（Directives）" class="headerlink" title="5. 指令（Directives）"></a>5. 指令（Directives）</h4><p>指令要解决的是<code>query</code>执行时字段参数无法覆盖的情况，例如引入或者忽略某个字段。指令为GraphQL执行添加了更多的信息。</p><p>指令实例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query hasConditionalFragment($condition: Boolean) &#123;</span><br><span class="line">    ...maybeFragment @include(if: $condition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment maybeFragment on Query &#123;</span><br><span class="line">    me &#123;</span><br><span class="line">        name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>include</code>指令表示只有在<code>if</code>参数为true时才引入片段表示的字段。</p><p><code>skip</code>指令表示在<code>if</code>参数为true时忽略片段中的字段。</p><p>熟悉了<strong>类型系统</strong>和<strong>查询语言</strong>，我们就可以用GraphQL来实现应用层的数据请求了。</p><p>其他三个GraphQL组件更偏向于DSL的实现和原理，本文不再做详细介绍。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="www.graphql.cn">GraphQL | 一种为你的API而生的查询语言</a></p></li><li><p><a href="http://taobaofed.org/blog/2016/03/10/graphql-in-depth/" target="_blank" rel="noopener">深入理解GraphQL</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前一篇文章中我们对GraphQL有了基础的了解，我们直到GraphQL使用&lt;code&gt;Schema&lt;/code&gt;来描述数据，并通过指定和实现GraphQL规范定义了支持&lt;code&gt;Schema&lt;/code&gt;查询的&lt;code&gt;DSQL （Domain Specific Query Language，领域特定查询语言）&lt;/code&gt;。&lt;code&gt;Schema&lt;/code&gt;帮助将复杂的业务模型数据抽象拆分成细粒度的基础数据结构，而&lt;code&gt;DSQL&lt;/code&gt;的实现则赋予了前端开发者自由组织和定制请求数据的能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="GraphQL" scheme="http://www.xiaoleon.cn/tags/GraphQL/"/>
    
      <category term="网络接口" scheme="http://www.xiaoleon.cn/tags/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Web(2) GraphQL简要介绍</title>
    <link href="http://www.xiaoleon.cn/2018/01/31/web-2/"/>
    <id>http://www.xiaoleon.cn/2018/01/31/web-2/</id>
    <published>2018-01-31T01:27:52.000Z</published>
    <updated>2018-01-31T13:00:47.937Z</updated>
    
    <content type="html"><![CDATA[<p>GraphQL是什么？GraphQL是一种既用于API的查询语言，也满足数据查询的运行时语言。GraphQL对你的API中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获取它需要的数据，而且没有任何冗余，也让API更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p><a id="more"></a><p>GraphQL is a query language created by Facebook in 2012 which provides a common interface between the client and the server for data fetching and manipulations.</p><p>The client ask for various data from the GraphQL server via queries. The response format is described in the query and defined by the client instead of the server: they are called client-specified queries. The structure of the data is not hardcoded as in traditional REST APIs - this makes retrieving data from the server more efficient for the client.</p><hr><h3 id="一、场景分析"><a href="#一、场景分析" class="headerlink" title="一、场景分析"></a>一、场景分析</h3><p>现有的数据业务场景一般是这样的，业务方提出需求，然后寻找开发资源，由后端提供数据，让前端实现各种不同的业务视图。这样的做法存在很多的重复劳动，如果能够将其中通用的内容抽取出来提供给各个业务方反复使用，必然能够节省宝贵的开发时间和开发人力。</p><p>前端的解决方案时将视图组件化，各个业务线既可以是组件的使用者，也可以是组件的生产者。那么问题来了，前端通过组件实现了跨业务的复用，后端接口如何相应地提高开发效率呢？</p><p>我们假设某个业务需要以下数据内容a：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    user(id: 3500401) &#123;</span><br><span class="line">        id,</span><br><span class="line">        name,</span><br><span class="line">        isViewerFriend</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显这不是一个JSON，但是我们仍然可以看懂它表示的是查询<code>id</code>为3500401用户的<code>id</code>、<code>name</code>和<code>isViewerFriend</code>信息。用户信息对于各个业务都是通用的，假设另外一个业务需要这样的用户信息b：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    user(id: 3500401) &#123;</span><br><span class="line">        name,</span><br><span class="line">        profilePicture(size: 50) &#123;</span><br><span class="line">            uri,</span><br><span class="line">            width,</span><br><span class="line">            height</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下，我们发现只是少了两个字段，多了一个字段而已。如果要实现我们的目标，即复用同一个接口来支持这两种业务的话，会有以下几种做法：</p><ul><li><p>用同一个接口，这个接口提供了所有数据。这样做的好处是实现起来简单，但缺点是对业务做判断的逻辑会增多，而且对于业务来说，响应内容中有些数据根本用不到</p></li><li><p>使用参数来区分不同的业务方并返回相应的数据。好处仍然是实现简单，虽然不会有用不到的数据返回，但是仍然需要增加业务逻辑判断，会造成以后维护的困难。</p></li></ul><p>此外，这样还会造成不同业务之间的强依赖，每次发布都需要各个业务线一起测试和回归。不重用接口则没法提高开发效率，重用接口则会有这些问题。</p><hr><h3 id="二、GraphQL解决方案"><a href="#二、GraphQL解决方案" class="headerlink" title="二、GraphQL解决方案"></a>二、GraphQL解决方案</h3><p>我们知道，用户信息对应的数据模型是固定的，每次请求其实是对这些数据做了过滤和筛选。对应到数据库操作，就是数据的查询操作。如果客户端也能够像“查询”一样发送请求，那不就可以从后端接口这个大的“大数据库”去过滤筛选业务需要的数据了吗？</p><p>GraphQL就是基于这样的思想来设计的。上面提到的（a）和（b）类型的数据结构就是GraphQL的查询内容。使用上面的查询，GraphQL服务器会分别返回如下响应内容。</p><p>a查询对应的响应</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">3500401</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Jing Chen"</span>,</span><br><span class="line">        <span class="attr">"isViewerFriend"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b查询对应的响应</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Jing Chen"</span>,</span><br><span class="line">        <span class="attr">"profilePicture"</span>: &#123;</span><br><span class="line">            <span class="attr">"uri"</span>: <span class="string">"http://example/pic.jpg"</span>,</span><br><span class="line">            <span class="attr">"width"</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="attr">"height"</span>: <span class="number">50</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要改变查询内容，前端就能定制服务器返回的响应内容，这就是GraphQL的客户端制定查询（<code>Client Specified Queries</code>）。</p><hr><h3 id="三、使用NodeJS实现GraphQL服务器"><a href="#三、使用NodeJS实现GraphQL服务器" class="headerlink" title="三、使用NodeJS实现GraphQL服务器"></a>三、使用NodeJS实现GraphQL服务器</h3><p>我们先按照官方文档搭建一个GraphQL服务器</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> graphql-intro &amp;&amp; <span class="built_in">cd</span> ./graphql-intro</span><br><span class="line">npm init</span><br><span class="line">npm install express --save</span><br><span class="line">npm install babel --save</span><br><span class="line">npm install babel-register --save</span><br><span class="line"><span class="built_in">type</span> <span class="built_in">nul</span>&gt; ./server.js</span><br><span class="line"><span class="built_in">type</span> <span class="built_in">nul</span>&gt; ./index.js</span><br></pre></td></tr></table></figure><p><code>index.js</code>的内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel-register'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./server.js'</span>);</span><br></pre></td></tr></table></figure><p><code>server.js</code>的内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="keyword">let</span> PORT = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/graphql'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">'Hello'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = app.listen(PORT, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> host = server.address().address;</span><br><span class="line">    <span class="keyword">let</span> port = server.address().port;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`GraphQL listening at http:<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后执行代码</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon index.js</span><br></pre></td></tr></table></figure><p>测试是否有效</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:<span class="number">3000</span>/graphql           // =&gt; 'Hello'</span><br></pre></td></tr></table></figure><p>接着编写<code>GraphQL Schema</code>（<code>Schema</code>是GraphQL请求的入口，用户的GraphQL请求会对应到具体的<code>Schema</code>），首先回忆一下GraphQL请求是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query getHightScore &#123; score &#125;</span><br></pre></td></tr></table></figure><p>上面的请求是获取<code>getHightScore</code>的<code>score</code>值。也可以加上查询条件，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query getHightScore(limit: 10) &#123; score &#125;</span><br></pre></td></tr></table></figure><p>这样的请求格式就是GraphQL中的<code>schema</code>。通过<code>schema</code>可以定义服务器的响应内容。</p><p>接下来我们在项目中使用graphql</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install graphql --save</span><br><span class="line">npm install body-parser --save</span><br></pre></td></tr></table></figure><p>graphql的npm包会负责组装服务器<code>schema</code>并处理GraphQL请求。</p><h4 id="1-创建schema"><a href="#1-创建schema" class="headerlink" title="1. 创建schema"></a>1. 创建schema</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">nul</span>&gt; ./schema.js</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    GraphQLObjectType,</span><br><span class="line">    GraphQLSchema,</span><br><span class="line">    GraphQLInt</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'graphql'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> schema = <span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    query: <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">        name: <span class="string">'RootQueryType'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            count: &#123;</span><br><span class="line">                type: GraphQLInt,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> schema;</span><br></pre></td></tr></table></figure><p>这段代码创建了一个<code>GraphQL Schema</code>实例。这个<code>schema</code>的顶级查询对象会返回一个<code>RootQueryType</code>对象，这个<code>RootQueryType</code>对象有一个整数类型的<code>count</code>域。GraphQL除了支持整数（<code>Interger</code>），还支持字符串（<code>String</code>）、列表（<code>List</code>）等多种类型的数据。</p><h4 id="2-连接schema"><a href="#2-连接schema" class="headerlink" title="2. 连接schema"></a>2. 连接schema</h4><p>下面将<code>GraphQL Schema</code>和服务器连接起来，我们需要修改<code>server.js</code>为如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> schema <span class="keyword">from</span> <span class="string">'./schema'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">'graphql'</span>;</span><br><span class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">'body-parser'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="keyword">let</span> PORT = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.text(&#123; <span class="attr">text</span>: <span class="string">'application/graphql'</span> &#125;));</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/graphql'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    graphql(schema, req.body)</span><br><span class="line">        .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">            res.send(<span class="built_in">JSON</span>.stringify(result, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = app.listen(PORT, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> host = server.address().address;</span><br><span class="line">    <span class="keyword">let</span> port = server.address().port;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`GraphQL listening at http:<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>验证下效果</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "query RootQueryType &#123; count &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p>结果如下图所示</p><p><img src="/images/web-2/1.png" alt="验证效果"></p><p>GraphQL查询还可以省略掉<code>queryRootQueryType</code>前缀</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "&#123; count &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p><img src="/images/web-2/2.png" alt="验证效果"></p><h4 id="3-检查服务器"><a href="#3-检查服务器" class="headerlink" title="3. 检查服务器"></a>3. 检查服务器</h4><p>GraphQL最让人感兴趣的是可以编写GraphQL查询来让GraphQL服务器告诉我们它支持哪些查询，即官方文档提到的自检性（<code>introspection</code>）。</p><p>例如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "&#123; __schema &#123; queryType &#123; name, fields &#123; name, description &#125; &#125; &#125; &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p><img src="/images/web-2/3.png" alt="验证效果"></p><p>而我们实际的GraphQL查询请求内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    __schema &#123;</span><br><span class="line">        queryType &#123;</span><br><span class="line">            name,</span><br><span class="line">            fields &#123;</span><br><span class="line">                name,</span><br><span class="line">                description</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上每个GraphQL根域都会自动加上一个<code>__schema</code>域，这个域有一个子域叫<code>queryType</code>。我们可以通过查询这些域来了解GraphQL服务器支持哪些查询。我们可以修改<code>schema.js</code>来为<code>count</code>域加上<code>description</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> schema = <span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    query = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">        name: <span class="string">'RootQueryType'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            count: &#123;</span><br><span class="line">                type: GraphQLInt,</span><br><span class="line">                description: <span class="string">'The count!'</span>,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>验证一下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "&#123; __schema &#123; queryType &#123; name, fields &#123; name, description &#125; &#125; &#125; &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p><img src="/images/web-2/4.png" alt="验证效果"></p><h4 id="4-变异（mutation）"><a href="#4-变异（mutation）" class="headerlink" title="4. 变异（mutation）"></a>4. 变异（mutation）</h4><p>GraphQL中将对数据的修改操作称为<code>mutation</code>，在GraphQL Schema中按照如下形式来定义一个<code>mutation</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let schema = new GraphQLSchema(&#123;</span><br><span class="line">    query: ...</span><br><span class="line">    mutation: //TODO</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>mutation</code>查询和普通查询请求（<code>query</code>）的重要区别在于<code>mutation</code>操作是序列化执行的。例如GraphQL规范中给出的示例，服务器一定会序列化下面的<code>mutation</code>请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    first: changeTheNumber(newNumber: 1) &#123;</span><br><span class="line">        theNumber</span><br><span class="line">    &#125;,</span><br><span class="line">    second: changeTheNumber(newNumber: 3) &#123;</span><br><span class="line">        theNumber</span><br><span class="line">    &#125;,</span><br><span class="line">    third: changeTheNumber(newNumber: 2) &#123;</span><br><span class="line">        theNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求结束时<code>theNumber</code>的值会是<code>2</code>。下面为我们的服务器添加一个<code>mutation</code>查询，修改<code>schema.js</code>为如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    GraphQLObjectType,</span><br><span class="line">    GraphQLSchema,</span><br><span class="line">    GraphQLInt</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'graphql'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> schema = <span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    query: <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">        name: <span class="string">'RootQueryType'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            count: &#123;</span><br><span class="line">                type: GraphQLInt,</span><br><span class="line">                <span class="comment">// Add description</span></span><br><span class="line">                description: <span class="string">'The count!'</span>,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// Note: this is the newly added mutation query</span></span><br><span class="line">    mutation: <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">        name: <span class="string">'RootMutationType'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            updateCount: &#123;</span><br><span class="line">                type: GraphQLInt,</span><br><span class="line">                description: <span class="string">'Update the count'</span>,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> schema;</span><br></pre></td></tr></table></figure><p>验证一下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "mutation RootMutationType &#123; updateCount &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p><img src="/images/web-2/5.png" alt="验证效果"></p><hr><h3 id="四、业务场景模拟"><a href="#四、业务场景模拟" class="headerlink" title="四、业务场景模拟"></a>四、业务场景模拟</h3><p>搭建好GraphQL服务器后，我们来模拟下业务场景的实际需求，对于电商平台来说，最常用的就是商品信息，假设目前的商品数据模型可以用下面的<code>GraphQLObject</code>来表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ItemType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'item'</span>,</span><br><span class="line">    descriptions: <span class="string">'item'</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">        id: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item id'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        title: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item title'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        price: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item price'</span>,</span><br><span class="line">            resolve: <span class="function"><span class="keyword">function</span>(<span class="params">root, param, context</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (root.price / <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        pic: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item pic url'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>查询商品的<code>schema</code>如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ItemSchema = <span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    query: &#123;</span><br><span class="line">        name: <span class="string">'ItemQuery'</span>,</span><br><span class="line">        description: <span class="string">'query item'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            item: &#123;</span><br><span class="line">                type: ItemType,</span><br><span class="line">                description: <span class="string">'item'</span>,</span><br><span class="line">                args: &#123;</span><br><span class="line">                    id: &#123;</span><br><span class="line">                        type: GraphQLInt,</span><br><span class="line">                        required: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params">root, obj, ctx</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">yield</span> ItemService(obj[<span class="string">'id'</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过如下<code>query</code>可以查询id为12345的商品信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query ItemQuery(id: 12345) &#123;</span><br><span class="line">    id</span><br><span class="line">    title</span><br><span class="line">    price</span><br><span class="line">    pic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>商品详情页展示时需要加上优惠价格信息，我们可以修改<code>ItemType</code>，为它加上一个<code>promotion</code>字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ItemType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'item'</span>,</span><br><span class="line">    description: <span class="string">'item'</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">        id: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item id'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        title: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item title'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        price: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item price'</span>,</span><br><span class="line">            resolve: <span class="function"><span class="keyword">function</span>(<span class="params">root, param, context</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (root.price / <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        pic: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item pic url'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        promotion: &#123;</span><br><span class="line">            type: GraphQLInt,</span><br><span class="line">            description: <span class="string">'promotion price'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>商品详情页的查询为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query ItemQuery(id: 12345) &#123;</span><br><span class="line">    id</span><br><span class="line">    title</span><br><span class="line">    price</span><br><span class="line">    pic</span><br><span class="line">    promotion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ItemSchema</code>无需修改，只要在<code>ItemService</code>的返回结果中加上<code>promotion</code>就可以了。这样接口的修改对于原有业务是透明的，而新的业务也能基于已有的代码快速开发和迭代。</p><p>再假设有一个新的页面，只需要用到宝贝的图片信息，业务方可以使用下面的查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query ItemQuery(id: 12345) &#123;</span><br><span class="line">    id</span><br><span class="line">    pic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器代码不用做任何修改。</p><p>至此我们已经实现了一个GraphQL基础服务器。在实际业务中数据模型肯定会更加复杂，而GraphQL也提供了强大的类型系统（<code>Type System</code>）让我们能够轻松地描述各种数据类型，它提供的抽象层能够为依赖同一套数据模型的不同业务方提供灵活的数据支持。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="www.graphql.cn">GraphQL | 一种为你的API而生的查询语言</a></p></li><li><p><a href="https://www.jianshu.com/p/0343b83e0cbb" target="_blank" rel="noopener">GraphQL 初体验：GraphQL + Node.js</a></p></li><li><p><a href="http://taobaofed.org/blog/2015/11/26/graphql-basics-server-implementation/" target="_blank" rel="noopener">Node.js服务端实践之GraphQL初探</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GraphQL是什么？GraphQL是一种既用于API的查询语言，也满足数据查询的运行时语言。GraphQL对你的API中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获取它需要的数据，而且没有任何冗余，也让API更容易地随着时间推移而演进，还能用于构建强大的开发者工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="GraphQL" scheme="http://www.xiaoleon.cn/tags/GraphQL/"/>
    
      <category term="网络接口" scheme="http://www.xiaoleon.cn/tags/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>JS(12) 客户端存储</title>
    <link href="http://www.xiaoleon.cn/2018/01/30/js-12/"/>
    <id>http://www.xiaoleon.cn/2018/01/30/js-12/</id>
    <published>2018-01-30T14:55:14.000Z</published>
    <updated>2018-02-02T12:48:05.179Z</updated>
    
    <content type="html"><![CDATA[<p>Web应用允许使用浏览器提供的API实现将数据存储到用户的电脑上，这种客户端存储相当于赋予了Web浏览器记忆功能。比方说，Web应用就可以用这种方式来“记住”用户的偏好甚至是用户所有的状态信息，以便准确地“回忆”起用户上一次访问的位置。客户端存储遵循“同源策略”，因此不同站点的页面是无法互相读取对方存储的数据，而同一站点的不同页面之间是可以互相共享存储数据的，它为我们提供了一种通信机制，例如，一个页面上填写的表单数据可以显示在另外一个页面中。Web应用可以选择它们存储数据的有效期：比如采用临时存储可以让数据保存至当前窗口关闭或者浏览器退出；采用永久存储，可以将数据永久地存储到硬盘上，数年或者数月不失效。</p><a id="more"></a><p>客户端存储有以下几种形式：</p><ul><li><p>Web存储</p><p>Web存储最初作为HTML5的一部分被定义成API形式，但是后来被剥离出来作为独立的一份标准了。Web存储标准所描述的API包含localStorage对象和sessionStorage对象，这两个对象实际上是持久化关联数组，是名值对的映射表，“名”和“值”都是字符串。Web存储易于使用、支持大容量数据存储同时兼容当前所有的主流浏览器，但是不兼容早期浏览器。</p></li><li><p>cookie</p><p>cookie是一种早期的客户端存储机制，起初是针对服务器端脚本设计使用的。尽管在客户端提供了非常繁琐的JavaScript API来操作cookie，但它们难用至极，而且只适合存储少量文本数据。不仅如此，任何以cookie形式存储的数据，不论服务器端是否需要，每一次HTTP请求都会把这些数据传输到服务器端。cookie目前仍然被客户端程序员大量使用的一个重要原因是：所有新旧浏览器都支持它。但是，随着Web Storage的普及，cookie终将会回归到最初的形态：作为一种被服务器脚本使用的客户端存储机制。</p></li><li><p>IE User Data</p><p>微软在IE5及以后的IE浏览器中实现了它专属的客户端存储机制——“userData”。userData可以实现一定量的字符串数据存储，对于IE8以前的IE浏览器，可以将其用做是Web存储的替代方案。</p></li><li><p>离线Web应用</p><p>HTML5标准中定义了一组“离线Web应用”API，用以缓存Web页面以及相关资源（脚本、CSS文件、图像等）。它实现的是将Web应用整体存储在客户端，而不仅仅是存储数据。它能够让Web应用“安装”在客户端，这样一来，哪怕网络部可用的时候Web应用依然是可用的。</p></li><li><p>Web数据库</p><p>为了能够让开发者像使用数据库那样来操作大量数据，很多主流的浏览器纷纷在其中开始集成客户端数据库功能。Safari、Chrome和Opera都内置了SQL数据库的客户端API。遗憾的是，这类API的标准化工作以失败告终，并且Firefox和IE也都不打算实现这种API。目前还有一种正在标准化的数据库API，称为“索引数据库API”（indexed database API）。调用该API返回的是一个不包含查询语句的简单数据库对象。这两种客户端数据库API都是异步的，都是用了事件处理机制。</p></li></ul><hr><h3 id="一、localStorage和sessionStorage"><a href="#一、localStorage和sessionStorage" class="headerlink" title="一、localStorage和sessionStorage"></a>一、localStorage和sessionStorage</h3><p>实现了“Web存储”草案标准的浏览器在Window对象上定义了两个属性：localStorage和sessionStorage。这两个属性都代表同一个Storage对象——一个持久化关联数组，数组使用字符串来索引，存储的值也都是字符串形式的。Storage对象在使用上和一般的JavaScript对象没什么区别：设置对象的属性为字符串值，随后浏览器会将该值存储起来。localStorage和sessionStorage两者的区别在于存储的有效期和作用域的不同：数据可以存储多长时间以及谁拥有数据的访问权。</p><p>下面的代码使用的是localStorage，但是它对sessionStorage也同样适用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = localStorage.username;               <span class="comment">// 查询一个存储的值</span></span><br><span class="line">name = localStorage[<span class="string">'username'</span>];                <span class="comment">// 等价于数组表示法</span></span><br><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">    name = prompt(<span class="string">'What is your name?'</span>);        <span class="comment">// 询问客户一个问题</span></span><br><span class="line">    localStorage.username = name;               <span class="comment">// 存储用户的答案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代所有存储的name/value对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> localStorage) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = localStorage[name];             <span class="comment">// 查询每个名字对应的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Storage对象还定义了一些诸如存储、获取、遍历和删除的方法。“Web存储”草案标准指出，我们既可以存储结构化的数据（对象和数组），也可以存储原始类型数据，还可以存储诸如日期、正则表达式甚至文件对象在内的内置类型的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当存储一个数字的时候，会把它自动转换成一个字符串</span></span><br><span class="line"><span class="comment">// 但是，当获取该值的时候别忘记手动将其转换成数字类型</span></span><br><span class="line">localStorage.x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="built_in">parseInt</span>(localStorage.x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样地，存储一个日起类型数据的时候进行编码，获取的时候进行解码</span></span><br><span class="line">localStorage.lastRead = (<span class="keyword">new</span> <span class="built_in">Date</span>()).toUTCString();</span><br><span class="line"><span class="keyword">var</span> lastRead = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(localStorage.lastRead));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是哦那个JSON可以使得对基本数据类型编码的工作变得很方便</span></span><br><span class="line">localStorage.data = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(localStorage.data);</span><br></pre></td></tr></table></figure><h4 id="1-存储有效期和作用域"><a href="#1-存储有效期和作用域" class="headerlink" title="1. 存储有效期和作用域"></a>1. 存储有效期和作用域</h4><p>localStorage和sessionStorage的区别在于存储的有效期和作用域的不同。通过localStorage存储的数据是永久性的，除非Web应用可以删除存储的数据，或者用户通过设置浏览器配置来删除，否则数据将一直保存在用户的电脑上，永不过期。</p><p>localStorage的作用域是限定在文档源(document origin)级别的，文档源是通过协议、主机名以及端口三者来确定的，因此，下面每个url都拥有不同的文档源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com</span><br><span class="line">https://www.example.com</span><br><span class="line">http://static.example.com</span><br><span class="line">http://www.example.com:8000</span><br></pre></td></tr></table></figure><p>同源的文档间共享同样的localStorage数据（不论该源的脚本是否真正地访问localStorage）。它们可以互相读取对方的数据，甚至可以覆盖对方的数据。但是，非同源的文档间互相都不能读取或者覆盖对方的数据（即使它们运行的脚本是来自同一台第三方服务器也不行）。</p><p>需要注意的是localStorage的作用域也受浏览器供应商的限制。如果使用Firefox访问站点，那么下次用另一个浏览器（Chrome）再次访问的时候，那么本次是无法获取上次存储的数据的。</p><p>通过sessionStorage存储的数据和通过localStorage存储的数据的有效期也是不同的：前者的有效期和存储数据的脚本所在的最顶层的窗口或者是浏览器标签页是一样的。一旦窗口或者标签页被永久关闭了，那么所有通过sessionStorage存储的数据也都被删除了。（要注意的是，现代浏览器已经具备了重新打开最近关闭的标签页随后恢复上一次浏览的会话功能，因此，这些标签页以及与之相关的sessionStorage的有效期可能会更加长些）。</p><p>与localStorage一样，sessionStorage的作用域也是限定在文档中，因此非同源文档间都是无法共享sessionStorage的。不仅如此，sessionStorage的作用域还被限定在窗口中。如果同源的文档渲染在不同的浏览器标签页总，那么它们互相之间拥有的是各自的sessionStorage数据，无法共享；一个标签页中的脚本是无法读取或者覆盖由另一个标签页脚本写入的数据，哪怕这两个标签页渲染的是同一个页面，运行的是同一个脚本也不行。</p><p>要注意的是，这里提到的基于窗口作用域的sessionStorage指的窗口只是顶级窗口。如果一个浏览器标签页包含两个<code>&lt;iframe&gt;</code>元素，它们所包含的文档是同源的，那么这两者之间是可以共享sessionStorage的。</p><h4 id="2-存储API"><a href="#2-存储API" class="headerlink" title="2. 存储API"></a>2. 存储API</h4><p>localStorage和sessionStorage通常被当作普通的JavaScript对象使用：通过设置属性来存储字符串值，查询该属性来读取该值。除此之外，这两个对象还提供了更加正式的API。调用<code>setItem()</code>方法，将对应的名字和值传进去，可以实现数据存储。调用<code>getItem()</code>方法，将名字传进去，可以获取对应的值。调用<code>removeItem()</code>方法，将名字传进去，可以删除对应的数据。调用<code>clear()</code>方法，可以删除所有存储的数据。最后，使用<code>length</code>属性以及<code>key()</code>方法，传入<code>0 ~ length-1</code>的数字，可以枚举所有存储数据的名字。下面是一些使用localStorage的例子，这些代码对sessionStorage也适用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'x'</span>, <span class="number">1</span>);</span><br><span class="line">localStorage.getItem(<span class="string">'x'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; localStorage.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = localStorage.key(i);</span><br><span class="line">    <span class="keyword">var</span> name = localStorage.getItem(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">localStorage.removeItem(<span class="string">'x'</span>);</span><br><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure><p>尽管通过设置和查询属性能更加方便地存储和获取数据，但是有的时候还是不得不使用上面提到的这些方法的。比如说，其中<code>clear()</code>方法是唯一能删除存储对象中所有名值对的方法。同样的还有，removeItem()方法也是唯一通用的删除单个名值对的方式，因为IE8不支持delete操作符。</p><p>如果浏览器提供商完全实现了“Web存储”的标准，支持对象和数组类型的数据存储，那么就会又多了一个使用<code>setItem()</code>和<code>getItem()</code>这类方法的理由。对象和数组类型的值通常是可变的，因此存储对象要求存储它们的副本，以确保之后任何对这类对象的改变都不影响到存储的对象。同样的，在获取该对象的时候也要求获取的是该对象的副本，以确保以获取对象的改动不会影响到存储的对象。而这类操作如果使用基于属性的API就会令人困惑。考虑下面这段代码（假设浏览器已经支持了结构化数据的存储）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localStorage.o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;              <span class="comment">// 存储一个带有x属性的对象</span></span><br><span class="line">localStorage.o.x = <span class="number">2</span>;                   <span class="comment">// 试图去设置该对象的属性值</span></span><br><span class="line">localStorage.o.x;                       <span class="comment">// =&gt; 1: x没有变</span></span><br></pre></td></tr></table></figure><p>上述第二行代码想要设置存储的对象的属性值，但事实上，它获取到的只是存储的对象的副本，随后设置了该对象的属性值，然后就将该副本废弃了。真正存储的对象保持不变。像这样的情况，使用<code>getItem()</code>就不会这么让人困惑了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.getItem(<span class="string">'o'</span>).x = <span class="number">2</span>;        <span class="comment">// 我们并不想存储2</span></span><br></pre></td></tr></table></figure><p>最后，还有另外一个使用显式的机遇方法的存储API的理由就是：在还不支持“Web存储”标准的浏览器中，其他的存储机制的顶层API对其也是兼容的。下面这段代码使用cookie和IE userData来实现存储API。如果使用基于方法的API，当localStorage可用的时候就可以使用它编写代码，而当它在其他浏览器上不可用的时候依然可以依赖其他的存储机制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memory = <span class="built_in">window</span>.localStorage ||</span><br><span class="line">            (<span class="built_in">window</span>.UserDataStorage &amp;&amp; <span class="keyword">new</span> UserDataStorage()) ||</span><br><span class="line">            <span class="keyword">new</span> cookieStorage();</span><br><span class="line"><span class="keyword">var</span> username = memory.getItem(<span class="string">'username'</span>);</span><br></pre></td></tr></table></figure><h4 id="3-存储事件"><a href="#3-存储事件" class="headerlink" title="3. 存储事件"></a>3. 存储事件</h4><p>无论什么时候存储在localStorage和sessionStorage的数据发生改变，浏览器都会在其他对该数据可见的窗口对象上触发存储事件（但是，在对数据进行改变的窗口对象上是不会触发的）。如果浏览器有两个标签页都打开了来自同源的页面，其中一个页面在localStorage上存储了数据，那么另外一个标签页就会接收到一个存储事件。要记住的是sessionStorage的作用域是限制在顶层窗口的，因此对sessionStorage的改变只有当有相牵连的窗口的时候才会触发存储事件。还有要注意的是，只有当存储数据真正发生改变的时候才会触发存储事件。像给已经存在的存储项设置一个一模一样的值，亦或是删除一个本来就不存在的存储项都是不会触发存储事件的。</p><p>为存储事件注册处理程序可以通过<code>addEventListener()</code>方法（IE下使用<code>attachEvent()</code>方法）。在绝大多数浏览器下，还可以使用给window对象设置onstorage属性的方式。</p><p>与存储事件相关的事件对象有5个非常重要的属性（IE8不支持）：</p><ul><li><p>key</p><p>  被设置或者溢出的项的名字或者键名。如果调用的是clear()函数，那么该属性值为null。</p></li><li><p>newValue</p><p>  保存该项的新值；或者调用removeItem()时，该属性值为null。</p></li><li><p>oldValue</p><p>  改变或者删除该项前，保存该项原先的值；当插入一个新项的时候，该属性值为null。</p></li><li><p>storageArea</p><p>  这个属性值就好比是目标Window对象上的localStorage属性或者是sessionStorage属性。</p></li><li><p>url</p><p>  触发该存储变化脚本所在文档的url。</p></li></ul><p>最后要注意的是：localStorage和存储事件都是采用广播机制的，浏览器会对目前正在访问同样站点的所有窗口发送消息。举个例子，如果一个用户要求网站停止动画效果，那么站点可能会在localStorage中存储该用户的首选项，这样一来，以后再访问该站点的时候就自动停止动画效果了。因为存储了该首选项，导致了触发一个存储事件让其他展现统一站点的窗口也获得了这样的一个用户请求。再比如，一个基于Web的图片编辑应用，通常允许在其他的窗口中展示工作条。当用户选择一个工具的时候，应用就可以使用localStorage来存储当前的状态，然后通知其他窗口用户选择了新的工具。</p><hr><h3 id="二、cookie"><a href="#二、cookie" class="headerlink" title="二、cookie"></a>二、cookie</h3><p>cookie是指Web浏览器存储的少量数据，同时它是与具体的Web页面或者站点相关的。cookie最早是设计为被服务端所用的，从底层来看，作为HTTP协议的一种扩展实现它。cookie数据会自动在Web浏览器和Web服务器之间传输的，因此服务端脚本就可以读写存储在客户端的cookie值。</p><p>操作cookie的API很早就已经定义和实现了，因此该API的兼容性很好。但是，该API几乎形同虚设，根本没有提供诸如查询、设置、删除cookie的方法，所有这些操作都要通过以特殊格式的字符串形式读写Document对象的cookie属性来完成。每个cookie的有效期和作用域都可以通过cookie属性来分别指定。这些属性也是通过同一个cookie属性上以特殊格式的字符串来设定的。</p><h4 id="1-有效期和作用域"><a href="#1-有效期和作用域" class="headerlink" title="1. 有效期和作用域"></a>1. 有效期和作用域</h4><p>除了名和值，cookie还有一些可选的属性来控制cookie的有效期和作用域。cookie默认的有效期很短暂：它只能持续在Web浏览器的会话期间，一旦用户关闭浏览器，cookie保存的数据就丢失了。要注意的是：这与sessionStorage的有效期还是有区别的。cookie的作用域并不是局限在浏览器的单个窗口中，它的有效期和整个浏览器进程而不是单个浏览器窗口的有效期一致。要想延长cookie的有效期，可以通过设置<code>max-age</code>属性，但是必须要明确告诉浏览器cookie的有效期是多长（单位是秒）。一旦设置了有效期，浏览器就会将cookie数据存储在一个文件中，并且直到过了指定的有效期才会删除该文件。</p><p>和localStorage以及sessionStorage类似，cookie的作用域是通过文档源和文档路径来确定的。该作用域通过cookie的path和domain属性也是可配置的。默认情况下，cookie和创建它的Web页面有关，并对该Web页面以及和该Web页面同目录或者子目录的其他Web页面可见。比如，Web页面<code>http://www.example.com/catalog/index.html</code>页面创建了一个cookie，那么该cookie对<code>http://www.example.com/catalog/order.html</code>页面和<code>http://www.example.com/catalog/widgets/index.html</code>页面都是可见的，但它对<code>http://www.example.com/about.html</code>页面不可见。</p><p>默认的cookie的可见性行为满足了最常见的需求。不过，有的时候，我们可能希望让整个网站都能够使用cookie的值，而不管是哪个页面创建它的。比方说，当用户在一个页面表单中输入了它的邮件地址，我们想要将它保存下来，为了下次该用户回到这个页面填写表单，或者在网站其他页面的任何地方要求输入账单地址的时候，将其作为默认的邮件地址。要满足这样的需求，可以设置cookie的路径（设置cookie的path属性）。</p><p>这样一类，来自同一个Web服务器的Web页面，只要其url是以指定的路径前缀开始的，都可以共享cookie。例如，如果<code>http://www.example.com/catalog/widgets/index.html</code>页面创建了一个cookie，并且将改路径设置成“<code>/catalog</code>”，那么该cookie对于<code>http://www.example.com/catalog/order.html</code>页面也是可见的。或者，如果把路径设置成“<code>/</code>”，那么该cookie对任何<code>http://www.example.com</code>这台Web服务器上的页面都是可见的。</p><p>将cookie的路径设置成“<code>/</code>”等于是让cookie和localStorage拥有同样的作用域，同时当它请求该站点上任何一个Web页面的时候，浏览器都必须将cookie的名字和值传递给服务器。但是，要注意的是，cookie的path属性不能被用做访问控制机制。如果一个Web页面想要读取同一站点其他页面的cookie，只要简单地将其他页面以隐藏<code>&lt;iframe&gt;</code>的形式加在进来，随后读取对应文档的cookie就可以了。同源策略限制了跨站的cookie窥探，但是对于同一站点的文档它是完全合法的。</p><p>cookie的作用域默认由文档源限制。但是，有的大型网站想要子域之间能够互相共享cookie。比如，<code>order.example.com</code>域下的服务器想要读取<code>catalog.example.com</code>域下设置的cookie值。这个时候就需要通过设置cookie的domain属性来达到目的。如果<code>catalog.example.com</code>域下的一个页面创建了一个cookie，并将其path属性设置成“<code>/</code>”，其domain设置成“<code>.example.com</code>”，那么该cookie就对所有<code>catalog.example.com</code>、<code>orders.example.com</code>以及任何其他<code>example.com</code>域下的任何其他服务器都可见。如果没有为一个cookie设置域属性，那么domain属性的默认值是当前Web服务器的主机名。要注意的是，cookie的域只能设置为当前服务器的域。</p><p>最后要介绍的cookie属性是secure，它是一个布尔类型的属性，用来表明cookie的值以何种形式通过网络传递。cookie默认是以不安全的形式（通过普通的、不安全的HTTP连接）传递的。而一旦cookie被标识为“安全的”，那就只能当浏览器和服务器通过HTTPS或者其他的安全协议连接的时候才能传递它。</p><h4 id="2-保存cookie"><a href="#2-保存cookie" class="headerlink" title="2. 保存cookie"></a>2. 保存cookie</h4><p>要给当前文档设置默认有效期的cookie值，只须将cookie属性设置为一个字符串形式的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"version="</span> + <span class="built_in">encodeURIComponent</span>(<span class="built_in">document</span>.lastModified);</span><br></pre></td></tr></table></figure><p>下次读取cookie属性的时候，之前存储的名值对的数据就在文档的cookie列表中。由于cookie的名值中的值不允许包含分号、逗号和空白负，因此，在存储前一般可以采用<code>encodeURIComponent()</code>对值进行编码。相应的，读取cookie值的时候需要采用<code>decodeURIComponent()</code>函数解码。</p><p>以简单的名值对形式存储的cookie数据有效期只在当前Web浏览器的会话内，一旦用户关闭浏览器，cookie数据就丢失了。如果想要延长cookie的有效期，就需要设置<code>max-age</code>属性来指定cookie的有效期（单位是秒）。按照如下的字符串形式设置cookie属性即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=value; max-age=seconds</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setcookie</span>(<span class="params">name, value, daysToLive</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookie = name + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> daysToLive === <span class="string">'number'</span>)</span><br><span class="line">        cookie += <span class="string">"; max-age="</span> + (daysToLive * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">    <span class="built_in">document</span>.cookie = cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，如果要设置cookie的path、domain和secure属性，只须在存储cookie值前，以如下字符串形式追加在cookie值的后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; path=path</span><br><span class="line">; domain=domain</span><br><span class="line">; secure</span><br></pre></td></tr></table></figure><p>要改变cookie的值，就需要使用相同的名字、路径和域，但是新的值重新设置cookie的值。同样的，设置新的<code>max-age</code>属性就可以改变原来的cookie的有效期。</p><p>要删除一个cookie，需要使用相同的名字、路径和域，然后指定一个任意（非空）的值，并且将<code>max-age</code>属性指定为0，再次设置cookie。</p><h4 id="3-读取cookie"><a href="#3-读取cookie" class="headerlink" title="3. 读取cookie"></a>3. 读取cookie</h4><p>使用JavaScript表达式来读取cookie属性的时候，其返回的值是一个字符串，该字符串都是由一系列名值对组成，不同的名值对之间通过“分号和空格”分开，其内容包含了所有作用在当前文档的cookie。但是，它并不包含其他设置的cookie属性。通过<code>document.cookie</code>属性可以获取cookie的值，但是为了更好地查看cookie的值，一般会采用<code>split()</code>方法将cookie值中的名值对都分离出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getcookie</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookie = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> all = <span class="built_in">document</span>.cookie;</span><br><span class="line">    <span class="keyword">if</span> (all === <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> cookie;</span><br><span class="line">    <span class="keyword">var</span> list = all.split(<span class="string">'; '</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> cookie = list[i];</span><br><span class="line">        <span class="keyword">var</span> p = cookie.indexOf(<span class="string">'='</span>);</span><br><span class="line">        <span class="keyword">var</span> name = cookie.substring(<span class="number">0</span>, p);</span><br><span class="line">        <span class="keyword">var</span> value = cookie.substring(p + <span class="number">1</span>);</span><br><span class="line">        value = <span class="built_in">decodeURIComponent</span>(value);</span><br><span class="line">        cookie[name] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-cookie的局限性"><a href="#4-cookie的局限性" class="headerlink" title="4. cookie的局限性"></a>4. cookie的局限性</h4><p>cookie的设计初衷是给服务端脚本用来存储少量数据的，该数据会在每次请求一个相关的URL时传递到服务器中。RFC2965鼓励浏览器供应商对cookie的数目和大小不做限制。可是，要知道，该标准不允许浏览器保存超过300个cookie，为每个Web服务器保存的cookie数不能超过20个，而且，每个cookie保存的数据不能超过4KB。实际上，现代浏览器允许cookie总数超过300个，但是部分浏览器对单个cookie大小仍然有4KB的限制。</p><h4 id="5-cookie相关的存储"><a href="#5-cookie相关的存储" class="headerlink" title="5. cookie相关的存储"></a>5. cookie相关的存储</h4><p>下例展示了如何实现基于cookie的一系列存储API方法。该例定义了一个cookieStorage函数，通过将<code>max-age</code>和<code>path</code>属性传递给该构造函数，就会返回一个对象，然后就可以像使用localStorage和sessionStorage一样来使用这个对象了。但是要注意的是，该例并没有实现存储事件，因此，当设置和查询cookieStorage对象的属性的时候，不会实现自动保存和获取对应的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cookieStorage.js</span></span><br><span class="line"><span class="comment">本类实现像localStorage和sessionStorage一样的存储API，不同的是，基于HTTP cookie实现它</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cookieStorage</span>(<span class="params">maxage, path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookie = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> cookie = &#123;&#125;;</span><br><span class="line">        <span class="keyword">var</span> all = <span class="built_in">document</span>.cookie;</span><br><span class="line">        <span class="keyword">if</span> (all === <span class="string">''</span>)</span><br><span class="line">            <span class="keyword">return</span> cookie;</span><br><span class="line">        <span class="keyword">var</span> list = all.split(<span class="string">'; '</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> cookie = list[i];</span><br><span class="line">            <span class="keyword">var</span> p = cookie.indexOf(<span class="string">'='</span>);</span><br><span class="line">            <span class="keyword">var</span> name = cookie.substring(<span class="number">0</span>, p);</span><br><span class="line">            <span class="keyword">var</span> value = cookie.substring(p + <span class="number">1</span>);</span><br><span class="line">            value = <span class="built_in">decodeURIComponent</span>(value);</span><br><span class="line">            cookie[name] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cookie;</span><br><span class="line">    &#125; ());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> keys = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> cookie) </span><br><span class="line">        keys.push(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.length = keys.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.key = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span> || n &gt;= keys.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> keys[n];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getItem = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cookie[name] || <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setItem = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(key <span class="keyword">in</span> cookie)) &#123;</span><br><span class="line">            keys.push(key);</span><br><span class="line">            <span class="keyword">this</span>.length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cookie[key] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cookie = key + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxage)</span><br><span class="line">            cookie += <span class="string">'; max-age='</span> + maxage;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (path)</span><br><span class="line">            cookie += <span class="string">'; path='</span> + path;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.cookie = cookie;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.removeItem = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(key <span class="keyword">in</span> cookie))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> cookie[key];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys[i] === key) &#123;</span><br><span class="line">                keys.splice(i, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.length--;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.cookie = key + <span class="string">'=; max-age=0'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++)</span><br><span class="line">            <span class="built_in">document</span>.cookie = keys[i] + <span class="string">'=; max-age=0'</span>;</span><br><span class="line"></span><br><span class="line">        cookies = &#123;&#125;;</span><br><span class="line">        keys = [];</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、应用程序存储和离线Web应用"><a href="#三、应用程序存储和离线Web应用" class="headerlink" title="三、应用程序存储和离线Web应用"></a>三、应用程序存储和离线Web应用</h3><p>HTML5中新增了“应用程序缓存”，允许Web应用将应用程序自身本地保存到用户的浏览器中。不像localStorage和sessionStorage只是保存Web应用程序相关的数据，它是将应用程序自身保存起来——应用程序所需要运行的所有文件（HTML、CSS、JavaScript、图片等）。“应用程序缓存”和一般的浏览器缓存不同：它不会随着用户清除浏览器缓存而被清除。同时，换存起来的应用程序也不会像一般固定大小的缓存那样，老数据会被最近一次访问的新数据代替掉。它其实不是临时存储在缓存中：应用程序更像是被“安装”在那里，除非被用户“卸载”或者“删除”它们，否则它们就会一直“驻扎”在那里。所以，总的来说，“应用程序缓存”在真正意义上不是缓存，更好地说法应该称之为“应用程序存储”。</p><p>让Web应用能够实现“本地安装”的目的是要保证它们能够在离线状态（比如，当在飞机上或者手机没信号的时候）下依然可以访问。将自己“安装”到应用程序缓存中的Web应用，在离线状态下使用localStorage来保存应用相关的数据，同时还具备一套同步机制，在再次回到在线状态的时候，能够将存储的数据传输给服务器。我们先来结合扫下应用程序是如何将自己“安装”到应用程序缓存中的。</p><h4 id="1-应用程序缓存清单"><a href="#1-应用程序缓存清单" class="headerlink" title="1. 应用程序缓存清单"></a>1. 应用程序缓存清单</h4><p>想要将应用程序“安装”到应用程序缓存中，首先要创建一个清单：包含了所有应用程序依赖的所有URL列表。然后，通过在应用程序主HTML页面的<code>&lt;html&gt;</code>标签中设置manifest属性，指向该清单文件就可以了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"myapp.appcache"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>...<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>...<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>清单文件中的首行内容必须以“CACHE MANIFEST”字符串开始。其余就是要缓存的文件URL列表，一行一个URL。相对路径的URL都相对于清单文件的URL。会忽略内容中的空行，会作为注释而忽略以“#”开始的行。注释前面可以有空格，但是在同一行注视后面是不允许有非空字符的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"></span><br><span class="line">myapp.html</span><br><span class="line">myapp.js</span><br><span class="line">myapp.css</span><br><span class="line">images/background.png</span><br></pre></td></tr></table></figure><blockquote><p><strong>缓存清单的MIME类型</strong></p><p>应用程序缓存清单文件约定以.appcache作为文件扩展名。但是，这也仅仅只是个约定而已，Web服务器真正识别清单文件的方式是通过“text/cache-manifest”这个MIME类型的一个清单。如果服务器将清单文件的Content-Type的头信息设置成其他MIME类型，那么就不会缓存应用程序了。因此，可能需要对Web服务器做一定的配置来使用这个MIME类型，比如，在Web应用目录下创建Apache服务器的一个.htaccess文件。</p></blockquote><p>清单文件包含要缓存的应用的标识。如果一个Web应用有很多Web页面（用户可以访问多个HTML页面），那么每个HTML页面就需要设置<code>&lt;html manifest=&gt;</code>属性来指向清单文件。事实上，将这些不同的页面都指向同一个清单文件，可以很清楚地表达它们都是需要换存起来的，同时它们又是来自同一个Web应用的。如果一个应用只有少量的HTML页面，那么一般会把这些页面都显式地列在清单文件中。</p><p>像之前提到的，一个简单的清单必须列出Web应用依赖的所有资源。一旦一个Web应用首次下载下来并缓存，之后的任何加在请求就都来自缓存。从缓存中去载入一个应用资源的时候，就要求它请求的任何资源务必要在清单中。不会载入不在清单中的资源。这种政策有点离线的味道。如果一个简单的缓存起来的应用能够从缓存中载入并运行，那么它也可以在浏览器的离线状态下运行。通常情况下，很多复杂的Web应用无法将它们依赖的所有资源都缓存起来。但是，如果它们同时也有一个复杂的清单的话，它们仍然可以使用应用程序缓存。</p><h4 id="2-复杂的清单"><a href="#2-复杂的清单" class="headerlink" title="2. 复杂的清单"></a>2. 复杂的清单</h4><p>一个应用从应用程序缓存中载入的时候，只有其清单文件中列举出来的资源文件会载入。前面例子中的清单文件一次列举一个资源的URL。事实上，清单文件还有比这更复杂的语法，例句资源的方式也还有另外两种。在清单文件中可以使用特殊的区域头来标识该头信息之后清单项的类型。像该例中列举的简单缓存项事实上都属于“CACHE”区域，这也是默认的区域。另外两种区域是以“NETWORK”和“FALLBACK”头信息开始的。</p><p>“NETWORK”区域标识了该URL中的资源从不缓存，总要通过网络获取。通常，会将一些服务端的脚本资源放在“NETWORK”区域中，而实际上该区域中的资源的URL都只是URL前缀，用来表示以此URL前缀开头的资源都应该要通过网络加载。当然，如果浏览器处于离线状态，那么这些资源都将获取失败。“NETWORK”区域中的URL还支持“*”通配符。该通配符表示对任何不在清单中的资源，浏览器都将通过网络加载。这实际上违背了这样一条规则：缓存应用程序必须要在清单中列举的所有应用相关的资源！</p><p>“FALLBACK”区域中的清单项每行都包含两个URL。第二个URL是指需要加载和存储在缓存中的资源，第一个URL是一个前缀。任何能够匹配到该前缀的URL都不会换存起来，但是可能的话，它们会从网络中载入。如果从网络中载入这样一个URL失败的话，就会使用第二个URL指定的缓存资源来代替，从缓存中获取。想象一个Web应用包含一定数量的视频教程。这些视频都很大，显然把它们缓存到本地是不合适的。因此，在离线状态下，通过清单文件中的fallback区域，就可以使用一些基于文本的帮助文件来代替了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"></span><br><span class="line">CACHE:</span><br><span class="line">myapp.html</span><br><span class="line">myapp.css</span><br><span class="line">myapp.js</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">videos/ offline_help.html</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">cgi/</span><br></pre></td></tr></table></figure><h4 id="3-缓存的更新"><a href="#3-缓存的更新" class="headerlink" title="3. 缓存的更新"></a>3. 缓存的更新</h4><p>当一个Web应用从缓存中载入的时候，所有与之相关的文件也是直接从缓存中获取。在线状态下，浏览器会异步地检查清单文件是否有更新。如果有更新，新的清单文件以及清单中列举的所有文件都会下载下来重新保存到应用程序缓存中。但是，要注意的是，浏览器只是检查清单文件，而不会去检查缓存的文件是否有更新：只检查清单文件。比如，如果修改了一个缓存的JavaScript文件，并且要想让该文件生效，就必须去更新下清单文件。由于应用程序依赖的文件列表其实并没有变化，因此最简单的方式就是更新版本号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># myapp version 1</span><br><span class="line">myapp.html</span><br><span class="line">myapp.js</span><br></pre></td></tr></table></figure><p>同样，如果想要让Web应用从缓存中“卸载”，就要在服务器端删除清单文件，使得请求该文件的时候返回HTTP404无法找到的错误，同时，修改HTML文件以便它们与该清单列表断开链接。</p><p>要注意的是，浏览器检查清单文件以及更新缓存的操作是异步的，可能是在从缓存中载入应用之前，也有可能同时进行。因此，对于简单的Web应用而言，在更新清单文件之后，用户必须载入应用两次才能保证最新的版本生效：第一次是从缓存中载入老版本随后更新缓存；第二次才从缓存中载入最新的版本。</p><p>浏览器在更新缓存过程中会触发一系列事件，可以通过注册处理程序来跟踪这个过程同时提供反馈给用户。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">applicationCache.onupdateready = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reload = confirm(<span class="string">"A new version of this application is available\n"</span> +</span><br><span class="line">                        <span class="string">"and will be used the next time you reload.\n"</span> +</span><br><span class="line">                        <span class="string">"Do you want to reload now?"</span>);</span><br><span class="line">    <span class="keyword">if</span> (reload)</span><br><span class="line">        location.reload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，该事件处理程序是注册在ApplicationCache对象上的，该对象是Window的applicationCache属性的值。支持应用程序缓存的浏览器会定义该属性。此外，除了上面例子中的updateready事件之外，还有其他7种应用程序缓存事件可以监控。下面展示了一个简单的处理程序通过显示对应的消息来通知用户缓存更新的进度，以及当前缓存的状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面所有的事件处理程序都是用此函数来显示状态消息</span></span><br><span class="line"><span class="comment">// 由于都是通过调用status函数来显示状态，因此所有处理程序都返回false来阻止浏览器</span></span><br><span class="line"><span class="comment">// 显示其默认状态消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">status</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将消息输出到id为“statusline”的文档元素中</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'statusline'</span>).innerHTML = msg;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每当应用程序载入的时候，都会检查该清单文件</span></span><br><span class="line"><span class="comment">// 也总会首先触发“checking”事件</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onchecking = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'Check for a new version.'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果清单文件没有改动，同时应用程序也已经缓存了</span></span><br><span class="line"><span class="comment">// “noupdate”事件会被触发，整个过程结束</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onnoupdate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'This version is up-to-date.'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果还未缓存应用程序，或者清单文件有改动</span></span><br><span class="line"><span class="comment">// 那么浏览器会下载并缓存清单中的所有资源</span></span><br><span class="line"><span class="comment">// 触发“downloading”事件，同时意味着下载过程开始</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.ondownloading = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'Downloading new version.'</span>);</span><br><span class="line">    <span class="built_in">window</span>.progresscount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下载过程中会间断性地触发“progress”事件</span></span><br><span class="line"><span class="comment">// 通常是在每个文件下载完毕的时候</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 事件对象应当是“process”事件</span></span><br><span class="line">    <span class="comment">// 通过该对象可以计算出下载完成比例，但是，如果它不是“process”事件，</span></span><br><span class="line">    <span class="comment">// 我们统计调用的次数</span></span><br><span class="line">    <span class="keyword">var</span> progress = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> (e &amp;&amp; e.lengthComputable)</span><br><span class="line">        progress = <span class="string">' '</span> + <span class="built_in">Math</span>.round(<span class="number">100</span> * e.loaded / e.total) + <span class="string">'%'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        progress = <span class="string">' ('</span> + ++progresscount + <span class="string">')'</span>;</span><br><span class="line">    </span><br><span class="line">    status(<span class="string">'Downloading new version'</span> + progress);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当下载完成并且首次将应用程序下载到缓存中时，</span></span><br><span class="line"><span class="comment">// 浏览器会触发“cached”事件</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.oncached = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'This application is now cached locally'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当下载完成并将缓存中的应用程序更新后，浏览器会触发“updateready”事件</span></span><br><span class="line"><span class="comment">// 要注意的是：触发此事件的时候，用户仍然可以看到老版本的应用程序</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onupdateready = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'A new version has been download. Reload to run it'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果浏览器处于离线状态，检查清单列表失败，则会触发“error”事件</span></span><br><span class="line"><span class="comment">// 当一个未缓存的应用程序引用一个不存在的清单文件，也会触发此事件</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">"Coundn't load manifest or cache application"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个缓存的应用程序引用一个不存在的清单文件</span></span><br><span class="line"><span class="comment">// 会触发“obsolete”事件，同时会将应用从缓存中移除</span></span><br><span class="line"><span class="comment">// 之后都不会从缓存而是通过网络来加载资源</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onobsolete = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'This application is no longer cached. '</span> +</span><br><span class="line">            <span class="string">'Reload to get the latest version from the network.'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次载入了一个设置了manifest属性的HTML文件，浏览器都会触发“checking”事件，并通过网络载入该清单文件。不过之后，会随着不同的情况触发不同的事件。</p><ul><li><p>没有可用的更新</p><p>  如果应用程序已经缓存并且清单文件没有改动，则浏览器会触发“noupdate”事件。</p></li><li><p>有可用的更新</p><p>  如果应用程序已经缓存了并且清单文件发生了改动，则浏览器会触发“downloading”事件，并开始下载和缓存清单文件中列举的所有资源。随着下载过程的进行，浏览器还会触发“progress”事件，在下载完成后，会触发“updateready”事件。</p></li><li><p>首次载入新的应用程序</p><p>  如果还未缓存应用程序，“downloading”事件和“progress”事件都会触发。但是，当下载完成后，浏览器会触发“cached”事件而不是“updateready”事件。</p></li><li><p>浏览器处于离线状态</p><p>  如果浏览器处于离线状态，它无法检查清单文件，同时它会触发“error”事件。如果一个未缓存的应用程序引用一个不存在的清单文件，浏览器也会触发该事件。</p></li><li><p>清单文件不存在</p><p>  如果浏览器处于在线状态，应用程序也已经换存起来了，但是清单文件不存在（返回404无法找到错误），浏览器会触发“obsolete”事件，并将该应用程序从缓存中移除。</p></li></ul><p>除了使用事件处理程序之外，还可以使用<code>applicationCache.status</code>属性来查看当前缓存状态，该属性有6个可能的属性值：</p><ul><li><p><code>ApplicationCache.UNCACHED (0)</code></p><p>  应用程序没有设置manifest属性，未缓存</p></li><li><p><code>ApplicationCache.IDLE (1)</code></p><p>  清单文件已经检查完毕，并且已经缓存了最新的应用程序</p></li><li><p><code>ApplicationCache.CHECKING (2)</code></p><p>  浏览器正在检查清单文件</p></li><li><p><code>ApplicationCache.DOWNLOADING (3)</code></p><p>  浏览器正在下载并缓存清单中列举的所有文件</p></li><li><p><code>ApplicationCache.UPDATEREADY (4)</code></p><p>  已经下载和缓存了最新版的应用程序</p></li><li><p><code>ApplicationCache.OBSOLETE (5)</code></p><p>  清单文件不存在，缓存将被清除</p></li></ul><p>ApplicationCache对象还定义了两个方法：<code>update()</code>方法显式调用了更新缓存算法以检测是否有最新版本的应用程序。这导致浏览器检测同一个清单文件（并触发相同的事件），这和第一次载入应用程序时的效果是一样的。</p><p>还有一个方法是<code>swapCache()</code>，该方法更加巧妙。还记得当浏览器下载并缓存更新版本的应用时，用户仍然在运行老版本的应用吧。只有当用户再次载入应用时，才会访问到最新版本。但是如果用户没有重新载入，就必须要保证老版本的应用也要工作正常。同时要注意的时，老版本应用程序的相关资源可能是从缓存中加载的：比如，应用程序可能使用XMLHttpRequest去获取文件，而这些请求也务必要保证能够从老版本缓存中的文件获取到。因此，浏览器在用户再次载入应用前必须在缓存中保留老版本的应用。</p><p><code>swapCache()</code>方法告诉浏览器它可以弃用老的缓存，所有的请求都从新缓存中获取。要注意的是，这并不会重新载入应用程序：所有已经载入的HTML文件、图片、脚本等资源都不会改变。但是，之后的请求都将从最新的缓存中获取。这会导致“版本错乱”的问题，因此，一般不推荐使用，除非应用程序设计得很好，确保这样的方式没有问题。想象下，比方说，有这么个应用程序，它什么也不做，就只是在浏览器检查清单文件的整个过程中，显示过度画面。触发“noupdate”事件时，它继续“前进”并载入应用程序的首页。触发“downloading”事件，并且更新缓存后，它显示合适的反馈给用户。触发“updateready”事件时，它调用<code>swapCache()</code>方法，然后从最新的缓存中载入更新过的首页。</p><p>要注意的是，只有当状态属性是<code>ApplicationCache.UPDATEREADY</code>或者<code>ApplicationCache.OBSOLETE</code>时，调用<code>swapCache()</code>方法才有意义（当状态是OBSOLETE时，调用<code>swapCache()</code>方法可以立即弃用废弃的缓存，让之后所有的请求都通过网络获取）。如果在状态属性是其他数值的时候调用<code>swapCache()</code>方法，它就会抛出异常。</p><h4 id="4-离线Web应用"><a href="#4-离线Web应用" class="headerlink" title="4. 离线Web应用"></a>4. 离线Web应用</h4><p>离线Web应用指的是将自己“安装”在应用程序缓存中的程序，使得哪怕在浏览器处于离线状态时候依然可访问它。举个最简单的例子——类似时钟和万花筒生成器这样的应用——Web应用要离线可用需要做的事情。但是，大多数重要的Web应用也需要像服务器上传数据：哪怕是简单的游戏应用都有可能需要把用户的最高得分上传到服务器上。这类应用也可以成为离线应用。它们可以使用localStorage来存储应用数据，然后当在线的时候再将数据上传到服务器。在本地存储和服务器端同步数据是将Web应用转变为离线应用最巧妙的缓解，特别是当用户需要从多台设备获取数据的时候。</p><p>为了在离线状态可用，Web应用需要可以告知别人自己是离线还是在线，同时当网络连接的状态发生改变时候也能“感知”到。通过<code>navigator.onLine</code>属性，可以检测浏览器是否在线，同时，在Window对象上注册在线和离线事件的处理程序，可以检测网络连接状态的改变。</p><p>下面以一个简单的离线Web应用结束，该应用使用了这些技术。该应用名叫“PermaNote”——一个简单的记事本程序，它将用户的文本保存到localStorage中，并且在网络连接可用的时候，将其上传到服务器。PermaNote只允许用户编辑单个笔记，而且不考虑任何授权和身份验证的问题——它假设服务端有区分用户的方式，但是不包括任何登陆界面。PermaNode应用包含三个文件。其中appcache文件是一个缓存清单文件，它列出了另外两个文件，同时指定不需要缓存“note”这个url：我们使用此url来实现在服务端读写笔记数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- permanote.appcache --&gt;</span><br><span class="line"></span><br><span class="line">CACHE MANIFEST</span><br><span class="line"></span><br><span class="line"># PermaNote v8</span><br><span class="line">permanote.html</span><br><span class="line">permanote.js</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">note</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- permanote.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"permanote.appcache"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>PermaNote Editor<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"permanote.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">            <span class="selector-id">#editor</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">250px</span>; &#125;</span></span><br><span class="line"><span class="css">            <span class="selector-id">#statusline</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span>; &#125;</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"toolbar"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"savebutton"</span> <span class="attr">onclick</span>=<span class="string">"save()"</span>&gt;</span>Save<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"sync()"</span>&gt;</span>Sync Note<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"applicationCache.update()"</span>&gt;</span>Update Application<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"editor"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"statusline"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// permanote.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> editor, statusline, savebutton, idletimer;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次载入时，初始化本地存储</span></span><br><span class="line">    <span class="keyword">if</span> (localStorage.note == <span class="literal">null</span>)</span><br><span class="line">        localStorage.note = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> (localStorage.lastModified == <span class="literal">null</span>)</span><br><span class="line">        localStorage.lastModified = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (localStorage.lastSaved == <span class="literal">null</span>)</span><br><span class="line">        localStorage.lastSaved = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找编辑器UI元素，并初始化全局变量</span></span><br><span class="line">    editor = <span class="built_in">document</span>.getElementById(<span class="string">'editor'</span>);</span><br><span class="line">    statusline = <span class="built_in">document</span>.getElementById(<span class="string">'statusline'</span>);</span><br><span class="line">    savebutton = <span class="built_in">document</span>.getElementById(<span class="string">'savebutton'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化编辑器，将保存的笔记数据填充为其内容</span></span><br><span class="line">    editor.value = localStorage.note;</span><br><span class="line">    <span class="comment">// 同步前禁止编辑</span></span><br><span class="line">    editor.disabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一旦文本区有内容输入</span></span><br><span class="line">    editor.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将新的值保存到localStorage中</span></span><br><span class="line">        localStorage.note = editor.value;</span><br><span class="line">        localStorage.lastModified = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="comment">// 重置闲置计时器</span></span><br><span class="line">        <span class="keyword">if</span> (idletimer)</span><br><span class="line">            clearTimeout(idletime);</span><br><span class="line">        idletimer = setTimeout(save, <span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// 启用保存按钮</span></span><br><span class="line">        savebutton.disabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次载入应用程序时，尝试同步服务器</span></span><br><span class="line">    sync();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离开页面前保存数据到服务器</span></span><br><span class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (localStorage.lastModified &gt; localStorage.lastSaved)</span><br><span class="line">        save();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离线时，通知用户</span></span><br><span class="line"><span class="built_in">window</span>.onoffline = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'Offline'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次返回在线状态时，进行同步</span></span><br><span class="line"><span class="built_in">window</span>.ononline = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    sync();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有新版本应用的时候，提醒用户</span></span><br><span class="line"><span class="comment">// 这里我们也可以采用location.reload()方法来强制重新载入应用</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onupdateready = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'A new version of this application is available. Reload to run it.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当没有新版本的时候也通知用户</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onnoupdate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'You are running the latest version of the application'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于在状态栏中显示状态消息的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">status</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    statusline.innerHTML = msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每当笔记内容更新后，如果用户停止编辑超过5分钟</span></span><br><span class="line"><span class="comment">// 就会自动将笔记文本上传到服务器（在线状态下）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">save</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idletimer)</span><br><span class="line">        clearTimeout(idletimer);</span><br><span class="line"></span><br><span class="line">    idletimer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (navigator.onLine) &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">'PUT'</span>, <span class="string">'/note'</span>);</span><br><span class="line">        xhr.send(editor.value);</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            localStorage.lastSaved = <span class="built_in">Date</span>.now();</span><br><span class="line">            savebutton.disabled = <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查服务端是否有新版本的笔记，</span></span><br><span class="line"><span class="comment">// 如果没有，则将当前版本保存到服务器端</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (navigator.onLine) &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, <span class="string">'/note'</span>);</span><br><span class="line">        xhr.send();</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> remoteModTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> remoteModTime = xhr.getResponseHeader(<span class="string">'Last-Modified'</span>);</span><br><span class="line">                remoteModTime = <span class="keyword">new</span> <span class="built_in">Date</span>(remoteModTime).getTime();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (remoteModTime &gt; localStorage.lastModified) &#123;</span><br><span class="line">                status(<span class="string">'Newer note found on server.'</span>);</span><br><span class="line">                <span class="keyword">var</span> useit = confirm(<span class="string">'There is a newer version of the note\n'</span> + </span><br><span class="line">                                    <span class="string">'on the server. Click OK to use that version\n'</span> +</span><br><span class="line">                                    <span class="string">'or click Cancel to continue editing this\n'</span> +</span><br><span class="line">                                    <span class="string">'version and overwrite the server'</span>);</span><br><span class="line">                <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">                <span class="keyword">if</span> (useit) &#123;</span><br><span class="line">                    editor.value = localStorage.note = xhr.responseText;</span><br><span class="line">                    localStorage.lastSaved = now;</span><br><span class="line">                    status(<span class="string">'Newest version downloaded'</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    status(<span class="string">'Ignoring newer version of the note.'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                localStorage.lastModified = now;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                status(<span class="string">'You are editing the current version of the note'</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (localStorage.lastModified &gt; localStorage.lastSaved) &#123;</span><br><span class="line">                save();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            editor.disabled = <span class="literal">false</span>;</span><br><span class="line">            editor.focus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 离线状态下，不能同步</span></span><br><span class="line">        status(<span class="string">"Can't sync while offline"</span>);</span><br><span class="line">        editor.disabled = <span class="literal">false</span>;</span><br><span class="line">        editor.focus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web应用允许使用浏览器提供的API实现将数据存储到用户的电脑上，这种客户端存储相当于赋予了Web浏览器记忆功能。比方说，Web应用就可以用这种方式来“记住”用户的偏好甚至是用户所有的状态信息，以便准确地“回忆”起用户上一次访问的位置。客户端存储遵循“同源策略”，因此不同站点的页面是无法互相读取对方存储的数据，而同一站点的不同页面之间是可以互相共享存储数据的，它为我们提供了一种通信机制，例如，一个页面上填写的表单数据可以显示在另外一个页面中。Web应用可以选择它们存储数据的有效期：比如采用临时存储可以让数据保存至当前窗口关闭或者浏览器退出；采用永久存储，可以将数据永久地存储到硬盘上，数年或者数月不失效。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript客户端存储" scheme="http://www.xiaoleon.cn/tags/JavaScript%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>JS(11) 脚本化HTTP</title>
    <link href="http://www.xiaoleon.cn/2018/01/30/js-11/"/>
    <id>http://www.xiaoleon.cn/2018/01/30/js-11/</id>
    <published>2018-01-30T14:44:34.000Z</published>
    <updated>2018-02-02T12:48:05.169Z</updated>
    
    <content type="html"><![CDATA[<p>超文本传输协议（<code>HyperText Transfer Protocol，HTTP</code>）规定Web浏览器如何从Web服务器获取文档和向Web服务器提交表单内容，以及Web服务器如何响应这些请求和提交。Web浏览器会处理大量HTTP。通常，HTTP并不在脚本的控制下，只是当用户单机链接、提交表单和输入URL时才发生。</p><a id="more"></a><p>术语Ajax描述了一种主要使用脚本操纵HTTP的Web应用架构。Ajax应用的主要特点是使用脚本操纵HTTP和Web服务器进行数据交换，不会导致页面重载。避免页面重载的能力使Web应用感觉更像传统的桌面应用。Web应用可以使用Ajax技术把用户的交互数据记录到服务器中，也可以开始只显示简单页面，之后按需加载额外的数据和页面组件来提升应用的启动时间。</p><p><code>&lt;img&gt;</code>元素无法实现完整的Ajax传输协议，因为数据交换是单向的：客户端能发送数据到服务器，但服务器的响应一直是张图片导致客户端无法轻易从中提取信息。然而，<code>&lt;iframe&gt;</code>元素更加强大，为了把<code>&lt;iframe&gt;</code>作为Ajax传输协议使用，脚本首先要把发送给Web服务器的信息编码到URL中，然后设置<code>&lt;iframe&gt;</code>的src属性为该URL。服务器能创建一个包含相应内容的HTML，并把它返回给Web浏览器，并且在<code>&lt;iframe&gt;</code>中显示它。<code>&lt;iframe&gt;</code>需要对用户不可见，例如可以使用css隐藏它。脚本能通过遍历<code>&lt;iframe&gt;</code>的文档对象来读取服务端的响应。</p><p>实际上，<code>&lt;script&gt;</code>元素的src属性能设置URL并发起HTTP GET请求。使用<code>&lt;script&gt;</code>元素实现脚本操纵HTTP是非常吸引人的，因此它们可以跨域通信而不受限于同源策略。通常，使用基于<code>&lt;script&gt;</code>的Ajax传输协议时，服务器的响应采用JSON编码的数据格式，当执行脚本时，JavaScript解析器能够自动将其“解码”。由于它使用JSON数据格式，因此这种Ajax传输协议也叫做“JSONP”。</p><p>虽然在<code>&lt;iframe&gt;</code>和<code>&lt;script&gt;</code>传输协议上能实现Ajax技术，但通常还有更简单的方式。一段时间以来，所有浏览器都支持XMLHttpRequest对象，它定义了用脚本操纵HTTP的API。除了常用的GET请求，这个API还包含实现POST请求的能力，同时它能用文本或Document对象的形式返回服务器的响应。虽然名字叫XMLHttpRequest API，但并没有限定只能使用XML文档，它能获取任何类型的文本文档。</p><p>Comet传输协议比Ajax更精妙，但都需要客户端和服务器之间建立（必要时重新建立）连接，同时需要服务器保持连接处于打开状态，这样它才能够发送异步信息。隐藏的<code>&lt;iframe&gt;</code>能像Comet传输协议一样有用，例如，如果服务器以<code>&lt;iframe&gt;</code>中待执行的<code>&lt;script&gt;</code>元素的形式发送每条信息。实现Comet的一种更可靠跨平台方案是客户端建立一个和服务器的连接（使用Ajax传输协议），同时服务器保持这个连接打开直到它需要推送一条消息。服务器每发送一条消息就关闭这个连接，这样可以确保客户端正确接收到消息。处理该消息之后，客户端马上为后续的消息推送建立一个新连接。</p><p>实现可靠的跨平台Comet传输协议是非常有挑战性的，所以大部分使用Comet架构的Web应用开发者依赖于像Dojo这样的Web框架库中的传输协议。</p><p>在Ajax和Comet之上构建更高级的通信协议是可行的。例如，这些客户端/服务器技术可以用RPC（Remote Procedure call，远程过程调用）机制或发布/订阅事件系统的基础。</p><hr><h3 id="一、使用XMLHttpRequest"><a href="#一、使用XMLHttpRequest" class="headerlink" title="一、使用XMLHttpRequest"></a>一、使用XMLHttpRequest</h3><p>浏览器在XMLHttpRequest类上定义了它们的HTTP API。这个类的每个实例都表示一个独立的请求/响应对，并且这个对象的属性和方法允许指定请求细节和提取响应数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在IE5和IE6中模拟XMLHttpRequest()构造函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.XMLHttpRequest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">'Msxml2.XMLHTTP.6.0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e1) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">'Msxml2.XMLHTTP.3.0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (e2) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'XMLHttpRequest is not supported!'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个HTTP请求由4部分组成：</p><ul><li><p>HTTP请求方法或动作（verb）</p></li><li><p>正在请求的URL</p></li><li><p>一个可选的请求头集合，其中可能包括身份验证信息</p></li><li><p>一个可选的请求主体</p></li></ul><p>服务器返回的HTTP响应包含3部分：</p><ul><li><p>一个数字和文字组成的状态码，用来显示请求的成功和失败</p></li><li><p>一个响应头集合</p></li><li><p>响应主体</p></li></ul><p>HTTP的基础请求/相应架构非常简单并且易于使用。但在实践中会有各种各样随之而来的复杂问题：客户端和服务器交换cookie，服务器重定向浏览器到其他服务器，缓存某些资源而剩下的不换村，某些客户端通过代理服务器发送所有的请求等。XMLHttpRequest不是协议级的HTTP API而是浏览器级的API。浏览器需要考虑cookie、重定向、缓存和代理，但代码只需要关心请求和响应。</p><h4 id="1-指定请求"><a href="#1-指定请求" class="headerlink" title="1. 指定请求"></a>1. 指定请求</h4><p>创建XMLHttpRequest对象之后，发起HTTP请求的下一步是调用XMLHttpRequest对象的<code>open()</code>方法去指定这个请求的两个必须部分：方法和URL。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.open(<span class="string">'GET'</span>,                     <span class="comment">// 开始一个HTTP GET请求</span></span><br><span class="line">            <span class="string">'data.csv'</span>);                <span class="comment">// URL的内容</span></span><br></pre></td></tr></table></figure><p><code>open()</code>的第一个参数指定HTTP方法或动作。这个字符串不区分大小写，但通常大家用大写字母来匹配HTTP协议。“GET”和“POST”方法是得到广泛支持的。“GET”用于常规请求，它适用于当URL完全制定请求资源，当请求对服务器没有任何副作用以及当服务器的响应是可缓存时。“POST”方法常用于HTML表单。它在请求主体中包含额外数据（表单数据）且这些数据常存储到服务器上的数据库中（副作用）。相同URL的重复POST请求从服务器得到的响应可能不同，同时不应该缓存使用这个方法的请求。</p><p>除了“GET”和“POST”之外，XMLHttpRequest规范也允许把“DELETE”、“HEAD”、“OPTIONS”和“PUT”作为<code>open()</code>的第一个参数。旧浏览器并不支持所有这些方法，但至少“HEAD”得到广泛支持。</p><p><code>open()</code>的第二个参数是URL，它是请求的主题。这时相对于文档的URL，这个文档包含调用<code>open()</code>的脚本。如果只i的那个绝对URL、协议、主机和端口通常必须匹配所在文档的对应内容：跨域的请求通常会报错。</p><p>如果有请求头的话，请求进程的下个步骤就是设置它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br></pre></td></tr></table></figure><p>如果对相同的头调用<code>setRequestHeader()</code>多次，新值不会取代之前指定的值，相反，HTTP请求将包含这个头的多个副本或这个头将指定多个值。</p><p>我们不能自己指定“Content-Length”、“Date”、“Referer”或“User-Agent”头，XMLHttpRequest将自动添加这些头而防止伪造它们。类似地，XMLHttpRequest对象自动处理cookie、连接时间、字符集和编码判断，所以我们无法向<code>setRequestHeader()</code>传递这些头信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Accept-Charset      Content-Transfer-Encoding       TE</span><br><span class="line">Accept-Encoding     Date                            Trailer</span><br><span class="line">Connection          Expect                          Transfer-Encoding</span><br><span class="line">Content-Length      Host                            Upgrade</span><br><span class="line">Cookie              Keep-Alive                      User-Agent</span><br><span class="line">Cookie2             Referer                         Via</span><br></pre></td></tr></table></figure><p>我们能为请求指定“Authorization”头，但通常不需要这么做。如果请求一个受密码保护的URL，把用户名和密码作为第4个和第5个参数传递给<code>open()</code>，则XMLHttpRequest将设置合适的头。</p><p>使用XMLHttpRequest发起HTTP请求的最后一步是指定可选的请求主体并向服务器发送它。使用<code>send()</code>方法像如下这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>GET请求绝对没有主体，所以应该传递null或省略这个参数。POST请求通常拥有主体，同时它应该匹配使用<code>setRequestHeader()</code>指定的“Content-Type”头。</p><blockquote><p><strong>顺序问题</strong></p><p>HTTP请求的各部分有指定顺序：请求方法和URL首先到达，然后是请求头，最后是请求主体。XMLHttpRequest实现通常直到调用<code>send()</code>方法才开始启动网络。但XMLHttpRequest API的设计似乎使每个方法都将写入网络流。这意味着调用XMLHttpRequest方法的顺序必须匹配HTTP请求的架构。例如，<code>setRequestHeadr()</code>方法的调用必须在调用<code>open()</code>之后且在调用<code>send()</code>之前，否则它将抛出异常。</p></blockquote><p>下面使用了我们目前介绍的所有XMLHttpRequest方法。它用POST方法发送文本字符串给服务器，并忽略服务器返回的任何响应。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postMessage</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'POST'</span>, <span class="string">'/log.php'</span>);</span><br><span class="line">    request.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=UTF-8'</span>);</span><br><span class="line">    request.send(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-取得响应"><a href="#2-取得响应" class="headerlink" title="2. 取得响应"></a>2. 取得响应</h4><p>一个完整的HTTP响应由状态码、响应头集合和响应主体组成。这些都可以通过XMLHttpRequest对象的属性和方法使用：</p><ul><li><p>status和statusText属性以数字和文本的形式返回HTTP状态码。这些属性保存标准的HTTP值，像200和“OK”表示成功请求，404和“Not Found”表示URL不能匹配服务器上的任何资源。</p></li><li><p>使用<code>getResponseHeader()</code>和<code>getAllResponseHeaders()</code>能查询响应头。XMLHttpRequest会自动处理cookie：它会从<code>getAllResponseHeaders()</code>头返回集合中过滤掉cookie头，而如果给<code>getResponseHeader()</code>传递“Set-Cookie”和“Set-Cookie2”则返回null。</p></li><li><p>响应主体可以从responseText属性中得到文本形式的，从responseXML属性中得到Document形式的。</p></li></ul><p>XMLHttpRequest对象通常异步使用：发送请求后，<code>send()</code>方法立即返回，直接响应返回，前面列出的相应方法和属性才有效。为了在响应准备就绪时得到通知，必须监听XMLHttpRequest对象上的readystatechange事件。但是为了理解这个事件类型，我们必须理解readyState属性。</p><p>readyState是一个整数，它指定了HTTP请求的状态，下表列出了它可能的值。</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>UNSENT</td><td>0</td><td><code>open()</code>尚未调用</td></tr><tr><td>OPENED</td><td>1</td><td><code>open()</code>已调用</td></tr><tr><td>HEADERS_RECEIVED</td><td>2</td><td>接收到头信息</td></tr><tr><td>LOADING</td><td>3</td><td>接收到响应主体</td></tr><tr><td>DONE</td><td>4</td><td>响应完成</td></tr></tbody></table><p>第一列的符号是XMLHttpRequest构造函数定义的常量。这些常量是XMLHttpRequest规范的一部分，但老的浏览器和IE8没有定义它们，通常看到使用硬编码值4来表示XMLHttpRequest.DONE。</p><p>理论上，每次readyState属性改变都会触发readystatechange事件。实际中，当readyState改变为0或1时可能没有触发这个事件。当调用<code>send()</code>时，即使readyState仍处于OPENED状态，也通常触发它。某些浏览器在LOADING状态时能触发多次事件来给出进度反馈。当readyState值改变为4或服务器的响应完成时，所有的浏览器都触发readystatechange事件。因为在响应完成之前也会触发事件，所以事件处理程序应该一直检验readyState值。</p><p>为了监听readystatechange事件，请把事件处理函数设置为XMLHttpRequest对象的onreadystatechange属性。也能用<code>addEventListener()</code>，但通常每个请求只需要一个处理程序，所以只设置onreadystatechange更容易。</p><p>下面定义了<code>getText()</code>函数来演示如何监听readystatechange事件。事件处理程序首先要确保请求完成。如果这样，它会检查响应状态码来确保请求成功。然后它查找“Content-Type”头来验证响应主体是否时期望的类型。如果3个条件都得到满足，它会把响应主体（以文本形式）发送给指定的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getText</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'GET'</span>, url);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState == <span class="number">4</span> &amp;&amp; request.status == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> type = request.getResponseHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line">            <span class="keyword">if</span> (type.match(<span class="regexp">/^text/</span>))</span><br><span class="line">                callback(request.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    request.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>1) 同步响应</p><p>由于其本身的性质，异步处理HTTP响应是最好的方式。然而，XMLHttpRequest也支持同步响应。如果把false作为第三个参数传给<code>open()</code>，那么<code>send()</code>方法将阻塞直到请求完成。在这种情况下，不需要使用事件处理程序：一旦<code>send()</code>返回，仅需要检查XMLHttpRequest对象的status和responseText属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTextSync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">"GET"</span>, url, <span class="literal">false</span>);</span><br><span class="line">    request.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.status != <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(request.statusText);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> type = request.getResponseHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!type.match(<span class="regexp">/^text/</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected textual response; got: '</span> + type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> request.responseText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步请求是吸引人的，但应该避免使用它们。客户端JavaScript是单线程的，当<code>send()</code>方法阻塞时，它通常会导致整个浏览器UI冻结。如果连接的服务器响应慢，那么用户的浏览器将冻结。</p></li><li><p>2) 响应解码</p><p>在前面的示例中，我们假设服务器使用像“text/plain”、“text/html”、“text/css”这样的MIME类型发送文本响应，然后我们使用XMLHttpRequest对象的responseText属性得到它。</p><p>还可以通过其他方式来处理服务器的响应。如果服务器发送XML或XHTML文档作为其响应，我们可以通过responseXML属性获得一个解析形式的XML文旦。这个属性的值是一个Document对象。</p><p>如果服务器向发送诸如对象或数组这样的结构化数据作为其响应，它应该传输JSON编码的字符串数据。当接收它时，可以把responseText属性传递给<code>JSON.parse()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'GET'</span>, url);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState == <span class="number">4</span> &amp;&amp; request.status == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> type = request.getResponseHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line">            <span class="keyword">if</span> (type.indexOf(<span class="string">'xml'</span>) !== <span class="number">-1</span> &amp;&amp; request.responseXML)</span><br><span class="line">                callback(request.responseXML);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">'application/json'</span>)</span><br><span class="line">                callback(<span class="built_in">JSON</span>.parse(request.responseText));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                callback(request.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    request.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中检查该响应的“<code>Content-Type</code>”头且专门处理“<code>application/json</code>”影响。我们可能希望特殊编码的另一个响应类型是“<code>application/javascript</code>”或“<code>text/javascript</code>”。我们能使用XMLHttpRequest请求JavaScript脚本，然后使用全局<code>eval()</code>执行这个脚本。但是，在这种情况下不需要使用XMLHttpRequest对象，因为<code>&lt;script&gt;</code>元素本身操纵HTTP脚本的能力完全可以加载并执行脚本。且记住<code>&lt;script&gt;</code>元素能发起跨域HTTP请求，而XMLHttpRequest API则禁止。</p><p>Web服务端通常使用二进制数据响应HTTP请求。responseText属性只能用于文本（比如图片文件），且它不能妥善处理二进制响应，即使对最终字符串使用了<code>charCodeAt()</code>。XHR2定义了处理二进制响应的方法，本文不详细介绍该方法。</p><p>服务器响应的正常解码是假设服务器为这个响应发送了“<code>Content-Type</code>”头和正确的MIME类型。假设我们将下载XML文件，而我们计划把它当作纯文本对待。可以使用<code>setOverrideMimeType()</code>让XMLHttpRequest知道它不需要把文件解析成XML文档</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.overrideMimeType(<span class="string">'text/plain; charset=utf-8'</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-编码请求主体"><a href="#3-编码请求主体" class="headerlink" title="3. 编码请求主体"></a>3. 编码请求主体</h4><p>HTTP POST请求包括一个请求主体，它包含客户端传递给服务器的数据。</p><ul><li><p>1) 表单编码的请求</p><p>默认情况下，HTML表单通过POST方法发送给服务器，而编码后的表单数据则用做请求主体。对表单数据使用的编码方案相对简单：对每个表单元素的名字和值执行普通的URL编码（使用十六进制转义码替换特殊字符），使用等号把编码后的名字和值分开，并使用“<code>&amp;</code>”符号分开名值对。一个简单表单的编码如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find=pizza&amp;zipcode=<span class="number">01234</span>&amp;radius=<span class="number">1</span>km</span><br></pre></td></tr></table></figure><p>表单数据编码格式有一个正式的MIME类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>当使用POST方法提交这种顺序的表单数据时，必须设置“<code>Content-Type</code>”请求头为这个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeFormData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!data) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> pairs = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> name <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.hasOwnProperty(name))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> data[name] === <span class="string">'function'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> value = data[name].toString();</span><br><span class="line">        name = <span class="built_in">encodeURIComponent</span>(name.replace(<span class="string">'%20'</span>, <span class="string">'+'</span>));</span><br><span class="line">        value = <span class="built_in">encodeURIComponent</span>(value.replace(<span class="string">'%20'</span>, <span class="string">'+'</span>));</span><br><span class="line">        pairs.push(name + <span class="string">'='</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pairs.join(<span class="string">'&amp;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postData</span>(<span class="params">url, data, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'OPEN'</span>, url);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span> &amp;&amp; callback)</span><br><span class="line">            callback(request);</span><br><span class="line">    &#125;;</span><br><span class="line">    request.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">    request.send(encodeFormData(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url, data, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'GET'</span>, url + <span class="string">'?'</span> + encodeFormData(data));</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span> &amp;&amp; callback)</span><br><span class="line">            callback(request);</span><br><span class="line">    &#125;;</span><br><span class="line">    request.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2) JSON编码的请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postJSON</span>(<span class="params">url, data, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'POST'</span>, url);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span> &amp;&amp; callback)</span><br><span class="line">            callback(request);</span><br><span class="line">    &#125;;</span><br><span class="line">    request.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">    request.send(<span class="built_in">JSON</span>.stringigy(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>3) XML编码的请求</p><p>XML有时也用于数据传输的编码。JavaScript对象的用表单编码或JSON编码版本表达的pizza查询，也能用XML文档来表示它。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">query</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">find</span> <span class="attr">zipcode</span>=<span class="string">"01234"</span> <span class="attr">radius</span>=<span class="string">"1km"</span>&gt;</span></span><br><span class="line">        pizza</span><br><span class="line">    <span class="tag">&lt;/<span class="name">find</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">query</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在目前展示的所有示例中，XMLHttpRequest的<code>send()</code>方法的参数是一个字符串或null。实际上，这里可以传入XML Document对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postQuery</span>(<span class="params">url, what, where, radius, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'POST'</span>, url);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span> &amp;&amp; callback)</span><br><span class="line">            callback(request);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> doc = <span class="built_in">document</span>.implementation.createDocument(<span class="string">''</span>, <span class="string">'query'</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">var</span> query = doc.documentElement;</span><br><span class="line">    <span class="keyword">var</span> find = doc.createElement(<span class="string">'find'</span>);</span><br><span class="line">    query.appendChild(find);</span><br><span class="line">    find.setAttribute(<span class="string">'zipcode'</span>, where);</span><br><span class="line">    find.setAttribute(<span class="string">'radius'</span>, radius);</span><br><span class="line">    find.appendChild(doc.createTextNode(what));</span><br><span class="line">    request.send(doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当给<code>send()</code>方法传入XML文档时，并没有预先指定“Content-Type”头，但XMLHttpRequest对象会自动设置一个合适的头。类似地，如果给<code>send()</code>传入一个字符串但没有指定“Content-Type”头，那么XMLHttpRequest会添加“<code>ext/plain;charset=utf-8</code>”头。</p></li><li><p>4) 上传文件</p><p>HTML表单的特性之一是当用户通过<code>&lt;input type=&quot;file&quot;&gt;</code>元素选择文件时，表单将在它产生的POST请求主体中发送文件内容。HTML表单始终能上传文件，但它还不能使用XMLHttpRequest API做相同的事情。然后，XHR2 API允许通过向<code>send()</code>方法传入File对象来实现上传文件。</p><p>没有<code>File()</code>对象构造函数，脚本仅能获得表示用户当前选择文件的File对象。在支持File对象的浏览器中，每个<code>&lt;input type=&quot;file&quot;&gt;</code>元素有一个files属性，它是File对象中的类数组对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">whenReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elts = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elts.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> input = elts[i];</span><br><span class="line">        <span class="keyword">if</span> (input.type != <span class="string">'file'</span>)   </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">var</span> url = input.getAttribute(<span class="string">'data-uploadto'</span>);</span><br><span class="line">        <span class="keyword">if</span> (!url)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        input.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> file = <span class="keyword">this</span>.files[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (!file)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">            xhr.open(<span class="string">'POST'</span>, url);</span><br><span class="line">            xhr.send(file);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>文件类型是更通用的二进制大对象（Blob）类型中的一个子类型。XHR2允许向<code>send()</code>方法传入任何Blob对象。如果没有显式设置Content-Type头，这个Blob对象的type属性用于设置待上传的Content-Type头。如果需要上传已经产生的二进制数据，可以把数据转化为Blob并将其作为请求主体。</p></li><li><p>5) multipart/form-data请求</p><p>当HTML表单同时包含文件上传元素和其他元素时，浏览器不能使用普通的表单编码而必须使用称为“<code>multipart/form-data</code>”的特殊Content-Type来用POST方法提交表单。这种编码包括使用长“边界”字符串把请求主体分离成多个部分。对于文本数据，手动创建”<code>multipart/form-data</code>“请求主体是可能的，但很复杂。</p><p>XHR2定义了新的FormData API，它容易实现多部分请求主体。首先，使用<code>FormData()</code>构造函数创建FormData对象，然后按需多次调用这个对象的<code>append()</code>方法把个体“部分”（可以是字符串、File或Blob对象）添加到请求中。最后，把FormData对象传递给<code>send()</code>方法。<code>send()</code>方法将对请求定义合适的边界字符串和设置“Content-Type”头。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postFormData</span>(<span class="params">url, data, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> FormData === <span class="string">'undefined'</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'FormData is not implemented'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'POST'</span>, url);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span> &amp;&amp; callback)</span><br><span class="line">            callback(request);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> formdata = <span class="keyword">new</span> FormData();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.hasOwnProperty(name))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">var</span> value = data[name];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        formdata.append(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    request.send(formdata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-HTTP进度事件"><a href="#4-HTTP进度事件" class="headerlink" title="4. HTTP进度事件"></a>4. HTTP进度事件</h4><p>在之前的示例中，使用readystatechange事件探测HTTP请求的完成。XHR2规范草案定义了更多有用的事件集，在这个新的事件模型中，XMLHttpRequest对象在请求的不同阶段触发不同类型的事件，所以它不需要再检查readyState属性。</p><p>在支持它们的浏览器中，这些新事件会像如下这样触发。当调用<code>send()</code>时，触发单个loadstart事件。当正在加载服务器响应时，XMLHttpRequest对象会发生progress事件，通常每隔50毫秒左右，所以可以使用这些事件给用户反馈请求的进度。如果请求快速完成，它可能从不会触发progress事件。当事件完成，会触发load事件。</p><p>一个完成的请求不一定是成功的请求，例如，load事件的处理程序应该检查XMLHttpRequest对象的status状态码来确定收到的是“200 OK”而不是“404 Not Found”的HTTP响应。</p><p>HTTP请求无法完成有3种情况，对应3种事件。如果请求超时，会触发timeout事件。如果请求中止，会触发abort事件。最后，像太多重定向这样的网络错误会阻止请求完成，但这些情况发生时会触发error事件。</p><p>对于任何具体请求，浏览器将只会触发load、abort、timeout和error事件中的一个。XHR2规范草案指出一旦这些事件中的一个发生后，浏览器应该触发loadend事件。</p><p>可以通过XMLHttpRequest对象的<code>addEventListener()</code>方法为这些progress事件中的每个都注册处理程序。如果每种事件只有一个事件处理程序，通常更容易的方法是只设置对应的处理程序属性，比如onprogress和onload。甚至可以使用这些属性是否存在来测试浏览器是否支持progress事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'onprogress'</span> <span class="keyword">in</span> (<span class="keyword">new</span> XMLHttpRequest())) &#123;</span><br><span class="line">    <span class="comment">// 支持progress事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了像type和timestamp这样常用的Event对象属性外，与这些progress事件相关联的事件对象还有3个有用的属性。loaded属性是目前传输的字节数值。total属性是自“Content-Length”头传输的数据的整体长度（单位是字节），如果不知道内容长度则为0。最后，如果直到内容长度则lengthComputable属性为true，否则为false。显然，total和loaded属性对progress事件处理程序相当有用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.lengthComputable)</span><br><span class="line">        progress.innerHTML = <span class="built_in">Math</span>.round(<span class="number">100</span> * e.loaded / e.total) + <span class="string">'% Complete'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-上传进度事件"><a href="#5-上传进度事件" class="headerlink" title="5. 上传进度事件"></a>5. 上传进度事件</h4><p>除了为监控HTTP响应的加载定义的这些有用的事件外，XHR2也给出了用于监控HTTP请求上传的事件。在实现这些特性的浏览器中，XMLHttpRequest对象将有upload属性。upload属性值是一个对象，它定义了<code>addEventListener()</code>方法和整个progress事件集合，比如onprogress和onload。（但upload对象没有定义onreadystatechange属性，upload仅能触发新的事件类型。）</p><p>我们能仅仅像使用常见的progress事件处理程序一样使用upload事件处理程序。对于XMLHttpRequest对象x，设置<code>x.onprogress</code>以监控响应的下载进度，并且设置<code>x.upload.onprogress</code>以监控请求的上传进度。</p><p>下面我们延时如何使用upload progress事件把上传进度反馈给用户。这个示例也演示了如何从拖放API中获得File对象和如何使用FormData API在单个XMLHttpRequest请求中上传多个文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">whenReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elts = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'fileDropTarget'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elts.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> target = elts[i];</span><br><span class="line">        <span class="keyword">var</span> url = target.getAttribute(<span class="string">'data-uploadto'</span>);</span><br><span class="line">        <span class="keyword">if</span> (!url)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        createFileUploadDropTarget(target, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createFileUploadDropTarget</span>(<span class="params">target, url</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> uploading = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(target, url);</span><br><span class="line"></span><br><span class="line">        target.ondragenter = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'dragenter'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uploading)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> types = e.dataTransfer.types;</span><br><span class="line">            <span class="keyword">if</span> (types &amp;&amp; </span><br><span class="line">                (types.contains &amp;&amp; types.contains(<span class="string">'Files'</span>)) ||</span><br><span class="line">                (types.indexOf &amp;&amp; types.indexOf(<span class="string">'Files'</span>) !== <span class="number">-1</span>)) &#123;</span><br><span class="line">                target.classList.add(<span class="string">'wantdrop'</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        target.ondragover = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!uploading)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        target.ondragleave = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!uploading)</span><br><span class="line">                target.classList.remove(<span class="string">'wantdrop'</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        target.ondrop = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (uploading) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> files = e.dataTransfer.files;</span><br><span class="line">            <span class="keyword">if</span> (files &amp;&amp; files.length) &#123;</span><br><span class="line">                uploading = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">var</span> message = <span class="string">"Uploading files:&lt;ul&gt;"</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++)</span><br><span class="line">                    message += <span class="string">'&lt;li&gt;'</span> + files[i].name + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">                message += <span class="string">'&lt;/ul&gt;'</span>;</span><br><span class="line"></span><br><span class="line">                target.innerHTML = message;</span><br><span class="line">                target.classList.remove(<span class="string">'wantdrop'</span>);</span><br><span class="line">                target.classList.add(<span class="string">'uploading'</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">                xhr.open(<span class="string">'POST'</span>, url);</span><br><span class="line">                <span class="keyword">var</span> body = <span class="keyword">new</span> FormData();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; file.length; i++)</span><br><span class="line">                    body.append(i, files[i]);</span><br><span class="line">                xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.lengthComputable) &#123;</span><br><span class="line">                        target.innerHTML = message + <span class="built_in">Math</span>.round(e.loaded / e.total * <span class="number">100</span>) + <span class="string">'% COmplete'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                xhr.upload.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                    uploading = <span class="literal">false</span>;</span><br><span class="line">                    target.classList.remove(<span class="string">'uploading'</span>);</span><br><span class="line">                    target.innerHTML = <span class="string">'Drop files to upload'</span>;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                xhr.send(body);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            target.classList.remove(<span class="string">'wantdrop'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="6-中止请求和超时"><a href="#6-中止请求和超时" class="headerlink" title="6. 中止请求和超时"></a>6. 中止请求和超时</h4><p>可以通过调用XMLHttpRequest对象的<code>abort()</code>方法来取消正在进行的HTTP请求。<code>abort()</code>方法在所有的XMLHttpRequest版本和XHR2中可用，调用<code>abort()</code>方法在这个对象上触发abort事件，可以通过XMLHttpRequest对象的onabort属性来判断是否存在。</p><p>调用<code>abort()</code>的主要原因是完成取消或超时请求消耗的时间太长或当响应变得无关时。假设使用XMLHttpRequest为文本输入域请求自动完成推荐。如ugoyonghu在服务器的建议达到之前输入了新字符，这时等待请求不再有用，应该中止。</p><p>XHR2定义了timeout属性来指定请求自动中止后的毫秒数，也定义了timeout事件用于当超时发生时触发（不是abort事件）。可以用<code>setTimeout()</code>和<code>abort()</code>方法实现自己的超时。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timedGetText</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="keyword">var</span> timedout = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        timedout = <span class="literal">true</span>;</span><br><span class="line">        request.abort();</span><br><span class="line">    &#125;, timeout);</span><br><span class="line">    request.open(<span class="string">'GET'</span>, url);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readystate !== <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (timedout)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="keyword">if</span> (request.status == <span class="number">200</span>)</span><br><span class="line">            callback(request.responseText);</span><br><span class="line">    &#125;;</span><br><span class="line">    request.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-跨域HTTP请求"><a href="#7-跨域HTTP请求" class="headerlink" title="7. 跨域HTTP请求"></a>7. 跨域HTTP请求</h4><p>作为同源策略的一部分，XMLHttpRequest对象通常仅可以发起和文档具有相同服务器的HTTP请求。这个限制关闭了安全漏洞，但它笨手笨脚并且也阻止了大量合适使用的跨域请求。可以在<code>&lt;form&gt;</code>和<code>&lt;iframe&gt;</code>元素中使用跨域URL，而浏览器显示最终的跨域文档。但因为同源策略，浏览器不允许原始脚本查找跨域文档的内容。使用XMLHttpRequest，文档内容都是通过responseText属性暴露，所以同源策略不允许XMLHttpRequest进行跨域请求。（注意<code>&lt;script&gt;</code>元素并未真正受限于同源策略：它加载并执行任何来源的脚本。）</p><p>XHR2通过在HTTP相应中选择发送合适的CORS（Cross-Origin Resource Sharing，跨域资源共享）允许跨域访问网站。作为Web程序员，使用这个功能并不需要做什么额外的工作：如果浏览器支持XMLHttpRequest的CORS且实现跨域请求的网站决定使用CORS允许跨域请求，那么同源策略将会放宽而跨域请求就会正常工作。</p><p>虽然实现CORS支持的跨域请求工作不需要做任何事情，但有些安全细节需要了解。首先，如果给XMLHttpRequest的<code>open()</code>方法传入用户名和密码，那么它们绝对不会通过跨域请求发送（这使分布式密码破解攻击成为可能）。除外，跨域请求通常也不会包含其他任何的用户证书：cookie和HTTP身份令牌（token）通常不会作为请求的内容部分发送且任何作为跨域响应来接收的cookie都会丢弃。如果跨域请求需要这几种凭证才能成功，那么必须在用<code>send()</code>发送请求前设置XMLHttpRequest的withCredentials属性为true。这样做不常见，但测试withCredentials的存在性是测试浏览器是否支持CORS的一种方法。</p><p>下面示例使用XMLHttpRequest实现HTTP HEAD请求以下载文档中<code>&lt;a&gt;</code>元素链接资源的类型、大小和时间等信息。这个HEAD请求按需发起，且由此产生的链接信息会出现在工具提示中。这个示例假设跨域链接的信息不可用，但通过支持CORS的浏览器尝试下载它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">whenReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> supportsCORS = (<span class="keyword">new</span> XMLHttpRequest()).withCredentials !== <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> links = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; links.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> link = links[i];</span><br><span class="line">        <span class="keyword">if</span> (!link.href)                             </span><br><span class="line">            <span class="comment">// 跳过没有超链接的锚点</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (link.title)                             </span><br><span class="line">            <span class="comment">// 跳过已经有工具提示的链接</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (link.host !== location.host || link.protocol !== location.protocol) &#123;</span><br><span class="line">            <span class="comment">// 如果这是一个跨域链接</span></span><br><span class="line">            link.title = <span class="string">'站外链接'</span>;</span><br><span class="line">            <span class="keyword">if</span> (!supportsCORS)</span><br><span class="line">                <span class="comment">// 如果没有CORS支持就退出</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 否则，我们能了解这个链接的更多信息</span></span><br><span class="line">            <span class="comment">// 所以继续前进，注册事件处理程序，于是我们可以尝试</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (link.addEventListener)</span><br><span class="line">            link.addEventListener(<span class="string">'mouseover'</span>, mouseoverHandler, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            link.attachEvent(<span class="string">'onmouseover'</span>, mouseoverHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mouseoverHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> link = e.target || e.srcElement;</span><br><span class="line">        <span class="keyword">var</span> url = link.href;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        req.open(<span class="string">'HEAD'</span>, url);</span><br><span class="line">        req.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (req.readyState !== <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> type = req.getResponseHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line">                <span class="keyword">var</span> size = req.getResponseHeader(<span class="string">'Content-Length'</span>);</span><br><span class="line">                <span class="keyword">var</span> date = req.getResponseHeader(<span class="string">'Last-Modified'</span>);</span><br><span class="line"></span><br><span class="line">                link.title = <span class="string">'类型：'</span> + type + <span class="string">' \n'</span> + <span class="string">'大小：'</span> + size + <span class="string">' \n'</span> + <span class="string">'时间：'</span> + date;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!link.title)</span><br><span class="line">                    link.title = <span class="string">"Couldn't fetch details:\n"</span> + req.status + <span class="string">' '</span> + req.statusText;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        req.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (link.removeEventListener)</span><br><span class="line">            link.removeEventListener(<span class="string">'mouseover'</span>, mouseoverHandler, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            link.detachEvent(<span class="string">'onmouseover'</span>, mouseoverHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="二、借助script发送HTTP请求：JSONP"><a href="#二、借助script发送HTTP请求：JSONP" class="headerlink" title="二、借助script发送HTTP请求：JSONP"></a>二、借助script发送HTTP请求：JSONP</h3><p>本文概述提到过<code>&lt;script&gt;</code>元素可以作为一种Ajax传输机制：只须设置<code>&lt;script&gt;</code>元素的src属性（假如它还没插入到document中，需要插入进去），然后浏览器就会发送一个HTTP请求以下载src属性所指向的URL。使用<code>&lt;script&gt;</code>元素进行Ajax传入的一个主要原因是，它不受同源策略的影响，因此可以使用它们从其他的服务器请求数据，第二个原因是包含JSON编码数据的响应体会自动解码执行。</p><blockquote><p><strong>脚本和安全性</strong></p><p>为了使用<code>&lt;script&gt;</code>元素进行Ajax传入，必须允许Web页面可以执行远程服务器发送过来的任何JavaScript代码。这意味着对于不可信的服务器，不应该采取该技术。当与可信的服务器通信时，要提防攻击者可能进入服务器中，然后黑客会接管你的网页，运行他自己的代码，并显示任何他想要的内容，还表现的就像这些内容本就来自你的网站。</p><p>需要注意的是，这种方式普遍用于可信的第三方脚本，特别是在页面中嵌入广告和“组件”。作为Ajax传输使用的<code>&lt;script&gt;</code>与可信的Web服务通信，没有比这更危险的了。</p></blockquote><p>这种使用<code>&lt;script&gt;</code>元素作为Ajax传入的技术称为JSONP，若HTTP请求所得到的响应数据是经过JSON编码的，则适合使用该技术。P代表“填充”或“前缀”。</p><p>假设我们已经写了一个服务，它处理GET请求并返回JSON编码的数据，同源的文档可以在代码中使用XMLHttpRequest和JSON.parse()。加入在服务器上启用了CORS，在新的浏览器上，跨域的文档也可以使用XMLHttpRequest享受到该服务。在不支持CORS的旧浏览器上，跨域文档只能通过<code>&lt;script&gt;</code>元素访问这个服务。使用JSONP，JSON响应数据是合法的JavaScript代码，当它到达时浏览器将执行它。相反，不使用JSONP，而是对JSON编码过的数据解码，结果还是数据，并没有做任何事情。</p><p>这就是JSONP中P的意义所在。当通过<code>&lt;script&gt;</code>元素调用数据时，响应内容必须用JavaScript函数名和圆括号包裹起来。而不是发送这样一段JSON数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">"buckle"</span>: <span class="string">"my shoe"</span>&#125;]</span><br></pre></td></tr></table></figure><p>它会发送这样一个包裹后的JSON响应：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleResponse(</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">"buckle"</span>: <span class="string">"my shoe"</span>&#125;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>包裹后的响应会成为<code>&lt;script&gt;</code>元素的内容，它先判断JSON编码后的数据，然后把它传递给<code>handleResponse()</code>函数，我们可以假设，文档会拿这些数据做一些有用的事情。</p><p>为了可行起见，我们必须通过某种方式告诉服务，它正在从一个<code>&lt;script&gt;</code>元素调用，必须返回一个JSONP响应，而不应该是普通的JSON响应。这个可以通过在URL中添加一个查询参数来实现：例如，追加“<code>?json</code>”。</p><p>在实践中，支持JSONP的服务不会强制指定客户端必须实现的回调函数名称，比如handleResponse。想法，它们使用查询参数的值，允许客户端指定一个函数名，然后使用函数名去填充响应。下面代码使用了一个名为jsonp的查询参数来指定回调函数的名称。许多支持JSONP的服务都能分辨出这个参数名。另一个常见的参数名称是callback，为了让使用到的服务支持类似特殊的需求，就需要在代码上做一些修改了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSONP</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cbnum = <span class="string">'cb'</span> + getJSONP.count++;</span><br><span class="line">    <span class="keyword">var</span> cbname = <span class="string">'getJSONP.'</span> + cbnum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (url.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>)</span><br><span class="line">        url += <span class="string">'?jsonp='</span> + cbname;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        url += <span class="string">'&amp;jsonp='</span> + cbname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line"></span><br><span class="line">    getJSONP[cbnum] = <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callback(response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">delete</span> getJSONP[cbnum];</span><br><span class="line">            script.parentNode.removeChild(script);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    script.src = url;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getJSONP.counter = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="三、基于服务器端推送事件的Comet技术"><a href="#三、基于服务器端推送事件的Comet技术" class="headerlink" title="三、基于服务器端推送事件的Comet技术"></a>三、基于服务器端推送事件的Comet技术</h3><p>在服务器端推送事件的标准草案中定义了一个EventSource对象，简化了Comet应用程序的编写可以传递一个URL给<code>EventSource()</code>构造函数，然后再返回的实例上监听消息事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ticker = <span class="keyword">new</span> EventSource(<span class="string">'stockprices.php'</span>);</span><br><span class="line">ticker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type = e.type;</span><br><span class="line">    <span class="keyword">var</span> data = e.data;</span><br><span class="line">    <span class="comment">// 现在处理事件类型和事件的字符串数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与message事件关联的事件对象有一个data属性，这个属性保存服务器作为该事件的负载发送的任何字符串。如同其他类型的事件一样，该对象还有一个type属性，默认值是message，事件源可以修改这个值。onmessage事件处理程序接收从一个给定的服务器事件源发出的所有事件，如果有必要，也可以根据type属性派发一个事件。</p><p>服务器端推送事件的协议很简单。客户端（创建一个EventSource对象时会）建立一个到服务器的链接，服务器保持这个连接处于打开状态。当发生一个事件时，服务器端在连接中写入几行文本，抛给客户端的事件可能看起来是这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">event: bid              <span class="comment">// 设置时间对象的类型</span></span><br><span class="line">data: GOOG              <span class="comment">// 设置data属性</span></span><br><span class="line">daa: <span class="number">999</span>                <span class="comment">// 追加新的一行和更多的数据</span></span><br><span class="line">                        <span class="comment">// 一个空行会触发消息事件</span></span><br></pre></td></tr></table></figure><p>该协议还有一些额外的细节，比如允许事件携带给定ID，然后再次连上的客户端高速服务器它受到的最后一个事件的ID，这样服务器就可以重新发送客户端错过的事件。</p><p>Comet架构的一个常见应用是聊天应用，聊天客户端可以通过XMLHttpRequest向聊天室发送新的消息，也可以通过EventSource对象订阅聊天信息。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 一个使用EventSource的简易聊天客户端</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 注意一些UI细节</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> nick = prompt(<span class="string">'Enter your nickname'</span>);               <span class="comment">// 获取用户昵称</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>);           <span class="comment">// 找出input表单元素</span></span></span><br><span class="line"><span class="javascript">        input.focus();                                          <span class="comment">// 设置键盘焦点</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 通过EventSource注册新消息的通知</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> chat = <span class="keyword">new</span> EventSource(<span class="string">'/chat'</span>);</span></span><br><span class="line"><span class="javascript">        chat.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;                      <span class="comment">// 当捕获一条消息时</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> msg = event.data;                                <span class="comment">// 从事件对象中取得文本数据</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> node = <span class="built_in">document</span>.createTextNode(msg);            <span class="comment">// 把它放入一个文本节点</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);            <span class="comment">// 创建一个div</span></span></span><br><span class="line"><span class="javascript">            div.appendChild(node);                              <span class="comment">// 将文本节点插入div中</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.insertBefore(div, input);             <span class="comment">// 将div插入input之前</span></span></span><br><span class="line"><span class="javascript">            input.scrollIntoView();                             <span class="comment">// 保证input元素可见</span></span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 使用XMLHttpRequest把用户的消息发送给服务器</span></span></span><br><span class="line"><span class="javascript">        input.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                           <span class="comment">// 用户完成输入</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> msg = nick + <span class="string">': '</span> + input.value;                <span class="comment">// 组合用户名和用户输入的信息</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">            xhr.open(<span class="string">'POST'</span>, <span class="string">'/chat'</span>);                          <span class="comment">// 发送到/chat</span></span></span><br><span class="line"><span class="javascript">            xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=UTF-8'</span>);</span></span><br><span class="line"><span class="undefined">            xhr.send(msg);</span></span><br><span class="line"><span class="javascript">            input.value = <span class="string">''</span>;                                   <span class="comment">// 准备下次输入</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input"</span> <span class="attr">style</span>=<span class="string">"width:100%"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们通过一个服务器示例结束Comet架构的探讨。下面示例展示了一个用NodeJS编写的定制HTTP服务器。当一个客户端请求根URL为“<code>/</code>”时，它会把上面示例展示的聊天客户端代码发送到客户端。当客户端创建了一个指向“<code>/chat</code>”的GET请求时，它会用一个数组来保存响应数据流并保持连接处于打开状态。当客户端发起针对“chat”的POST请求时，它会将响应的主体部分作为一条聊天消息使用并写入数据，以“<code>data:</code>”作为Server-Sent Events的前缀，添加到每个已打开的响应数据流上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定制的Server-Sent Events聊天服务器</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clientui = <span class="built_in">require</span>(<span class="string">'fs'</span>).readFileSync(<span class="string">'chatclient.html'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServerResponse对象数组，用于接收发送的事件</span></span><br><span class="line"><span class="keyword">var</span> clients = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每20秒发送一条注释到客户端</span></span><br><span class="line"><span class="comment">// 这样它们就不会关闭连接再重连</span></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clients.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">        client.write(<span class="string">':ping?n'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新服务器</span></span><br><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> http.Server();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当服务器获取到一个新的请求，运行回调函数</span></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 解析请求的URL</span></span><br><span class="line">    <span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>).parse(request.url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求是发送到“/”，服务器就发送客户端聊天室UI</span></span><br><span class="line">    <span class="keyword">if</span> (url.pathname === <span class="string">'/'</span>) &#123;</span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>&#125;);</span><br><span class="line">        response.write(clientui);</span><br><span class="line">        response.end();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果请求是发送到“/chat”之外的地址，则返回404</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (url.pathname !== <span class="string">'/chat'</span>) &#123;</span><br><span class="line">        response.writeHead(<span class="number">404</span>);</span><br><span class="line">        response.end();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果请求类型是post，那么就有一个客户端发送了一条新的消息</span></span><br><span class="line">    <span class="keyword">if</span> (request.method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">        request.setEncoding(<span class="string">'utf-8'</span>);</span><br><span class="line">        <span class="keyword">var</span> body = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在获取到数据后，将其添加到请求主体中</span></span><br><span class="line">        request.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">            body += chunk;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当请求完成时，发送一个空响应</span></span><br><span class="line">        <span class="comment">// 并将消息传播到所有处于监听状态的客户端中</span></span><br><span class="line">        request.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            response.writeHead(<span class="number">200</span>);</span><br><span class="line">            response.end();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将消息转换成文本/事件流格式</span></span><br><span class="line">            <span class="comment">// 确保每一行的前缀都是“data:”</span></span><br><span class="line">            <span class="comment">// 并以两个换行符结束</span></span><br><span class="line">            message = <span class="string">'data: '</span> + body + <span class="string">"\r\n\r\n"</span>;</span><br><span class="line">            <span class="comment">// 发送消息给所有监听的客户端</span></span><br><span class="line">            clients.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">                client.write(message);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Otherwise, a client is requesting a stream of messages</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">'Content-Type'</span>: <span class="string">'text/event-stream'</span></span><br><span class="line">        &#125;);</span><br><span class="line">        response.write(<span class="string">'data: Connected\n\n'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果客户端关闭了链接</span></span><br><span class="line">        <span class="comment">// 从活动客户端数组中删除对应的响应对象</span></span><br><span class="line">        request.connection.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            clients.splice(clients.indexOf(response), <span class="number">1</span>);</span><br><span class="line">            response.end();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记下响应对象，这样就可以向他发送未来的消息</span></span><br><span class="line">        clients.push(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器，监听8000端口</span></span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;超文本传输协议（&lt;code&gt;HyperText Transfer Protocol，HTTP&lt;/code&gt;）规定Web浏览器如何从Web服务器获取文档和向Web服务器提交表单内容，以及Web服务器如何响应这些请求和提交。Web浏览器会处理大量HTTP。通常，HTTP并不在脚本的控制下，只是当用户单机链接、提交表单和输入URL时才发生。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript脚本化HTTP" scheme="http://www.xiaoleon.cn/tags/JavaScript%E8%84%9A%E6%9C%AC%E5%8C%96HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JS(10) 脚本化文档</title>
    <link href="http://www.xiaoleon.cn/2018/01/30/js-10/"/>
    <id>http://www.xiaoleon.cn/2018/01/30/js-10/</id>
    <published>2018-01-30T14:33:04.000Z</published>
    <updated>2018-02-02T12:48:05.179Z</updated>
    
    <content type="html"><![CDATA[<p>客户端JavaScript的存在使得静态的HTML文档变成了交互式的Web应用。脚本化Web页面内容是JavaScript的核心目标。每一个Web浏览器窗口、标签页和框架由一个Window对象所表示。每个Window对象有一个document属性引用了Document对象。Document对象表示窗口的内容，Document对象并非独立的，它是一个巨大的API中的核心对象，叫做文档对象模型（<code>Document Object Model，DOM</code>），它代表和操作文档的内容。</p><a id="more"></a><p>本文主要介绍以下内容：</p><ul><li><p>如何在文档中查询或选取单独的元素</p></li><li><p>如何将文档作为节点树来遍历，如何找到任何文档元素的祖先、兄弟和后代元素</p></li><li><p>如何查询和设置文档元素的属性</p></li><li><p>如何通过创建、插入和删除节点来修改文档结构</p></li><li><p>如何与HTML表单一起工作</p></li></ul><hr><h3 id="一、DOM概览"><a href="#一、DOM概览" class="headerlink" title="一、DOM概览"></a>一、DOM概览</h3><p>文档对象模型（DOM）是表示和操作HTML和XML文档内容的基础API。API不是特别复杂，但是需要理解大量的架构细节。首先，应该理解HTML或XML文档的嵌套元素在DOM树对象中的表示。HTML文档的树状结构包含表示HTML标签或元素和表示文本字符串的节点，它也可能包含表示HTML注释的节点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>An HTML Document<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">i</span>&gt;</span>simple<span class="tag">&lt;/<span class="name">i</span>&gt;</span> document.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="二、选取文档元素"><a href="#二、选取文档元素" class="headerlink" title="二、选取文档元素"></a>二、选取文档元素</h3><p>大多数客户端JavaScript程序运行时总是在操作一个或多个文档元素。当这些程序启动时，可以使用全局变量document来引用Document对象。但是，为了操作文档中的元素，必须通过某种方式获得或选取这些引用文档元素的Element对象。DOM定义许多方式来选取元素，查询文档的一个或多个元素有如下办法</p><ul><li><p>用指定的id属性</p></li><li><p>用指定的name属性</p></li><li><p>用指定的标签名字</p></li><li><p>用指定的css类</p></li><li><p>匹配指定的css选择器</p></li></ul><h4 id="1-通过ID获取元素"><a href="#1-通过ID获取元素" class="headerlink" title="1. 通过ID获取元素"></a>1. 通过ID获取元素</h4><p>任何HTML元素可以有一个id属性，在文档中该值必须唯一。可以用Document对象的<code>getElementById()</code>方法选取一个基于唯一ID的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> section1 = <span class="built_in">document</span>.getElementById(<span class="string">'section1'</span>);</span><br></pre></td></tr></table></figure><p>这是最简单和常用的选取元素的方法。如果想要操作某一组指定的文档元素，提供这些元素的id属性值，并使用id查找这些Element对象。如果需要通过ID查找多个元素，会发现下面的<code>getElements()</code>函数非常有用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElements</span>(<span class="params"><span class="regexp">/*ids...*/</span></span>)</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">elements</span> = </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> id = <span class="built_in">arguments</span>[i];</span><br><span class="line">        <span class="keyword">var</span> elt = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">        <span class="keyword">if</span> (elt == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'No element with id: '</span> + id);</span><br><span class="line">        elements[id] = elt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-通过名字选取元素"><a href="#2-通过名字选取元素" class="headerlink" title="2. 通过名字选取元素"></a>2. 通过名字选取元素</h4><p>HTML的name属性最初打算为表单元素分配名字，在表单数据提交到服务器时使用该属性的值。类似id属性，name是给元素分配名字，但是区别于id，name属性的值不是必须唯一：多个元素可能有同样的名字，在表单中，单选和复选按钮通常是这种情况。而且，和id不一样的是name属性只在少数HTML元素中有效，包括表单、表单元素、<code>&lt;iframe&gt;</code>和<code>&lt;img&gt;</code>元素。</p><p>基于name属性的值选取HTML元素，可以使用Document对象的<code>getElementsByName()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> radiobuttons = <span class="built_in">document</span>.getElementsByName(<span class="string">'favorite_color'</span>);</span><br></pre></td></tr></table></figure><p><code>getElementsByName()</code>定义在HTMLDocument类中，而不再Document类中，所以它只针对HTML文档可用，在XML文档中不可用。它返回一个NodeList对象，后者的行为类似一个包含若干Element对象的只读数组。在IE9及以下版本中，<code>getElementsByName()</code>也返回id属性匹配指定值的元素。为了兼容，应该小心谨慎，不要将同样的字符串同时用作名字和id。</p><h4 id="3-通过标签名选取元素"><a href="#3-通过标签名选取元素" class="headerlink" title="3. 通过标签名选取元素"></a>3. 通过标签名选取元素</h4><p>Document对象的<code>getElementsByTagName()</code>方法可以用来选取指定类型（标签名）的所有HTML或XML元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spans = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>);</span><br></pre></td></tr></table></figure><p>类似于<code>getElementsByName()</code>，<code>getElementsByTagName()</code>返回一个NodeList对象，返回的元素按照在文档中的顺序排序。给<code>getElementsByTagName()</code>传递通配符参数“*”将获得一个代表文档中所有元素的NodeList对象。</p><p>Element类也定义<code>getElementsByTagName()</code>方法，其原理和Document版本的一样，但是它只选取调用该方法的元素的后代元素。因此，要查找文档中第一个<code>&lt;p&gt;</code>元素里面的所有<code>&lt;span&gt;</code>元素，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstpara = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> firstParaSpans = firstpara.getElementsByTagName(<span class="string">'span'</span>);</span><br></pre></td></tr></table></figure><p>HTMLDocument对象还定义两个属性，它们指代特殊的单个元素而不是元素的集合。<code>document.body</code>是一个HTML文档的<code>&lt;body&gt;</code>元素，<code>document.head</code>是<code>&lt;head&gt;</code>元素。这些属性总是会定义：如果文档源代码未显式地包含<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>元素，浏览器将隐式地创建它们。Document类的documentElement属性指代文档的跟属性。在HTML文档中，它总是指代<code>&lt;html&gt;</code>元素。</p><h4 id="4-通过css类选取元素"><a href="#4-通过css类选取元素" class="headerlink" title="4. 通过css类选取元素"></a>4. 通过css类选取元素</h4><p>HTML元素的class属性值是一个以空格隔开的列表，可以为空或包含多个标识符。它描述一种方法来定义多组相关的文档元素：在它们的class属性中有相同标识符的任何元素属于改组的一部分。在JavaScript中clsss是保留字，所以客户端JavaScript使用className属性来保存HTML的class属性值。class属性通常与css样式表一起使用，对某组内的所有元素应用相同的样式。</p><p>类似<code>getElementsByTagName()</code>，在HTML文档和HTML元素上都可以调用<code>getElementsByClassName()</code>，它的返回值是一个实时的NodeList对象，包含文档或元素所有匹配的后代节点。<code>getElementsByClassName()</code>只需要一个字符串参数，但是该字符串可以由多个空格隔开的标识符组成。只有当元素的class属性值包含所有的指定的标识符时才匹配，但是标识符的顺序是无关紧要的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> warinings = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'warning'</span>);</span><br><span class="line"><span class="keyword">var</span> log = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'fatal error'</span>);</span><br></pre></td></tr></table></figure><h4 id="5-通过css选择器选取元素"><a href="#5-通过css选择器选取元素" class="headerlink" title="5. 通过css选择器选取元素"></a>5. 通过css选择器选取元素</h4><p>css样式表有一种非常强大的语法，那就是选择器，它用来描述文档中的若干或多组元素。Document对方提供了<code>querySelectorAll()</code>方法，用于根据选择器获取元素。它接收包含一个css选择器的字符串参数，返回一个表示文档中匹配选择器的所有元素的NodeList对象。与前面描述的选取元素的方法不同，<code>querySelectorAll()</code>返回的NodeList对象并不是实时的：它包含在调用时刻选择器所匹配的元素，但它并不更新后续文档的变化。如果没有匹配的元素，<code>querySelectorAll()</code>将会返回一个空的NodeList对象。如果选择器字符串非法，<code>querySelectorAll()</code>将抛出一个异常。</p><p>除了<code>querySelectorAll()</code>，文档对象还定义了<code>querySelector()</code>方法，与前者工作原理类似，但它只返回第一个匹配的元素，或者如果没有匹配的元素就返回null。</p><p>这两个方法在Element节点中也有定义。在元素上调用时，指定的选择器仍然在整个文档中进行匹配，然后过滤出结果集以便它只包含指定元素的后代元素。这看起来是违反常规的，因为它意味着选择器字符串能包含元素的祖先而不仅仅是上述所匹配的元素。</p><p>注意，css定义了“<code>:first-line</code>”和“<code>:first-letter</code>”等伪元素。在css中，它们匹配文本节点的一部分而不是实际元素。如果和<code>querySelectorAll()</code>或<code>querySelector()</code>一起使用它们是不匹配的。而且，很多浏览器会拒绝返回“<code>:link</code>”和“<code>:visited</code>”等伪类的匹配结果，因为这会泄漏用户的浏览历史记录。</p><p><code>querySelectorAll()</code>是终极的选取元素的方法：它是一种非常强大的技术，通过它客户端的JavaScript程序能选择它们想要操作的元素。幸运的是，甚至在没有<code>querySelectorAll()</code>的原生支持的浏览器中也可以使用css选择器。jQuery库使用这种基于css选择器的查询作为它的核心编程方式。基于jQuery的Web应用程序使用一个轻便的、跨浏览器的、和<code>querySelectorAll()</code>等效的方法，命名为<code>$()</code>。</p><p>jquery的css选择器匹配代码已经作为一个独立的标准库提出来并发布了，命名为Sizzle。它已经被Dojo和其他一些客户端库所采纳，使用一个类似Sizzle的库的好处就是在老式浏览器中选取元素也能正常工作，并保证一个基准的选择器集合在所有的浏览器中都能运行。</p><h4 id="6-document-all"><a href="#6-document-all" class="headerlink" title="6. document.all"></a>6. document.all</h4><p>在DOM标准化之前，IE引入了<code>document.all</code>集合来表示所有文档中的元素（除了Text节点）。<code>document.all</code>已经被标准的方法所取代，现在已经废弃不应该再使用了。</p><hr><h3 id="三、文档结构和遍历"><a href="#三、文档结构和遍历" class="headerlink" title="三、文档结构和遍历"></a>三、文档结构和遍历</h3><p>一旦从文档中选取了一个元素，有时需要查找文档中与之在结构上相关的部分（父亲、兄弟和子女）。文档从概念上可以看作是一颗节点对象树。</p><h4 id="1-作为节点树的文档"><a href="#1-作为节点树的文档" class="headerlink" title="1. 作为节点树的文档"></a>1. 作为节点树的文档</h4><p>Document对象、它的Element对象和文档中表示文本的Text对象都是Node对象。Node对象定义了以下重要的属性：</p><ul><li><p><code>parentNode</code></p><p>  该节点的父节点，或者针对类似Document对象应该是null，因为它没有父节点。</p></li><li><p><code>childNodes</code></p><p>  只读的类数组对象（NodeList对象），它是该节点的子节点的实时表示。</p></li><li><p><code>firstChild</code>、<code>lastChild</code></p><p>  该节点的子节点中的第一个和最后一个，如果该节点没有子节点则为null。</p></li><li><p><code>nextSibling</code>、<code>previousSibling</code></p><p>  该节点的兄弟节点中的前一个和下一个。具有相同父节点的两个节点为兄弟节点。节点的顺序反映了它们在文档中出现的顺序。这两个属性将节点之间以双向链表的形式连接起来。</p></li><li><p><code>nodeType</code></p><p>  该节点的类型。9代表Document节点，1代表Element节点，3代表Text节点，8代表Comment节点，11代表DocumentFragment节点。</p></li><li><p><code>nodeValue</code></p><p>  Text节点或Comment节点的文本内容。</p></li><li><p><code>nodeName</code></p><p>  元素的标签名，以大写形式表示。</p></li></ul><p>使用这些Node属性，可以用以下类似的表达式得到文档的第一个子节点下面的第二个子节点的引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.childNodes[<span class="number">0</span>].childNodes[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">document</span>.firstNode.firstChild.nextSibling;</span><br></pre></td></tr></table></figure><p>假设上述提到的文档代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么第一个子节点下面的第二个子节点就是<code>&lt;body&gt;</code>元素，它的nodeType为1，nodeName为“BODY”。</p><p>但请注意，该API对文档文本的变化极为敏感。例如，如果修改了文档，在<code>&lt;html&gt;</code>和<code>&lt;head&gt;</code>标签之间插入一个新行，那么表示该新行的Text节点就是文档的第一个子节点下面的第一个子节点，并且<code>&lt;head&gt;</code>元素就是第二个子节点而不是<code>&lt;body&gt;</code>元素了。</p><h4 id="2-作为元素树的文档"><a href="#2-作为元素树的文档" class="headerlink" title="2. 作为元素树的文档"></a>2. 作为元素树的文档</h4><p>当将主要的兴趣点集中在文档的元素上而非它们之间的文本（和它们之间的空白）上时，我们可以使用另外一个更有用的API。它将文档看作是Element对象树，忽略部分文档：Text和Comment节点。</p><p>该API的第一部分是Element对象的children属性。类似ChildNodes，他也是一个NodeList对象，但不同的是children列表只包含Element对象。children并非标准属性，但是它在所有当前的浏览器中都能工作。</p><p>注意，Text和Comment节点没有children属性，它意味着<code>Node.parentNode</code>属性不可能返回Text或Comment节点。任何Element的parentNode总是另一个Element，或者，追溯到树根的Document或DocumentFragment节点。</p><p>基于元素的文档遍历API的第二部分是Element属性，后者类似Node对象的子属性和兄弟属性</p><p><code>firstElementChild，lastElementChild</code>：类似<code>firstChild</code>和<code>lastChild</code>，但只代表子Element。</p><p><code>nextElementSibling，previousElementSibling</code>：类似<code>nextSibling</code>和<code>previousSibling</code>，但只代表兄弟Element。</p><p><code>childElementCount</code>：子元素的数量。返回的值和<code>children.length</code>值相等。</p><p>子元素和兄弟元素的属性是标准属性。由于逐个元素的文档遍历的API并未完全标准化，我们仍然可以通过如下的遍历函数来实现这种功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回元素e的第n层祖先元素，如果不存在此类祖先或祖先不是Element，</span></span><br><span class="line"><span class="comment">（列入Document或DocumentFragment）则返回null</span></span><br><span class="line"><span class="comment">如果n为0，则返回e本身</span></span><br><span class="line"><span class="comment">如果n为1，则返回其父元素</span></span><br><span class="line"><span class="comment">如果n为2，则返回其祖父元素，依此类推</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parent</span>(<span class="params">e, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="literal">undefined</span>)</span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; e) &#123;</span><br><span class="line">        e = e.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!e || e.nodeType !== <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回元素e的第n个兄弟元素</span></span><br><span class="line"><span class="comment">如果n为正，返回后续的第n个兄弟元素</span></span><br><span class="line"><span class="comment">如果n为负，返回前面的第n个兄弟元素</span></span><br><span class="line"><span class="comment">如果n为零，返回e本身</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sibling</span>(<span class="params">e, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(e &amp;&amp; n !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.nextElementSibling) &#123;</span><br><span class="line">                e = e.nextElementSibling;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (e = e.nextSibling; e &amp;&amp; e.nodeType !== <span class="number">1</span>; e = e.nextSibling) &#123;</span><br><span class="line">                    <span class="comment">// 空循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.previousElementSibling) &#123;</span><br><span class="line">                e = e.previousElementSibling;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (e = e.previousSibling; e &amp;&amp; e.nodeType !== <span class="number">1</span>; e = e.previousSibling) &#123;</span><br><span class="line">                    <span class="comment">// 空循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回元素e的第n代子元素，如果不存在则为null</span></span><br><span class="line"><span class="comment">负值n代表从后往前技术。0表示第一个子元素，而-1代表最后一个</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params">e, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.children) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 转换负的n为数组索引</span></span><br><span class="line">            n += e.children.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e.children[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.firstElementChild) &#123;</span><br><span class="line">            e = e.firstElementChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (e = e.firstChild; e &amp;&amp; e.nodeType !== <span class="number">1</span>; e = e.nextSibling) &#123;</span><br><span class="line">                <span class="comment">// 空循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sibling(e, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.lastElementChild) &#123;</span><br><span class="line">            e = e.lastElementChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (e = e.lastChild; e &amp;&amp; e.nodeType !== <span class="number">1</span>; e = e.previousSibling) &#123;</span><br><span class="line">                <span class="comment">// 空循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sibling(e, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-自定义Element的方法"><a href="#3-自定义Element的方法" class="headerlink" title="3. 自定义Element的方法"></a>3. 自定义Element的方法</h4><p>所有当前浏览器都实现了DOM，故类似Element和HTMLDocument等类型都像String和Array一样是类。他们不是构造函数，但它们有原型对象，可以用自定义方法扩展它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.nextElementSibling)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.nextElementSibling;</span><br><span class="line">    <span class="keyword">var</span> sib = <span class="keyword">this</span>.nextSibling;</span><br><span class="line">    <span class="keyword">while</span>(sib &amp;&amp; sib.nodeType !== <span class="number">1</span>) &#123;</span><br><span class="line">        sib = sib.nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sib;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="四、属性"><a href="#四、属性" class="headerlink" title="四、属性"></a>四、属性</h3><p>HTML元素由一个标签和一组称为属性（attribute）的名值对组成。HTML元素的属性值在代表这些元素的HTMLElement对象的属性（property）中是可用的。DOM还定义了另外的API来获取或设置XML属性值和非标准的HTML属性。</p><h4 id="1-HTML属性作为Element的属性"><a href="#1-HTML属性作为Element的属性" class="headerlink" title="1. HTML属性作为Element的属性"></a>1. HTML属性作为Element的属性</h4><p>表示HTML文档元素的HTMLElement对象定义了读/写属性，它们影射了元素的HTML属性。HTMLElement定义了通用的HTTP属性（如id、标题lang和dir）的属性，以及事件处理程序属性（如onclick）。特定的Element子类型为其元素定义了特定的属性。例如，查询一张图片的url，可以使用表示<code>&lt;img&gt;</code>的HTMLElement对象的src属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">'myimage'</span>);</span><br><span class="line"><span class="keyword">var</span> imgurl = image.src;</span><br><span class="line">image.id === <span class="string">'myimage'</span>;</span><br></pre></td></tr></table></figure><p>同样的，可以为一个<code>&lt;form&gt;</code>元素设置表单提交的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.forms[<span class="number">0</span>];</span><br><span class="line">f.action = <span class="string">'http://www.example.com/submit.php'</span>;</span><br><span class="line">f.method = <span class="string">'post'</span>;</span><br></pre></td></tr></table></figure><p>HTML属性名不区分大小写，但JavaScript属性名则大小写敏感。从HTML属性名转换到JavaScript属性名应该采用小写。但是，如果属性名包含不止一个单词，则将除了第一个单词以外的单词的首字母大写，例如defaultChecked和tabIndex。</p><p>有些HTML属性名在JavaScript中是保留字。对于这些属性，一般的规则是为属性名加前缀“html”。例如，HTML的for属性在JavaScript中变为htmlFor属性。但“class”在JavaScript中变为className。</p><p>表示HTML属性的值通常是字符串。当属性为布尔值或数值，属性也是布尔值或数值，而不是字符串。事件处理程序属性值总是Function对象（或null）。H5规范定义了一个新的属性（如<code>&lt;input&gt;</code>和相关元素的form属性）用以将元素ID转换为实际的Element对象。最后，任何HTML元素的style属性值是<code>CSSStyleDeclaration</code>对象，而不是字符串。</p><p>注意，这个基于属性的API用来获取和设置属性值，但没有定义任何从元素中删除属性的方法。奇怪的是，delete操作符也无法完成此目的。</p><h4 id="2-获取和设置非标准HTML属性"><a href="#2-获取和设置非标准HTML属性" class="headerlink" title="2. 获取和设置非标准HTML属性"></a>2. 获取和设置非标准HTML属性</h4><p>如上所述，HTMLElement和其子类型定义了一些属性，它们对应于元素的标准HTML属性。Element类型还定义了<code>getAttribute()</code>和<code>setAttribute()</code>方法来查询和设置非标准的HTML属性，也可用来查询和设置XML文档中元素上的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> image = <span class="built_in">document</span>.images[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> width = <span class="built_in">parseInt</span>(image.getAttribute(<span class="string">'width'</span>));</span><br><span class="line">image.setAttribute(<span class="string">'class'</span>, <span class="string">'thumbnail'</span>);</span><br></pre></td></tr></table></figure><p>上述代码给出了这些方法和前面的基于属性的API之间两个重要的区别。首先，属性值都被看作是字符串。<code>getAttribute()</code>不返回数值、布尔值或对象。其次，方法使用标准属性名，甚至当这些名称为JavaScript保留字时也不例外。对HTML元素来说，属性名不区分大小写。</p><p>Element类还定义了两个相关方法，<code>hasAttribute()</code>和<code>removeAttribute()</code>，它们用来检测命名属性是否存在和完全删除属性。当属性为布尔值时这些方法特别有用：有些属性（如disabled等）在一个元素中是否存在是重点关键，而其值却无关紧要。</p><h4 id="3-数据集属性"><a href="#3-数据集属性" class="headerlink" title="3. 数据集属性"></a>3. 数据集属性</h4><p>有时候在HTML元素上绑定一些额外的信息也是很有帮助的，当JavaScript选取这些元素并以某种方式操纵这些信息时就是很典型的情况。有时可以通过给class属性添加特殊的标识符来完成。其他时候针对更复杂的数据，客户端程序员会借助使用非标准的属性。如上所述，可以使用<code>getAttribute()</code>和<code>setAttribute()</code>来读和写非标准属性的值。</p><p>H5提供了一个解决方案。在HTML5文档中，任意以“<code>data-</code>”为前缀的小写的属性名字都是合法的。这些“数据集属性”将不会对其元素的表现产生影响，它们定义了一种标准的、附加额外数据的方法，并不是在文档合法性上做出让步。</p><p>H5还在Element对象上定义了<code>dataset</code>属性。该属性指代一个对象，它的各个属性对应于去掉前缀的<code>data-</code>属性。因此<code>dataset.x</code>应该保存<code>data-x</code>属性的值。带连字符的属性对应于驼峰命名法属性名：<code>data-jquery-test</code>属性就变成<code>dataset.jqueryTest</code>属性。</p><h4 id="4-作为Attr节点的属性"><a href="#4-作为Attr节点的属性" class="headerlink" title="4. 作为Attr节点的属性"></a>4. 作为Attr节点的属性</h4><p>还有一种使用Element的属性的方法。Node类型定义了attributes属性。针对非Element对象的任何节点，该属性为null。对于Element对象，attributes属性是只读的类数组对象，它代表元素的所有属性。类似Nodelists，attributes对象也是实时的。它可以用数字索引访问，这意味着可以枚举元素的所有属性。并且，它也可以用属性名索引。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.attributes[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">document</span>.body.attributes.bgColor;</span><br><span class="line"><span class="built_in">document</span>.body.attributes[<span class="string">'onload'</span>];</span><br></pre></td></tr></table></figure><p>当索引attributes对象时得到的值是Attr对象。Attr对象一类特殊的Node，但从来不会像Node一样去用。Attr的name和value属性返回该属性的名字和值。</p><hr><h3 id="五、元素的内容"><a href="#五、元素的内容" class="headerlink" title="五、元素的内容"></a>五、元素的内容</h3><h4 id="1-作为HTML的元素内容"><a href="#1-作为HTML的元素内容" class="headerlink" title="1. 作为HTML的元素内容"></a>1. 作为HTML的元素内容</h4><p>读取Element的innerHTML属性作为字符串标记返回那个元素的内容。在元素上设置该属性调用了Web浏览器的解析器，用新字符串内容的解析展现形式替换元素当前内容。</p><p>Web浏览器很擅长解析HTML，通常设置innerHTML效率非常高，甚至在指定的值需要解析时效率也是相当不错。但注意，对innerHTML属性用“+=”操作符重复追加一小段文本通常效率低下，因为它既要序列化又要解析。</p><p>innerHTML是IE4中引入的，虽然所有的浏览器都支持他已经有很长时段时间了，但随着H5的到来它才变得标准化。H5说innerHTML应该在Document节点以及Element节点上工作正常，但这还未被普遍地支持。</p><p>H5还标准化了outerHTML属性。当查询outerHTML时，返回的HTML或XML标记的字符串包含被查询元素的开头和结尾标签。当设置元素的outerHTML时，元素本身被新的内容所替换。只有Element节点定义了outerHTML属性，Document节点则无。</p><p>IE引入的另一个特性是<code>insertAdjacentHTML()</code>方法，它将在H5中标准化，它将任意的HTML标记字符插入到指定的元素“相邻”的位置。标记是该方法的第二个参数，并且“相邻”的精确含义依赖于第一个参数的值。第一个参数为具有以下值之一的字符串：<code>“beforebegin”、“afterbegin”、“beforeend”和“afterend”</code>。</p><pre><code>|&lt;div id=&quot;target&quot;&gt;|This is the element content|&lt;/div&gt;|↑                 ↑                           ↑      ↑beforebegin   afterbegin                  beforeend  afterend</code></pre><h4 id="2-作为纯文本的元素内容"><a href="#2-作为纯文本的元素内容" class="headerlink" title="2. 作为纯文本的元素内容"></a>2. 作为纯文本的元素内容</h4><p>有时需要查询纯文本形式的元素内容，或者在文档中插入纯文本（不必转义HTML标记中使用的尖括号和&amp;符号）。标准的方法是用Node的textContent属性来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> text = para.textContent;</span><br><span class="line">para.textContent = <span class="string">'hello world!'</span>;</span><br></pre></td></tr></table></figure><p><code>textContent</code>属性在除了低版本IE的所有当前浏览器中都支持。在IE中，可以用Element的innerText属性来代替。微软在IE 4中引入了innerText属性，它在除了低版本的FireFox的所有当前浏览器都支持。</p><p><code>textContent</code>和<code>innerText</code>属性非常相似，通常可以互相替换使用。不过要小心空元素（在JavaScript中字符串””是假值）和未定义的属性之间的区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个参数，返回元素的textContent或innerText</span></span><br><span class="line"><span class="comment">两个参数，用value参数的值设置元素的textContent或innerText</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">textContent</span>(<span class="params">element, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content = element.textContent;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (content !== <span class="literal">undefined</span>)</span><br><span class="line">            <span class="keyword">return</span> content;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> element.innerText;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (content !== <span class="literal">undefined</span>)</span><br><span class="line">            element.textContent = value;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            element.innerText = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>textContent属性就是将指定元素的所有后代Text节点简单地串联在一起。innerText没有一个明确指定的行为，但是和textContent有一些不同。innerText不返回<code>&lt;script&gt;</code>元素的内容。它忽略多余的空白，并试图保留表格格式。同时，innerText针对某些表格元素（<code>&lt;table&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;tr&gt;</code>）是只读的属性。</p><h4 id="3-作为Text节点的元素内容"><a href="#3-作为Text节点的元素内容" class="headerlink" title="3. 作为Text节点的元素内容"></a>3. 作为Text节点的元素内容</h4><p>另一种方法处理元素的内容是当作一个子节点列表，每个子节点可能有它字迹的一组子节点。当考虑元素的内容时，通常感兴趣的是它的Text节点。</p><p>下面展示一个<code>textContent()</code>函数，它递归地遍历元素的子节点，然后连接后代节点中所有的Text节点的文本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">textContent</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> child, type, s = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(child = e.firstChild; child != <span class="literal">null</span>; child = child.nextSibling) &#123;</span><br><span class="line">        type = child.nodeType;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="number">3</span> || type === <span class="number">4</span>)</span><br><span class="line">            s += child.nodeValue;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="number">1</span>)</span><br><span class="line">            s += textContent(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nodeValue属性可以读/写，设置它可以改变Text或CDATASection节点所显示的内容。Text和CDATASection都是CharacterData的子类型。CharacterData定义了data属性，它和nodeValue的文本相同。以下函数通过设置data属性将Text节点的内容转换成大写形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upcase</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n.nodeType == <span class="number">3</span> || n.nodeType == <span class="number">4</span>)     <span class="comment">// 如果n是Text或CDATA节点</span></span><br><span class="line">        n.data = n.data.toUpperCase();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n.childNodes.length; i++)</span><br><span class="line">            upcase(n.childNodes[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CharacterData还定义了一些在Text或CDATASection节点不太常用的方法来添加、删除、插入和替换文本。除了修改已存在Text节点的内容，还可以在Element中插入全新的Text节点或用新Text节点来替换已有节点。</p><hr><h3 id="六、创建、插入和删除节点"><a href="#六、创建、插入和删除节点" class="headerlink" title="六、创建、插入和删除节点"></a>六、创建、插入和删除节点</h3><p>我们已经看到用HTML和纯文本字符串如何来查询和修改文档内容，也已经看到我们能够遍历Document来检查组成Document的每个Element和Text节点。在每个节点级别修改文档也是有可能的。Document类型定义了创建Element和Text对象的方法，Node类型定义了在节点树中插入、删除和替换的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadasync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    s.src = url;</span><br><span class="line">    head.appendChild(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-创建节点"><a href="#1-创建节点" class="headerlink" title="1. 创建节点"></a>1. 创建节点</h4><p>创建新的Element节点可以使用Document对象的<code>createElement()</code>方法。给方法传递元素的标签名：对HTML文档来说该文档不区分大小写，对XML文档则区分大小写。</p><p>Text节点用类似的方法创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newnode = <span class="built_in">document</span>.createTextNode(<span class="string">'text node content'</span>);</span><br></pre></td></tr></table></figure><p>Document也定义了一些其他的工厂方法，如不经常使用的<code>createComment()</code>、<code>createDocumentFragment()</code>。</p><p>另一种创建新文档节点的方法是复制已存在的节点。每个节点有一个<code>cloneNode()</code>方法来返回该节点的一个全新副本。给方法传递参数true也能够递归地复制所有的后代节点，或传递参数false只是执行一个浅复制。在除了IE的其他浏览器中，Document对象还定义了一个类似的方法叫<code>importNode()</code>。如果给它传递另一个文档的一个节点，它将返回一个适合本文档插入的节点的副本。传递true作为第二个参数，该方法将递归地导入所有的后代节点。</p><h4 id="2-插入节点"><a href="#2-插入节点" class="headerlink" title="2. 插入节点"></a>2. 插入节点</h4><p>一旦有了一个新节点，就可以用Node的方法<code>appendChild()</code>或<code>insertBefore()</code>将它插入到文档中。<code>appendChild()</code>是在需要插入的Element节点上调用的，它插入指定的节点使其称为那个节点的最后一个子节点。</p><p><code>insertBefore()</code>就像<code>appencChild()</code>一样，除了它接收两个参数。第一个参数就是待插入的节点，第二个参数是已存在的节点，新节点将插入该节点的前面。该方法应该是在新节点的父节点上调用，方法的第二个参数必须是该父节点的子节点。如果传递null作为第二个参数，<code>insertBefore()</code>的行为类似<code>appencChild()</code>，它将节点插入在最后。</p><p>如果调用<code>appencChild()</code>或<code>insertBefore()</code>将已存在文档中的一个节点再次插入，那么节点将自动从它当前的位置删除并在新的位置重新插入：没有必要显式地删除该节点。</p><h4 id="3-删除和替换节点"><a href="#3-删除和替换节点" class="headerlink" title="3. 删除和替换节点"></a>3. 删除和替换节点</h4><p><code>removeChild()</code>方法是从文档树中删除一个节点。但是请小心：该方法不是在待删除的节点上调用，而是在其父节点上调用。在父节点上调用该方法，并将需要删除的子节点作为方法参数传递给它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n.parentNode.removeChild(n);</span><br></pre></td></tr></table></figure><p><code>replaceChild()</code>方法删除一个子节点并用一个新的节点取而代之。在父节点上调用该方法，第一个参数是新节点，第二个参数是需要代替的节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n.parentNode.replaceChild(<span class="built_in">document</span>.createTextNode(<span class="string">'[ REDACRTED ]'</span>, n));</span><br></pre></td></tr></table></figure><h4 id="4-使用DocumentFragment"><a href="#4-使用DocumentFragment" class="headerlink" title="4. 使用DocumentFragment"></a>4. 使用DocumentFragment</h4><p>DocumentFragment是一种特殊的Node，它作为其他节点的一个临时的容器。像这样创建一个DocumentFragment</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment();</span><br></pre></td></tr></table></figure><p>像Document节点一样，DocumentFragment是独立的，而不是任何其他文档的一部分。它的parentNode总是null。但类似Element，它可以有任意多的子节点，可以用<code>appendChild()</code>、<code>insertBefore()</code>等方法来操作它们。</p><p>DocumentFragment的特殊之处在于它使得一组节点被当作一个节点看待：如果给<code>appendChild()</code>、<code>insertBefore()</code>或<code>replaceChild()</code>传递一个DocumentFragment，其实是将该文档片段的所有子节点插入到文档中，而非片段本身。（文档片段的子节点从片段移动到文档中，文档片段清空以便重用。）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倒序排序节点n的子节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="comment">// 从后至前循环子节点，将每一个子节点移动到文档片段中</span></span><br><span class="line">    <span class="comment">// n的最后一个节点变成f的第一个节点，反之亦然</span></span><br><span class="line">    <span class="comment">// 注意，给f添加一个节点，该节点自动地会从n中删除</span></span><br><span class="line">    <span class="keyword">while</span>(n.lastChild)</span><br><span class="line">        f.appendChild(n.lastChild);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后，把f的所有子节点一次性全部移回n中</span></span><br><span class="line">    n.appendChild(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面代码使用innerHTML属性和DocumentFragment实现<code>insertAdjacentHTML()</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Insert = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.createElement(<span class="string">'div'</span>).insertAdjacentHTML) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            before: <span class="function"><span class="keyword">function</span>(<span class="params">e, h</span>) </span>&#123; e.insertAdjacentHTML(<span class="string">'beforebegin'</span>, h); &#125;,</span><br><span class="line">            after: <span class="function"><span class="keyword">function</span>(<span class="params">e, h</span>) </span>&#123; e.insertAdjacentHTML(<span class="string">'afterend'</span>, h); &#125;,</span><br><span class="line">            atStart: <span class="function"><span class="keyword">function</span>(<span class="params">e, h</span>) </span>&#123; e.insertAdjacentHTML(<span class="string">'afterbegin'</span>, h); &#125;,</span><br><span class="line">            atEnd: <span class="function"><span class="keyword">function</span>(<span class="params">e, h</span>) </span>&#123; e.insertAdjacentHTML(<span class="string">'beforeend'</span>, h); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fragment</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> elt = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">        <span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">        elt.innerHTML = html;</span><br><span class="line">        <span class="keyword">while</span>(elt.firstChild)</span><br><span class="line">            frag.appendChild(elt.firstChild);</span><br><span class="line">        <span class="keyword">return</span> frag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> Insert = &#123;</span><br><span class="line">        before: <span class="function"><span class="keyword">function</span>(<span class="params">elt, html</span>) </span>&#123;</span><br><span class="line">            elt.parentNode.insertBefore(fragment(html), elt);</span><br><span class="line">        &#125;,</span><br><span class="line">        after: <span class="function"><span class="keyword">function</span>(<span class="params">elt, html</span>) </span>&#123;</span><br><span class="line">            elt.parentNode.insertBefore(fragment(html), elt.nextSibling);</span><br><span class="line">        &#125;,</span><br><span class="line">        atStart: <span class="function"><span class="keyword">function</span>(<span class="params">elt, html</span>) </span>&#123;</span><br><span class="line">            elt.insertBefore(fragment(html), elt.firstChild);</span><br><span class="line">        &#125;,</span><br><span class="line">        atEnd: <span class="function"><span class="keyword">function</span>(<span class="params">elt, html</span>) </span>&#123;</span><br><span class="line">            elt.appendChild(fragment(html));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Element.prototype.insertAdjacentHTML = <span class="function"><span class="keyword">function</span>(<span class="params">pos, html</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(pos.toLowerCase()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'beforebegin'</span>: <span class="keyword">return</span> Insert.before(<span class="keyword">this</span>, html);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'afterend'</span>: <span class="keyword">return</span> Insert.after(<span class="keyword">this</span>, html);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'afterbegin'</span>: <span class="keyword">return</span> Insert.atStart(<span class="keyword">this</span>, html);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'beforeend'</span>: <span class="keyword">return</span> Insert.atEnd(<span class="keyword">this</span>, html);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Insert;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><hr><h3 id="七、文档和元素的几何形状和滚动"><a href="#七、文档和元素的几何形状和滚动" class="headerlink" title="七、文档和元素的几何形状和滚动"></a>七、文档和元素的几何形状和滚动</h3><p>在本文中，到目前为止我们考虑的文档被看作是元素和文本节点的抽象树。但是当浏览器在窗口中渲染文档时，它创建文档的一个视图表现层，在那里每个元素有自己的位置和尺寸。通常，Web应用程序可以将文档看作是元素的树，并且不用关心在屏幕上这些元素是如何渲染的。但有时，判定一个元素精确的几个形状也是非常有必要的。如果想用css动态定位一个元素到某个已经由浏览器定位后的普通元素的旁边，首先需要判定那个元素的当前位置。</p><p>本节阐述了在浏览器窗口中完成文档的布局以后，怎样才能在抽象的基于树的文档模型与几何形状的基于坐标的视图之间来回变换。</p><h4 id="1-文档坐标和视口坐标"><a href="#1-文档坐标和视口坐标" class="headerlink" title="1. 文档坐标和视口坐标"></a>1. 文档坐标和视口坐标</h4><p>元素的位置是以像素来度量的，向右代表X坐标的增加，向下代表Y坐标的增加。但是，有两个不同的点作为坐标系的原点：元素的X和Y坐标可以相对于文档的左上角或者相对于在其中显示文档的视口的左上角。在顶级窗口和标签页中，“视口”只是实际显示文档内容的浏览器的一部分：它不包括浏览器“外壳”（如菜单、工具条和标签页）。针对框架页中显示的文档，视口是定义了框架页的<code>&lt;iframe&gt;</code>元素。无论在何种情况下，当讨论元素的位置时，必须弄清楚所使用的坐标是文档坐标还是视口坐标。（视口坐标有时也叫做窗口坐标）。</p><p>如果文档比视口要小，或者说它还未出现滚动，则文档的左上角就是视口的左上角，文档和视口坐标系统是同一个。但是，一般来说，要在两种坐标系之间互相转换，必须加上或减去滚动的偏移量（scroll offset）。例如，在文档坐标中如果一个元素的Y坐标是200px，并且用户已经把浏览器向下滚动75px，那么视口坐标中元素的Y坐标是125px。同样，在视口坐标中如果一个元素的X坐标是400px，并且用户已经水平滚动了视口200px，那么文档坐标中元素的X坐标是600px。</p><p>文档坐标比视口坐标更加基础，并且在用户滚动时它们不会发生变化。不过，在客户端编程中使用视口坐标是非常常见的。当使用css指定元素的位置时运用了文档坐标。但是，最简单的查询元素位置的方法返回视口坐标中的位置。类似地，当为鼠标事件注册事件处理程序函数时，报告的鼠标指针的坐标是在视口坐标系中的。</p><p>为了在坐标系之间互相转换，我们需要判定浏览器窗口的滚动条的位置。Window对象的pageXOffset和pageYOffset属性在所有的浏览器中提供这些值。也可以通过scrollLeft和scrollTop属性来获得滚动条的位置。</p><p>令人迷惑的是，正常情况下通过查询文档的根节点（<code>document.documentElement</code>）来获取这些属性值，但在怪异模式下，必须在文档的<code>&lt;body&gt;</code>元素（<code>document.body</code>）上查询它们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollOffset</span>(<span class="params">w</span>) </span>&#123;</span><br><span class="line">    w = w || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w.pageXOffset != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            x: w.pageXOffset,</span><br><span class="line">            y: w.pageYOffset</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> d = w.document;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">'CSS1Compat'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            x: d.documentElement.scrollLeft,</span><br><span class="line">            y: d.documentElement.scrollTop</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  &#123;</span><br><span class="line">        x: d.body.scrollLeft,</span><br><span class="line">        y: d.body.scrollTop</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时能够判定视口的尺寸也是非常有用的——例如，为了确定文档的哪些部分是当前可见的。利用滚动偏移量查询视口尺寸的简单方法在IE8及更早的版本中无法工作，而且该技术在IE中的运行方式还要取决于浏览器处于怪异模式还是标准模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewportSize</span>(<span class="params">w</span>) </span>&#123;</span><br><span class="line">    w = w || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w.innerWidth != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            w: w.innerWidth,</span><br><span class="line">            h: w.innerHeight</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> d = w.document;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">'CSS1Compat'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            w: d.documentElement.clientWidth,</span><br><span class="line">            h: d.documentElement.clientHeight</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        w: d.body.clientWidth,</span><br><span class="line">        h: d.body.clientHeight</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-查询元素的几何尺寸"><a href="#2-查询元素的几何尺寸" class="headerlink" title="2. 查询元素的几何尺寸"></a>2. 查询元素的几何尺寸</h4><p>判定一个元素的尺寸和位置最简单的方法是调用它的<code>getBoundingClientRect()</code>方法。该方法是在IE5中引入的，而现在当前的所有浏览器都实现了。它不需要参数，返回一个有left、right、top和bottom属性的对象。</p><p>这个方法返回元素在视口坐标中的位置。（<code>getBoundingClientRect()</code>方法名中的“Client”是一种间接指代，它就是Web浏览器客户端——专指它定义的窗口或视口。）为了转化为甚至用户滚动浏览器窗口以后仍然有效的文档坐标，需要加上滚动的偏移量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = e.getBoundingClientRect();</span><br><span class="line"><span class="keyword">var</span> offsets = getScrollOffsets();</span><br><span class="line"><span class="keyword">var</span> x = box.left + offsets.x;</span><br><span class="line"><span class="keyword">var</span> y = box.top + offsets.y;</span><br></pre></td></tr></table></figure><p><code>getBoundingClientRect()</code>返回的对象还包含width和height属性，但是在低版本IE中未实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = e.getBoundingClientRect();</span><br><span class="line"><span class="keyword">var</span> w = box.width || (box.right - box.left);</span><br><span class="line"><span class="keyword">var</span> h = box.height || (box.bottom - box.top);</span><br></pre></td></tr></table></figure><p>注意：<code>getBoundingClientRect()</code>所返回的坐标包含元素的边框和内边距，但不包含元素的外边距。</p><p>如果<code>getBoundingClientRect()</code>方法名中的“Client”指定了返回的矩形的坐标系，那么方法名中的“Bounding”作何解释呢？浏览器在布局时块状元素（如图片、段落和div元素等）总是为矩形。但是，内联元素（如span、code和b等）可能垮了多行，因此可能由多个矩形组成。想像一下，一些被断成两行的斜体文本（用<code>&lt;i&gt;&lt;/i&gt;</code>标记的）。它的形状是由第一行的右边部分和第二行的左边部分两个矩形组成的。如果在内联元素上调用<code>getBoundingClientRect()</code>，它返回“边界矩形”。对于如上描述的<code>&lt;i&gt;</code>元素，边界矩形会包含整整两行的宽度。</p><p>如果想查询内联元素每个独立的矩形，调用<code>getClientRects()</code>方法来获得一个只读的类数组对象，它的每个元素类似于<code>getBoundingClientRect()</code>返回的矩形对象。</p><p>注意，<code>getBoundingClientRect()</code>和<code>getClientRects()</code>所返回的矩形对象并不是实时的。在用户滚动或改变浏览器窗口大小时不会更新它们。</p><h4 id="3-判定元素在某点"><a href="#3-判定元素在某点" class="headerlink" title="3. 判定元素在某点"></a>3. 判定元素在某点</h4><p><code>getBoundingClientRect()</code>方法使我们能在视口中判定元素的位置。但有时我们想反过来，判定在视口中的指定位置上有什么元素。这可以用Document对象的<code>elementFromPoint()</code>方法来判定。传递X和Y坐标（使用视口坐标而非文档坐标），该方法返回在指定位置的一个元素。选取元素的算法的意图是它返回在那个点的最里面的和最上面的元素。如果指定的点在视口以外，<code>elementFromPoint()</code>返回null，即使该点在转换为文档坐标后是完美有效的，返回值也一样。</p><p><code>elementFromPoint()</code>方法看上去很有用，典型的案例是将鼠标指针的坐标传递给它来判定鼠标在哪个元素上。但是鼠标事件对象已经在target属性中包含了这些信息，因此实际上<code>elementFromPoint()</code>不经常使用。</p><h4 id="4-滚动"><a href="#4-滚动" class="headerlink" title="4. 滚动"></a>4. 滚动</h4><p>下文示例展示了如何在浏览器窗口中查询滚动条的位置，该例子中的scrollLeft和scrollTop属性可以用来设置让浏览器滚动。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> documentHeight = <span class="built_in">document</span>.documentElement.offsetHeight;</span><br><span class="line"><span class="keyword">var</span> viewportHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.scrollTo(<span class="number">0</span>, documentHeight - viewportHeight);</span><br></pre></td></tr></table></figure><p>Window的<code>scrollBy()</code>方法和<code>scroll()</code>和<code>scrollTo()</code>类似，但是它的参数是相对的，并在当前滚动条的偏移量上增加。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    scrollBy(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>通常，除了滚动到文档中用数字表示的位置，我们只是想让它滚动使得文档中的某个元素可见。可以利用<code>getBoundingClientRect()</code>计算元素的位置，并转换为文档坐标，然后用<code>scrollTo()</code>方法达到目的。但是在需要显示的HTML元素上调用<code>scrollIntoView()</code>方法更加方便。该方法保证了元素能在视口中可见。默认情况下，它试图将元素的上边缘放在或尽量接近视口的上边缘。如果只传递false作为参数，它将试图将元素的下边缘放在或尽量接近视口的下边缘。只要有助于元素在视口内可见，浏览器也会水平滚动视口。</p><p><code>scrollIntoView()</code>的行为与设置<code>window.location.hash</code>为一个命名锚点（<code>&lt;a name=&quot;&quot;&gt;</code>元素）的名字后浏览器产生的行为类似。</p><h4 id="5-关于元素尺寸、位置和溢出的更多信息"><a href="#5-关于元素尺寸、位置和溢出的更多信息" class="headerlink" title="5. 关于元素尺寸、位置和溢出的更多信息"></a>5. 关于元素尺寸、位置和溢出的更多信息</h4><p><code>getBoundingClientRect()</code>方法在所有当前的浏览器上都有定义，但如果需要支持老式浏览器，不能依靠此方法而必须使用更老的技术来判定元素的尺寸和位置。元素的尺寸比较简单：任何HTML元素的只读属性offsetWidth和offsetHeight以css像素返回它的屏幕尺寸。返回的尺寸包含元素的边框和内边距，除去了外边距。</p><p>所有的HTML元素拥有offsetLeft和offsetTop属性来返回元素的X和Y坐标。对于很多元素，这些值是文档坐标，并直接指定元素的位置。但对于已定位元素的后代元素和一些其他元素（如表格单元），这些属性返回的坐标是相对于祖先元素的而非文档。offsetParent属性指定这些属性所相对的父元素。如果offsetParent为null，这些属性都是文档坐标。因此，一般来说，用offsetLeft和offsetTop来计算元素e的位置需要一个循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementPosition</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(e != <span class="literal">null</span>) &#123;</span><br><span class="line">        x += e.offsetLeft;</span><br><span class="line">        y += e.offsetTop;</span><br><span class="line">        e = e.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: x, <span class="attr">y</span>: y &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过循环offsetParent对象链来累加偏移量，该函数计算指定元素的文档坐标。这里不能对元素的位置就一锤定音，尽管如此——这个<code>getElementPosition()</code>函数也不总是计算正确的值。</p><p>除了这些名字以offset开头的属性外，所有的文档元素定义了其他两组属性，其名称一组以client开头，另一组以scroll开头。即，每个HTML元素都有以下这些属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">offsetWidth     clientWidth     scrollWidth</span><br><span class="line">offsetHeight    clientHeight    scrollHeight</span><br><span class="line">offsetLeft      clientLeft      scrollLeft</span><br><span class="line">offsetTop       clientTop       scrollTop</span><br><span class="line">offsetParent</span><br></pre></td></tr></table></figure><p>为了理解这些client和scroll属性，我们需要直到HTML元素的实际内容有可能比分配用来容纳内容的盒子更大，因此单个元素可能有滚动条。内容区域是视口，就像浏览器的窗口，当实际内容比视口更大时，需要把元素的滚动条位置考虑进去。</p><p>clientWidth和clientHeight类似offsetWidth和offsetHeight，不同的是它们不包含边框大小，只包含内容和它的内边距。同时，如果浏览器在内边距和边框之间添加了滚动条，clientWidth和clientHeight在其返回值中也不包含滚动条。注意，对于类似<code>&lt;i&gt;</code>、<code>&lt;code&gt;</code>和<code>&lt;span&gt;</code>这些内联元素，clientWidth和clientHeight总是返回0。</p><p>有一个特殊的案例，在文档的跟元素上查询这些属性时，它们的返回值和窗口的innerWidth和innerHeight属性值相等。</p><p>clientLeft和clientTop属性没什么用：它们返回元素的内边距的外边缘和它的边框的外边缘之间的水平距离和垂直距离，通常这些值就等于左边和上边的边框宽度。但是如果元素有滚动条，并且浏览器将这些滚动条放置在左侧或顶部（不太常见），clientLeft和clientTop也就包含了滚动条的宽度。对于内联元素，clientLeft和clientTop总是0。</p><p>scrollWidth和scrollHeight是元素的内容区域加上它的内边距再加上任何溢出内容的尺寸。当内容正好和内容区域匹配而没有溢出时，这些属性与clientWidth和clientHeight是相等的。但当溢出时，它们就包含溢出的内容，返回值比clientWidth和clientHeight要大。</p><p>最后，scrollLeft和scrollTop指定元素的滚动条的位置。scrollLeft和ScrollTop是可写的属性，通过设置它们来让元素中的内容滚动。（HTML元素没有类似Window对象的<code>scrollTo()</code>方法。）</p><hr><h3 id="八、HTML表单"><a href="#八、HTML表单" class="headerlink" title="八、HTML表单"></a>八、HTML表单</h3><p>HTML的<code>&lt;form&gt;</code>元素和各种各样的表单输入元素在客户端编程中有着重要的地位。这些HTML元素可以追述到Web的最开始，比JavaScript更早。HTML表单就是第一代Web应用程序背后的运作机制，它根本就不需要JavaScript。用户输入从表单元素来收集；表单将这些输入递交给服务器；服务器处理输入并生成一个新的HTML页面显示在客户端。</p><p>即使当整个表单数据都是由客户端JavaScript来处理并不会提交到服务器时，HTML表单元素仍然是收集用户数据很好的方法。在服务端程序中，表单必须要有一个“提交”按钮，否则它就没有用处。另一方面，在客户端编程中，“提交”按钮不是必须的（虽然它可能仍然有用）。服务端程序是基于表单提交动作的——它们按表单大小的块处理数据——这限制了它们的交互性。客户端程序是基于事件的——它们可以对单独的表单元素上的事件做出相应——这使得它们有更好的响应度。</p><table><thead><tr><th>HTML元素</th><th>类型属性</th><th>事件处理程序</th><th>描述和事件</th></tr></thead><tbody><tr><td><code>&lt;input type=&quot;button&quot;&gt;</code>或<code>&lt;button type=&quot;button&quot;&gt;</code></td><td>“button”</td><td>onclick</td><td>按钮</td></tr><tr><td><code>&lt;input type=&quot;checkbox&quot;&gt;</code></td><td>“checkbox”</td><td>onchange</td><td>复选按钮</td></tr><tr><td><code>&lt;input type=&quot;file&quot;&gt;</code></td><td>“file”</td><td>onchange</td><td>载入Web服务器的文件的文件名输入域；它的value是只读的</td></tr><tr><td><code>&lt;input type=&quot;hidden&quot;&gt;</code></td><td>“hidden”</td><td>none</td><td>数据由表单提交，但对用户不可见</td></tr><tr><td><code>&lt;option&gt;</code></td><td>none</td><td>none</td><td>Select对象中的单个选项；事件处理程序在Select对象上，而非单独的Option对象上</td></tr><tr><td><code>&lt;input type=&quot;password&quot;&gt;</code></td><td>“password”</td><td>onchange</td><td>密码输入框，输入的字符不可见</td></tr><tr><td><code>&lt;input type=&quot;radio&quot;&gt;</code></td><td>“radio”</td><td>onchange</td><td>单选按钮，同时只能选定一个</td></tr><tr><td><code>&lt;input type=&quot;reset&quot;&gt;</code>或<code>&lt;button type=&quot;reset&quot;&gt;</code></td><td>“reset”</td><td>onclick</td><td>重置表单的按钮</td></tr><tr><td><code>&lt;select&gt;</code></td><td>“select-one”</td><td>onchange</td><td>选项只能单选的列表或下拉菜单</td></tr><tr><td><code>select multiple</code></td><td>“select-multiple”</td><td>onchange</td><td>选项可以多选的列表</td></tr><tr><td><code>&lt;input type=&quot;submit&quot;&gt;</code>或<code>&lt;button type=&quot;submit&quot;&gt;</code></td><td>“submit”</td><td>onclick</td><td>表单提交按钮</td></tr><tr><td><code>&lt;input type=&quot;text&quot;&gt;</code></td><td>“text”</td><td>onchange</td><td>单行文本输入域；type属性缺少或无法识别时默认的input元素</td></tr><tr><td><code>&lt;textarea&gt;</code></td><td>“textarea”</td><td>onchange</td><td>多行文本输入域</td></tr></tbody></table><h4 id="1-选取表单和表单元素"><a href="#1-选取表单和表单元素" class="headerlink" title="1. 选取表单和表单元素"></a>1. 选取表单和表单元素</h4><p>表单和它们所包含的元素可以用如<code>getElementbyId()</code>和<code>getElementsByTagName()</code>等标准的方法从文档中来选取。在支持<code>querySelectAll()</code>的浏览器中，也可以通过这个方法获取对应的元素。有name或id属性的<code>&lt;form&gt;</code>元素能够通过很多方法来选取。<code>name=&quot;address&quot;</code>属性的<code>&lt;form&gt;</code>可以用以下任何方法来选取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.address;                                 <span class="comment">// 不可靠：不要使用</span></span><br><span class="line"><span class="built_in">document</span>.address;                               <span class="comment">// 仅当表单有name属性时可用</span></span><br><span class="line"><span class="built_in">document</span>.forms.address;                         <span class="comment">// 显式访问有name或id的表单</span></span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>];                              <span class="comment">// 不可靠：n是表单的序号</span></span><br></pre></td></tr></table></figure><p>如果要明确地选取一个表单元素，可以索引表单对象的elements属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.forms.address.elements[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">document</span>.forms.address.elements.street;</span><br></pre></td></tr></table></figure><p>一般来说指定文档元素的方法用id属性要比name属性更佳。但是，name属性在HTML表单提交中有特殊的目的，它在表单中较为常用，在其他元素较少使用。它应用于相关的复选按钮组和强制共享name属性的、互斥的单选按钮组。请记住，当用name来索引一个HTMLCollection并且它包含多个元素来共享name时，返回值是一个类数组对象，它包含所有匹配的元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"shipping"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Shipping Method<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"method"</span> <span class="attr">value</span>=<span class="string">"1st"</span>&gt;</span>First-class<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"method"</span> <span class="attr">value</span>=<span class="string">"2day"</span>&gt;</span>2-day Air<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"method"</span> <span class="attr">value</span>=<span class="string">"overnite"</span>&gt;</span>Overnight<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于该表单，用如下代码来引用单选按钮元素数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> methods = <span class="built_in">document</span>.forms.shipping.elements.method;</span><br></pre></td></tr></table></figure><p>注意，<code>&lt;form&gt;</code>元素本身有一个HTML属性和对应的JavaScript属性叫“method”，所以在此案例中，必须要用该表单的elements属性而非直接访问method属性。为了判定用户选取哪种运输方式，需要遍历数组中的表单元素并检测它们的checked属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shipping_method;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; methods.length; i++)</span><br><span class="line">    <span class="keyword">if</span> (methods[i].checked)</span><br><span class="line">        shipping_method = methods[i].value;</span><br></pre></td></tr></table></figure><h4 id="2-表单和元素的属性"><a href="#2-表单和元素的属性" class="headerlink" title="2. 表单和元素的属性"></a>2. 表单和元素的属性</h4><p>在JavaScript产生之前，要用一个专用的“提交”按钮来提交表单，用一个专用的“重置”按钮来重置各表单元素的值。JavaScript的Form元素支持两个方法：<code>submit()</code>和<code>reset()</code>，它们完成同样的目的。调用Form对象的<code>submit()</code>方法来提交表单，调用<code>reset()</code>方法来重置表单元素的值。</p><hr><h3 id="九、其他文档特性"><a href="#九、其他文档特性" class="headerlink" title="九、其他文档特性"></a>九、其他文档特性</h3><h4 id="1-Document的属性"><a href="#1-Document的属性" class="headerlink" title="1. Document的属性"></a>1. Document的属性</h4><p>本文已经介绍的Document属性有body、documentElement和forms等这些特殊的文档元素。文档还定义了一些其他有趣的属性：</p><ul><li><p><code>cookie</code></p><p>  允许JavaScript程序读、写HTTP cookie的特殊的属性</p></li><li><p><code>domain</code></p><p>  该属性允许当Web页面之间交互时，相同域名下互相信任的Web服务器之间协作放宽同源策略安全限制</p></li><li><p><code>lastModified</code></p><p>  包含文档修改时间的字符串</p></li><li><p><code>location</code></p><p>  与Window的location属性引用同一个Location对象</p></li><li><p><code>referrer</code></p><p>  如果有，它表示浏览器导航到当前链接的上一个文档。该属性值和HTTP的Referer头信息的内容相同，只是拼写上有两个r</p></li><li><p><code>title</code></p><p>  文档的<code>&lt;title&gt;</code>标签之间的内容</p></li><li><p><code>URL</code></p><p>  文档的URL，只读字符串而不是Location对象。该属性值与location.href的初始值相同，只是不包含Location对象的动态变化。例如，如果用户在文档中导向到一个新的片段，location.href会发生变化，但是document.URL则不会</p></li></ul><p>referrer是这些属性中最有趣的属性之一：它包含用户链接到当前文档的上一个文档的URL。可以用如下代码来使用该属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.referrer.indexOf(<span class="string">'http://www.google.com/search?'</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">document</span>.referrer.substring(ref.indexOf(<span class="string">'?'</span>) + <span class="number">1</span>).split(<span class="string">'&amp;'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args[i].substring(<span class="number">0</span>, <span class="number">2</span>) == <span class="string">'q='</span>) &#123;</span><br><span class="line">            <span class="built_in">document</span>.write(<span class="string">'&lt;p&gt;Welcome Google User.'</span>);</span><br><span class="line">            <span class="built_in">document</span>.write(<span class="string">'You searched for: '</span> + <span class="built_in">unescape</span>(args[i].substring(<span class="number">2</span>)).replace(<span class="string">'+'</span>, <span class="string">' '</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-document-write-方法"><a href="#2-document-write-方法" class="headerlink" title="2. document.write()方法"></a>2. document.write()方法</h4><p>只有在解析文档时才能使用<code>write()</code>方法输出HTML到当前文档中，理解这点非常重要。也就是说能够在<code>&lt;script&gt;</code>元素中的顶层代码中调用<code>document.write()</code>，就是因为这些脚本的执行是文档解析流程的一部分。如果将<code>document.write()</code>放在一个函数的定义中，而该函数的调用是从一个事件处理程序中发起的，产生的结果未必是你想要的——事实上，它会擦出当前文档和它包含的脚本！同理，在设置了defer和async的脚本中不要使用<code>document.write()</code>。</p><p>值得一提的是Document对象还支持<code>writeln()</code>方法，除了在其参数的输出之后追加一个换行符以外它和<code>write()</code>方法完全一样。例如，在<code>&lt;pre&gt;</code>元素内输入预格式化的文本时着非常有用。</p><p>在当今的代码中<code>document.write()</code>方法并不常用：innerHTML属性和其他DOM技术提供了更好的方法来为文档增加内容。另一方面，某些算法的确使得它们本身成为很好的流式I/O API，如同<code>write()</code>方法提供的API一样。如果正在书写在运行时计算和输出文本的代码，可以考虑如下代码，它利用指定元素的innerHTML属性包装了简单的<code>write()</code>和<code>close()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ElementStream</span>(<span class="params">elt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> elt === <span class="string">'string'</span>)</span><br><span class="line">        elt = <span class="built_in">document</span>.getElementById(elt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.elt = elt;</span><br><span class="line">    <span class="keyword">this</span>.buffer = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementStream.prototype.write = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.buffer += <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">""</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ElementStream.prototype.writeln = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.buffer += <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">""</span>) + <span class="string">"\n"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ElementStream.prototype.close = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elt.innerHTML = <span class="keyword">this</span>.buffer;</span><br><span class="line">    <span class="keyword">this</span>.buffer = <span class="string">''</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-查询选取的文本"><a href="#3-查询选取的文本" class="headerlink" title="3. 查询选取的文本"></a>3. 查询选取的文本</h4><p>有时判定用户在文档中选取了哪些文本非常有用。可以用类似如下的函数达到目的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedText</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.getSelection)                    <span class="comment">// H5标准API</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.getSelection().toString();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.selection)                <span class="comment">// IE特有的技术</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.selection.createRange().text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准的<code>window.getSelection()</code>方法返回一个Selection对象，后者描述了当前选取的一系列一个或多个Range对象。Selection和Range定义了一个不太常用的较为复杂的API。<code>toString()</code>方法是Selection对象中最重要的也广泛实现了的特性，它返回选取的纯文本内容。</p><h4 id="4-可编辑的内容"><a href="#4-可编辑的内容" class="headerlink" title="4. 可编辑的内容"></a>4. 可编辑的内容</h4><p>有两种方法来启用编辑功能。其一，设置任何变迁的HTML contenteditable属性；其二，设置对应元素的JavaScript contentEditable属性；这都将使得元素的内容变成可编辑。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"editor"</span> <span class="attr">contenteditable</span>&gt;</span></span><br><span class="line">    Click to edit</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器可能为表单字段和contenteditable元素支持自动拼写检查。在支持该功能的浏览器中，检查可能默认开启或关闭。为元素添加spellcheck属性来显式开启拼写检查，而使用<code>spellcheck=false</code>来显式关闭该功能。</p><p>将Document对象的designMode属性设置为“on”使得整个文档可编辑。（设置为“off”将恢复为只读文档）designMode属性并没有对应的HTML属性。如下代码使得<code>&lt;iframe&gt;</code>内部的文档可编辑</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"editor"</span> <span class="attr">src</span>=<span class="string">"about:blank"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">onLoad(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> editor = <span class="built_in">document</span>.getElementById(<span class="string">'editor'</span>);</span></span><br><span class="line"><span class="javascript">    editor.contentDocument.designMode = <span class="string">'on'</span>;</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;客户端JavaScript的存在使得静态的HTML文档变成了交互式的Web应用。脚本化Web页面内容是JavaScript的核心目标。每一个Web浏览器窗口、标签页和框架由一个Window对象所表示。每个Window对象有一个document属性引用了Document对象。Document对象表示窗口的内容，Document对象并非独立的，它是一个巨大的API中的核心对象，叫做文档对象模型（&lt;code&gt;Document Object Model，DOM&lt;/code&gt;），它代表和操作文档的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript脚本化文档" scheme="http://www.xiaoleon.cn/tags/JavaScript%E8%84%9A%E6%9C%AC%E5%8C%96%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>JS(9) 类型、值和变量</title>
    <link href="http://www.xiaoleon.cn/2018/01/30/js-9/"/>
    <id>http://www.xiaoleon.cn/2018/01/30/js-9/</id>
    <published>2018-01-30T14:23:02.000Z</published>
    <updated>2018-02-02T12:48:05.179Z</updated>
    
    <content type="html"><![CDATA[<p>计算机程序的运行需要对值（<code>value</code>）进行操作。在编程语言中，能够表示并操作的值的类型称作数据类型（<code>type</code>），编程语言最基本的特性就是能够支持多种数据类型。当程序需要将值保存起来以备将来使用时，便将其赋值给一个变量（<code>variable</code>）。变量是一个值的符号名称，可以通过名称来获得对值的引用。变量的工作机制是编程语言的另一个基本特性。</p><a id="more"></a><p>JavaScript的数据类型分为两类：原始类型（<code>primitive type</code>）和对象类型（<code>object type</code>）。JavaScript中的原始类型包括数字、字符串和布尔值。</p><p>JavaScript中有两个特殊的原始值：<code>null</code>（空）和<code>undefined</code>（未定义），它们不是<code>数字</code>、<code>字符串</code>和<code>布尔值</code>。它们通常分别代表了各自特殊类型的唯一的成员。</p><p>JavaScript中除了以上类型之外就是对象了（ES6中新增了<code>Symbol</code>类型）。对象（<code>object</code>）是属性（<code>property</code>）的集合，每个属性都由“名/值对”（值可以是原始值，比如数字、字符串，也可以是对象）构成。其中有一个比较特殊的对象——全局对象（<code>global object</code>）。</p><p>JavaScript的类型可以分为原始类型和对象类型，也可分为可以拥有方法的类型和不能拥有方法的类型，同样可分为可变类型（<code>mutable</code>）和不可变类型（<code>immutable</code>）。可变类型的值是可修改的，对象和数组属于可变类型：JavaScript程序可以更改对象属性值和数组元素的值。<code>数字</code>、<code>布尔值</code>、<code>null</code>和<code>undefined</code>属于不可变类型——比如，修改一个数值的内容本身就说不通。<code>字符串</code>可以堪称是由字符组成的数组，然而在JavaScript中，字符串是不可变的：可以访问字符串任意位置的文本，但JavaScript并为提供修改已知字符串的文本内容的方法。</p><p>JavaScript可以自由地进行数据类型转换，比如，如果在程序期望使用字符串的地方使用了数字，JavaScript会自动将数字转换为字符串。如果在期望使用布尔值的地方使用了非布尔值，程序也会进行相应的转换。</p><hr><h3 id="一、数字"><a href="#一、数字" class="headerlink" title="一、数字"></a>一、数字</h3><p>和其他编程语言不同，JavaScript不区分整数值和浮点数值。JavaScript中所有数字均用浮点数值表示。JavaScript采用IEEE 754标准定义的64位浮点格式表示数字，这意味着它能表示的最大值是<code>±1.7976931348623157 * 10e308</code>，最小值是<code>±5 * 10e-324</code>。</p><p>按照JavaScript中的数字格式，能够表示的整数范围是从<code>-2*53 ~ 2*53</code>，包含边界值。如果使用了超过此范围的整数，则无法保证低位数字的精度。然而需要注意的是，JavaScript中实际的操作（比如数字索引），则是基于32位整数。</p><h4 id="1-整型直接量"><a href="#1-整型直接量" class="headerlink" title="1. 整型直接量"></a>1. 整型直接量</h4><p>在JavaScript程序中，用一个数字序列表示一个十进制整数，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">100000</span></span><br></pre></td></tr></table></figure><p>除了十进制的整型直接量，JavaScript同样能识别八进制、十六进制值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xff</span>;                           <span class="comment">// 15*16+15=255</span></span><br><span class="line"><span class="number">0377</span>;                           <span class="comment">// 3*64+7*8+7=255</span></span><br></pre></td></tr></table></figure><p>最好不要使用以0为前缀的整型直接量，毕竟我们无法得知当前JavaScript的实现是否支持八进制的解析。在ES6的严格模式下，八进制直接量是明令禁止的。</p><h4 id="2-浮点型直接量"><a href="#2-浮点型直接量" class="headerlink" title="2. 浮点型直接量"></a>2. 浮点型直接量</h4><p>浮点型直接量可以含有小数点，它们采用的是传统的实数写法。一个实数由整数部分、小数点和小数部分组成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">2345.789</span></span><br><span class="line"><span class="number">6.02e23</span></span><br><span class="line"><span class="number">1.4738223E-32</span></span><br></pre></td></tr></table></figure><h4 id="3-JavaScript中的算术运算"><a href="#3-JavaScript中的算术运算" class="headerlink" title="3. JavaScript中的算术运算"></a>3. JavaScript中的算术运算</h4><p>JavaScript程序是使用语言本身提供的算术运算符来进行数字运算的。这些运算符包括<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>。</p><p>除了基本的运算符外，JavaScript还支持更加复杂的算术运算，这些复杂运算通过作为Math对象的属性定义的函数和常量来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>);                        <span class="comment">// =&gt; 9007199254740992: 2e53</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">.6</span>);                         <span class="comment">// =&gt; 1.0: 四舍五入</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">.6</span>);                          <span class="comment">// =&gt; 1.0: 向上取整</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">.6</span>);                         <span class="comment">// =&gt; 0.0: 向下取整</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="number">-5</span>);                           <span class="comment">// =&gt; 5: 求绝对值</span></span><br><span class="line"><span class="built_in">Math</span>.max(x, y, z);                      <span class="comment">// 返回最大值</span></span><br><span class="line"><span class="built_in">Math</span>.min(x, y, z);                      <span class="comment">// 返回最小值</span></span><br><span class="line"><span class="built_in">Math</span>.random();                          <span class="comment">// 生成一个大于等于0小于1.0的伪随机数</span></span><br><span class="line"><span class="built_in">Math</span>.PI;                                <span class="comment">// π: 圆周率</span></span><br><span class="line"><span class="built_in">Math</span>.E;                                 <span class="comment">// e: 自然对数的底数</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">3</span>);                           <span class="comment">// 3的平方根</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">3</span>, <span class="number">1</span>/<span class="number">3</span>);                       <span class="comment">// 3的立方根</span></span><br><span class="line"><span class="built_in">Math</span>.sin(<span class="number">0</span>);                            <span class="comment">// 三角函数，还有Math.cos，Math.atan等</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">10</span>);                           <span class="comment">// 10的自然对数</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">100</span>)/<span class="built_in">Math</span>.LN10;                <span class="comment">// 以10为底100的对数</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">512</span>)/<span class="built_in">Math</span>.LN2;                 <span class="comment">// 以2为底512的对数</span></span><br><span class="line"><span class="built_in">Math</span>.exp(<span class="number">3</span>);                            <span class="comment">// e的三次幂</span></span><br></pre></td></tr></table></figure><p>JavaScript中的算术运算在溢出（<code>overflow</code>）、下溢（<code>underflow</code>）或被零整除时不会报错。当数字运算结果超过了JavaScript所能表示的数字上限，结果为一个特殊的无穷大值（<code>infinity</code>），在JavaScript中以<code>Infinity</code>表示，负无穷大以<code>-Infinity</code>表示。无穷大值的行为特征和我们所期望的是一致的：基于它们的加减乘除运算结果还是无穷大值。</p><p>下溢（<code>underflow</code>）是当运算结果无限接近于零并比JavaScript所能表示的最小值还小的时候发生的情形。这种情况下，JavaScript会返回0。当一个负数发生下溢时，JavaScript返回一个特殊的值“<code>负零</code>”。这个值几乎和正常的零完全一样，JavaScript程序中很少用到负零。</p><p>被零整出在JavaScript中并不报错：它只是简单地返回无穷大或负无穷大。但有一个例外，零除以零是没有意义的，这种整除运算结果也是一个非数字值（<code>not-a-number, NaN</code>）。无穷大除以无穷大，给任意负数作开方运算或者算术运算符不是数字或无法转换为数字的操作数一起使用时都将会返回NaN。</p><p>JavaScript中的非数字值有一点特殊：它和任何值都不想等，包括自身。也就是说，没办法通过<code>x==NaN</code>来判断变量x是否是NaN。相反，应当使用<code>x!=x</code>来判断，当前仅当x为NaN的时候，表达式的结果才为true。函数<code>isNaN()</code>的作用与此类似，如果参数是NaN或者是一个非数字值（比如字符串和对象），则返回true。JavaScript有一个类似的函数<code>isFinite()</code>，在参数不是NaN、Inifity或-Infinity的时候返回true。</p><blockquote><p>负零值同样有些特殊，它和正零值是相等的（甚至使用===严格相等来判断）。</p></blockquote><p>这意味着这两个值几乎一模一样，除了作为除数之外。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> negz = <span class="number">-0</span>;</span><br><span class="line">zero === negz;                          <span class="comment">// true 正零值和负零值相等</span></span><br><span class="line"><span class="number">1</span>/zero === <span class="number">1</span>/negz;                      <span class="comment">// false 正无穷大和负无穷大不等</span></span><br></pre></td></tr></table></figure><hr><h3 id="二、文本"><a href="#二、文本" class="headerlink" title="二、文本"></a>二、文本</h3><p>字符串（string）是一组由16位值组成的不可变的有序序列，每个自负通常来自于Unicode字符集。JavaScript通过字符串类型来表示文本。字符串的长度（length）是其所含16位值的个数。JavaScript字符串（和其数组）的索引从零开始：第一个字符的位置是0，第二个字符的位置是1，以此类推。空字符串（empty string）长度为0，JavaScript中并没有表示单个字符的“字符型”。要表示一个16位值，只须将其赋值给字符串变量即可，这个字符串长度为1。</p><h4 id="1-字符串直接量"><a href="#1-字符串直接量" class="headerlink" title="1. 字符串直接量"></a>1. 字符串直接量</h4><p>在JavaScript程序中的字符串直接量，是由单引号或双引号括起来的字符序列。由单引号定界的字符串中可以包含双引号，由双引号定界的字符串中也可以包含单引号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>;</span><br><span class="line"><span class="string">'testing'</span>;</span><br><span class="line"><span class="string">"3.14"</span>;</span><br><span class="line"><span class="string">'name="myform"'</span>;</span><br><span class="line"><span class="string">"Wouldn't you prefer O'Reilly's book?"</span>;</span><br></pre></td></tr></table></figure><p>在ES3中，字符串直接量必须写在一行中，而在ES5中，字符串直接量可以拆分成数行，每行必须以反斜线（<code>\</code>）结束，反斜线和行结束符都不算是字符串直接量的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"two\nlines"</span>;</span><br><span class="line"><span class="string">"one\</span></span><br><span class="line"><span class="string">long\</span></span><br><span class="line"><span class="string">line"</span>                                   <span class="comment">// 用三行代码定义了显示为单行的字符串，在ES5中可用</span></span><br></pre></td></tr></table></figure><h4 id="2-字符串的使用"><a href="#2-字符串的使用" class="headerlink" title="2. 字符串的使用"></a>2. 字符串的使用</h4><p>JavaScript的内置功能之一就是字符串连接。如果将加号（+）运算符用于数字，表示两数相加。但将它用于字符串，则表示字符串连接，将第二个字符串拼接在第一个之后。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">'Hello, '</span> + <span class="string">'world'</span>;              <span class="comment">// 'Hello, world'</span></span><br><span class="line">greeting = <span class="string">"Welcome to my blog, "</span> + <span class="string">' '</span> + name;</span><br></pre></td></tr></table></figure><p>要确定一个字符串的长度——其所包含的16位值的个数——可以使用字符串的length属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.length;</span><br></pre></td></tr></table></figure><p>除了length属性，字符串还提供许多可以调用的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello, world'</span>;</span><br><span class="line">s.charAt(<span class="number">0</span>);                            <span class="comment">// 'h'</span></span><br><span class="line">s.charAt(s.length<span class="number">-1</span>);                   <span class="comment">// 'd'</span></span><br><span class="line">s.substring(<span class="number">1</span>, <span class="number">4</span>);                      <span class="comment">// 'ell'</span></span><br><span class="line">s.slice(<span class="number">1</span>, <span class="number">4</span>);                          <span class="comment">// 'ell'</span></span><br><span class="line">s.slice(<span class="number">-3</span>);                            <span class="comment">// 'rld'</span></span><br><span class="line">s.indexOf(<span class="string">'l'</span>);                         <span class="comment">// 2</span></span><br><span class="line">s.lastIndexOf(<span class="string">'l'</span>);                     <span class="comment">// 10</span></span><br><span class="line">s.indexOf(<span class="string">'l'</span>, <span class="number">3</span>);                      <span class="comment">// 3</span></span><br><span class="line">s.split(<span class="string">', '</span>);                          <span class="comment">// ['hello', 'world']</span></span><br><span class="line">s.replace(<span class="string">'h'</span>, <span class="string">'H'</span>);                    <span class="comment">// 'Hello, world'</span></span><br><span class="line">s.toUpperCase();                        <span class="comment">// 'HELLO, WORLD'</span></span><br></pre></td></tr></table></figure><p>记住，在JavaScript中字符串是固定不变的，类似<code>replace()</code>和<code>toUpperCase()</code>的方法都返回新字符串，原字符串本身并没有发生改变。</p><p>在ES5中，字符串可以当作只读数组，除了使用<code>charAt()</code>方法，也可以使用方括号来访问字符串中的单个字符（16位值）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'hello, world'</span>;</span><br><span class="line">s[<span class="number">0</span>];                                   <span class="comment">// 'h'</span></span><br><span class="line">s[s.length - <span class="number">1</span>];                        <span class="comment">// 'd'</span></span><br></pre></td></tr></table></figure><hr><h3 id="三、布尔值"><a href="#三、布尔值" class="headerlink" title="三、布尔值"></a>三、布尔值</h3><p>布尔值指代真或假、开或关、是或否。这个类型只有两个值，保留字true和false。</p><p>任意JavaScript的值都可以转换为布尔值，下面这些值会被转换成false</p><p><code>undefined    null    0    -0    NaN    &quot;&quot;</code></p><p>所有其他值，包括所有对象（数组）都会转成true。</p><hr><h3 id="四、null和undefined"><a href="#四、null和undefined" class="headerlink" title="四、null和undefined"></a>四、null和undefined</h3><p><code>null</code>是JavaScript语言的关键字，它表示一个特殊值，常用来描述“空值”。对<code>null</code>执行<code>typeof</code>运算，结果返回字符串“<code>object</code>”，也就是说，可以将<code>null</code>认为是一个特殊的对象值，含义是“<code>非对象</code>”。但实际上，通常认为<code>null</code>是它自有类型的唯一一个成员，它可以表示数字、字符串和对象是“无值”的。</p><p>JavaScript还有第二个值来表示值的空缺，用未定义的值表示更深层次的“空值”。在ES3中，<code>undefined</code>是可读/写的变量，可以给它赋任意值。这个错误在ES5中做了修正，<code>undefined</code>在该版本中是只读的。如果使用<code>typeof</code>运算符得到<code>undefined</code>的类型，则返回“<code>undefined</code>”，表明这个值是这个类型的唯一成员。</p><hr><h3 id="五、全局对象"><a href="#五、全局对象" class="headerlink" title="五、全局对象"></a>五、全局对象</h3><p>全局对象（<code>global object</code>）在JavaScript中有着重要的用途：全局对象的属性是全局定义的符号，JavaScript程序可以直接使用。当JavaScript解释器启动时，它将创建一个新的全局对象，并给它一组定义的初始属性：</p><ul><li><p>全局属性，比如<code>undefined</code>、<code>Infinity</code>和<code>NaN</code></p></li><li><p>全局函数，比如<code>isNaN()</code>、<code>parseInt()</code>、<code>eval()</code></p></li><li><p>构造函数：比如<code>Date()</code>、<code>RegExp()</code>、<code>String()</code>、<code>Object()</code>和<code>Array()</code></p></li><li><p>全局对象，比如<code>Math</code>和<code>JSON</code></p></li></ul><p>在代码的最顶级——不在任何函数内的JavaScript代码——可以使用JavaScript关键字<code>this</code>来引用全局对象。</p><hr><h3 id="六、包装对象"><a href="#六、包装对象" class="headerlink" title="六、包装对象"></a>六、包装对象</h3><p>JavaScript对象是一种复合值：它是属性或已命名值的集合。通过“<code>.</code>”符号来引用属性值。当属性值是一个函数的时候，称其为方法。我们看到字符串也同样具有属性和方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello world!'</span>;</span><br><span class="line"><span class="keyword">var</span> word = s.substring(s.indexOf(<span class="string">' '</span>) + <span class="number">1</span>, s.length);</span><br></pre></td></tr></table></figure><p>字符串既然不是对象，为什么它会有属性呢？只要引用了字符串s的属性，JavaScript就会将字符串值通过调用<code>new String(s)</code>的方式转换成对象，这个对象继承了字符串的方法，并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会销毁。</p><p>同字符串一样，数字和布尔值也具有各自的方法：通过<code>Number()</code>和<code>Boolean()</code>构造函数创建一个临时对象，这些方法的调用均是来自于这个临时对象。<code>null</code>和<code>undefined</code>没有包装对象：访问它们的属性会造成一个类型错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'test'</span>;</span><br><span class="line">s.len = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> t = s.len;</span><br></pre></td></tr></table></figure><p>运行上述代码时，t的值是<code>undefined</code>。第二行代码创建一个临时字符串对象，并给其<code>len</code>属性赋值为4，随即销毁这个对象。第三行通过原始的字符串值创建一个新字符串对象，尝试读取其<code>len</code>属性，这个属性自然不存在，表达式求值结果为<code>undefined</code>。这段代码说明了在读取字符串、数字和布尔值的属性值（或方法）的时候，表现的和对象一样。但如果试图给其属性赋值，则会忽略这个操作：修改只是发生在临时对象上，而这个临时对象并未继续保留下来。</p><p>存取字符串、数字或布尔值的属性时创建的临时对象称作包装对象。它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象。</p><p>需要注意的是，可通过<code>String()</code>、<code>Number()</code>、<code>Boolean()</code>构造函数来显式创建包装对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'test'</span>, n = <span class="number">1</span>, b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> S = <span class="keyword">new</span> <span class="built_in">String</span>(s);</span><br><span class="line"><span class="keyword">var</span> N = <span class="keyword">new</span> <span class="built_in">Number</span>(n);</span><br><span class="line"><span class="keyword">var</span> B = <span class="keyword">new</span> <span class="built_in">Boolean</span>(b);</span><br></pre></td></tr></table></figure><p>其中“<code>==</code>”运算符时，原始值与其包装对象相等，“<code>===</code>”全等运算符时，它们不等。通过typeof运算符可以看到原始值和其包装对象的不同。</p><hr><h3 id="七、不可变的原始值和可变的对象引用"><a href="#七、不可变的原始值和可变的对象引用" class="headerlink" title="七、不可变的原始值和可变的对象引用"></a>七、不可变的原始值和可变的对象引用</h3><p>JavaScript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着本质区别。原始值是不可更改的：任何方法都无法更改一个原始值。对字符串来说不那么容易理解，因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来修改字符串中的字符。实际上，JavaScript是禁止这样做的，字符串所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s.toUpperCase();                        <span class="comment">// 'HELLO'</span></span><br><span class="line">s;                                      <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure><p>原始值的比较是值的比较：只有在它们的值相等时它们才相等。这对数字、布尔值、null和undefined来说听起来有点难懂，并没有其他办法来比较它们。同样，对于字符串来说则不明显：如果比较两个单独的字符串，当且仅当它们的长度相等且每个索引的字符都想等时，JavaScript才认为它们相等。</p><p>对象和原始值不同，首先，它们是可变的——它们的值是可修改的。对象的比较并非值的比较：即使两个对象包含相同的属性及相同的值，它们也是不相等的。各个索引元素完全相等的两个数组也不想等。</p><p>我们通常将对象成为引用类型（reference type），以此赖和JavaScript的基本类型区分开来。依照术语的叫法，对象值都是引用（reference），对象的比较均是引用的比较：当且仅当它们引用同一个基对象时，它们才相等。</p><hr><h3 id="八、显示类型转换"><a href="#八、显示类型转换" class="headerlink" title="八、显示类型转换"></a>八、显示类型转换</h3><p>做显式类型转换最简单的方法就是使用<code>Boolean()</code>、<code>Number()</code>、<code>String()</code>或<code>Object()</code>函数，当不实用<code>new</code>运算符调用这些函数时，它们会作为类型转换函数做类型转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'3'</span>);                            <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">false</span>);                          <span class="comment">// 'false'</span></span><br><span class="line"><span class="built_in">Boolean</span>([]);                            <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="number">3</span>);                              <span class="comment">// new Number(3)</span></span><br></pre></td></tr></table></figure><p>JavaScript中的某些运算符会做隐式的类型转换，有时用于类型转换。如果“<code>+</code>”运算符的一个操作数是字符串，它将会把另外一个操作数转换为字符串。一元“<code>+</code>”运算符将其操作数转换为数字，同样，一元“<code>!</code>”运算符将其操作数转换为布尔值并取反。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x + <span class="string">''</span>;                                 <span class="comment">// 等价于String(x)</span></span><br><span class="line">+x;                                     <span class="comment">// 等价于Number(x)，也可以是x-0</span></span><br><span class="line">!!x;                                    <span class="comment">// 等价于Boolean(x)</span></span><br></pre></td></tr></table></figure><hr><h3 id="九、变量声明"><a href="#九、变量声明" class="headerlink" title="九、变量声明"></a>九、变量声明</h3><p>在JavaScript程序中，使用一个变量之前应当先声明。变量是使用关键字<code>var</code>来声明的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">var</span> j, sum;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果未在<code>var</code>声明语句中给变量指定初始值，那么虽然声明了这个变量，但在给它存入一个值之前，它的初始值就是<code>undefined</code>。</p><h4 id="1-变量作用域"><a href="#1-变量作用域" class="headerlink" title="1. 变量作用域"></a>1. 变量作用域</h4><p>在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就会被局部变量所遮盖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">'local'</span>;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">&#125;</span><br><span class="line">checkScope();                           <span class="comment">// 'local'</span></span><br></pre></td></tr></table></figure><h4 id="2-函数作用域和声明提前"><a href="#2-函数作用域和声明提前" class="headerlink" title="2. 函数作用域和声明提前"></a>2. 函数作用域和声明提前</h4><p>在JavaScript中没有块级作用域（ES5及以前），JavaScript取而代之地使用了函数作用域（<code>function scope</code>）：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</p><p>在如下所示代码中，在不同位置定义了变量i、j和k，它们都在同一个作用域内——这三个变量在函数体内均是有定义的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> o == <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(k);             <span class="comment">// 输出数字0~9</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(k);                 <span class="comment">// k已经定义了，输出10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(j);                     <span class="comment">// j已经定义了，但可能没有初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-作为属性的变量"><a href="#3-作为属性的变量" class="headerlink" title="3. 作为属性的变量"></a>3. 作为属性的变量</h4><p>当声明一个JavaScript全局变量时，实际上是定义了全局对象的一个属性。当使用<code>var</code>声明一个变量时，创建的属性是不可配置的，也就是说这个变量无法通过<code>delete</code>运算符删除。</p><p>JavaScript全局变量是全局对象的属性，这是在ES规范中强制规定的。对于局部变量则没有如此规定，但我们可以想象得到，局部变量当作跟函数调用相关的某个对象的属性。ES5规范称为“声明上下文对象”。JavaScript可以允许使用<code>this</code>关键字来引用全局对象，却没有方法可以引用局部变量中存放的对象。这种存放局部变量的对象的特有性质，是一种对我们不可见的内部实现。</p><h4 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4. 作用域链"></a>4. 作用域链</h4><p>如果将一个局部变量看作是自定义实现的对象的属性的话，那么可以换个角度来解读变量作用域。每一段JavaScript代码（全局代码或函数）都有一个与之关联的作用域链（<code>scope chain</code>）。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript需要查找变量x的值的时候（这个过程称作“变量解析”（<code>variable resolution</code>）），它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，JavaScript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类推。如果作用域链上没有任何一个对象函数属性x，那么就认为这段代码的作用链上不存在x，并最终抛出一个引用错误（<code>ReferenceError</code>）异常。</p><p>在JavaScript的最顶层代码中，作用域链有一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。理解对象链的创建规则是非常重要的。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来讲，事情变得更加有趣，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机程序的运行需要对值（&lt;code&gt;value&lt;/code&gt;）进行操作。在编程语言中，能够表示并操作的值的类型称作数据类型（&lt;code&gt;type&lt;/code&gt;），编程语言最基本的特性就是能够支持多种数据类型。当程序需要将值保存起来以备将来使用时，便将其赋值给一个变量（&lt;code&gt;variable&lt;/code&gt;）。变量是一个值的符号名称，可以通过名称来获得对值的引用。变量的工作机制是编程语言的另一个基本特性。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript类型" scheme="http://www.xiaoleon.cn/tags/JavaScript%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="JavaScript值" scheme="http://www.xiaoleon.cn/tags/JavaScript%E5%80%BC/"/>
    
      <category term="JavaScript变量" scheme="http://www.xiaoleon.cn/tags/JavaScript%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>JS(8) Window对象</title>
    <link href="http://www.xiaoleon.cn/2018/01/30/js-8/"/>
    <id>http://www.xiaoleon.cn/2018/01/30/js-8/</id>
    <published>2018-01-30T14:09:00.000Z</published>
    <updated>2018-02-02T12:48:05.159Z</updated>
    
    <content type="html"><![CDATA[<p>Window对象是客户端JavaScript程序的全局对象，本文介绍Window对象的属性和方法，这些属性定义了许多不同的API。</p><a id="more"></a><p>本文主要介绍以下方面：</p><ul><li><p><code>setTimeout()</code>和<code>setInterval()</code></p></li><li><p><code>location</code>属性，以及如何获取当前显示文档的url和载入新的文档</p></li><li><p><code>history</code>属性，以及如何在历史记录中向前和向后移动</p></li><li><p><code>navigator</code>属性，以及如何获取浏览器厂商和版本信息，如何使用screen属性查询窗口尺寸</p></li><li><p><code>alert()</code>、<code>promt()</code>、<code>confirm()</code>、<code>showModalDialog()</code></p></li><li><p><code>onerror</code>处理方法，以及如何在未捕获的JavaScript异常发生时调用</p></li><li><p>HTML元素的<code>ID</code>和<code>name</code>作为<code>Window</code>对象的属性来使用</p></li><li><p>如何打开和关闭浏览器窗口，以及如何编写可以在多个窗口和嵌套窗体中工作的JavaScript代码</p></li></ul><hr><h3 id="一、计时器"><a href="#一、计时器" class="headerlink" title="一、计时器"></a>一、计时器</h3><p><code>setTimeout()</code>和<code>setInterval()</code>可以用来注册在指定时间之后单次或重复调用的函数。</p><p>Window对象的<code>setTimeout()</code>方法用来实现一个函数在指定的毫秒数之后运行。<code>setTimeout()</code>返回一个值，这个值可以传递给<code>clearTimeout()</code>用于取消这个函数的执行。</p><p><code>setInterval()</code>和<code>setTimeout()</code>一样，只不过这个函数会在指定毫秒数的间隔里重复调用。</p><p>由于历史原因，<code>setTimeout()</code>和<code>setInterval()</code>的第一个参数可以作为字符串传入。如果这么做，那这个字符串会在指定的超时时间或间隔之后进行求值（相当于执行<code>eval()</code>）。除前两个参数之外，H5规范还允许<code>setTimeout()</code>和<code>setInterval()</code>传入额外的参数，并在调用函数时把这些参数传递过去。</p><p>如果以0毫秒的超时时间来调用<code>setTimeout()</code>，那么指定的函数不会立刻执行。相反，会把它放到队列中，等到前面处于等待状态的事件处理程序全部执行完成后，再“立刻”调用它。</p><hr><h3 id="二、浏览器定位和导航"><a href="#二、浏览器定位和导航" class="headerlink" title="二、浏览器定位和导航"></a>二、浏览器定位和导航</h3><p>Window对象的<code>location</code>属性引用的是Location对象，它表示该窗口中当前显示的文档的url，并定义了方法来使窗口载入新的文档。</p><p>Document对象的<code>location</code>属性也引用到Location对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location == <span class="built_in">document</span>.location;           <span class="comment">// 总是返回true</span></span><br></pre></td></tr></table></figure><p>Document对象也有一个url属性，是文档首次载入后保存该文档的url的静态字符串。如果定位到文档中的片段标识符，Location对象会做相应的更新，而<code>document.url</code>属性则不会改变。</p><h4 id="1-解析url"><a href="#1-解析url" class="headerlink" title="1. 解析url"></a>1. 解析url</h4><p>Window对象的<code>location</code>属性引用的是Location对象，它表示该窗口中当前显示的文档的url。Location对象的href属性是一个字符串，后者包含url的完整文本。Location对象的<code>toString()</code>方法返回href属性的值，因此会隐式调用<code>toString()</code>的情况下，可以使用location代替<code>location.href</code>。</p><p>这个对象的其他属性——<code>protocol</code>、<code>host</code>、<code>hostname</code>、<code>port</code>、<code>pathname</code>和<code>search</code>，分别表示url的各个部分。他们成为“url分解”属性。</p><p>Location对象的<code>hash</code>和<code>search</code>属性比较有趣。如果有的话，<code>hash</code>属性返回url中的“片段标识符”部分。<code>search</code>属性也类似，它返回的是问号之后的url，这部分通常是某种类型的查询字符串。一般来说，这部分内容是用来参数化url并在其中嵌入参数的。</p><h4 id="2-载入新的文档"><a href="#2-载入新的文档" class="headerlink" title="2. 载入新的文档"></a>2. 载入新的文档</h4><p>Location对象的<code>assign()</code>方法可以使窗口载入并显示指定的url中的文档。<code>replace()</code>方法也类似，但它在载入新文档之前会从浏览历史中把当前文档删除。如果脚本无条件地载入一个新文档，<code>replace()</code>方法可能是比<code>assign()</code>方法更好的选择。否则，“后退”按钮会把浏览器带回到原始文档，而相同的脚本则会再次载入新文档。如果检测到用户的浏览器不支持某些特性来显示功能齐全的版本，可以用<code>location.replace()</code>来载入静态的HTML版本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果浏览器不支持XMLHttpRequest对象</span></span><br><span class="line"><span class="comment">// 则将其重定向到一个不需要Ajax的静态页面</span></span><br><span class="line"><span class="keyword">if</span> (!XMLHttpRequest) &#123;</span><br><span class="line">    location.replace(<span class="string">'staticpage.html'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在这个例子中传入<code>replace()</code>的是一个相对url。相对url是相对于当前页面所在的目录来解析的，就像将它们用于一个超链接中。</p><p>除了<code>assign()</code>和<code>replace()</code>方法，Location对象还定义了<code>reload()</code>方法，后者可以让浏览器重新载入当前文档。</p><p>使浏览器跳转到新页面的一种更传统的方法是直接把新的url赋值给location属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location = <span class="string">"http://www.orilly.com"</span>;</span><br></pre></td></tr></table></figure><p>还可以吧相对url赋给<code>location</code>，它们会相对当前url进行解析</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location = <span class="string">"page2.html"</span>;</span><br></pre></td></tr></table></figure><p>纯粹的片段标识符是相对url的一种类型，它不会让浏览器载入新文档，但只会使它滚动到文档的某个位置。<code>#top</code>标识符是个特殊的例子：如果文档中没有元素的ID是“<code>top</code>”，它会让浏览器跳到文档开始处。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳转到文档的顶部</span></span><br><span class="line">location = <span class="string">'#top'</span>;</span><br></pre></td></tr></table></figure><p>Location对象的URL分解属性是可写的，对它们重新赋值会改变url的位置，并且导致浏览器载入一个新的文档（如果改变的是<code>hash</code>属性，则在当前文档中进行跳转）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.search = <span class="string">'?page='</span> + (pagenum + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="三、浏览历史"><a href="#三、浏览历史" class="headerlink" title="三、浏览历史"></a>三、浏览历史</h3><p>History对象用来把窗口的浏览历史用文档和文档状态列表的形式表示。History对象的<code>length</code>属性表示浏览历史列表中的元素数量，但出于安全的因素，脚本不能访问已保存的url。（如果允许，则任意脚本都可以窥探我们的浏览历史）。</p><p>如果窗口包含多个子窗口（比如<code>&lt;iframe&gt;</code>元素），子窗口的浏览历史会按时间顺序穿插在主窗口的历史中。这意味着在主窗口调用<code>history.back()</code>可能会导致其中一个子窗口往回跳转到前一个显示的文档，但主窗口保留当前状态不变。</p><hr><h3 id="四、浏览器和屏幕信息"><a href="#四、浏览器和屏幕信息" class="headerlink" title="四、浏览器和屏幕信息"></a>四、浏览器和屏幕信息</h3><p>脚本有时候需要获取和它们所在的Web浏览器或浏览器所在的桌面相关的信息。本节所介绍Window对象的<code>navigator</code>和<code>screen</code>属性。它们分别引用的是Navigator和Screen对象，而这些对象提供的信息允许脚本来根据环境定制自己的行为。</p><h4 id="1-Navigator对象"><a href="#1-Navigator对象" class="headerlink" title="1. Navigator对象"></a>1. Navigator对象</h4><p>Window对象的<code>navigator</code>属性引用的是包含浏览器厂商和版本信息的Navigator对象。Navigator对象的命名是为了纪念Netscape之后Navigator浏览器，不过所有其他的浏览器也支持它。</p><p>过去，Navigator对象通常被脚本用来确定它们是在IE中还是在Netscape中运行。这种浏览器嗅探方法有问题，因为它要求随着新浏览器和现有浏览器的新版本的引入而不断地调整。如今，有一种更好地功能测试方法，只需要测试所需要的功能，而不是假设特定的浏览器版本及其功能。</p><p>然而，浏览器嗅探有时候仍然有价值。这样的一种情况是，当需要解决存在于某个特定的浏览器的特定版本中的特殊的bug时。Navigator对象有4个属性用于提供关于运行中的浏览器的版本信息，并且可以使用这些属性进行浏览器嗅探。</p><ul><li><p>appName</p><p>  Web浏览器的全称。</p></li><li><p>appVersion</p><p>  此属性通常以数字开始，并跟着包含浏览器厂商和版本信息的详细字符串。</p></li><li><p>userAgent</p><p>  浏览器在它的USER-AGENT HTTP头部中发送的字符串。这个属性通常包含appVersion中的所有信息，并且常常也可能包含其他的细节。</p></li><li><p>platform</p><p>  在其上运行浏览器的操作系统（并且可能是硬件）的字符串。</p></li></ul><p>下文示例中展示了如何使用正则表达式从<code>navigator.userAgent</code>中抽取浏览器名称和版本号的方法（摘自jQuery）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> browser = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = navigator.userAgent.toLowerCase();</span><br><span class="line">    <span class="keyword">var</span> match = <span class="regexp">/(webkit)[ \/]([\w.]+)/</span>.exec(s) ||</span><br><span class="line">    /(opera)(?:.*version)?[ \/]([\w.]+)/.exec(s) ||</span><br><span class="line">    /(msie)([\w.]+)/.exec(s) ||</span><br><span class="line">    !<span class="regexp">/compatible/</span>.test(s) &amp;&amp; <span class="regexp">/(mozilla)(?:.*? rv:([\w.]+))?/</span>.exec(s) ||</span><br><span class="line">    [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: match[<span class="number">1</span>] || <span class="string">''</span>, <span class="attr">version</span>: match[<span class="number">2</span>] || <span class="string">'0'</span> &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>除了浏览器厂商和版本信息的属性之外，Navigator对象还包含一些杂项的属性和方法。以下是一些标准化的属性以及广泛应用但未标准化的属性：</p><ul><li><p>onLine</p><p>  <code>navigator.onLine</code>属性表示浏览器当前是否连接到网络。</p></li><li><p>geolocation</p><p>  Geolocation对象定义用于确定用户地理位置信息的接口。</p></li><li><p>javaEnabled()</p><p>  一个非标准的方法，当浏览器可以运行Java小程序时返回true。</p></li><li><p>cookieEnabled()</p><p>  一个非标准的方法，如果浏览器可以保存永久的cookie时，返回true。当cookie配置为“视具体情况而定”时可能会返回不正确的值。</p></li></ul><h4 id="2-Screen对象"><a href="#2-Screen对象" class="headerlink" title="2. Screen对象"></a>2. Screen对象</h4><p>Window对象的screen属性引用的是Screen对象。它提供有关窗口显示的大小和可用的颜色数量信息。属性<code>width</code>和<code>height</code>指定的是以像素为单位的窗口大小。属性<code>availWidth</code>和<code>availHeight</code>指定的是实际可用的显示大小，它们排除了像桌面任务栏这样的特性所占用的控件。属性<code>colorDepth</code>指定的是显示的<code>BPP</code>（<code>bits-per-pixel</code>）值，典型的值有16、24和32.</p><p><code>window.screen</code>属性和它引用的Screen对象都是非标准但广泛实现的。可以用Screen对象来确定Web应用是否运行在一个小屏幕的设备上。</p><hr><h3 id="五、对话框"><a href="#五、对话框" class="headerlink" title="五、对话框"></a>五、对话框</h3><p>Window对象提供了3个方法来向用户显示简单的对话框。<code>alert()</code>向用户显示一条信息并等待用户关闭对话框。<code>confirm()</code>也显示一条信息，要求用户单机“确定”或“取消”按钮，并返回一个布尔值。<code>propty()</code>同样也显示一条消息，等待用户输入字符串，并返回那个字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = promp(<span class="string">'What is your name?'</span>);</span><br><span class="line">    <span class="keyword">var</span> correct = confirm(<span class="string">'You entered: '</span>) + name + <span class="string">'\n'</span></span><br><span class="line">        + <span class="string">'Click Okay to proceed of Cancel to re-enter;'</span></span><br><span class="line">&#125; <span class="keyword">while</span> (!correct) </span><br><span class="line">alert(<span class="string">'Hello, '</span> + name);</span><br></pre></td></tr></table></figure><p>方法<code>confirm()</code>和<code>prompt()</code>都会产生阻塞，也就是说，在用户关掉它们所显示的对话框之前，它们不会返回。这就意味着在弹出一个对话框前，代码就会停止运行。如果当前正在载入文档，也会停止载入，直到用户用要求的输入进行响应为止。在大多数的浏览器里，<code>alert()</code>也会产生阻塞，并等待用户关闭对话框，但并不总是这样。</p><hr><h3 id="六、错误处理"><a href="#六、错误处理" class="headerlink" title="六、错误处理"></a>六、错误处理</h3><p>Window对象的<code>onerror</code>属性是一个事件处理程序，当未捕获的异常传播到调用栈上时就会调用它，并把错误消息输出到浏览器的JavaScript控制台上。如果给这个属性赋一个函数，那么只要这个窗口中发生了JavaScript错误，就会调用该函数，即它成了窗口的错误处理程序。</p><p>由于历史原因，Window对象的<code>onerror</code>事件处理函数的调用通过三个字符串参数，而不是通过通常传递的一个事件对象。</p><p><code>window.onerror</code>的第一个参数是描述错误的一条消息。第二个参数是一个字符串，它存放引发错误的JavaScript代码所在的文档的url。第三个参数是文档中发生错误的行数。</p><p>除了这三个参数之外，<code>onerror</code>处理程序的返回值也很重要。如果<code>onerror</code>处理程序返回false，它通知浏览器事件处理程序已经处理了错误，不需要其他操作。换句话说，浏览器不应该显示它字迹的错误消息。遗憾的是，由于历史原因，Firefox里的错误处理程序必须返回true来表示它已经处理了错误。</p><p><code>onerror</code>处理程序是早期JavaScript的遗物，那时语言核心不包含<code>try/catch</code>异常处理语句。现代代码很少使用它，但是在开发阶段，你可能要这样定义一个错误处理程序，当由错误发生时，来显式地通知你</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">msg, url, line</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (onerror.num++ <span class="xml"><span class="tag">&lt; <span class="attr">onerror.max</span>) &#123;</span></span></span><br><span class="line"><span class="xml">        alert('ERROR: ' + msg + '\n' + url + ':' + line);</span></span><br><span class="line"><span class="xml">        return true;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">onerror.max = 3;</span></span><br><span class="line"><span class="xml">onerror.num = 0;</span></span><br></pre></td></tr></table></figure><hr><h3 id="七、作为Window对象属性的文档元素"><a href="#七、作为Window对象属性的文档元素" class="headerlink" title="七、作为Window对象属性的文档元素"></a>七、作为Window对象属性的文档元素</h3><p>如果在HTML文档中用<code>id</code>属性来为元素命名，并且如果Window对象没有此名字的属性，Window对象会赋予一个属性，它的名字是<code>id</code>属性的值，而它们的值指向表示文档元素的HTMLElement对象。</p><p>在客户端JavaScript中，Window对象是以全局对象的形式存在于作用域链的最上层，这就意味着在HTML文档中使用的<code>id</code>属性会成为可以被脚本访问的全局变量。如果文档包含一个<code>&lt;button id=&quot;okay&quot;/&gt;</code>元素，可以通过全局变量okay来引用此元素。</p><p>但是，有一个重要的警告：如果Window对象已经具有此名字的属性，这就不会发生。比如，id是“history”、“location”或“navigator”的元素，就不会以全局变量的形式出现，因为这些id已经占用了。同样，如果HTML文档包含一个id为“x”的元素，并且还在代码中声明并赋值给全局变量x，那么显式声明的变量会隐藏隐式的元素变量。如果脚本中的变量声明出现在命名元素之前，那这个变量的存在就会阻止元素获取它的window属性。而如果脚本的变量声明出现在命名元素之后，那么变量的显式赋值会覆盖该属性的隐式值。</p><p>元素ID作为全局变量的隐式应用是Web浏览器演化过程中遗留的怪癖。它主要是出于与已有Web页面后向兼容性的考虑。但这里并不推荐使用这种做法——浏览器厂商可以在任何时候为Window对象定义新属性，而这些新属性都会破坏使用了此属性名的隐式定义的代码。</p><p>用<code>document.getElementById()</code>来显示查找元素，如果给它一个更简单的名字，这种用法会变得更加简便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">&#125;</span><br><span class="line">ui.prompt = $(<span class="string">'prompt'</span>);</span><br></pre></td></tr></table></figure><p>假设<code>ID</code>并没有被Window对象使用的话，那么任何由<code>id</code>属性的HTML元素都会成为全局变量的值。以下HTML元素如果由<code>name</code>属性的话，也会这样表现：</p><p><code>&lt;a&gt; &lt;applet&gt; &lt;area&gt; &lt;embed&gt; &lt;form&gt; &lt;frame&gt; &lt;frameset&gt; &lt;iframe&gt; &lt;img&gt; &lt;object&gt;</code></p><p><code>id</code>元素在文档中必须是唯一的：两个元素不能有相同的<code>id</code>。但是，这对<code>name</code>属性无效。如果上面的元素有多于一个有相同的<code>name</code>属性（或者一个元素有<code>name</code>属性，而另一个元素具有相同值的id属性），具有该名称的隐式全局变量会引用一个类数组对象，这个类数组对象的元素是所有命名的元素。</p><p>有<code>name</code>或<code>id</code>属性的<code>&lt;iframe&gt;</code>元素是个特殊的例子，为它们隐式创建的变量不会引用表示自身的Element对象，而是引用表示<code>&lt;iframe&gt;</code>元素创建的嵌套浏览器窗体的Window对象。</p><hr><h3 id="八、多窗口和窗体"><a href="#八、多窗口和窗体" class="headerlink" title="八、多窗口和窗体"></a>八、多窗口和窗体</h3><p>一个Web浏览器窗口可能在桌面上包含多个标签页。每一个标签页哦都市独立的“浏览上下文”（<code>browsing context</code>），每一个上下文都有独立的Window对象，而且相互之间互不干扰。每个标签页中运行的脚本通常并不知道其他标签页的存在，更不用说和其他标签页的Window对象进行交互操作或者操作其他文档内容了。如果Web浏览器不支持多标签页，或者把标签页关掉了，可能在某一时刻桌面上会有很多打开的Web浏览器窗口。而使用标签页，每个桌面窗口中的Window对象都是独立的，也就是说彼此就是完全独立的，和其他桌面窗口没有任何联系。</p><p>但是窗口并不总是和其他窗口完全没关系。一个窗口或标签页中的脚本可以打开新的窗口或标签页，当一个脚本这样做时，这样多个窗口或窗口与另一个窗口的文档之间就可以互操作。</p><h4 id="1-打开和关闭窗口"><a href="#1-打开和关闭窗口" class="headerlink" title="1. 打开和关闭窗口"></a>1. 打开和关闭窗口</h4><p>使用Window对象的<code>open()</code>方法可以打开一个新的浏览器窗口（或标签页，这通常和浏览器的配置选项有关）。<code>Window.open()</code>载入指定的url到新的或已存在的窗口中，并返回代表那个窗口的Window对象。</p><p>它包含4个可选参数：</p><ul><li><p>第一个参数是要在新窗口中显示文档的url。如果这个参数省略了，那么会使用空白页面的url <code>about:blank</code></p></li><li><p>第二个参数是新打开的窗口的名字。如果指定的是一个已经存在的窗口的名字，会直接使用已存在的窗口。否则，会打开新的窗口，并将这个指定的名字赋值给它。如果省略次参数，会使用指定的名字“<code>_blank</code>”开打一个新的、未命名的窗口。</p><p>窗口的名字是非常重要的，因为它允许<code>open()</code>方法引用已存在的窗口，并同时可以作为<code>&lt;a&gt;</code>和<code>&lt;form&gt;</code>元素上HTML <code>target</code>属性的值，用来表示引用的文档（或表单提交结果）应该显示在命名的窗口中。这个<code>target</code>属性的值可以设置为“<code>_blank</code>”、“<code>_parent</code>”或“<code>_top</code>”，从而使引用的文档显示在新的空白窗口、父窗口/窗体或顶层窗口中。</p></li><li><p>第三个参数是一个以逗号分隔的列表，包含大小和各种属性，用以表明新窗口是如何打开的。如果省略这个参数，那么新窗口就会用一个默认的大小，而且带有一整组标准的UI组件，即菜单栏、状态栏、工具栏等。在标签式浏览器中，会创建一个新的标签。这个参数是非标准的，H5规范也主张浏览器忽略它。注意：当指定第三个参数时，所有没有显式指定的功能都会忽略。出于各种安全原因，浏览器包含对可能指定的功能的限制。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w = <span class="built_in">window</span>.open(<span class="string">'smallwin.html'</span>, <span class="string">'smallwin'</span>, <span class="string">'width=400,height=350,status=yes,resizable:yes'</span>);</span><br></pre></td></tr></table></figure><ul><li>第四个参数只在第二个参数命名是一个存在的窗口时才有用。它是一个布尔值，声明了由第一个参数指定的url是应用替换掉窗口浏览历史的当前条目（true），还是应该在窗口浏览历史中创建一个新的条目（false），后者是默认的设置。</li></ul><p>就像方法<code>open()</code>打开一个新窗口一样，方法<code>close()</code>将关闭一个窗口。如果已经创建了Window对象，可以使用如下的代码将它关掉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win.close();</span><br></pre></td></tr></table></figure><p>运行在那个窗口中的JavaScript代码则可以使用下面的代码关闭</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.close();</span><br></pre></td></tr></table></figure><p>注意：要显式地使用标识符window，这样可以避免混淆Window对象的<code>close()</code>方法和Document对象的<code>close()</code>方法——如果正在从事件处理程序调用<code>close()</code>，这很重要。</p><p>即使一个窗口关闭了，代表它的Window对象仍然存在。已关闭的窗口会有个值为true的closed属性，它的document会是null，它的方法通常也不会再工作。</p><h4 id="2-窗体之间的关系"><a href="#2-窗体之间的关系" class="headerlink" title="2. 窗体之间的关系"></a>2. 窗体之间的关系</h4><p>Window对象的方法<code>open()</code>返回代表新创建的窗口的Window对象。而且这个新窗口具有opener属性，该属性可以打开它的原始窗口。这样，两个窗口就可以相互引用，彼此都可以读取对方的属性或是调用对方的方法。窗体也是这样的，窗口或窗体中运行的代码都可以通过下面介绍的属性引用到自己的窗口或窗体，以及嵌套的子窗体。</p><p>任何窗口中的JavaScript代码都可以将自己的窗口引用为window或self。窗体可以用parent属性引用包含它的窗口或窗体的Window对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.history.back();</span><br></pre></td></tr></table></figure><p>如果一个窗口是顶级窗口或标签，而不是窗体，那么其parent属性引用的就是这个窗口本身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有顶级窗口才会返回true</span></span><br><span class="line">parent == self;</span><br></pre></td></tr></table></figure><p>如果一个窗体包含在另一个窗体中，而后者又包含在顶级窗口中，那么该窗体就可以使用<code>parent.parent</code>来引用顶级窗口。top属性是一个通用的快捷方式，无论一个窗体被嵌套了几层，它的top属性引用的都是指向包含它的顶级窗口。如果一个Window对象代表的是一个顶级窗口，那么它的top属性引用的就是窗口本身。对于那些顶级窗口的直接子窗体，top属性就等价于parent属性。</p><p>parent和top属性允许脚本引用它的窗体的祖先。有不止一种方法可以引用窗口或窗体的子孙窗体。窗体是通过<code>&lt;iframe&gt;</code>元素创建的。可以用获取其他元素的方法来获取一个表示<code>&lt;iframe&gt;</code>的元素对象。假定文档里有<code>&lt;iframe id=&quot;f1&quot;&gt;</code>。那么，表示该iframe的元素对象就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframeElement = <span class="built_in">document</span>.getElementById(<span class="string">'f1'</span>);</span><br></pre></td></tr></table></figure><p><code>&lt;iframe&gt;</code>元素有<code>contentWindow</code>属性，引用该窗体的Window对象，所以此窗体的Window对象就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> childFrame = <span class="built_in">document</span>.getElementById(<span class="string">'f1'</span>).contentWindow;</span><br></pre></td></tr></table></figure><p>可以进行反向操作——从表示窗体的Window对象来获取该窗体的<code>&lt;iframe&gt;</code>元素——用Window对象的<code>frameElement</code>属性。表示顶级窗口的Window对象的frameElement属性为null，窗体中的Window对象的frameElement属性不是null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elt = <span class="built_in">document</span>.getElementById(<span class="string">'f1'</span>);</span><br><span class="line"><span class="keyword">var</span> win = elt.contentWindow;</span><br><span class="line">win.frameElement == elt;                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">window</span>.frameElement == <span class="literal">null</span>;                <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>尽管如此，通常不需要使用<code>getElementById()</code>方法和<code>contentWindow</code>属性来获取窗口中子窗体的引用。每个Window对象都有一个frames属性，它引用自身包含的窗口或窗体的子窗体。frames属性引用的是类数组对象，并可以通过数字或窗体名进行索引。要引用窗口的第一个子窗体，可以用<code>frames[0]</code>。要引用第二个子窗体的第三个子窗体，可以用<code>frames[1].frames[2]</code>。窗体里创建的代码可以用<code>parent.frames[1]</code>引用兄弟窗体。注意<code>frames[]</code>数组里的元素是Window对象，而不是<code>&lt;iframe&gt;</code>元素。</p><p>如果指定<code>&lt;iframe&gt;</code>元素的name或id属性，那么除了用数字进行索引之外，还可以用名字来进行索引。例如，名字为“f1”的帧应该用<code>frames[&#39;f1&#39;]</code>或<code>frames.f1</code>。</p><p>前面讲过，<code>&lt;iframe&gt;</code>以及其他元素的name和id都可以自动通过Window对象的属性来引用，而<code>&lt;iframe&gt;</code>元素和其他的元素有所不同：对于窗体来说，通过Window对象的属性引用的<code>&lt;iframe&gt;</code>是指窗体中的Window对象，而不是元素对象。也就是说，可以通过窗体的名字“f1”来代替<code>frame.f1</code>。实际上，H5规范指出frames属性是一个自引用（self-referential）的属性，就像window和self一样。而这个Window对象看起来像一个由窗体组成的数组。也就是说可以通过<code>window[0]</code>来获取第一个子窗体的引用，可以通过<code>window.length</code>或<code>length</code>查询窗体的编号。但是这里我们使用frames来代替window会比较清晰一些。</p><h4 id="3-交互窗口中的JavaScript"><a href="#3-交互窗口中的JavaScript" class="headerlink" title="3. 交互窗口中的JavaScript"></a>3. 交互窗口中的JavaScript</h4><p>每个窗口和窗体都是它自身的JavaScript的执行上下文，以Window作为全局对象。但是如果一个窗口或窗体中的代码可以应用到其他窗口或窗体（并且同源策略没有阻止它），那么一个窗口或窗体的脚本就可以和其他窗口或窗体中的脚本进行交互。</p><p>设想一个Web页面里有两个<code>&lt;iframe&gt;</code>元素，分别叫“A”和“B”，并假设这些床体所包含的文档来自于相同的一个服务器，并且包含交互脚本。窗体A里的脚本定义了一个变量i</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>这个变量只是全局对象的一个属性，也是Window对象的一个属性。窗体A中的代码可以用标识符i来引用变量，或者用window对象显式地引用这个变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.i;</span><br></pre></td></tr></table></figure><p>由于窗体B中的脚本可以引用窗体A中的Window对象，因此它也可以引用那个Window对象的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.A.i = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>同样的，我们可以在窗体B中定义一个函数，在窗体A中进行调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.B.f();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = parent.B.f;</span><br></pre></td></tr></table></figure><p>当采用这种方式在窗体或窗口间共享函数时，牢记词法作用域的规则非常重要。函数在定义它的作用域中执行，而不是调用它的作用域中执行。就这个例子来说，如果函数f引用了全局变量，那么将在窗体B的属性中查找这些变量，即使函数是由窗体A调用的。</p><p>要记住构造函数也是函数，所以当用构造函数和相关的额原型对象定义一个类时，那个类只在一个单独的窗口中定义。假设一个窗口包含窗体A和窗体B，并且包含Set类。</p><p>顶级窗口的脚本可以创建新的Set对象，类似这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure><p>相反，每个床体中的代码必须显式地用父级窗口的属性类引用<code>Set()</code>构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> parent.Set();</span><br></pre></td></tr></table></figure><p>另外，每个窗体中的代码还可以定义自己的变量来引用构造函数，这样就更方便了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Set</span> = top.Set();</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure><p>和用户定义的类不同，内置的类（String、Date和RegExp等）都会在所有的窗口中自动预定义。但是要注意，每个窗口都有构造函数的一个独立副本和构造函数对应原型对象的一个独立副本。例如，每个窗口都有自己的<code>String()</code>构造函数和<code>String.prototype</code>对象的副本。因此，如果编写一个操作JavaScript字符串的新方法，并且通过把它赋值给当前窗口中的<code>String.prototype</code>对象而使它称为String类的一个方法，那么该窗口中的所有字符串就都可以使用这个新方法。但是，别的窗口中定义的字符串不能使用这个新方法。</p><p>事实上，每个Window都有自己的原型对象，这意味着instanceof操作符不能跨窗口工作。</p><hr><h3 id="九、-WindowProxy对象"><a href="#九、-WindowProxy对象" class="headerlink" title="九、 WindowProxy对象"></a>九、 WindowProxy对象</h3><p>我们已经讲过很多次，Window对象是客户端JavaScript的全局变量。但是从技术上来看，并不是这样的。Web浏览器每次向窗口或窗体中载入新的内容，它都会开始一个新的JavaScript执行上下文，包含一个新创建的全局对象。但是当多个窗口或窗体在使用时，有一个重要的概念，尽管窗体或窗口载入了新的文档，但是引用窗体或窗口的Window对象还仍然是一个有效的引用。</p><p>所以客户端JavaScript有两个重要的对象。客户端全局对象处于作用域链的顶级，并且是全局变量和函数定义的地方。事实上，全局对象会在窗口或窗体载入新内容时被替换。我们称为“Window对象”的对象实际上不是全局对象，而是全局对象的一个代理。每当查询或设置Window对象的属性时，就会在窗口或窗体的当前全局对象上查询或设置相同的属性。H5规范称这个代理对象为WindowProxy，但本文中我们继续使用名次Window对象。</p><p>由于它的代理行为，除了有更长的生命周期之外，代理对象表现得像真正的全局对象。如果可以比较两个对象，那么区分它们会很困难。但事实上，没有办法可以引用到真正地客户端全局对象。全局对象处于作用域链的顶端，但是<code>window</code>、<code>self</code>、<code>top</code>、<code>parent</code>以及窗体的属性全部返回代理对象。<code>window.open()</code>方法也返回代理对象，甚至顶级函数里this关键字的值都是代理对象，而不是真正的全局对象。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Window对象是客户端JavaScript程序的全局对象，本文介绍Window对象的属性和方法，这些属性定义了许多不同的API。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Window对象" scheme="http://www.xiaoleon.cn/tags/Window%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JS(7) 客户端JavaScript</title>
    <link href="http://www.xiaoleon.cn/2018/01/29/js-7/"/>
    <id>http://www.xiaoleon.cn/2018/01/29/js-7/</id>
    <published>2018-01-29T14:32:39.000Z</published>
    <updated>2018-02-02T12:48:05.169Z</updated>
    
    <content type="html"><![CDATA[<p><code>window</code>对象是所有客户端JavaScript特性和API的主要接入点。它表示Web浏览器的一个窗口或窗体，并且可以用标识符<code>window</code>来引用它。<code>Window</code>对象定义了一些属性，比如，指代<code>Location</code>对象的<code>location</code>属性，<code>Location</code>对象指定当前显示在窗口中的url，并允许脚本往窗口里载入新的url。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location = <span class="string">'http://www.oreilly.com/'</span>;</span><br></pre></td></tr></table></figure><p><code>Window</code>对象还定义了一些方法，比如<code>alert()</code>，可以弹出一个对话框用来显示一些信息。还有<code>setTimeout()</code>，可以注册一个函数，在给定的一段时间之后触发一个回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>注意上面的代码并没有显式地使用<code>window</code>属性。在客户端JavaScript中，<code>Window</code>对象也是全局对象。这意味着<code>Window</code>对象处于作用域链的顶部，它的属性和方法实际上是全局变量和全局函数。<code>Window</code>对象有一个引用自身的属性，叫做<code>window</code>。如果需要引用窗口对象本身，可以用这个属性，但是如果只是想要引用全局窗口对象的属性，通常并不需要用到<code>window</code>。</p><p><code>Window</code>对象的其中一个最重要的属性是<code>document</code>，它引用<code>Document</code>对象，后者表示显示在窗口中的文档。<code>Document</code>对象有一些重要方法，比如<code>getElementById()</code>，可以基于元素<code>id</code>属性的值返回单一的文档元素（表示HTML标签的一对开始/结束标记，以及它们之间的所有内容）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timestamp = <span class="built_in">document</span>.getElementById(<span class="string">'timestamp'</span>);</span><br></pre></td></tr></table></figure><p><code>getElementById()</code>返回的<code>Element</code>对象有其他重要的方法和属性，比如允许脚本获取它的内容，设置属性值等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timestamp.firstChild == <span class="literal">null</span>)</span><br><span class="line">    timestamp.appendChild(<span class="built_in">document</span>.createTextNode(<span class="keyword">new</span> <span class="built_in">Date</span>().toString()));</span><br></pre></td></tr></table></figure><p><code>Window</code>、<code>Documnet</code>和<code>Element</code>对象上另一个重要的属性集合是事件处理程序相关的属性。可以在脚本中为之绑定一个函数，这个函数会在某个事件发生时以异步的方式调用。事件处理程序可以让JavaScript代码修改窗口、文档和元素的行为。事件处理程序的属性名是以单词“<code>on</code>”开始的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timestamp.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.innerHTML = <span class="keyword">new</span> <span class="built_in">Date</span>().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Window</code>对象的<code>onload</code>处理程序是最重要的事件处理程序之一。当显示在窗口中的文档内容稳定并可以操作时会触发它。JavaScript代码通常封装在<code>onload</code>事件处理程序里。</p><hr><h3 id="一、在HTML里嵌套JavaScript"><a href="#一、在HTML里嵌套JavaScript" class="headerlink" title="一、在HTML里嵌套JavaScript"></a>一、在HTML里嵌套JavaScript</h3><p>在HTML文档里嵌入客户端JavaScript代码有4种方法</p><ul><li><p>内联，放置在<code>&lt;script&gt;&lt;/script&gt;</code>标签对之间</p></li><li><p>放置在由<code>&lt;script&gt;</code>标签的<code>src</code>属性指定的外部文件中</p></li><li><p>放置在HTML事件处理程序中，该事件处理程序由<code>onclick</code>或<code>onmouseover</code>这样的HTML属性值指定</p></li><li><p>放在一个URL里，这个URL使用特殊的“<code>javascript:</code>”协议</p></li></ul><p>值得注意的是，HTML事件处理程序属性和<code>javascript:URL</code>这两种方式在现代JavaScript代码里已经很少使用。内联脚本（没有<code>src</code>）也比它们之前用的少了。有个编程哲学叫“<code>unobtrusive JavaScript</code>”，主张内容（HTML）和行为（JavaScript代码）应该尽量地保持分离。根据这个编程哲学，JavaScript最好通过<code>&lt;script&gt;</code>元素的<code>src</code>属性来嵌入HTML文档里。</p><h4 id="1-script元素"><a href="#1-script元素" class="headerlink" title="1. script元素"></a>1. script元素</h4><p>JavaScript代码可以以内联的形式出现在HTML文件里的<code>&lt;script&gt;&lt;/script&gt;</code>标签之间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// javascript代码</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>在XHTML中，<code>&lt;script&gt;</code>标签中的内容被当作其他内容一样对待。如果JavaScript代码包含了“<code>&lt;</code>”或“<code>&amp;</code>”字符，那么这些字符就被解释成XML标记。因此，如果要使用XHTML，最好把所有的JavaScript代码放入到一个CDATA部分里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;![CDATA[</span><br><span class="line"><span class="comment">// javascript代码</span></span><br><span class="line">]]&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>src</code>属性时，<code>&lt;script&gt;&lt;/script&gt;</code>标签之间的任何内容都会忽略。如果需要，可以在<code>&lt;script&gt;</code>标签之间添加代码的补充说明文档或版权信息。但是要注意，如果由任何非空格或JavaScript注释的文本出现在<code>&lt;script src=&quot;&quot;&gt;</code>和<code>&lt;/script&gt;</code>之间，HTML5校验器将会报错。</p><p>以下是src属性的一些优点：</p><ul><li><p>1) 可以把大块的JavaScript代码从HTML文件中删除，这有助于保持内容和行为的分离，从而简化HTML文件</p></li><li><p>2) 如果多个Web页面共用相同的JavaScript代码，用src属性可以让我们只管理一份代码，而不用在代码改变时编辑每个HTML文件</p></li><li><p>3) 如果一个JavaScript代码文件由多个页面共享，就只需要下载它一次，通过使用它的第一个页面——随后的页面可以从浏览器缓存检索它</p></li><li><p>4) 由于src属性的值可以是任意的URL，因此来自一个Web服务器的JavaScript程序或Web页面可以使用由另一个Web服务器输出的代码。很多互联网广告依赖于此</p></li><li><p>5) 从其他网站载入脚本的能力，可以让我们更好地利用缓存。</p></li></ul><p><strong>书签</strong></p><p>在Web浏览器中，“书签”就是一个保存起来的URL。如果书签是<code>javascript:URL</code>，那么保存的就是一小段脚本，叫做<code>bookmarklet</code>。<code>bookmarklet</code>是一个小型程序，很容易就可以从浏览器的菜单或工具栏里启动。<code>bookmarklet</code>里的代码执行起来就像页面上的脚本一样，可以查询和设置文档的内容、呈现和行为。只要书签不返回值，它就可以当作当前显示的任何文档，而不把文档替换成新的内容。</p><p>考虑下面<code>&lt;a&gt;</code>标签里的<code>javascript:URL</code>。单机连接会打开一个简单的JavaScript表达式计算器，它允许在页面环境中计算表达式和执行语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">'javascript:</span></span><br><span class="line"><span class="string">    var e = "", r = "";</span></span><br><span class="line"><span class="string">    do &#123;</span></span><br><span class="line"><span class="string">        e = prompt("Expression: " + e + "\n" + r + \n", e);</span></span><br><span class="line"><span class="string">        try &#123; r = "Result: " + eval(e); &#125;</span></span><br><span class="line"><span class="string">        catch(ex) &#123; r = ex; &#125;</span></span><br><span class="line"><span class="string">    &#125; while(e);</span></span><br><span class="line"><span class="string">    void 0;</span></span><br><span class="line"><span class="string">'</span>&gt;</span><br><span class="line">JavaScript Evaluator</span><br><span class="line">&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><p>注意，即便这个JavaScript URL写成多行，HTML解析器仍将它作为单独的一行对待，并且其中的单行<code>//</code>注释也是无效的。还有，要记住代码是单引号中的HTML属性的一部分，所以代码不可以包含任何单引号。</p><p>在开发时，把这样的链接硬编码在页面中是有用的，而把它另存为可以在任何页面上运行的书签，就更有用了。通常，在浏览器里把超链接的地址加入书签可以这样做，在链接上右击并选择类似“<code>Bookmark Link</code>”的选项，或者拖动链接到书签工具栏。</p><p><code>bookmarklet</code>里的javascript存在于文档之外，可以想象成是一种用户扩展或者对于其他程序的修改。</p><hr><h3 id="二、JavaScript程序的执行"><a href="#二、JavaScript程序的执行" class="headerlink" title="二、JavaScript程序的执行"></a>二、JavaScript程序的执行</h3><p>JavaScript程序的执行有两个阶段。在第一阶段，载入文档内容，并执行<code>&lt;script&gt;</code>元素里的代码（包括内联脚本和外部脚本）。脚本通常会按照它们在文档里出现的顺序执行。所有脚本里的JavaScript代码都是从上往下，按照它在条件、循环以及其他控制语句中的出现顺序执行。</p><p>当文档再入完成，并且所有脚本执行完成后，JavaScript执行就进入它的第二阶段，这个阶段是异步的，而且由事件驱动的。在事件驱动阶段，Web浏览器调用事件处理程序函数（由第一阶段里执行的脚本指定的HTML事件处理程序，或之前调用的事件处理程序来定义），来响应异步发生的事件。调用事件处理程序通常是响应用户输入。但是，还可以由网络活动、运行时间或JavaScript代码中的错误来触发。</p><p>事件驱动阶段里发生的第一个事件是load事件，指示文档已经完全载入，并可以操作。JavaScript程序里经常用这个事件来触发或发送消息。我们会经常看到一些定义函数的脚本程序，除了定义一个onload事件处理程序函数外不做其他操作，这个函数会在脚本事件驱动阶段开始时被load事件触发。正式这个onload事件会对文档进行操作，并做程序想做的任何事。在文档载入完成之后，只要Web浏览器显示文档，事件驱动阶段就会一直持续下去。</p><p>核心JavaScript和客户端JavaScript都有一个单线程执行模型。脚本和事件处理程序在同一时间只能执行一个，没有并发性。</p><h4 id="1-同步、异步和延迟的脚本"><a href="#1-同步、异步和延迟的脚本" class="headerlink" title="1. 同步、异步和延迟的脚本"></a>1. 同步、异步和延迟的脚本</h4><p>JavaScript第一次添加到Web浏览器时，还没有API可以用来遍历和操作文档的结构和内容。当文档还在载入时，JavaScript影响文档内容的唯一方法是快速生成内容。它使用<code>document.write()</code>方法完成上述任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;Table <span class="keyword">of</span> Factorials&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">function factorial(n) &#123;</span></span><br><span class="line"><span class="regexp">    if (n &lt;= 1) return n;</span></span><br><span class="line"><span class="regexp">    else return n * factorial(n - 1);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">document.write('&lt;table&gt;');</span></span><br><span class="line"><span class="regexp">document.write('&lt;tr&gt;&lt;th&gt;n&lt;/</span>th&gt;<span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>n!<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="string">');</span></span><br><span class="line"><span class="string">for (var i = 1; i &lt;= 10; i++) &#123;</span></span><br><span class="line"><span class="string">    document.write('</span>&lt;tr&gt;<span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>' + i + '<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>' + factorial(i) + '<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="string">');</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">document.write('</span>&lt;<span class="regexp">/table&gt;');</span></span><br><span class="line"><span class="regexp">document.write('Generate at ' + new Date());</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>当HTML解析器遇到<code>&lt;script&gt;</code>元素时，它默认必须先执行脚本，然后再恢复文档的解析和渲染。这对于内联脚本没什么问题，但如果脚本源代码是由一个<code>src</code>属性指定的外部文件，这意味着脚本后面的文档部分在下载和执行脚本之前，都不会出现在浏览器中。</p><p>脚本的执行只在默认情况下是同步和阻塞的。<code>&lt;script&gt;</code>标签可以有<code>defer</code>和<code>async</code>属性，这可以改变脚本的执行方式。这些都是布尔属性、没有值；只需要出现在<code>&lt;script&gt;</code>标签里即可。HTML5说这些属性只在和<code>src</code>属性联合使用时才有效，有些浏览器还支持延迟的内联脚本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"deferred.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"async.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>defer</code>和<code>async</code>属性都像在告诉浏览器链接进来的脚本不会使用<code>document.write()</code>，也不会生成文档内容，因此浏览器可以在下载脚本时继续解析和渲染文档。<code>defer</code>属性使得浏览器延迟脚本的执行，直到文档的载入和解析完成，并可以操作。<code>async</code>属性使得浏览器可以尽快地执行脚本，而不用在下载脚本时阻塞文档解析。如果<code>&lt;script&gt;</code>标签同时有两个属性，同时支持两者的浏览器会遵守<code>async</code>属性并忽略<code>defer</code>属性。</p><p>注意，延迟的脚本会按照它们在文档里的出现顺序执行，而异步脚本在它们载入后执行，这意味着它们可能会无序执行。</p><p>甚至可以在不支持<code>async</code>属性的浏览器里，通过动态创建<code>&lt;script&gt;</code>元素并把它插入到文档中，来实现脚本的异步载入和执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadasync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    s.src = url;</span><br><span class="line">    head.appendChild(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-事件驱动的JavaScript"><a href="#2-事件驱动的JavaScript" class="headerlink" title="2. 事件驱动的JavaScript"></a>2. 事件驱动的JavaScript</h4><p>对于大部分浏览器中的大部分事件来说，会把一个对象传递给事件处理程序作为参数，那个对象的属性提供了事件的详细信息。比如，传递给单击事件的对象，会有一个属性说明鼠标的哪个按钮被单击。（在IE里，这些事件信息被存储在全局event对象里，而不是传递给处理程序函数。）事件处理程序的返回值有时用来指示函数是否充分处理了事件，以及阻止浏览器执行它默认会进行的各种操作。</p><p>有些事件的目标是文档元素，它们会经常往上传递给文档树，这个过程叫做“冒泡”。例如，如果用户在<code>&lt;button&gt;</code>元素上单击鼠标，单击事件就会在按钮上触发。如果注册在按钮上的函数没有处理（并且冒泡停止）该事件，事件会冒泡到按钮嵌套的容器元素，这样，任何注册在容器元素上的单击事件都会调用。</p><p>大部分可以成为事件目标的对象都有一个叫做<code>addEventListener()</code>的方法，而微软只在IE9及以上实现了它，在IE8及以前的浏览器中，必须使用一个相似的方法，叫<code>attachEvent()</code>。</p><p>客户端JavaScript程序还使用异步通知类型，这些类型往往不是事件。如果设置Window对象的onerror属性为一个函数，会在发生JavaScript错误（或其他未捕获的异常）时调用函数。</p><h4 id="3-客户端JavaScript线程模型"><a href="#3-客户端JavaScript线程模型" class="headerlink" title="3. 客户端JavaScript线程模型"></a>3. 客户端JavaScript线程模型</h4><p>JavaScript语言核心并不包含任何线程机制，并且客户端JavaScript传统上也没有定义任何线程机制。HTML5定义了一种作为后台线程的“<code>Web Worker</code>”，但是客户端JavaScript还像严格的单线程一样工作。甚至当可能并发执行的时候，客户端JavaScript也不会知晓是否真的有并行逻辑的执行。</p><p>单线程执行是为了让编程更加简单。编写代码时可以确保两个事件处理程序不会同一时刻运行，操作文档内容时也不必担心会有其他线程试图同时修改文档，并且永远不需要在写JavaScript代码时担心锁、死锁和竞态条件（race condition）。</p><p>单线程执行意味着浏览器必须在脚本和事件句处理程序执行的时候停止响应用户输入。这位JavaScript开发者带来了负担，它意味着JavaScript脚本和事件处理程序不能运行太长时间。如果一个脚本执行计算密集的任务，它将会给文档载入带来延迟，而用户无法在脚本完成前看到文档内容。如果事件处理程序执行计算密集的任务，浏览器可能变得无法响应，可能会导致用户认为浏览器崩溃了。</p><p>如果应用程序不得不执行太多的计算而导致明显的延迟，应该允许文档在执行这个计算之前完全载入，并确保能够告知用户计算正在进行并且浏览器没有挂起。如果可能将计算分解为离散的子任务，可以使用<code>setTimeout()</code>和<code>setInterval()</code>方法在后台运行子任务，同时更新一个进度指示器向用户显示反馈。</p><p>HTML5定义了一种并发的控制方式，叫做“<code>Web Worker</code>”。<code>Web Worker</code>是一个用来执行计算密集任务而不冻结用户界面的后台线程。运行在<code>Web Worker</code>线程里的代码不能访问文档内容，不能和主线程或者其他<code>worker</code>共享状态，只可以和主线程和其他<code>worker</code>通过异步事件进行通信，所以主线程不能检测并发性，并且<code>Web Worker</code>不能修改JavaScript程序的基础单线程执行模型。</p><h4 id="4-客户端JavaScript时间线"><a href="#4-客户端JavaScript时间线" class="headerlink" title="4. 客户端JavaScript时间线"></a>4. 客户端JavaScript时间线</h4><p>本节更详细地解释JavaScript程序执行的时间线</p><ul><li><p>1) Web浏览器创建Document对象，并且开始解析Web页面，解析HTML元素和它们的文本内容后添加<code>Element</code>对象和<code>Text</code>节点到文档中。在这个阶段<code>document.readyState</code>属性的值是“<code>loading</code>”。</p></li><li><p>2) 当HTML解析器遇到没有<code>async</code>和<code>defer</code>属性的<code>&lt;script&gt;</code>元素时，它把这些元素添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载（如果需要）和执行时解析器会暂停。这样脚本就可以用<code>document.write()</code>来吧文本插入到输入流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单定义函数和注册后面使用的注册事件处理程序，但它们可以遍历和操作文档树，因为它们执行时已经存在了。这样，同步脚本可以看到它字迹的<code>&lt;script&gt;</code>元素和它们之前的文档内容。</p></li><li><p>3) 当解析器遇到设置了<code>async</code>属性的<code>&lt;script&gt;</code>元素时，它开始下载脚本文件，并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器没有停下来等它下载。异步脚本禁止使用<code>document.write()</code>方法。它们可以看到自己的<code>&lt;script&gt;</code>元素和它之前的所有文档元素，并且可能或干脆不可能访问其他的文档内容。</p></li><li><p>4) 当文档完成解析，<code>document.readyState</code>属性变成“<code>interactive</code>”。</p></li><li><p>5) 所有有<code>defer</code>属性的脚本，会按它们在文档里的出现顺序执行。异步脚本可能也会在这个事件执行。延迟脚本能访问完整的文档树，禁止使用<code>document.write()</code>方法。</p></li><li><p>6) 浏览器在<code>Document</code>对象上触发<code>DOMContentLoaded</code>事件。这标志着程序执行从同步脚本执行阶段转换到了异步事件驱动阶段。但要注意，这时可能还有异步脚本没有执行完成。</p></li><li><p>7) 这时，文档已经完全解析完成，但是浏览器可能还在等待其他内容载入，比如图片。当所有这些内容完成载入时，并且所有异步脚本完成载入和执行，<code>document.readyState</code>变为“<code>complete</code>”，Web浏览器触发<code>Window</code>对象上的<code>load</code>事件。</p></li><li><p>8) 从此刻起，会调用异步事件，以异步响应用户输入事件、网络事件、计时器过期等。</p></li></ul><p>这是一条理想的时间线，但是有所浏览器都没有支持它的全部细节。所有浏览器普遍都支持<code>load</code>事件，都会触发它，它时决定文档完全载入并可以操作最通用的技术。<code>DOMContentLoaded</code>事件在<code>load</code>事件之前触发，当前所有浏览器都支持这个事件，但是属性的值在浏览器之间由细微的差别。</p><p>这条时间线没有指定什么时候文档开始对用户可见或什么时候Web浏览器必须开始响应用户输入事件。这些是实现细节，对于很长的文档或非常慢的网络连接，Web浏览器理论上会渲染一部分文档，并且在所有脚本执行之前，就能允许用户开始和页面产生一些交互。这种情况下，用户输入事件可能在程序执行的事件驱动阶段开始之前触发。</p><hr><h3 id="三、兼容性和互用性"><a href="#三、兼容性和互用性" class="headerlink" title="三、兼容性和互用性"></a>三、兼容性和互用性</h3><p>Web浏览器是Web应用的操作系统，但是Web是一个存在各种差异的环境，Web文档和应用会在不同操作系统的不同开发商的不同时代的浏览器上查看和运行。写一个健壮的客户端JavaScript程序并能正确地运行在这么多类型的平台上，的确是一种挑战。</p><p>客户端JavaScript兼容性和交互性的问题可以归纳为三类：</p><ul><li><p>演化</p><p>  Web平台一直在演变和发展当中。一个标准规范会倡导一个新的特性或API。如果特性看起来有用，浏览器开发商实现它。如果足够多的开发商实现它，开发者开始试用这个特性，并依赖于这个特性，然后这个特性就在Web平台中广泛使用。有时候浏览器开发商和Web开发者引领这种标准规范的指定，开发好官方的版本，之前该特性已经成为一个事实的标准。另一种情况，新特性已经被添加到Web中，新浏览器支持它但是老浏览器不支持。Web开发者必须在使用老浏览器的大量用户和使用新式浏览器的少量用户之间做出权衡。</p></li><li><p>未实现</p><p>  有时候，浏览器开发商之间对于某一个特性是否足够由用到要实现存在观点上的差异。一些开发商实现了这个特性，而其他的没有实现。有些现代浏览器实现的功能在老旧浏览器中没实现，这种情况还好，但同样实现一个功能在不同浏览器中有很大差别，例如，IE8不支持<code>&lt;canvas&gt;</code>元素，虽然所有其他浏览器已经实现了它。</p></li><li><p>bug</p><p>  每个浏览器都有bug，并且没有按照规范准确地实现所有的客户端JavaScript API。有时候编写能兼容各个浏览器的JavaScript程序是一个糟透了的工作，必须研究已有浏览器中的各种bug。</p></li></ul><p>HTML5标准化的努力的目标是最终产生一个测试套件，这必定会给浏览器兼容性领域留下一些宝贵的财富。</p><h4 id="1-处理兼容性问题的类库"><a href="#1-处理兼容性问题的类库" class="headerlink" title="1. 处理兼容性问题的类库"></a>1. 处理兼容性问题的类库</h4><p>处理不兼容问题其中最简单的方法时使用类库。在实际的开发工作中，今天不少Web开发者在它们所有的Web页面上用了客户端JavaScript框架，比如jQuery。使这些框架必不可少的一个重要功能是：它们定义了新的客户端API并兼容所有浏览器。例如，在jQuery里，事件处理程序的注册是通过叫<code>bind()</code>的方法完成的。如果基于jQuery做所有的Web开发，就永远不需要考虑<code>addEventListener()</code>和<code>attachEvent()</code>之间的不兼容性问题。</p><h4 id="2-分级浏览器支持"><a href="#2-分级浏览器支持" class="headerlink" title="2. 分级浏览器支持"></a>2. 分级浏览器支持</h4><p>分级浏览器（<code>graded browser support</code>）是由Yahoo!率先提出的一种测试技术。从某种维度对浏览器厂商/版本/操作系统变体进行分级。分级浏览器中的A级要通过所有的功能测试用例。对于C级浏览器来说则不必所有用例都通过测试。A级浏览器需要网页完全可用，C级浏览器只需在HTML完整情况下可用即可，而不需要JavaScript和CSS都正常工作。那些不是A级和C级的浏览器都称作X级浏览器：这部分都是全新的浏览器或者太罕见的浏览器。我们默认在这些浏览器中都是网页完全可用的，但官方并不会对X级浏览器中的功能提供完整支持和测试。</p><h4 id="3-功能测试"><a href="#3-功能测试" class="headerlink" title="3. 功能测试"></a>3. 功能测试</h4><p>功能测试（<code>capability testing</code>）是解决不兼容性问题的一种强大技术。如果我们想试用某个功能，但又不清楚这个功能是否在所有的浏览器中都有比较好的兼容性，则需要在脚本中添加相应的代码来检测是否在浏览器中支持该功能。如果期望使用的功能还没有被当前的平台所支持，要么不在该平台中使用它，要么提供可在所有平台上运行的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">    <span class="comment">// 使用w3c方法之前检测是否可用</span></span><br><span class="line">    element.addEventListener(<span class="string">'keydown'</span>, handler, <span class="literal">false</span>);</span><br><span class="line">    element.addEventListener(<span class="string">'keypress'</span>, handler, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">    <span class="comment">// 在使用IE方法之前首先检测是否可用</span></span><br><span class="line">    element.attachEvent(<span class="string">'onkeydown'</span>, handler);</span><br><span class="line">    element.attachEvent(<span class="string">'onkeypress'</span>, handler);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则，选择普遍支持的技术</span></span><br><span class="line">    element.onkeydown = element.onkeypress = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于功能测试最重要的是，它并不涉及浏览器开发商和浏览器的版本号。代码在当前的浏览器集合中有效，在浏览器的后续版本中也同样有效，而不管后续的浏览器是否实现了这些功能的集合。但要注意的是，这种方法需要测试某个属性或方法是否在浏览器中已经定义了，除非该属性或方法完全可用。如果Microsoft要定义一个<code>addEventListener()</code>方法，但Microsoft只是实现了一部分w3c规范，在调用<code>addEventListener()</code>之前这将会给使用特性测试的代码带来很多麻烦。</p><h4 id="4-怪异模式和标准模式"><a href="#4-怪异模式和标准模式" class="headerlink" title="4. 怪异模式和标准模式"></a>4. 怪异模式和标准模式</h4><p>Microsoft在发布IE6的时候，增加了IE5里没有的很多CSS标准特性。但为了确保与现有的Web内容的后向兼容性，它定义了两种不同的渲染模式。在“标准模式”或“CSS兼容模式”中，浏览器要遵循CSS标准，在“怪异模式”中，浏览器表现的和IE4和IE5中的怪异非标准模式一样。渲染模式的选择依赖于HTML文件顶部的<code>DOCTYPE</code>声明，在IE6中打开没有<code>DOCTYPE</code>的页面和声明了某些权限<code>Doctype</code>的页面都会按照怪异模式进行渲染，定义了严格的<code>Doctype</code>的页面会按照标准模式进行渲染，定义了HTML5 Doctype（<code>&lt;!DOCTYPE html&gt;</code>）的页面在所有现代浏览器中都会按照标准模式渲染。</p><p>怪异模式和标准模式之间的差别经历了很长时间的发展历程，现在新版本的IE都支持标准模式，其他主流浏览器也都支持标准模式。这两种模式都已经被HTML5规范所认可。怪异模式和标准模式之间的差异对于HTML和CSS开发者影响最大。但客户端JavaScript代码则是需要知道文档以哪种模式进行渲染的。要进行这种渲染模式的特性检测，通常检查<code>document.compatMode</code>属性。如果其值为“<code>CSS1Compat</code>”，则说明浏览器工作在标准模式；如果值为“<code>BackCompat</code>”（或undefined，说明属性根本不存在），则说明浏览器工作在怪异模式。所有现代浏览器都实现了<code>compatMode</code>属性，并且HTML5规范对它进行了标准化。</p><h4 id="5-浏览器测试"><a href="#5-浏览器测试" class="headerlink" title="5. 浏览器测试"></a>5. 浏览器测试</h4><p>功能测试非常适用于大型功能领域的支持，比如可以使用这种方法来确定浏览器是否支持w3c事件处理模型还是IE的事件处理模型。另外，有时候可能会需要在某种浏览器中解决个别的bug或难题，但却没有太好的方法来检测bug的存在性。在这种情况下，需要创建一个针对某个平台的解决方案，这个解决方案和特定的浏览器厂商、版本或操作系统（或三方面的组合）联系紧密。</p><p>在客户端JavaScript中检测浏览器类型和版本的方法就是使用<code>Navigator</code>对象，确定当前浏览器的厂商和版本的代码通常叫做浏览器嗅探器（<code>browser sniffer</code>）或者客户端嗅探器（<code>client sniffer</code>）。在Web早期，当Netscape和IE平台两者互不兼容的时候，客户端嗅探（<code>client sniffering</code>）就是一种常见的客户端编程技术，现在兼容性情况已经基本稳定，浏览器嗅探不像若干年前这样常用，但偶尔有些场景还会用到。</p><p>需要注意的是，客户端嗅探也可以在服务器端完成，Web服务器根据<code>User-Agent</code>头部可以有选择地返回特定的JavaScript代码给客户端。</p><h4 id="6-Internet-Explorer里的条件注释"><a href="#6-Internet-Explorer里的条件注释" class="headerlink" title="6. Internet Explorer里的条件注释"></a>6. Internet Explorer里的条件注释</h4><p>实际上，读者会发现客户端JavaScript编程中的很多不兼容性都是针对IE的。也就是说，必须按照某种方式为IE编写代码，而按照另一种方式为其他的浏览器编写代码。IE支持条件注释（IE5引入），尽管这种做法并不符合标准规范，但是在处理不兼容性时非常有用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if IE 6]&gt;</span></span><br><span class="line"><span class="comment">This content is actually inside an HTML comment.</span></span><br><span class="line"><span class="comment">It will only be displayed in IE 6.</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if lte IE 7]&gt;</span></span><br><span class="line"><span class="comment">This content will only be displayed by IE 5, 6 and 7 and earlier.</span></span><br><span class="line"><span class="comment">lte stands for 'less than or equal'. You can also use 'lt', 'gt' and 'gte'.</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if !IE]&gt;&lt;--&gt;</span></span><br><span class="line">This is normal HTML content, but IE will not display it.</span><br><span class="line">Because of the comment above and the comment below.</span><br><span class="line"><span class="comment">&lt;!--&gt;&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line">This is normal content, displayed by all browsers.</span><br></pre></td></tr></table></figure><p>IE的JavaScript解释器也支持条件注释，C和C++程序员可能觉得它们和C预处理器的<code>#ifdef/#endif</code>功能很相似。IE中的JavaScript条件注释以文本<code>/*@cc_on</code>开头，以文本<code>@*/</code>结束（cc_on stands中的cc表示条件编译）。下面的条件注释包含了只在IE中执行的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@cc_on</span></span><br><span class="line"><span class="comment">  @if (@_jscript)</span></span><br><span class="line"><span class="comment">    // 该代码位于一条JS注释内但在IE中执行它</span></span><br><span class="line"><span class="comment">    alert("In IE");</span></span><br><span class="line"><span class="comment">  @end</span></span><br><span class="line"><span class="comment">@*/</span></span><br></pre></td></tr></table></figure><p>在一条条件注释内部，关键字<code>@if</code>、<code>@else</code>和<code>@end</code>划分出哪些是要被IE的JavaScript解释器有条件地执行的代码。大多数时候，只需要上面所示的简单的条件：<code>@if(@_jscript)</code>。JScript是Microsoft字迹的JavaScript解释器的名字，而<code>@_jscript</code>变量在IE中总是为true。</p><p>通过条件注释和常规的JavaScript注释的合理的交叉组合，可以设置在IE中运行一段代码而在所有其他浏览器中运行另一段不同的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@cc_on</span></span><br><span class="line"><span class="comment">  @if (@_jscript)</span></span><br><span class="line"><span class="comment">    // 这里的代码在一条条件注释中，也在一条常规的JavaScript注释中</span></span><br><span class="line"><span class="comment">    // IE会执行这段代码，其他浏览器不执行它</span></span><br><span class="line"><span class="comment">    alert('You are using Internet Explorer');</span></span><br><span class="line"><span class="comment">  @else*/</span></span><br><span class="line">    <span class="comment">// 这段代码并没在JavaScript注释中，但仍然在IE条件注释中</span></span><br><span class="line">    <span class="comment">// 也就是说除了IE之外的所有浏览器都执行这里的代码</span></span><br><span class="line">    alert(<span class="string">'You are not using Internet Explorer'</span>);</span><br><span class="line">  <span class="comment">/*@end</span></span><br><span class="line"><span class="comment">@*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、可访问性"><a href="#四、可访问性" class="headerlink" title="四、可访问性"></a>四、可访问性</h3><p>Web是发布信息的理想工具，而JavaScript程序可以增强对信息的访问。然而，因为程序员写代码太过随意，以至于那些有视觉障碍或者肢体困难的用户没办法正确地获取信息。</p><p>盲人用户使用一种叫做屏幕阅读器的“辅助性技术”将书面的文字变成语音词汇。有些屏幕阅读器是识别JavaScript的，而另一些只能在禁用JavaScript时才会工作得更好。如果站点过于依赖JavaScript来呈现数据的话，就会把那些使用读屏软件的用户拒之门外。JavaScript可访问性的一条重要原则是，设计的代码即使在禁用JavaScript解释器的浏览器中也能正常使用（或至少以某种形式正常使用）。</p><p>可访问性关心的另一个重要的问题是，对于那些只使用键盘但不能使用鼠标的用户来说，如果编写的JavaScript代码依赖于特定的鼠标事件，这就会将那些不使用鼠标的用户排除在外。Web浏览器允许使用键盘来遍历和激活一个Web页面中的UI元素。并且JavaScript代码也应该允许这样做。</p><hr><h3 id="五、安全性"><a href="#五、安全性" class="headerlink" title="五、安全性"></a>五、安全性</h3><p>Web浏览器中包含JavaScript解释器，也就是说，一旦载入Web页面，就可以让任意的JavaScript代码在计算机里执行。很明显，这里存在着安全隐患，浏览器厂商也在不断地权衡下面这两个方面之间的博弈：</p><ul><li><p>定义强大的客户端API，启用强大的Web应用</p></li><li><p>阻止恶意代码读取或修改数据、盗取隐私、诈骗或浪费时间</p></li></ul><p>在标准化HTML5的进程中，浏览器厂商会小心掂量某个长期存在的安全限制，并且在不引入新的安全漏洞的基础上给客户端JavaScript添加少量的功能。</p><h4 id="1-JavaScript不能做什么"><a href="#1-JavaScript不能做什么" class="headerlink" title="1. JavaScript不能做什么"></a>1. JavaScript不能做什么</h4><p>Web浏览器针对恶意代码的第一条防线就是它们不支持某些功能。</p><ul><li><p>客户端JavaScript没有权限来写入或删除客户计算机上的任意文件或列出任意目录。</p></li><li><p>客户端JavaScript没有任何通用的网络能力。</p></li></ul><p>浏览器针对恶意代码的第二条防线是在自己支持的某些功能上施加限制。</p><ul><li><p>JavaScript程序可以打开一个新的浏览器窗口，但是为了防止广告商滥用弹出窗口，很多浏览器限制了这一功能，使得只有为了响应鼠标单击这样的用户触发事件的时候，才能使用它。</p></li><li><p>JavaScript程序可以关闭自己打开的浏览器窗口，但是不允许它不经过用户确认就关闭其他的窗口。</p></li><li><p>HTML <code>FileUpload</code>元素的<code>value</code>属性是只读的。如果可以设置这个属性，脚本就能设置它为任意期望的文件名，从而导致表单上传指定文件的内容到服务器。</p></li><li><p>脚本不能读取从不同服务器载入的文档的内容，除非这个就是包含该脚本的文档。类似地，一个脚本不能在来自不同服务器的文档上注册事件监听器。这就防止脚本窃取其他页面的用户输入。这一限制叫做同源策略（<code>same-origin policy</code>）。</p></li></ul><h4 id="2-同源策略"><a href="#2-同源策略" class="headerlink" title="2. 同源策略"></a>2. 同源策略</h4><p>同源策略是对JavaScript代码能够操作哪些Web内容的一条完整的安全限制。当Web页面使用多个<code>&lt;iframe&gt;</code>元素或者打开其他浏览器窗口的时候，这一策略通常就会发挥作用。在这种情况下，同源策略负责管理窗口或窗体中的JavaScript代码以及和其它窗口或帧的交互。具体来说，脚本只能读取和所属文档相同的窗口和文档的属性。</p><p>文档的来源包含协议、主机，以及载入文档的URL端口。从不同Web服务器载入的文档具有不同的来源。通过同一主机的不同端口载入的文档具有不同的来源。使用<code>http:</code>协议载入的文档和使用<code>https:</code>协议载入的文档具有不同的来源，即使它们来自同一个服务器。</p><p>脚本本身的来源和同源策略并不相关，相关的是脚本所嵌入的文档的来源，理解这一点很重要。例如，假设一个来自主机A的脚本被包含到（使用<code>&lt;script&gt;</code>标记的<code>src</code>属性）宿主B的一个Web网页中。这个脚本的来源是主机B，并且可以完整地访问包含它的文档的内容。如果脚本打开一个新窗口并载入来自主机B的另一个文档，脚本对这个文档的内容也具有完全的访问权限。但是，如果脚本打开第三个窗口并载入一个来自主机C的文档（或者是来自主机A），同源策略就会发挥作用，阻止脚本访问这个文档。</p><p>实际上，同源策略并非应用于不同源的窗口中的所有对象的所有属性。不过它应用到了其中的大多数属性，尤其是对<code>Document</code>对象的几乎所有属性而言。凡是包含另一个服务器中文档的窗口或窗体，都是同源策略适用的范围。如果脚本打开一个窗口，脚本也可以关闭它，但不能以任何方式查看窗口内部。同源策略还应用于使用<code>XMLHttpRequest</code>生成的HTTP请求。这个对象允许客户端JavaScript生成任意的HTTP请求到脚本所属文档的Web服务器，但是不允许脚本和其他Web服务器通信。</p><h4 id="3-不严格的同源策略"><a href="#3-不严格的同源策略" class="headerlink" title="3. 不严格的同源策略"></a>3. 不严格的同源策略</h4><p>在某些情况下，同源策略就显得太过严格了。本节会介绍三种不严格的同源策略。</p><p>同源策略给那些使用多个子域的大站点带来了一些问题。例如，来自<code>home.example.com</code>的文档里的脚本想要合法地读取从<code>developer.example.com</code>载入的文档的属性，或者来自<code>orders.example.com</code>的脚本可能需要读<code>catalog.example.com</code>上的文档的属性。为了支持这种类型的多域名站点，可以使用Document对象的domain属性。在默认情况下，属性domain存放的是载入文档的服务器的主机名。可以设置这一属性，不过使用的字符串必须是具有有效的域前缀或它本身。因此，如果一个domain属性的初始值是字符串“<code>home.example.com</code>”，就可以把它设置为字符串“<code>example.com</code>”，但是不能设置为“<code>home.example</code>”或“<code>ample.com</code>”。另外，domain值中必须有一个点号，不能把它设置为“<code>com</code>”或其他顶级域名。</p><p>如果两个窗口包含的脚本把domain设置成了相同的值，那么这两个窗口就不再受同源策略的约束，它们可以相互读取对方的属性。例如，从<code>order.example.com</code>和<code>catalog.example.com</code>载入的文档中的脚本可以把它们的<code>document.domain</code>属性都设置为“<code>example.com</code>”，这样一来，这些文档就有了同源性，可以相互读取属性。</p><p>不严格的同源策略的第二项技术已经标准化为：跨域资源共享（<code>Cross-Origin Resource Sharing</code>）。这个标准草案用新的“<code>Origin:</code>”请求头和新的<code>Access-Control-Allow-Origin</code>响应头来扩展HTTP。它允许服务器用头信息显式地列出源，或使用通配符来匹配所有的源并允许由任何地址请求文件。</p><p>另一种新技术，叫做跨文档消息（<code>cross-document messaging</code>），允许来自一个文档的脚本可以传递文本消息到另一个文档里的脚本，而不管脚本的来源是否不同。调用<code>Window</code>对象上的<code>postMessage()</code>方法，可以异步传递消息事件（可以用onmessage事件处理函数处理它）到窗口的文档里。一个文档里的脚本还是不能调用在其他文档里的方法和读取属性，但它们可以用这种消息传递技术来实现安全的通信。</p><h4 id="4-脚本化插件和ActiveX控件"><a href="#4-脚本化插件和ActiveX控件" class="headerlink" title="4. 脚本化插件和ActiveX控件"></a>4. 脚本化插件和ActiveX控件</h4><p>尽管核心JavaScript语言和基本的客户端对象模型缺乏大多数恶意代码所需要的文件系统功能和网络功能，但情况并不像看上去那么简单。在很多Web浏览器中，JavaScript亦被用作很多软件或插件的“脚本引擎”，这样的组件由IE中的ActiveX控件和其他浏览器的插件。Flash和Java插件是最常安装的例子，它们为客户端脚本提供了非常重要且强大的特性。</p><p>脚本化ActiveX控件和插件的能力也存在着安全性的问题。例如，Java applet具有访问底层网络的能力。Java安全“沙箱”阻止applet和载入它的服务器之外的任何服务器进行通信，因此，这并未打开一个安全漏洞。但是，它暴露了一个根本问题：如果插件是可以脚本化的，我们不仅要无条件相信Web浏览器的安全架构，还要相信插件的安全架构。实际上，Java和Flash插件看上去具有健壮的安全性，并且不会为客户端JavaScript引来安全问题。然而，ActiveX脚本化有着更加糟糕的历史遗留问题。IE浏览器已经能够访问各种各样的脚本化ActiveX控件，而这些控件是Windows操作系统的一部分，并且在过去，操作系统还存在很多可被控件利用的安全漏洞。</p><h4 id="5-跨站脚本"><a href="#5-跨站脚本" class="headerlink" title="5. 跨站脚本"></a>5. 跨站脚本</h4><p>跨站脚本（<code>Cross-site scripting</code>），或者叫做XSS，这个术语用来表示一类安全问题，也就是攻击者向目标Web站点注入HTML标签或者脚本。防止XSS攻击是服务器端Web开发者的一项基本工作。然而，客户端JavaScript程序员也必须意识到或者能够预防跨站脚本。</p><p>如果Web页面动态地产生文档内容，并且这些文档内容是基于用户提交的数据的，而并没有通过从中移除任何嵌入的HTML标签来“消毒”的话，那么这个Web页面很容易遭到跨站脚本攻击。来看一个小例子，考虑如下的Web页面，它使用JavaScript通过用户的名字来向用户问好</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> name = <span class="built_in">decodeURIComponent</span>(<span class="built_in">window</span>.location.search.substring(<span class="number">1</span>)) || <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">'Hello '</span> + name);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两行脚本使用<code>window.location.search</code>来获得它们自己的URL中以“<code>?</code>”开始的部分。它使用<code>document.write()</code>来向文档添加动态生成的内容。这个页面专门通过如下的一个URL来调用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/greet.html?David</span><br></pre></td></tr></table></figure><p>这么使用的时候，它会显示文本“Hello David”。但考虑以下，当用下面的URL来调用它，会发生什么情况</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- %3C和%3E是尖括号的编码 --&gt;</span> </span><br><span class="line">http://www.example.com/greet.html?%3Cscript%3Ealert('David')%3C/script%3E</span><br></pre></td></tr></table></figure><p>只用这个URL，脚本会动态生成另一个脚本。在这个例子中，注入的脚本只显示一个对话框，这还是相对较好的情况。但是，如果考虑以下的情况</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://siteA/greet.html?name=%3Cscript src=siteB/evil.js%3E%3C/script%3E</span><br></pre></td></tr></table></figure><p>之所以叫做跨站脚本攻击，就是因为它涉及多个站点。站点B（或者站点C）包含一个专门构造的到站点A的链接，它会注入一个来自站点B的脚本。脚本<code>eval.js</code>驻留在恶意站点B中，但现在，它嵌入到站点A中，并且可以对站点A的内容进行任何想要的操作。它可能损坏这个页面或者使其不能正常工作。这可能会对站点A的用户带来不少坏处。更危险的是，恶意脚本可以读取A所存储的cookie（可能是统计数据或者其他的个人验证信息），然后把数据发送回站点B。注入的脚本甚至可以诱骗用户击键并将数据发送回站点B。</p><p>通常，防止XSS攻击的方式是，在使用任何不可信的数据来动态创建文档内容之前，从中移除HTML标签。可以通过添加如下一行代码来移除尖括号，从而修复前面给出的<code>greet.html</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = name.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>).replace(<span class="regexp">/&gt;/g</span>, <span class="string">'%gt;'</span>);</span><br></pre></td></tr></table></figure><p>HTML5的内容安全策略则更进一步，它为<code>&lt;iframe&gt;</code>元素定义了一个sandbox属性。在实现之后，它允许显示不可信的内容，并自动禁用脚本。</p><h4 id="6-拒绝服务攻击"><a href="#6-拒绝服务攻击" class="headerlink" title="6. 拒绝服务攻击"></a>6. 拒绝服务攻击</h4><p>这里描述的同源策略和其他的安全限制可以很好地预防恶意代码毁坏数据或者防止侵犯隐私这种问题。然而，它们并不能防止另外一种攻击：拒绝服务攻击，这种攻击手法非常暴利。如果访问了启用JavaScript功能的一个恶意Web站点，这个站点可以使用一个<code>alert()</code>对话框的无限循环占用浏览器，或者用一个无限循环或没有意义的计算来占用CPU。</p><p>某些浏览器可以检测运行时间很长的脚本，并且让用户选择终止它们。但是恶意脚本可以使用<code>window.setInterval()</code>这样的方法来占用CPU，并通过分配很多的内存来攻击你的系统。Web浏览器并没有通用的方法来防止这种笨重的攻击手法。实际上，由于没有人会返回一个滥用这种脚本的网站，因此这在Web上不是一个常见的问题。</p><hr><h3 id="六、客户端框架"><a href="#六、客户端框架" class="headerlink" title="六、客户端框架"></a>六、客户端框架</h3><p>一些Web开发者发现基于客户端框架或类库来创建它们的Web应用非常便捷，从某种意义上来讲类库也是框架，它们对Web浏览器提供的标准和专用API进行了封装，向上提供更高级别的API，用以更高效地进行客户端变成开发。一旦使用一个框架，就要用框架定义的API来写代码，使用框架的一个明显的好处是高级的API可以用更简洁的代码完成更复杂的功能。此外，完善的框架也会帮我们处理上文提到的很多兼容性、安全性和可访问性问题。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;window&lt;/code&gt;对象是所有客户端JavaScript特性和API的主要接入点。它表示Web浏览器的一个窗口或窗体，并且可以用标识符&lt;code&gt;window&lt;/code&gt;来引用它。&lt;code&gt;Window&lt;/code&gt;对象定义了一些属性，比如，指代&lt;code&gt;Location&lt;/code&gt;对象的&lt;code&gt;location&lt;/code&gt;属性，&lt;code&gt;Location&lt;/code&gt;对象指定当前显示在窗口中的url，并允许脚本往窗口里载入新的url。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="客户端JavaScript" scheme="http://www.xiaoleon.cn/tags/%E5%AE%A2%E6%88%B7%E7%AB%AFJavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS(6) Object.assign()</title>
    <link href="http://www.xiaoleon.cn/2018/01/29/js-6/"/>
    <id>http://www.xiaoleon.cn/2018/01/29/js-6/</id>
    <published>2018-01-29T14:26:15.000Z</published>
    <updated>2018-02-02T12:48:05.179Z</updated>
    
    <content type="html"><![CDATA[<p><code>Object.assign()</code>方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><p><code>target</code>：目标对象</p></li><li><p><code>sources</code>：源对象</p></li></ul><p><strong>返回值</strong></p><ul><li>目标对象</li></ul><hr><h3 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a>一、描述</h3><p>如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。</p><p><code>Object.assign()</code>方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的<code>[[Get]]</code>和目标对象的<code>[[Set]]</code>，所以它会调用相关的getter和setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含<code>getter</code>，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用<code>Object.getOwnPropertyDescriptor()</code>和<code>Object.defineProperty()</code>。</p><p><code>String</code>类型和<code>Symbol</code>类型的属性都会被拷贝。</p><p>在出现错误的情况下，例如，如果属性不可写，会引发<code>TypeError</code>，如果在引发错误之前添加了任何属性，则可以更改<code>target</code>对象。</p><p>注意，<code>Object.assign()</code>会跳过那些值为<code>null</code>或<code>undefined</code>的源对象。</p><hr><h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><h4 id="1-复制一个对象"><a href="#1-复制一个对象" class="headerlink" title="1. 复制一个对象"></a>1. 复制一个对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy);                              <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-只有一个参数"><a href="#2-只有一个参数" class="headerlink" title="2. 只有一个参数"></a>2. 只有一个参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj) === obj;                     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果该参数不是对象，则会先转换成对象，然后返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">true</span>);                            <span class="comment">// &#123; [[PrimitiveValue]]: true &#125;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="number">10</span>);                              <span class="comment">// &#123; [[PrimitiveValue]]: 10 &#125;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="string">'abc'</span>);                           <span class="comment">// &#123; &#123;0: 'a', 1: 'b', 2: 'c', length: 3, [[PrimitiveValue]]: 'abc'&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>);                        <span class="comment">// 'number'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>);                       <span class="comment">// 报错 undefined无法转成对象</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>);                            <span class="comment">// 报错 null无法转成对象</span></span><br></pre></td></tr></table></figure><h4 id="3-深拷贝问题"><a href="#3-深拷贝问题" class="headerlink" title="3. 深拷贝问题"></a>3. 深拷贝问题</h4><p>针对深拷贝，需要使用其他方法，因为<code>Object.assign()</code>拷贝的是属性值。加入源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2));          <span class="comment">// &#123; a: 0, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">    obj1.a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1));          <span class="comment">// &#123; a: 1, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2));          <span class="comment">// &#123; a: 0, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">    obj2.a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1));          <span class="comment">// &#123; a: 1, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2));          <span class="comment">// &#123; a: 2, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">    obj2.b.c = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1));          <span class="comment">// &#123; a: 1, b: &#123; c: 3 &#125; &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2));          <span class="comment">// &#123; a: 2, b: &#123; c: 3 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deep Clone</span></span><br><span class="line">    obj1 = &#123; <span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">let</span> obj3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</span><br><span class="line">    obj1.a = <span class="number">4</span>;</span><br><span class="line">    obj1.b.c = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj3));          <span class="comment">// &#123; a: 0, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h4 id="4-合并对象"><a href="#4-合并对象" class="headerlink" title="4. 合并对象"></a>4. 合并对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o3 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(o1, o2, o3);</span><br><span class="line"><span class="built_in">console</span>.log(obj);                               <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o1);                                <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;，注意目标对象自身也会改变</span></span><br></pre></td></tr></table></figure><h4 id="5-合并具有相同属性的对象"><a href="#5-合并具有相同属性的对象" class="headerlink" title="5. 合并具有相同属性的对象"></a>5. 合并具有相同属性的对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o3 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, o1, o2, o3);</span><br><span class="line"><span class="built_in">console</span>.log(obj);                               <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>属性被后续参数中具有相同属性的其他对象覆盖。</p><h4 id="6-拷贝symbol类型的属性"><a href="#6-拷贝symbol类型的属性" class="headerlink" title="6. 拷贝symbol类型的属性"></a>6. 拷贝symbol类型的属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; [<span class="built_in">Symbol</span>(<span class="string">'foo'</span>)]: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, o1, o2);</span><br><span class="line"><span class="built_in">console</span>.log(obj);                               <span class="comment">// &#123; a: 1, [Symbol('foo')]: 2 &#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj);              <span class="comment">// [Symbol(foo)]</span></span><br></pre></td></tr></table></figure><h4 id="7-继承属性和不可枚举属性"><a href="#7-继承属性和不可枚举属性" class="headerlink" title="7. 继承属性和不可枚举属性"></a>7. 继承属性和不可枚举属性</h4><p>继承属性和不可枚举属性是不能拷贝的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;, &#123;           <span class="comment">// foo是个继承属性</span></span><br><span class="line">    bar: &#123;</span><br><span class="line">        value: <span class="number">2</span>                                <span class="comment">// bar是个不可枚举属性</span></span><br><span class="line">    &#125;,</span><br><span class="line">    baz: &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span>                        <span class="comment">// baz是个自身可枚举属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy);                              <span class="comment">// &#123; baz: 3 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="8-原始类型"><a href="#8-原始类型" class="headerlink" title="8. 原始类型"></a>8. 原始类型</h4><p>原始类型会被包装为对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> v2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> v3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> v4 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, <span class="literal">null</span>, v2, <span class="literal">undefined</span>, v3, v4);</span><br><span class="line"><span class="comment">// 原始类型会被包装，null和undefined会被忽略</span></span><br><span class="line"><span class="comment">// 注意，只有字符串的包装对象才可能有自身可枚举属性</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);                               <span class="comment">// &#123; '0': 'a', '1': 'b', '2': 'c' &#125;</span></span><br></pre></td></tr></table></figure><h4 id="9-异常"><a href="#9-异常" class="headerlink" title="9. 异常"></a>9. 异常</h4><p>异常会打断后续拷贝任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'foo'</span>, &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);                                             <span class="comment">// target的foo属性是个只读属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, &#123;<span class="attr">bar</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">foo2</span>: <span class="number">2</span>, <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">foo3</span>: <span class="number">3</span>&#125;, &#123;<span class="attr">baz</span>: <span class="number">4</span>&#125;);</span><br><span class="line"><span class="comment">// TypeError: 'foo' is read-only</span></span><br><span class="line"><span class="comment">// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target.bar);                        <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo2);                       <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo);                        <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo3);                       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(target.baz);                        <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4 id="10-拷贝访问器"><a href="#10-拷贝访问器" class="headerlink" title="10. 拷贝访问器"></a>10. 拷贝访问器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    get bar() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="comment">// &#123; foo: 1, bar: 2 &#125;</span></span><br><span class="line"><span class="comment">// copy.bar的值来自obj.bar的getter函数的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(copy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个函数会拷贝所有自有属性的属性描述符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeAssign</span>(<span class="params">target, ...sources</span>) </span>&#123;</span><br><span class="line">    sources.forEach(<span class="function"><span class="params">source</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> descriptors = <span class="built_in">Object</span>.keys(source).reduce(<span class="function">(<span class="params">descrpitors, key</span>) =&gt;</span> &#123;</span><br><span class="line">            descriptors[key] = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, key);</span><br><span class="line">            <span class="keyword">return</span> descriptors;</span><br><span class="line">        &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object.assign默认也会拷贝可枚举的Symbols</span></span><br><span class="line">        <span class="built_in">Object</span>.getOwnPropertySymbols(source).forEach(<span class="function"><span class="params">sym</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, sym);</span><br><span class="line">            <span class="keyword">if</span> (descriptor.enumerate) &#123;</span><br><span class="line">                descriptors[sym] = descriptor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">Object</span>.defineProperties(target, descriptors);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copy = completeAssign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy);                              <span class="comment">// &#123; foo: 1, get bar() &#123; return 2; &#125; &#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">MDN Object.assign()</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/object#Object-assign" target="_blank" rel="noopener">阮一峰 ECMAScript 6入门</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Object.assign()&lt;/code&gt;方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。&lt;/p&gt;
    
    </summary>
    
      <category term="原生JS学习" scheme="http://www.xiaoleon.cn/categories/%E5%8E%9F%E7%94%9FJS%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Object.assign()" scheme="http://www.xiaoleon.cn/tags/Object-assign/"/>
    
      <category term="JS函数" scheme="http://www.xiaoleon.cn/tags/JS%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>JS(5) 类和模块</title>
    <link href="http://www.xiaoleon.cn/2018/01/29/js-5/"/>
    <id>http://www.xiaoleon.cn/2018/01/29/js-5/</id>
    <published>2018-01-29T13:50:01.000Z</published>
    <updated>2018-02-02T12:48:05.169Z</updated>
    
    <content type="html"><![CDATA[<p>每个JavaScript对象都是一个属性集合，相互之间没有任何联系。在JavaScript中也可以定义对象的类，让每个对象都共享某些属性，这种“共享”的特性是非常有用的。类的成员或实例都包含一些属性，用以存放或定义它们的状态，其中有些属性定义了它们的行为（通常称为方法）。这些行为通常是由类定义的，而且为所有实例所共享。</p><a id="more"></a><p>在JavaScript中，类的实现是基于其原型继承机制的。如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例，并且往往意味着（但不是绝对）它们是由同一个构造函数创建并初始化的。</p><h3 id="一、类和原型"><a href="#一、类和原型" class="headerlink" title="一、类和原型"></a>一、类和原型</h3><p>在JavaScript中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。我们在前文中定义了一个<code>inherit()</code>函数，这个函数返回一个新创建的对象，后者继承自某个原型对象。如果定义了一个原型对象，然后通过<code>inherit()</code>函数创建一个继承自它的对象，这样就定义了一个JavaScript类。通常，类的实例还需要进一步的初始化，通常是通过定义一个函数来创建并初始化这个新对象。下方代码给一个表示“值的范围”的类定义了原型对象，还定义了一个“工厂”函数用以创建并初始化类的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range.js 实现一个能表示值的范围的类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用inherit()函数来创建对象，这个对象继承自在下面定义的原型对象</span></span><br><span class="line">    <span class="comment">// 原型对象作为函数的一个属性存储，并定义所有“范围对象”所共享的方法</span></span><br><span class="line">    <span class="keyword">var</span> r = inherit(range.methods);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储新的“范围对象”的起始位置和结束位置</span></span><br><span class="line">    <span class="comment">// 这两个属性是不可继承的，每个对象都拥有唯一的属性</span></span><br><span class="line">    r.from = <span class="keyword">from</span>;</span><br><span class="line">    r.to = to;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回这个新创建的对象</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型对象定义方法，这些方法为每个范围对象所继承</span></span><br><span class="line">range.methods = &#123;</span><br><span class="line">    <span class="comment">// 如果x在范围内，则返回true，否则返回false</span></span><br><span class="line">    <span class="comment">// 这个方法可以比较数字范围，也可以比较字符串和日期范围</span></span><br><span class="line">    includes: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="keyword">this</span>.to;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于范围内的每个整数都调用一次f</span></span><br><span class="line">    <span class="comment">// 这个方法只可用作数字范围</span></span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from); x &lt;= <span class="keyword">this</span>.to; x++) &#123;</span><br><span class="line">            f(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回表示这个范围的字符串</span></span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.from + <span class="string">'...'</span> + <span class="keyword">this</span>.to + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是使用“范围对象”的一些例子</span></span><br><span class="line"><span class="keyword">var</span> r = range(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">r.includes(<span class="number">2</span>);                                  <span class="comment">// =&gt; true  2在这个范围内</span></span><br><span class="line">r.foreach(<span class="built_in">console</span>.log);                         <span class="comment">// =&gt; 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(r);                                 <span class="comment">// =&gt; (1...3)</span></span><br></pre></td></tr></table></figure><p>这段代码定义了一个工厂方法<code>range()</code>，用来创建新的范围对象。我们注意到，这里给<code>range()</code>函数定义了一个属性<code>range.methods</code>，用以快捷地存放定义类的原型对象。把原型对象挂在函数上没什么大不了，但也不是惯用做法。再者，注意<code>range()</code>函数给每个范围对象都定义了<code>from</code>和<code>to</code>属性，用以定义范围的起始位置和结束位置，这两个属性是非共享的，当然也是不可继承的。最后，注意在<code>range.methods</code>中定义的那些可共享、可继承的方法都用到了<code>from</code>和<code>to</code>属性，而且使用了<code>this</code>关键字，为了指代它们，二者使用<code>this</code>关键字来指代调用这个方法的对象。任何类的方法都可以通过<code>this</code>的这种基本用法来读取对象的属性。</p><hr><h3 id="二、类和构造函数"><a href="#二、类和构造函数" class="headerlink" title="二、类和构造函数"></a>二、类和构造函数</h3><p>上文示例中展示了在JavaScript中定义类的其中一种方法。但这种方法并不常用，毕竟它没有定义构造函数，构造函数是用来初始化新创建的对象的。使用<code>new</code>关键字调用构造函数会自动创建一个新对象，因此构造函数本身只需初始化这个新对象的状态即可。调用构造函数的一个重要特征是，构造函数的<code>prototype</code>属性被用做新对象的原型。这意味着通过同一个构造函数创建的所有对象都继承自一个相同的对象，因此它们都是同一个类的成员。下文示例对前面代码进行了修改，使用构造函数代替工厂函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range2.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个构造函数，用以初始化新创建的“范围对象”</span></span><br><span class="line"><span class="comment">// 注意，这里并没有创建并返回一个对象，仅仅是初始化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 存储“范围对象”的起始位置和结束位置</span></span><br><span class="line">    <span class="comment">// 这两个属性是不可继承的，每个对象都拥有唯一的属性</span></span><br><span class="line">    <span class="keyword">this</span>.from = <span class="keyword">from</span>;</span><br><span class="line">    <span class="keyword">this</span>.to = to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有“范围对象”都继承自这个对象</span></span><br><span class="line"><span class="comment">// 注意：属性的名字必须是prototype</span></span><br><span class="line">Range.prototype = &#123;</span><br><span class="line">    includes: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="keyword">this</span>.to;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from); x &lt;= <span class="keyword">this</span>.to; x++) &#123;</span><br><span class="line">            f(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.from + <span class="string">'...'</span> + <span class="keyword">this</span>.to + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Range(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">r.includes(<span class="number">2</span>);                                  <span class="comment">// =&gt; true  2在这个范围内</span></span><br><span class="line">r.foreach(<span class="built_in">console</span>.log);                         <span class="comment">// =&gt; 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(r);                                 <span class="comment">// =&gt; (1...3)</span></span><br></pre></td></tr></table></figure><p>将两个代码进行对比，可以发现两种定义类的技术的差别。首先，注意当工程函数<code>range()</code>转化为构造函数时被重命名为<code>Range()</code>。这里遵循了一个常见的编程约定：定义构造函数即是定义类，并且类名首字母要大写。而普通的函数和方法都是首字母小写。</p><p>再者，注意<code>Range()</code>构造函数是通过<code>new</code>关键字调用的，而<code>range()</code>工厂函数则不必使用new。由于<code>Range()</code>构造函数是通过<code>new</code>关键字调用的，因此不必调用<code>inherit()</code>或其他什么逻辑来创建新对象。<code>Range()</code>构造函数只不过就是初始化<code>this</code>而已。构造函数甚至不必返回这个新创建的对象，构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。</p><blockquote><p>构造函数就是用来“构造新对象”的，它必须通过关键字<code>new</code>来调用，如果将构造函数用作普通函数的话，往往不会正常工作。开发者可以通过命名约定（构造函数首字母大写，普通方法首字母小写）来判断是否应当在函数之前冠以关键字<code>new</code>。</p></blockquote><p>两个代码之间还有一个非常重要的区别，就是原型对象的命名，在第一段示例代码中的原型是<code>range.methods</code>。这种命名方式很方便同时具有很好的语义，但又过于随意。在第二段代码中的原型是<code>Range.prototype</code>，这是一个强制的命名。对<code>Range()</code>构造函数的调用会自动使用<code>Range.prototype</code>作为新<code>Range</code>对象的原型。</p><h4 id="1-构造函数和类的标识"><a href="#1-构造函数和类的标识" class="headerlink" title="1. 构造函数和类的标识"></a>1. 构造函数和类的标识</h4><p>上文提到，原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。而初始化对象的状态的构造函数则不能作为类的标识，如果两个构造函数的<code>prototype</code>属性指向同一个原型对象，那么这两个构造函数创建的实例是属于同一个类的。</p><p>尽管构造函数不像原型那样基础，但构造函数是类的“外在表现”。很明显的，构造函数的名字通常用做类名。比如，我们说<code>Range()</code>构造函数创建<code>Range</code>对象。然而，更根本的讲，当使用<code>instanceof</code>运算符来检测对象是否属于某个类时会用到构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果r继承自Range.prototype，则返回true</span></span><br><span class="line">r <span class="keyword">instanceof</span> Range</span><br></pre></td></tr></table></figure><p>实际上<code>instanceof</code>运算符并不会检查<code>r</code>是否由<code>Range()</code>构造函数初始化而来，而是会检查<code>r</code>是否继承自<code>Range.prototype</code>。不过，<code>instanceof</code>的语法则强化了“构造函数是类的公有标识”的概念。本文后面还会对<code>instanceof</code>运算符进行介绍。</p><h4 id="2-constructor属性"><a href="#2-constructor属性" class="headerlink" title="2. constructor属性"></a>2. constructor属性</h4><p>上文实例中，将<code>Range.prototype</code>定义为一个新对象，这个对象包含类所需要的方法。其实没有必要新创建一个对象，用单个对象直接量的属性就可以方便地定义原型上的方法。任何JavaScript函数都可以用作构造函数，并且调用构造函数是需要用到一个<code>prototype</code>属性的。因此，每个JavaScript函数（ES5中的<code>Function.bind()</code>方法返回的函数除外）都自动拥有一个<code>prototype</code>属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性<code>constructor</code>。<code>constructor</code>属性的值是一个函数对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;          <span class="comment">// 这是一个函数对象</span></span><br><span class="line"><span class="keyword">var</span> p = F.prototype;            <span class="comment">// 这是F相关联的原型对象</span></span><br><span class="line"><span class="keyword">var</span> c = p.constructor;          <span class="comment">// 这是与原型相关联的函数</span></span><br><span class="line">c === F;                        <span class="comment">// true  对于任意函数 F.prototype.constructor == F</span></span><br></pre></td></tr></table></figure><p>可以看到构造函数的原型中存在预先定义好的<code>constructor</code>属性，这意味着对象通常继承的<code>constructor</code>均指代它们的构造函数。由于构造函数是类的“公共标识”，因此这个<code>constructor</code>属性为对象提供了类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> F();                <span class="comment">// 创建类F的一个对象</span></span><br><span class="line">o.constructor === F;            <span class="comment">// true  constructor属性指代这个类</span></span><br></pre></td></tr></table></figure><p>需要注意的是，示例2定义的<code>Range</code>类使用它自身的一个新对象重写预定义的<code>Range.prototype</code>对象。这个新定义的原型对象不含有<code>constructor</code>属性。因此<code>Range</code>类的实例也不含有<code>constructor</code>属性，我们可以通过补救措施来修正这个问题，显式给原型添加一个构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Range.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Range,         // 显式设置构造函数反向引用</span><br><span class="line">    includes: function(x) &#123; ... &#125;,</span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; ... &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种常见的解决办法是使用预定义的原型对象，预定义的原型对象包含<code>constructor</code>属性，然后依次给原型对象添加方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展预定义的Range.prototype对象，而不重写之</span></span><br><span class="line"><span class="comment">// 这样就自动创建Range.prototype.constructor属性</span></span><br><span class="line">Range.prototype.includes = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; ... &#125;;</span><br><span class="line">Range.prototype.foreach = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; ... &#125;;</span><br><span class="line">Range.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="三、JavaScript中Java式的类继承"><a href="#三、JavaScript中Java式的类继承" class="headerlink" title="三、JavaScript中Java式的类继承"></a>三、JavaScript中Java式的类继承</h3><p>Java或其他类似强类型面向对象语言的类可能是这个样子：</p><ul><li><p>实例字段</p><p>  它们是基于实例的属性或变量，用以保存独立对象的状态。</p></li><li><p>实例方法</p><p>  它们是类的所有实例所共享的方法，由每个独立的实例调用。</p></li><li><p>类字段</p><p>  这些属性或变量是属于类的，而不是属于类的某个实例的。</p></li><li><p>类方法</p><p>  这些方法是属于某个类的，而不是属于类的某个实例的。</p></li></ul><p>JavaScript和Java的一个不同之处在于，JavaScript中的函数都是以值的形式出现的，方法和字段之间并没有太大的区别。如果属性值是函数，那么这个属性就定义一个方法；否则，它只是一个普通的属性或“字段”。尽管存在诸多差异，我们还是可以用JavaScript模拟出Java中的这四种类成员类型。JavaScript中的类牵扯三种不同的对象，三种对象的属性的行为和下面三种类成员非常相似：</p><ul><li><p>构造函数对象</p><p>  构造函数（对象）为JavaScript的类定义了名字。任何添加到这个构造函数对象的属性都是类字段和类方法（如果属性值是函数的话就是类方法）。</p></li><li><p>原型对象</p><p>  原型对象的属性被类的所有实例所继承，如果原型对象的属性值是函数的话，这个函数就作为类的实例的方法来调用。</p></li><li><p>实例对象</p><p>  类的每个实例都是一个独立的对象，直接给这个实例定义的属性是不会为所有实例对象所共享的。定义在实例上的非函数属性，实际上是实例的字段。</p></li></ul><p>在JavaScript中定义类的步骤可以缩减为一个分三步的算法。第一步，先定义一个构造函数，并设置初始化新对象的实例属性。第二步，给构造函数的<code>prototype</code>对象定义实例的方法。第三步，给构造函数定义类字段和类属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineClass</span>(<span class="params">constructor,           <span class="regexp">//</span> 用以设置实例的属性的函数</span></span></span><br><span class="line"><span class="function"><span class="params">                    methods,                <span class="regexp">//</span> 实例的方法，复制至原型中</span></span></span><br><span class="line"><span class="function"><span class="params">                    statics</span>)                // 类属性，复制至构造函数中</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (methods) &#123;</span><br><span class="line">        extend(<span class="keyword">constructor</span>.prototype, methods);</span><br><span class="line">    &#125;</span><br><span class="line">    if (statics) &#123;</span><br><span class="line">        extend(<span class="keyword">constructor</span>, statics);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Range类的另一个实现</span><br><span class="line">var SimpleRange = defineClass(function(f, t) &#123; <span class="keyword">this</span>.f = f; <span class="keyword">this</span>.t = t; &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                includes: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; ... &#125;,</span><br><span class="line">                                toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                upto: <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SimpleRange(o, t); &#125;</span><br><span class="line">                            &#125;)</span><br></pre></td></tr></table></figure><p>尽管JavaScript可以模拟出Java式的类成员，但Java中有很多重要的特性是无法在JavaScript类中模拟的。首先，对于Java类的实例方法来说，实例字段可以用作局部变量，而不需要使用关键字<code>this</code>来引用它们。JavaScript是没办法模拟这个特性的，但可以使用<code>with</code>语句来近似地实现这个功能（但并不推荐）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Complex.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;'</span> + r + <span class="string">', '</span> + i + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中可以使用<code>final</code>声明字段为常量，并且可以将字段和方法声明为<code>private</code>，用以表示它们是私有成员且在类的外面是不可见的。在JavaScript中没有这些关键字，关于这个问题我们在后文中还会碰到：私有属性可以使用闭包里的局部变量来模拟，常量属性可以在ES5中直接实现。</p><hr><h3 id="四、类的扩充"><a href="#四、类的扩充" class="headerlink" title="四、类的扩充"></a>四、类的扩充</h3><p>JavaScript中基于原型的继承机制是动态的：对象从其原型继承属性，如果创建对象之后原型的属性发生改变，也会影响到继承这个原型的所有实例对象。这意味着我们可以通过给原型对象添加新方法来扩充JavaScript类。</p><p>JavaScript内置类的原型对象也是一样如此“开放”，也就是说可以给数字、字符串、数组、函数等数据类型添加方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">o <span class="regexp">/*, ...args */</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// bind方法的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些其他例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多次调用这个函数f，传入一个迭代数</span></span><br><span class="line"><span class="comment">// 比如，要输出hello三次</span></span><br><span class="line"><span class="comment">// var n = 3；</span></span><br><span class="line"><span class="comment">// n.times(function(n) &#123; console.log(n + 'hello'); &#125;);</span></span><br><span class="line"><span class="built_in">Number</span>.prototype.times = <span class="function"><span class="keyword">function</span>(<span class="params">f, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="built_in">Number</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        f.call(context, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不存在ES5的string.trim()方法的话，就定义它</span></span><br><span class="line"><span class="comment">// 这个方法用以除去字符串开头和结尾的空格</span></span><br><span class="line"><span class="built_in">String</span>.prototype.trim = <span class="built_in">String</span>.prototype.trim || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+/</span>|\s+$/g, <span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回函数的名字，如果它有（非标准的）name属性，则直接使用name属性</span></span><br><span class="line"><span class="comment">// 否则，将函数转换为字符串然后从中提取名字</span></span><br><span class="line"><span class="comment">// 如果是没有名字的函数，则返回一个空字符串</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name || <span class="keyword">this</span>.toString().match(<span class="regexp">/function\s*\([^()*]\(/</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以给<code>Object.prototype</code>添加方法，从而使所有的对象都可以调用这些方法。但这种做法并不推荐，因为ES5之前，无法将这些新增的方法设置为不可枚举的，如果给<code>Object.prototype</code>添加属性，这些属性是可以被<code>for/in</code>循环遍历到的。后面我们会给出一个ES5的例子，其中使用<code>Object.defineProperty()</code>方法可以安全地扩充<code>Object.prototype</code>。</p><p>然后并不是所有的宿主环境可以使用<code>Object.defineProperty()</code>，这跟ECMAScript的具体实现有关。比如在很多Web浏览器中，可以给<code>HTMLElement.prototype</code>添加方法，这样当前文档中表示HTML标记的所有对象就都可以继承这些方法。但IE则不支持这样做。</p><hr><h3 id="五、类和类型"><a href="#五、类和类型" class="headerlink" title="五、类和类型"></a>五、类和类型</h3><p>JavaScript定义了少量的数据类型：<code>null、undefined、布尔值、数字、字符串、函数和对象</code>。<code>typeof</code>运算符可以得出值的类型。然而，我们往往更希望将类作为类型来对待，这样就可以根据对象所属的类来区分它们。JavaScript语言核心中的内置对象可以根据它们的<code>class</code>属性来区分彼此。但当我们使用本文中提到的技术来定义类的话，实例对象的<code>class</code>属性都是“<code>Object</code>”，此时无法根据<code>class</code>属性进行区分。</p><p>接下来我们介绍三种用以检测任意对象的类的技术：<code>instanceof</code>运算符、<code>constructor</code>属性，以及构造函数的名字。</p><h4 id="1-instanceof"><a href="#1-instanceof" class="headerlink" title="1. instanceof"></a>1. instanceof</h4><p><code>instanceof</code>操作符左侧是待检测其类的对象，右侧是定义类的构造函数。这里的继承可以不是直接继承。如果<code>o</code>所继承的对象继承自另一个对象，后一个对象继承自<code>c.prototype</code>，<code>o instanceof c</code>值同样是<code>true</code>。</p><p>正如本文前面所讲的，构造函数是类的公共个标识，但原型是唯一的标识。尽管<code>instanceof</code>运算符的右侧是构造函数，但计算过程中实际上是检测了对象的继承关系，而不是检测创建对象的构造函数。</p><p>如果想检测对象的原型链上是否存在某个特定的原型对象，可以使用<code>isPrototypeOf()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range.methods.isPrototypeOf(r);</span><br></pre></td></tr></table></figure><p><code>instanceof</code>运算符和<code>isPrototypeOf()</code>方法的缺点是，我们无法通过对象类获得类名，只能检测对象是否属于指定的类名。</p><h4 id="2-constructor"><a href="#2-constructor" class="headerlink" title="2. constructor"></a>2. constructor</h4><p>另一种识别对象是否属于某个类的方法是使用<code>constructor</code>属性，因为构造函数是类的公共标识，所以最直接的方法就是使用<code>constructor</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeAndValue</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">switch</span>(x.constructor) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Number</span>: <span class="keyword">return</span> <span class="string">'Number: '</span> + x;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">String</span>: <span class="keyword">return</span> <span class="string">'String: '</span> + x;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Date</span>: <span class="keyword">return</span> <span class="string">'Date: '</span> + x;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">RegExp</span>: <span class="keyword">return</span> <span class="string">'RegExp: '</span> + x;</span><br><span class="line">        <span class="keyword">case</span> Complex: <span class="keyword">return</span> <span class="string">'Complex: '</span> + x; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在代码中关键字<code>case</code>后的表达式都是函数，如果改用<code>typeof</code>运算符获取到对象的<code>class</code>属性的话，它们应当改为字符串。</p><p>使用<code>constructor</code>属性检测对象属于某个类的技术的不足之处和<code>instanceof</code>一样。在多个执行上下文的场景中它是无法正常工作的。</p><p>同样，在JavaScript中也并非所有的对象都包含<code>constructor</code>属性，在每个新创建的函数原型上默认会有<code>constructor</code>属性，但我们常常会忽略原型上的<code>constructor</code>属性。</p><h4 id="3-构造函数的名称"><a href="#3-构造函数的名称" class="headerlink" title="3. 构造函数的名称"></a>3. 构造函数的名称</h4><p>使用<code>instanceof</code>和<code>constructor</code>属性来检测对象所属的类有一个主要的问题，在多个执行上下文中存在构造函数的多个副本的时候，这两种方法的检测结果会出错。多个执行上下文中的函数看起来是一模一样的，但它们是相互独立的对象，因此彼此也不相等。</p><p>一种可能的解决方案是使用构造函数的名字而不是构造函数本身作为类标识符。一个窗口里的<code>Array</code>构造函数和另一个窗口的<code>Array</code>构造函数是不相等的，但是它们的名字是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以判断值的类型的type()函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t, c, n;                    <span class="comment">// type, class, name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理null值的特殊情形</span></span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">'null'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另外一种特殊情形：NaN和它自身不相等</span></span><br><span class="line">    <span class="keyword">if</span> (o !== o) <span class="keyword">return</span> <span class="string">'nan'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果typeof的值不是“object”，则使用这个值，这可以识别出原始值的类型和函数</span></span><br><span class="line">    <span class="keyword">if</span> ((t = <span class="keyword">typeof</span> o) !== <span class="string">'object'</span>) <span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回对象的类名，除非值是“Object”，这种方式可以识别出大多数的内置对象</span></span><br><span class="line">    <span class="keyword">if</span> ((c = classof(o)) !== <span class="string">'Object'</span>) <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果对象构造函数的名字存在的话，则返回它</span></span><br><span class="line">    <span class="keyword">if</span> (o.constructor &amp;&amp; <span class="keyword">typeof</span> o.constructor === <span class="string">'function'</span> &amp;&amp; (n = o.constructor.getName())) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他的类型都无法判别，一律返回“Object”</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Object'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classof</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回函数的名字（可能是空字符串），不是函数的话返回null</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'name'</span> <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name = <span class="keyword">this</span>.toString().match(<span class="regexp">/function\s*([^(]*\()/</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种使用构造函数名字来识别对象的类的做法和使用<code>constructor</code>属性一样有一个问题：并不是所有的对象都有<code>constructor</code>属性。此外，并不是所有的函数都有名字。如果使用不带名字的函数定义表达式定义一个构造函数，<code>getName()</code>方法则会返回空字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个构造函数没有名字</span></span><br><span class="line"><span class="keyword">var</span> Complex = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.r = x;</span><br><span class="line">    <span class="keyword">this</span>.i = y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这个构造函数有名字</span></span><br><span class="line"><span class="keyword">var</span> Range = <span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">f, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.from = f;</span><br><span class="line">    <span class="keyword">this</span>.to = t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-鸭式辩型"><a href="#4-鸭式辩型" class="headerlink" title="4. 鸭式辩型"></a>4. 鸭式辩型</h4><p>上文所描述的检测对象的类的各种技术多少都会有些问题，至少在客户端JavaScript中是如此。解决办法就是规避掉这些问题：不要关注“对象的类是什么”，而是关注“对象能做什么”。这种思考问题的方式在Python和Ruby中非常普遍，成为“鸭式辩型”</p><p><strong>像鸭子一样走路、有用并且嘎嘎叫的鸟就是鸭子</strong></p><p>对于JavaScript来说，这句话可以理解为“如果一个对象可以像鸭子一样走路、游泳并且嘎嘎叫，就认为这个对象是鸭子，哪怕它并不是从鸭子类的原型对象继承而来的”。</p><p>我们拿前文中的<code>Range</code>类来举例，起初定义这个类用以描述数字的范围。但要注意，<code>Range()</code>构造函数并没有对实参进行类型检查以确保实参是数字类型。但却将参数使用“<code>&gt;</code>”运算符进行比较运算，因为这里假定它们是可比较的。同样，<code>includes()</code>方法使用“<code>&lt;=</code>”运算符进行比较，但没有对范围的结束点进行类似的假设。因为类并没有强制使用特定的类型，它的<code>includes()</code>方法可以作用于任何结束点，只要结束点可以用关系运算符执行比较运算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowercase = <span class="keyword">new</span> Range(<span class="string">'a'</span>, <span class="string">'z'</span>);</span><br><span class="line"><span class="keyword">var</span> thisYear = <span class="keyword">new</span> Range(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2009</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2010</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><code>Range</code>类的<code>foreach()</code>方法中也没有显式的检测表示范围的结束点的类型，但<code>Math.ceil()</code>和“<code>++</code>”运算符表明它只能对数字结束点进行操作。</p><p>另外一个例子，我们之前讨论的类数组对象。在很多场景下，我们并不知道一个对象是否真的是<code>Array</code>实例，当然是可以通过判断是否包含非负的<code>length</code>属性来得知是否是<code>Array</code>的实例。我们说“包含一个值是非负整数的length”是数组的一个特性——“会走路”，任何具有“会走路”这个特征的对象都可以当作数组来对待。然而必须要了解的是，真正数组的<code>length</code>属性具有一些独有的行为：当添加新元素时，数组的长度会自动更新，并且当给<code>length</code>属性设置一个更小的整数时，数组会被自动截断。我们说这些特征是“会游泳”和“嘎嘎叫”。如果所实现的代码需要“会游泳”且能“嘎嘎叫”，则不能使用只“会走路”的类似数组的对象。</p><p>上文所讲到的鸭式辩型的例子提到了进行对象的“<code>&lt;</code>”运算符的职责以及<code>length</code>属性的特殊行为。但当我们提到鸭式辩型时，往往是说检测对象是否实现了一个或多个方法。一个强类型的<code>triathlon()</code>函数所需要的参数必须是<code>TriAthlete</code>对象。而一中“鸭式辩型”式的做法是，只要对象包含<code>walk()</code>、<code>swin()</code>和<code>bike()</code>这三个方法就可以作为参数传入。同里，可以重新设计<code>Range</code>类，使用结束点对象的<code>compareTo()</code>和<code>succ()</code>方法来替代“<code>&lt;</code>”和“<code>++</code>”运算符。</p><p>鸭式辩型的实现方法让人感觉太“放任自流”：仅仅是假设输入对象实现了必要的方法，根本没有执行进一步的检查。如果输入对象没有遵循“假设”，那么当代吗试图调用那些不存在的方法时就会报错。另一种实现方法是对输入对象进行检查。但不是检查它们的类，而是用适当的名字来检查它们所实现的方法。这样可以将非法输入尽可能早地拦截在外，并可给出带有更多提示信息的报错。</p><p>下文示例中按照鸭式辩型的理念定义了<code>quacks()</code>函数。<code>quacks()</code>函数用以检查一个对象是否实现了剩下参数所表示的方法。对于除第一个参数外的每个参数，如果是字符串的话则直接检查是否存在以它命名的方法；如果是对象的话则检查第一个对象中的方法是否在这个对象中也具有同名的方法；如果参数是函数，则假定它是构造函数，函数将检查第一个对象实现的方法是否在构造函数的原型对象中也具有同名的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用鸭式辩型实现的函数</span></span><br><span class="line"><span class="comment">// 如果o实现了除第一个参数之外的参数所表示的方法，则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quacks</span>(<span class="params">o <span class="regexp">/*, ...*/</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> arg = <span class="built_in">arguments</span>[i];</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">typeof</span> arg) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> o[arg] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span>  <span class="string">'function'</span>:</span><br><span class="line">                arg = arg.prototype;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'objet'</span>:</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> m <span class="keyword">in</span> arg) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg[m] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> o[m] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个<code>quacks()</code>函数还有一些地方是需要尤为注意的。首先，这里只是通过特定的名称来检测对象是否含有一个或多个值为函数的属性。我们无法得知这些已经存在的属性的细节信息，如果，函数是干什么用的？它们需要多少参数？参数类型是什么？然而这是鸭式辩型的本质所在，如果使用鸭式辩型而不是强制的类型检测的方式定义API，那么创建的API应当更具灵活性才可以，这样才能确保你提供给用户的API更加安全可靠。关于<code>quacks()</code>函数还有另一问题需要注意，就是它不能应用于内置类。比如，不能通过<code>quacks(o, Array)</code>来检测o是否实现了<code>Array</code>中所有同名的方法。原因是内置类的方法都是不可枚举的，<code>quacks()</code>中的<code>for/in</code>循环无法遍历到它们（注意，ES5中有一个补救办法，就是使用<code>Object.getOwnPropertyNames()</code>）。</p><hr><h3 id="六、JavaScript中的面向对象技术"><a href="#六、JavaScript中的面向对象技术" class="headerlink" title="六、JavaScript中的面向对象技术"></a>六、JavaScript中的面向对象技术</h3><p>到目前为止，我们讨论了JavaScript中类的基础知识：原型对象的重要性、它和构造函数之间的联系、<code>instanceof</code>运算符如何工作等。下面我们举一个例子，介绍如何利用JavaScript中的类进行编程。</p><h4 id="1-集合类"><a href="#1-集合类" class="headerlink" title="1. 集合类"></a>1. 集合类</h4><p>集合（<code>set</code>）是一种数据结构，用以表示非重复值的无序集合。集合的基础方法包括添加值、检测值是否在集合中，这种集合需要一种通用的实现，以保证操作效率。JavaScript的对象是属性名以及与之对应的值的基本集合。因此将对象只用做字符串的集合是大材小用。下面的例子实现了一个更加通用的<code>Set</code>类，它实现了从JavaScript值到唯一字符串的映射，然后将字符串用作属性名。对象和函数都不具备如此简明可靠的唯一字符串表示。因此集合类必须给集合中的每一个对象或函数定义一个唯一的属性标识。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;                        <span class="comment">// 这是一个构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.valus = &#123;&#125;;                    <span class="comment">// 集合数据保存在对象的属性里</span></span><br><span class="line">    <span class="keyword">this</span>.n = <span class="number">0</span>;                         <span class="comment">// 集合中值的个数</span></span><br><span class="line">    <span class="keyword">this</span>.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);    <span class="comment">// 把所有的参数都添加进这个集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;    <span class="comment">// 遍历每个参数</span></span><br><span class="line">        <span class="keyword">var</span> val = <span class="built_in">arguments</span>[i];                     <span class="comment">// 待添加到集合中的值</span></span><br><span class="line">        <span class="keyword">var</span> str = <span class="built_in">Set</span>._v2s(val);                    <span class="comment">// 把它转换为字符串</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.values.hasOwnProperty(str)) &#123;     <span class="comment">// 如果不在集合中</span></span><br><span class="line">            <span class="keyword">this</span>.values[str] = val;                 <span class="comment">// 将字符串和值对应起来</span></span><br><span class="line">            <span class="keyword">this</span>.n++;                               <span class="comment">// 集合中值的计数加一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;                                    <span class="comment">// 支持链式方法调用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> str= <span class="built_in">Set</span>._v2s(<span class="built_in">arguments</span>[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.values.hasOwnProperty(str)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>.values[str];</span><br><span class="line">            <span class="keyword">this</span>.n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.prototype.contains = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.values.hasOwnProperty(<span class="built_in">Set</span>._v2s(value));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.prototype.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合中的所有元素，在指定的上下文中调用f</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.foreach = <span class="function"><span class="keyword">function</span>(<span class="params">f, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> s <span class="keyword">in</span> <span class="keyword">this</span>.values) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.values.hasOwnproperty(s)) &#123;</span><br><span class="line">            f.call(context, <span class="keyword">this</span>.values[s]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个内部函数，用以将任意JavaScript值和唯一的字符串对应起来</span></span><br><span class="line"><span class="built_in">Set</span>._v2s = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (val) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">undefined</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'u'</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">null</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'n'</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'t'</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'f'</span>;</span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="keyword">switch</span>(<span class="keyword">typeof</span> val) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'#'</span> + val;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'"'</span> + val;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'@'</span> + objectId(val);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对任意对象来说，都会返回一个字符串</span></span><br><span class="line">    <span class="comment">// 针对不同的对象，这个函数会返回不同的字符串</span></span><br><span class="line">    <span class="comment">// 对于同一个对象的多次调用，总是返回相同的字符串</span></span><br><span class="line">    <span class="comment">// 为了做到这一点，它给o创建了一个属性，在ES5中，这个属性是不可枚举且只读的</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">objectId</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> prop = <span class="string">"|**objectid**|"</span>;        <span class="comment">// 私有属性，用以存放id</span></span><br><span class="line">        <span class="keyword">if</span> (!o.hasOwnProperty(prop)) &#123;      <span class="comment">// 如果对象没有id</span></span><br><span class="line">            o[prop] = <span class="built_in">Set</span>._v2s.next++;      <span class="comment">// 将下一个值赋给它</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>._v2s.next = <span class="number">100</span>;                        <span class="comment">// 设置初始id的值</span></span><br></pre></td></tr></table></figure><h4 id="2-枚举类型"><a href="#2-枚举类型" class="headerlink" title="2. 枚举类型"></a>2. 枚举类型</h4><p>枚举类型（<code>enumerated type</code>）是一种类型，它是值的有限集合，如果值定义为这个类型则该值是可列出的。<code>Enum</code>是ES5中的保留字，很有可能在将来JavaScript就会内置支持枚举类型。</p><p>下文示例中包含一个单独函数<code>enumeration()</code>。但它不是构造函数，它并没有定义一个名叫“<code>enumeration</code>”的类。相反，它是一个工厂方法，每次调用它都会创建并返回一个新的类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用4个值创建新的Coin类：Coin、Penny、Coin.Nickel等</span></span><br><span class="line"><span class="keyword">var</span> Coin = enumeration(&#123;<span class="attr">Penny</span>: <span class="number">1</span>, <span class="attr">Nickel</span>: <span class="number">5</span>, <span class="attr">Dime</span>: <span class="number">10</span>, <span class="attr">Quarter</span>: <span class="number">25</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> c = Coin.Dime;                          <span class="comment">// 这是新类的实例</span></span><br><span class="line">c <span class="keyword">instanceof</span> Coin;                          <span class="comment">// true  instanceof正常工作</span></span><br><span class="line">c.constructor == Coin;                      <span class="comment">// true  构造函数的属性正常工作</span></span><br><span class="line">Coin.Quarter + <span class="number">3</span> * Coin.Nicker;             <span class="comment">// 40  将值转换为数字</span></span><br><span class="line">Coin.Dime == <span class="number">10</span>;                            <span class="comment">// true  更多转换为数字的例子</span></span><br><span class="line">Coin.Dime &gt; Coin.Nickel;                    <span class="comment">// true  关系运算符正常工作</span></span><br><span class="line"><span class="built_in">String</span>(Coin.Dime) + <span class="string">':'</span> + Coin.Dime;        <span class="comment">// "Dime:10"  强制转换为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数创建一个新的枚举类型，实参对象表示类的每个实例的名字和值</span></span><br><span class="line"><span class="comment">// 返回值是一个构造函数，它标识这个新类</span></span><br><span class="line"><span class="comment">// 注意，这个构造函数也会抛出易畅：不能使用它来创建该类型的新实例</span></span><br><span class="line"><span class="comment">// 返回的构造函数包含名值对的映射表</span></span><br><span class="line"><span class="comment">// 包括由值组成的数组，以及一个foreach()迭代器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumeration</span>(<span class="params">namesToValues</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这个虚拟的构造函数是返回值</span></span><br><span class="line">    <span class="keyword">var</span> enumeration = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="string">"Can't Instantiate Enumerations"</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举值继承自这个对象</span></span><br><span class="line">    <span class="keyword">var</span> proto = enumeration.prototype = &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: enumeration,</span><br><span class="line">        toString: function() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;,</span><br><span class="line">        valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.value; &#125;,</span><br><span class="line">        toJSON: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    enumeration.values = [];                <span class="comment">// 用以存放枚举对象的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在创建新类型的实例</span></span><br><span class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> namesToValues) &#123;           <span class="comment">// 遍历每个值</span></span><br><span class="line">        <span class="keyword">var</span> e = inherit(proto);             <span class="comment">// 创建一个代表它的对象</span></span><br><span class="line">        e.name = name;                      <span class="comment">// 给它一个名字</span></span><br><span class="line">        e.value = namesToValues[name];      <span class="comment">// 给它一个值</span></span><br><span class="line">        enumeration[name] = e;              <span class="comment">// 将它设置为构造函数的属性</span></span><br><span class="line">        enumeration.values.push(e);         <span class="comment">// 将它存储到值数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个类方法，用来对类的实例进行迭代</span></span><br><span class="line">    enumeration.foreach = <span class="function"><span class="keyword">function</span>(<span class="params">f, c</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.values.length; i++) &#123;</span><br><span class="line">            f.call(c, <span class="keyword">this</span>.values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回标识这个新类型的构造函数</span></span><br><span class="line">    <span class="keyword">return</span> enumeration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用这个枚举类型来实现一个“<code>hello world</code>”小程序的话，就可以使用枚举类型来表示一副扑克牌。</p><figure class="highlight javascript"><figcaption><span>使用枚举类型来表示一副扑克牌</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Card</span>(<span class="params">suit, rank</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.suit = suit;                       <span class="comment">// 每张牌都有花色</span></span><br><span class="line">    <span class="keyword">this</span>.rank = rank;                       <span class="comment">// 以及点数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举类型定义花色和点数</span></span><br><span class="line">Card.Suit = enumeration(&#123;<span class="attr">Clubs</span>: <span class="number">1</span>, <span class="attr">Diamonds</span>: <span class="number">2</span>, <span class="attr">Hearts</span>: <span class="number">3</span>, <span class="attr">Spades</span>: <span class="number">4</span>&#125;);</span><br><span class="line">Card.Rank = enumeration(&#123;<span class="attr">Two</span>: <span class="number">2</span>, <span class="attr">Three</span>: <span class="number">3</span>, <span class="attr">Four</span>: <span class="number">4</span>, <span class="attr">Five</span>: <span class="number">5</span>, <span class="attr">Six</span>: <span class="number">6</span>, </span><br><span class="line">                        Seven: <span class="number">7</span>, <span class="attr">Eight</span>: <span class="number">8</span>, <span class="attr">Nine</span>: <span class="number">9</span>, <span class="attr">Ten</span>: <span class="number">10</span>,</span><br><span class="line">                        Jack: <span class="number">11</span>, <span class="attr">Queen</span>: <span class="number">12</span>, <span class="attr">King</span>: <span class="number">13</span>, <span class="attr">Ace</span>: <span class="number">14</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用以描述牌面的文本</span></span><br><span class="line">Card.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.rank.toString() + <span class="string">' of '</span> + <span class="keyword">this</span>.suit.toString();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较扑克牌中两张牌的大小</span></span><br><span class="line">Card.prototype.compareTo = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rank &lt; that.rank) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rank &gt; that.rank) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以扑克牌的玩法规则对牌进行排序的函数</span></span><br><span class="line">Card.orderByRank = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.compareTo(b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以桥牌的玩法规则对扑克牌进行排序的函数</span></span><br><span class="line">Card.orderBySuit = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.suit &lt; b.suit) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.suit &gt; b.suit) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.rank &lt; b.rank) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.rank &gt; b.rank) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用以表示一副标准扑克牌的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deck</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cards = <span class="keyword">this</span>.cards = [];            <span class="comment">// 一副牌就是由牌组成的数组</span></span><br><span class="line">    Card.Suit.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;         <span class="comment">// 初始化这个数组</span></span><br><span class="line">        Card.Rank.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">            cars.push(<span class="keyword">new</span> Card(s, r));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 洗牌的方法：重新洗牌并返回洗好的牌</span></span><br><span class="line">Deck.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历数组中的每个元素，随机找出牌面最小的元素，并与之（当前遍历的元素）交换</span></span><br><span class="line">    <span class="keyword">var</span> deck = <span class="keyword">this</span>.cards, len = deck.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>)), temp;      <span class="comment">// 随机数</span></span><br><span class="line">        temp = deck[i], deck[i] = deck[r], deck[r] = temp;      <span class="comment">// 交换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发牌的方法：返回牌的数组</span></span><br><span class="line">Deck.prototype.deal = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cards.length &lt; n)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'Out of cards'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cards.splice(<span class="keyword">this</span>.cards.length - n, n);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一副新扑克牌，洗牌并发牌</span></span><br><span class="line"><span class="keyword">var</span> deck = (<span class="keyword">new</span> Deck()).shuffle();</span><br><span class="line"><span class="keyword">var</span> hand = deck.deal(<span class="number">13</span>).sort(Card.orderBySuit);</span><br></pre></td></tr></table></figure><h4 id="3-标准转换方法"><a href="#3-标准转换方法" class="headerlink" title="3. 标准转换方法"></a>3. 标准转换方法</h4><p>对象类型转换时，有一些方法是在需要做类型转换时由JavaScript解释器自动调用的。不需要为定义的每个类都实现这些方法，但这些方法的确非常重要，如果没有为自定义的类实现这些方法，也应当是有意为之，而不应当因为疏忽而漏掉了它们。</p><p>最重要的方法首当<code>toString()</code>，这个方法的作用是返回一个可以表示这个对象的字符串。在希望使用字符串的地方用到对象的话（比如将对象用作属性名或使用“<code>+</code>”运算符来进行字符串连接运算），JavaScript会自动调用这个方法。如果没有实现这个方法，类会默认从<code>Object.prototype</code>中继承<code>toString()</code>方法，这个方法的运算结果是“<code>[object Object]</code>”，这个字符串用处不大。<code>toString()</code>方法应当返回一个可读的字符串，这样最终用户才能将这个输出值利用起来，然而有时候并不一定非要如此，不管怎样，可以返回可读字符串的<code>toString()</code>方法也会让程序调试变得更加轻松。</p><p><code>toLocaleString()</code>和<code>toString()</code>类似：<code>toLocaleString()</code>是以本地敏感性(<code>locale-sensitive</code>)的方式来将对象转换为字符串。默认情况下，对象所继承的<code>toLocaleString()</code>方法只是简单地调用<code>toString()</code>方法。有一些内置类型包含有用的<code>toLocaleString()</code>方法用以实际上返回本地化相关的字符串。如果需要为对象到字符串的转换定义<code>toString()</code>方法，那么同样需要定义<code>toLocaleString()</code>方法用以处理本地化的对象到字符串的转换。</p><p>第三个方法是<code>valueOf()</code>，它用来将对象转换为原始值。比如，当数学运算符（除了“<code>+</code>”运算符）和关系运算符作用于数字文本表示的对象时，会自动调用<code>valueOf()</code>方法。大多数对象都没有合适的原始值来表示它们，也没有定义这个方法。</p><p>第四个方法是<code>toJSON()</code>，这个方法是由<code>JSON.stringify()</code>自动调用的。JSON格式用于序列化良好的数据结构，而且可以处理JavaScript原始值、数组和纯对象。它和类无关，当对一个对象执行序列化操作时，它会忽略对象的原型和构造函数。比如将<code>Range</code>对象或<code>Complex</code>对象作为参数传入<code>JSON.stringify()</code>，会返回诸如<code>{&quot;form&quot;: 1, &quot;to&quot;: 3}</code>或<code>{&quot;r&quot;: 1, &quot;i&quot;: -1}</code>这种字符串。如果将这些字符串传入<code>JSON.parse()</code>，则会得到一个和<code>Range</code>对象和<code>Complex</code>对象具有相同属性的纯对象，但这个对象不会包含从<code>Range</code>和<code>Complex</code>继承来的方法。</p><p>上文实例中的<code>Set</code>类并没有定义上述方法中的任何一个，JavaScript中没有哪个原始值可以表示集合，因此也没有必要定义<code>valueOf()</code>方法，但该类应当包含<code>toString()</code>、<code>toLocaleString()</code>和<code>toJSON()</code>方法。可以用如下代码来实现，注意<code>extend()</code>函数的用法，这里使用<code>extend()</code>来向<code>Set.prototype</code>来添加方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将这些方法添加至Set类的原型对象中</span></span><br><span class="line">extend(<span class="built_in">Set</span>.prototype, &#123;</span><br><span class="line">    <span class="comment">// 将集合转换为字符串</span></span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> s = <span class="string">"&#123;"</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            s += ((i++ &gt; <span class="number">0</span>) ? <span class="string">", "</span>: <span class="string">""</span>) + v;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 类似toString，但是对于所有的值都将调用toLocaleString()</span></span><br><span class="line">    toLocaleString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> s = <span class="string">"&#123;"</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i++ &gt; <span class="number">0</span>) s += <span class="string">', '</span>;</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="literal">null</span>) s+= v;               <span class="comment">// null和undefined</span></span><br><span class="line">            <span class="keyword">else</span> s += v.toLocaleString();       <span class="comment">// 其他情况</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 将集合转换为值数组</span></span><br><span class="line">    toArray: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = [];</span><br><span class="line">        <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            a.push(v);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于要从JSON转换为字符串的集合都将被当作数组来对待</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.toJSON = <span class="built_in">Set</span>.prototype.toArray;</span><br></pre></td></tr></table></figure><h4 id="4-比较方法"><a href="#4-比较方法" class="headerlink" title="4. 比较方法"></a>4. 比较方法</h4><p>JavaScript的相等运算符比较对象时，比较的是引用而不是值。也就是说，给定两个对象引用，如果要看它们是否指向同一个对象，不是检查这两个对象是否具有相同的属性名和相同的属性值，而是直接比较这两个单独的对象是否相等，或者比较它们的顺序（就像“<code>&lt;</code>”和“<code>&gt;</code>”运算符进行的比较一样）。如果定义一个类，并且希望比较类的实例，应该定义合适的方法来执行比较操作。</p><p>为了能让自定义类的实例具备比较的功能，定义一个名叫<code>equals()</code>实例方法，这个方法只能接收一个实参，如果这个实参和调用此方法的对象相等的话则返回<code>true</code>。当然，这里所说的相等的含义是根据类的上下文来决定的。相对简单的类，可以通过简单地比较它们的<code>constructor</code>属性来确保两个对象是相同类型，然后比较两个对象的实例属性以保证它们的值相等。我们可以轻易地为<code>Range</code>类也实现类似的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Range类重写它的constructor属性，现在将它添加进去</span></span><br><span class="line">Range.prototype.constructor = Range;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个Range对象和其他不是Range的对象均不相等</span></span><br><span class="line"><span class="comment">// 当且仅当两个范围的端点相等，它们才相等</span></span><br><span class="line">Range.prototype.equals = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (that == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">// 处理null和undefined</span></span><br><span class="line">    <span class="keyword">if</span> (that.constructor !== Range)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">// 处理非Range对象</span></span><br><span class="line">    <span class="comment">// 当且仅当两个端点相等，才返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.from == that.from &amp;&amp; <span class="keyword">this</span>.to == that.to;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给<code>Set</code>类定义<code>equals()</code>方法稍微有些复杂，不能简单地比较两个集合的<code>values</code>属性，还要进行更深层次的比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.equals = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 一些次要情况的快捷处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> === that)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果that对象不是一个集合，它和this不相等</span></span><br><span class="line">    <span class="comment">// 我们用到了instanceof，使得这个方法可以用于Set的任何子类</span></span><br><span class="line">    <span class="comment">// 如果希望采用鸭式辩型的方法，可以降低检查的严格成都</span></span><br><span class="line">    <span class="comment">// 或者可以通过this.constructor == that.constructor来加强检查的严格程度</span></span><br><span class="line">    <span class="comment">// 注意，null和undefined两个值是无法用于instanceof运算的</span></span><br><span class="line">    <span class="keyword">if</span> (!(that <span class="keyword">instanceof</span> <span class="built_in">Set</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果两个集合的大小不一样，则它们不相等</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size() != that.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在检查两个集合中的元素是否完全一样</span></span><br><span class="line">    <span class="comment">// 如果两个集合不相等，则通过抛出异常来终止foreach循环</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!that.contains(v))</span><br><span class="line">                <span class="keyword">throw</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;                            <span class="comment">// 所有的元素都匹配，则两个集合相等</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x === <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">// 如果集合中有元素在另外一个集合中不存在</span></span><br><span class="line">        <span class="keyword">throw</span> x;                                    <span class="comment">// 重新抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于某些类来说，往往需要比较一个实例“大于”或者“小于”另外一个实例。比如，我们可能会基于<code>Range</code>对象的下边界来定义实例的大小关系。枚举类型可以根据名字的字母表顺序来定义实例的大小，也可以根据它包含的数值来定义大小，另一方面，<code>Set</code>对象其实是无法排序的。</p><p>如果将对象用于JavaScript的关系比较运算符，比如“<code>&lt;</code>”和“<code>&gt;</code>”，JavaScript会首先调用对象<code>valueOf()</code>方法，如果这个方法返回一个原始值，则直接比较原始值。上文中的<code>enumeration()</code>方法所返回的枚举类型包含<code>valueOf()</code>方法，因此可以使用关系运算符对它们做有意义的比较。但大多数类并没有<code>valueOf()</code>方法，为了按照显式定义的规则来比较这些类型的对象，可以定义一个名叫<code>compareTo()</code>的方法。</p><p><code>compareTo()</code>方法应当只能接收一个参数，这个方法将这个参数和调用它的对象进行比较。如果<code>this</code>对象小于参数对象，<code>compareTo()</code>应当返回比0小的值。如果<code>this</code>对象大于参数对象，应当返回比0大的值。如果两个对象相等，应该返回0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Range.prototype.compareTo = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.from - that.from;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文提到的<code>equals()</code>方法对其参数执行了类型检查，如果参数类型不合法则返回<code>false</code>。<code>compareTo()</code>方法并没有返回一个表示“这两个值不能比较”的值，由于<code>compareTo()</code>没有对参数做任何类型检查，因此如果给<code>compareTo()</code>方法传入错误类型的参数，往往会抛出异常。</p><p>注意，如果两个范围对象的下边界相等，为<code>Range</code>类定义的<code>compareTo()</code>方法会返回0。这意味着就<code>compareTo()</code>而言，任何两个起始点相同的<code>Range</code>对象都相等。这个相等概念的定义和<code>equals()</code>方法定义的相等概念是相背的，<code>equals()</code>要求两个端点均相等才算相等。最好将<code>Range</code>类的<code>equals()</code>和<code>compareTo()</code>方法中处理相等的逻辑保持一致。这里是<code>Range</code>类修正后的<code>compareTo()</code>方法，它的比较逻辑和<code>equals()</code>保持一致，但当传入不可比较的值时仍然会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据下边界来对Range对象排序，如果下边界相等则比较上边界</span></span><br><span class="line"><span class="comment">// 如果传入非Range值，则抛出异常</span></span><br><span class="line"><span class="comment">// 当且仅当this.equals(that)时，才返回0</span></span><br><span class="line">Range.prototype.compareTo = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(that <span class="keyword">instanceof</span> Range)) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Can't compare a Range with "</span> + that);</span><br><span class="line">    <span class="keyword">var</span> diff = <span class="keyword">this</span>.from - that.from;           <span class="comment">// 比较下边界</span></span><br><span class="line">    <span class="keyword">if</span> (diff == <span class="number">0</span>)</span><br><span class="line">        diff = <span class="keyword">this</span>.to - that.to;               <span class="comment">// 如果相等，比较上边界</span></span><br><span class="line">    <span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-方法借用"><a href="#5-方法借用" class="headerlink" title="5. 方法借用"></a>5. 方法借用</h4><p>JavaScript中的方法没有什么特别：无非是一些简单的函数，赋值给了对象的属性，可以通过对象来调用它。一个函数可以赋值给两个属性，然后作为两个方法来调用它。比如，我们在Set类中就这样做了，将<code>toArray()</code>方法创建了一个副本，并让它可以和<code>toJSON()</code>方法一样完成同样的功能。</p><p>多个类中的方法可以共用一个单独的函数。比如，<code>Array</code>类通常定义了一些内置方法，如果定义了一个类，它的实例是数组类的对象，则可以从<code>Array.prototype</code>中将函数复制至所定义的类的原型对象中，如果以经典的面向对象语言的视角来看JavaScript的话，把一个类的方法用到其他的类中的做法也称作“多重继承”（<code>multiple inheritance</code>）。然而，JavaScript并不是经典的面向对象语言，我们更倾向于将这种方法重用称作为“方法借用”（<code>borrowing</code>）。</p><p>不仅<code>Array</code>的方法可以借用，还可以自定义泛型方法（<code>generic method</code>）。比如我们定义泛型方法<code>toString()</code>和<code>equals()</code>，可以被<code>Range</code>、<code>Complex</code>和<code>Card</code>这些简单的类使用。如果<code>Range</code>类没有定义<code>equals()</code>方法，可以这样借用泛型方法<code>equals()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range.prototype.equals = generic.equals;</span><br></pre></td></tr></table></figure><p>注意，<code>generic.equals()</code>只会执行浅比较，因此这个方法并不适用于其实例太复杂的类，它们的实例属性通过其<code>equals()</code>方法指代对象。同样需要注意，这个方法包含一些特殊情况的程序逻辑，以处理新增至<code>Set</code>对象中的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generic = &#123;</span><br><span class="line">    <span class="comment">// 返回一个字符串，这个字符串包含构造函数的名字（如果构造函数包含名字）</span></span><br><span class="line">    <span class="comment">// 以及所有非继承来的、非函数属性的名字和值</span></span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> s = <span class="string">'['</span>;</span><br><span class="line">        <span class="comment">// 如果这个对象包含构造函数，且构造函数包含名字</span></span><br><span class="line">        <span class="comment">// 这个名字会作为返回字符串的一部分</span></span><br><span class="line">        <span class="comment">// 需要注意的是，函数的名字属性是非标准的，并不是在所有的环境中都可用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.constructor &amp;&amp; <span class="keyword">this</span>.constructor.name) &#123;</span><br><span class="line">            s += <span class="keyword">this</span>.constructor.name + <span class="string">': '</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举所有非继承的属性</span></span><br><span class="line">        <span class="keyword">var</span> n = o;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.hasOwnProperty(name))</span><br><span class="line">                <span class="keyword">continue</span>;                           <span class="comment">// 跳过继承的属性</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> value = <span class="keyword">this</span>[name];</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;                           <span class="comment">// 跳过方法</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n++) &#123;</span><br><span class="line">                s += <span class="string">', '</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s += name + <span class="string">'='</span> + value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">']'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过比较this和that的构造函数和实例属性来判断它们是否相等</span></span><br><span class="line">    <span class="comment">// 这种方法只适合于那些实例属性是原始值的情况，原始值可以通过“===”来比较</span></span><br><span class="line">    <span class="comment">// 这里还处理一中特殊情况，就是忽略由Set类添加的特殊属性</span></span><br><span class="line">    equals: <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (that == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.constructor !== that.constructor)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name === <span class="string">'|**objectid**'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;                               <span class="comment">// 跳过特殊属性</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.hasOwnProperty(name))</span><br><span class="line">                <span class="keyword">continue</span>;                               <span class="comment">// 跳过继承来的属性</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[name] !== that[name])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">// 比较是否相等</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                                   <span class="comment">// 如果所有属性都匹配，两个对象相等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-私有状态"><a href="#6-私有状态" class="headerlink" title="6. 私有状态"></a>6. 私有状态</h4><p>在经典的面向对象编程中，经常需要将对象的某个状态封装或隐藏在对象内，只有通过对象的方法才能访问这些状态，对外只暴露一些重要的状态变量可以直接读写。为了实现这个目的，类似Java的编程语言允许声明类的“私有”实例字段，这些私有实例字段只能被类的实例方法访问，且在类的外部是不可见的。</p><p>我们可以通过将变量（或参数）闭包在一个构造函数内来模拟实现私有实例字段，调用构造函数会创建一个实例。为了做到这一点，需要在构造函数内定义一个函数（因此这个函数可以访问构造函数内部的参数和变量），并将这个函数赋值给新创建对象的属性。下文实例展示了对<code>Range</code>类的另一种封装，新版的类的实例包含<code>from()</code>和<code>to()</code>方法用以返回范围的端点，而不是用<code>from</code>和<code>to</code>属性来获取端点。这里的<code>from()</code>和<code>to()</code>方法是定义在每个<code>Range</code>对象上的，而不是从原型中继承来的。其他的<code>Range</code>方法还是和之前一样定义在原型中，但获取端点的方式从之前直接从属性读取变成了通过<code>from()</code>和<code>to()</code>方法来读取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不要将端点保存为对象的属性，相反，定义存取器函数来返回端点的值</span></span><br><span class="line">    <span class="comment">// 这些值都保存在闭包中</span></span><br><span class="line">    <span class="keyword">this</span>.from = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">from</span>; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.to = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> to; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型上的方法无法直接操作端点</span></span><br><span class="line"><span class="comment">// 它们必须调用存取器方法</span></span><br><span class="line">Range.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Range,</span><br><span class="line">    includes: function(x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.from() &lt;= x &amp;&amp; x &lt;= <span class="keyword">this</span>.to();</span><br><span class="line">    &#125;,</span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from()), max = <span class="keyword">this</span>.to(); x &lt;= max; x++) &#123;</span><br><span class="line">            f(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.from() + <span class="string">'...'</span> + <span class="keyword">this</span>.to() + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个新的<code>Range</code>类定义了用以读取范围端点的方法，但没有定义设置端点的方法或属性。这让类的实例看起来是不可修改的，如果使用正确的话，一旦创建<code>Range</code>对象，端点数据就不可修改了。除非使用ES5中的某些特性，但<code>from</code>和<code>to</code>属性依然是可写的，并且<code>Range</code>对象实际上并不是真正不可修改的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Range(<span class="number">1</span>, <span class="number">5</span>);                    <span class="comment">// 一个不可修改的范围</span></span><br><span class="line">r.from = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                               <span class="comment">// 通过方法替换来修改它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但要注意的是，这种封装技术造成了更多的系统开销，使用闭包来封装类的状态的类一定会比不使用封装的状态变量的等价类运行速度更慢，并占用更多内存。</p><h4 id="7-构造函数的重载和工厂方法"><a href="#7-构造函数的重载和工厂方法" class="headerlink" title="7. 构造函数的重载和工厂方法"></a>7. 构造函数的重载和工厂方法</h4><p>有时候，我们希望对象的初始化有多种方式。比如，我们想通过半径和角度（极坐标）来初始化一个<code>Complex</code>对象，而不是通过实部和虚部来初始化，或者通过元素组成的数组来初始化一个<code>Set</code>对象，而不是通过传入构造函数的参数来初始化它。</p><p>有一个方法可以实现，通过重载（<code>overload</code>）这个构造函数来让它根据传入的参数的不同来执行不同的初始化方法。下面就是重载<code>Set</code>构造函数的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.values = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.n = o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">1</span> &amp;&amp; isArrayLike(<span class="built_in">arguments</span>[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">this</span>.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">this</span>.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码所定义的<code>Set</code>构造函数可以显式将一组元素作为参数列表传入，也可以传入元素组成的数组。但是这个构造函数有多义性，如果集合的某个成员是一个数组就无法通过这个构造函数来创建这个集合了（为了做到这一点，需要创建一个空集合，然后显式调用<code>add()</code>方法）。</p><p>在使用极坐标来初始化复数的例子中，实际上并没有看到有函数重载。代表复数两个纬度的数字都是浮点数，除非给构造函数传入第三个参数，否则构造函数无法识别到底传入的是极坐标参数还是直角坐标参数。相反，可以写一个工厂方法——一个类的方法用以返回类的一个实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Complex.polar = <span class="function"><span class="keyword">function</span>(<span class="params">r, theta</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Complex(r * <span class="built_in">Math</span>.cos(theta), r * <span class="built_in">Math</span>.sin(theta));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.fromArray = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    s = <span class="keyword">new</span> <span class="built_in">Set</span>();                      <span class="comment">// 创建一个空集合</span></span><br><span class="line">    s.add.apply(s, a);                  <span class="comment">// 将数组a的成员作为参数传入add()方法</span></span><br><span class="line">    <span class="keyword">return</span> s;                           <span class="comment">// 返回这个新集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以给工厂方法定义任意的名字，不同名字的工厂方法用以执行不同的初始化。但由于构造函数是类的公有标识，因此每个类只能有一个构造函数。但这并不是一个“必须遵守”的规则。在JavaScript中是可以定义多个构造函数继承自一个原型对象的，如果这样做的话，由这些构造函数的任意一个所创建的对象都属于同一类型（并不推荐这种技术）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set类的一个辅助构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SetFromArray</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Set</span>.apply(<span class="keyword">this</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SetFromArray.prototype = <span class="built_in">Set</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> SetFromArray([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">s <span class="keyword">instanceof</span> <span class="built_in">Set</span>;                       <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h3 id="七、子类"><a href="#七、子类" class="headerlink" title="七、子类"></a>七、子类</h3><p>在面向对象编程中，类B可以继承自另外一个类<code>A</code>。我们将<code>A</code>称为父类（<code>superclass</code>），将<code>B</code>称为子类（<code>subclass</code>）。<code>B</code>的实例从<code>A</code>继承了所有的实例方法。类<code>B</code>可以定义自己的实例方法，有些方法可以重载<code>A</code>中的同名方法，如果<code>B</code>的方法重载了<code>A</code>中的方法，<code>B</code>中的重载方法可能会调用<code>A</code>中的重载方法，这种做法称为“方法链”（<code>method chaining</code>）。同样，子类的构造函数<code>B()</code>有时候需要调用父类的构造函数<code>A()</code>，这种做法称为“构造函数链”（<code>constructor chaining</code>）。子类还可以有子类，当涉及类的层次结构时，往往需要定义抽象类（<code>abstract class</code>）。抽象类中定义的方法没有实现。抽象类中的抽象方法是在抽象类的具体子类中实现的。</p><p>在JavaScript中创建子类的关键之处在于，采用合适的方法对原型对象进行初始化。如果类<code>B</code>继承自类<code>A</code>，<code>B.prototype</code>必须是<code>A.prototype</code>的后嗣。<code>B</code>的实例继承自<code>B.prototype</code>，后者也同样继承自<code>A.prototype</code>。本节将对刚才提到的子类相关的术语做一一讲解，还会介绍类继承的替代方案：“组合”（<code>composition</code>）。</p><p>我们从上文的<code>Set</code>类开始讲解，本节将会讨论如何定义子类，如果实现构造函数链并重载方法，如果使用组合来代替继承，以及最后如果通过抽象类从实现中提炼出接口。</p><h4 id="1-定义子类"><a href="#1-定义子类" class="headerlink" title="1. 定义子类"></a>1. 定义子类</h4><p>JavaScript的对象可以从类的原型对象中继承属性（通常继承的是方法）。如果<code>O</code>是类<code>B</code>的实例，<code>B</code>是<code>A</code>的子类，那么<code>O</code>也一定从<code>A</code>中继承了属性。为此，首先要确保<code>B</code>的原型对象继承自<code>A</code>的原型对象。通过<code>inherit()</code>函数，可以这样实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.prototype = inherit(A.prototype);             <span class="comment">// 子类派生自父类</span></span><br><span class="line">B.prototype.constructor = B;                    <span class="comment">// 重载继承来的constructor属性</span></span><br></pre></td></tr></table></figure><p>这两行代码是在JavaScript中创建子类的关键。如果不这样做，原型对象仅仅是一个普通对象，它只继承自<code>Object.prototype</code>，这意味着我们的类和所有的类一样是<code>Object</code>的子类。如果将这两行代码添加至<code>defineClass()</code>函数中，可以将它变成<code>defineSubClass()</code>函数和<code>Function.prototype.extend()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineSubClass</span>(<span class="params">superclass,             <span class="regexp">//</span> 父类的构造函数</span></span></span><br><span class="line"><span class="function"><span class="params">                        constructor,            <span class="regexp">//</span> 新的子类的构造函数</span></span></span><br><span class="line"><span class="function"><span class="params">                        methods,                <span class="regexp">//</span> 实例方法：复制至原型中</span></span></span><br><span class="line"><span class="function"><span class="params">                        statics</span>)                 // 类属性：复制至构造函数中</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 建立子类的原型对象</span></span><br><span class="line">    <span class="keyword">constructor</span>.prototype = inherit(superclass.prototype);</span><br><span class="line">    <span class="keyword">constructor</span>.prototype.<span class="keyword">constructor</span> = <span class="keyword">constructor</span>;</span><br><span class="line"></span><br><span class="line">    //像对常规类一样复制方法和类属性</span><br><span class="line">    if (methods) &#123;</span><br><span class="line">        extend(<span class="keyword">constructor</span>.prototype, methods);</span><br><span class="line">    &#125;</span><br><span class="line">    if (statics) &#123;</span><br><span class="line">        extend(<span class="keyword">constructor</span>, statics);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="keyword">constructor</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 也可以通过父类构造函数的方法来做到这一点</span><br><span class="line">Function.prototype.extend = function(<span class="keyword">constructor</span>, methods, statics) &#123;</span><br><span class="line">    <span class="keyword">return</span> defineSubClass(<span class="keyword">this</span>, <span class="keyword">constructor</span>, methods, statics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下文实例中展示了不使用<code>defineSubClass()</code>函数如何“手动”实现子类。这里定义了<code>Set</code>的子类<code>SingletonSet</code>。<code>SingletonSet</code>是一个特殊的集合，它是只读的，而且含有单独的常量成员。</p><figure class="highlight javascript"><figcaption><span>Singleton 一个简单的子类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SingletonSet</span>(<span class="params">member</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.member = member;                   <span class="comment">// 记住集合中这个唯一的成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个原型对象，这个原型对象继承自Set的原型</span></span><br><span class="line">SingletonSet.prototype = inherit(<span class="built_in">Set</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给原型添加属性</span></span><br><span class="line"><span class="comment">// 如果有同名的属性就覆盖Set.prototype中的同名属性</span></span><br><span class="line">extend(Singleton.prototype, &#123;</span><br><span class="line">    <span class="comment">// 设置合适的constructor属性</span></span><br><span class="line">    <span class="keyword">constructor</span>: SingletonSet,</span><br><span class="line">    // 这个集合是只读的，调用add()和remove()都会报错</span><br><span class="line">    add: function() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'read-only set'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'read-only set'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// SingletonSet的实例中永远只有一个元素</span></span><br><span class="line">    size: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 这个方法只调用一次，传入这个集合的唯一成员</span></span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f, context</span>) </span>&#123;</span><br><span class="line">        f.call(context, <span class="keyword">this</span>.member);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// contains()方法非常简单：只须检查传入的值是否匹配这个集合唯一的成员即可</span></span><br><span class="line">    contains: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x === <span class="keyword">this</span>.member;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的<code>SingletonSet</code>类是一个比较简单的实现，它包含5个简单的方法定义。它实现了5个核心的<code>Set</code>方法，但从它的父类中继承了<code>toString()</code>、<code>toArray()</code>和<code>equals()</code>方法。定义子类就是为了继承这些方法。比如，<code>Set</code>类的<code>equals()</code>方法用来对<code>Set</code>实例进行比较，只要<code>Set</code>的实例包含<code>size()</code>和<code>foreach()</code>方法，就可以通过<code>equals()</code>比较。因为<code>SingletonSet</code>是<code>Set</code>的子类，所以它自动继承了<code>equals()</code>的实现，不用再实现一次。当然，如果想要最简单的实现方式，那么给<code>SingletonSet</code>类定义它自己的<code>equals()</code>版本会更高效一些</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SingletonSet.prototype.equals = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> that <span class="keyword">instanceof</span> <span class="built_in">Set</span> &amp;&amp; that.size() == <span class="number">1</span> &amp;&amp; that.contains(<span class="keyword">this</span>.member);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>SingletonSet</code>不是将<code>Set</code>中的方法列表静态地借用过来，而是动态地从<code>Set</code>类继承方法。如果给<code>Set.prototype</code>添加新的方法，<code>Set</code>和<code>SingletonSet</code>的所有实例就会立即拥有这个方法（假定<code>Singleton</code>没有定义与之同名的方法）。</p><h4 id="2-构造函数和方法链"><a href="#2-构造函数和方法链" class="headerlink" title="2. 构造函数和方法链"></a>2. 构造函数和方法链</h4><p>前文中<code>SingletonSet</code>类定义了全新的集合实现，而且将它继承自其父类的和新方法全部替换。然而定义子类时，我们往往希望对付类的行为进行修改或扩充，而不是完全替换掉它们。为了做到这一点，构造函数和子类的方法需要调用或链接到父类构造函数和父类方法。</p><p>下文示例对此做了展示。它定义了<code>Set</code>的子类<code>NonNullSet</code>，它不允许<code>null</code>和<code>undefined</code>作为它的成员。为了使用这种方式对成员做限制，<code>NonNullSet</code>需要在其<code>add()</code>方法中对<code>null</code>和<code>undefined</code>值做检测。但它需要完全重新实现一个<code>add()</code>方法，因此它调用父类中的这个方法。注意，<code>NonNullSet()</code>构造函数同样不需要重新实现，它只须将它的参数传入父类构造函数（作为函数来调用它，而不是通过构造函数来调用），通过父类的构造函数来初始化新创建的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NonNullSet是Set的子类，它的成员不能是null和undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NonNullSet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 仅链接到父类，作为普通函数调用父类的构造函数来初始化通过该构造函数调用创建的对象</span></span><br><span class="line">    <span class="built_in">Set</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将NonNullSet设置为Set的子类</span></span><br><span class="line">NonNullSet.prototype = inherit(<span class="built_in">Set</span>.prototype);</span><br><span class="line">NonNullSet.prototype.constructor = NonNullSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了将null和undefined排除在外，只须重写add()方法</span></span><br><span class="line">NonNullSet.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数是不是null或undefined</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>[i] == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Can't add null or undefined to a NonNullSet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类的add()方法以执行实际插入操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Set</span>.prototype.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们将这个非<code>null</code>集合的概念推而广之，称为“过滤后的集合”，这个集合中的成员必须首先传入一个过滤函数再执行添加操作。为此，定义一个类工厂函数，传入一个过滤函数，返回一个新的<code>Set</code>子类。实际上，可以对此做进一步的通用化的处理，定义一个可以接收两个参数的类工厂：子类和用于<code>add()</code>方法的过滤函数。这个工厂方法称为<code>filteredsetSubclass()</code>，并通过这样的方法来使用它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个只能保存字符串的“集合”类</span></span><br><span class="line"><span class="keyword">var</span> StringSet = filteredSetSubclass(<span class="built_in">Set</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个集合类的成员不能是null、undefined或函数</span></span><br><span class="line"><span class="keyword">var</span> MySet = filteredSetSubclass(NonNullSet, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x !== <span class="string">'function'</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>下文示例是这个类工厂的实现代码，注意，这个例子中的方法链和构造函数链和<code>NonNullSet</code>中的实现是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数返回具体的Set类的子类，并重写该类的add()方法用以对添加的元素做特殊的处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filteredSetSubclass</span>(<span class="params">superclass, filter</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 子类构造函数</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">constructor</span> = function() &#123;</span><br><span class="line">        <span class="comment">// 调用父类构造函数</span></span><br><span class="line">        superclass.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> proto = <span class="keyword">constructor</span>.prototype = inherit(superclass.prototype);</span><br><span class="line">    proto.<span class="keyword">constructor</span> = <span class="keyword">constructor</span>;</span><br><span class="line">    proto.add = function() &#123;</span><br><span class="line">        <span class="comment">// 在添加任何成员之前首先使用过滤器将所有参数进行过滤</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> v = <span class="built_in">arguments</span>[i];</span><br><span class="line">            <span class="keyword">if</span> (!filter(v))</span><br><span class="line">                <span class="keyword">throw</span> (<span class="string">'value '</span> + v + <span class="string">' rejected by filter'</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用父类的add()方法</span></span><br><span class="line">        superclass.prototype.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">constructor</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，值得强调的是，类似这种创建类工厂的能力是JavaScript语言动态特性的一个体现，类工厂是一种强大和有用的特性，这在Java和C++等语言中是没有的。</p><h4 id="3-组合vs子类"><a href="#3-组合vs子类" class="headerlink" title="3. 组合vs子类"></a>3. 组合vs子类</h4><p>在前文中，定义的集合可以根据特定的标准对集合成员进行限制，而且使用了子类的技术来实现这种功能，所创建的自定义子类使用了特定的过滤函数来对集合中的成员做限制。父类和过滤函数的每个组合都需要创建一个新的类。</p><p>然而还有另一种更好的方法来完成这种需求，即面向对象编程中一条广为人知的设计原则：“组合优于继承”。这样，可以利用组合的原理定义一个新的集合实现，它“包装”了另外一个集合对象，在将受限制的成员过滤掉之后会用到这个（包装的）集合对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现一个FilteredSet，它包装某个指定的“集合”对象，</span></span><br><span class="line"><span class="comment">并对传入add()方法的值应用了某种指定的过滤器</span></span><br><span class="line"><span class="comment">“范围”类中其他所有的和新方法延续到包装后的实例中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> FilteredSet = <span class="built_in">Set</span>.extend(</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">FilteredSet</span>(<span class="params">set, filter</span>) </span>&#123;         </span><br><span class="line">        <span class="keyword">this</span>.set = set;</span><br><span class="line">        <span class="keyword">this</span>.filter = filter;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实例方法</span></span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//　如果已有过滤器，直接使用它</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.filter) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> v = <span class="built_in">arguments</span>[i];</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.filter(v))</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'FilteredSet: value '</span> + v + <span class="string">' rejected by filter.'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用set中的add()方法</span></span><br><span class="line">            <span class="keyword">this</span>.set.add.apply(<span class="keyword">this</span>.set, <span class="built_in">arguments</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 剩下的方法都保持不变</span></span><br><span class="line">        remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.set.remove.apply(<span class="keyword">this</span>.set, <span class="built_in">arguments</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        contains: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.set.contains(v);</span><br><span class="line">        &#125;,</span><br><span class="line">        size: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.set.size();</span><br><span class="line">        &#125;,</span><br><span class="line">        foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f, c</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.set.foreach(f, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在这个例子中使用组合的一个好处是，只须创建一个单独的<code>FilteredSet</code>子类即可。可以利用这个类的实例来创建任意带有成员限制的集合实例。比如，不用上文中定义的<code>NonNullSet</code>类，可以这样做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> FilteredSet(<span class="keyword">new</span> <span class="built_in">Set</span>(), <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x !== <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>甚至还可以对已经过滤后的集合进行过滤</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> FilteredSet(s, &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(x <span class="keyword">instanceof</span> <span class="built_in">Set</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-类的层次结构和抽象类"><a href="#4-类的层次结构和抽象类" class="headerlink" title="4. 类的层次结构和抽象类"></a>4. 类的层次结构和抽象类</h4><p>在上节中给出了“组合优于继承”的原则，但为了将这条原则阐述清除，创建了<code>Set</code>的子类。这样做的原因是最终得到的类是<code>Set</code>的实例，它会从<code>Set</code>继承有用的辅助方法，比如<code>toString()</code>和<code>equals()</code>。尽管这是一个很实际的原因，但不用创建类似<code>Set</code>类这种具体类的子类也可以很好的用组合来实现“范围”。上文中的<code>SingletonSet</code>类可以有另外一种类似的实现，这个类还是继承自<code>Set</code>，因此它可以继承很多辅助方法，但它的实现和其父类的实现完全不一样。<code>SingletonSet</code>并不是<code>Set</code>类的专用版本，而是完全不同的另一种<code>Set</code>。在类层次结构中<code>SingletonSet</code>和<code>Set</code>应当是兄弟关系，而非父子关系。</p><p>不管是在经典的面向对象语言中还是在JavaScript中，通行的解决办法是“从实现中抽离出接口”。假定定义了一个<code>AbstractSet</code>类，其中定义了一些辅助方法比如<code>toString()</code>，但并没有实现诸如<code>foreach()</code>这样的和新方法。这样，实现的<code>Set</code>、<code>SingletonSet</code>和<code>FilteredSet</code>都是这个抽象类的子类，<code>FilteredSet</code>和<code>SingletonSet</code>都不必再实现某个不相关的类的子类了。</p><p>下文示例在这个思路上更进一步，定义了一个层次结构的抽象的集合类。<code>AbstractSet</code>只定义了一个抽象方法：<code>contains()</code>。任何类只要“声称”自己是一个表示范围的类，就必须至少定义这个<code>contains()</code>方法。然后，定义<code>AbstractSet</code>的子类<code>AbstractEnumerableSet</code>。这个类增加了抽象的<code>size()</code>和<code>foreach()</code>方法，而且定义了一些有用的非抽象方法（<code>toString()</code>、<code>toArray()</code>、<code>equals()</code>等），<code>AbstractEnumerableSet</code>并没有定义<code>add()</code>和<code>remove()</code>方法，它只代表只读集合。<code>SingletonSet</code>可以实现为非抽象子类。最后，定义了<code>AbstractEnumerableSet</code>的子类<code>AbstractWritableSet</code>。这个<code>final</code>抽象集合定义了抽象方法<code>add()</code>和<code>remove()</code>，并实现了诸如<code>union()</code>和<code>intersection()</code>等非具体方法，这两个方法调用了<code>add()</code>和<code>remove()</code>。<code>AbstractWritableSet</code>是<code>Set</code>和<code>FilteredSet</code>类相应的父类。但这个例子中并没有实现它，而是实现了一个新的名叫<code>ArraySet</code>的非抽象类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可用作任何抽象方法，非常方便</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abstractmethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'abstract method'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AbstractSet类定义了一个抽象方法 contains()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AbstractSet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Can't instantiate abstract classes"</span>);</span><br><span class="line">&#125;</span><br><span class="line">AbstractSet.prototype.contains = abstractmethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NotSet是AbstractSet的一个非抽象子类</span></span><br><span class="line"><span class="comment">所有不在其他集合中的成员都在这个集合中</span></span><br><span class="line"><span class="comment">因为它是在其他集合是不可写的条件下定义的</span></span><br><span class="line"><span class="comment">同时由于它的成员是无限个，因此它是不可枚举的</span></span><br><span class="line"><span class="comment">我们只能用它来检测元素成员的归属情况</span></span><br><span class="line"><span class="comment">注意，我们使用了Function.prototype.extend()方法来快捷定义这个子类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> NotSet = Abstract.extend(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">NotSet</span>(<span class="params">set</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set = set;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        contains: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="keyword">this</span>.set.contains(x);</span><br><span class="line">        &#125;,</span><br><span class="line">        toString: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'~'</span> + <span class="keyword">this</span>.set.toString();</span><br><span class="line">        &#125;,</span><br><span class="line">        equals: <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that <span class="keyword">instanceof</span> NotSet &amp;&amp; <span class="keyword">this</span>.set.equals(that.set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AbstractEnumerableSet是AbstractSet的一个抽象子类</span></span><br><span class="line"><span class="comment">它定义了抽象方法size()和foreach()</span></span><br><span class="line"><span class="comment">然后实现了非抽象方法isEmpty()、toArray()、to[Locale]String()和equals()方法</span></span><br><span class="line"><span class="comment">子类实现了contains()、size()和foreach()，这三个方法可以很轻易地调用这5个非抽象方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> AbstractEnumerableSet = AbstractSet.extend(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Can't instantiate abstract classes"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        size: abstractmethod,</span><br><span class="line">        foreach: abstractmethod,</span><br><span class="line">        isEmpty: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.size() == <span class="number">0</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> s = <span class="string">"&#123;"</span>, i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (i++ &gt; <span class="number">0</span>)</span><br><span class="line">                    s += <span class="string">', '</span>;</span><br><span class="line">                s += v;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> s + <span class="string">"&#125;"</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        toLocaleString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> s = <span class="string">"&#123;"</span>, i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (i++ &gt; <span class="number">0</span>)</span><br><span class="line">                    s += <span class="string">', '</span>;</span><br><span class="line">                <span class="keyword">if</span> (v == <span class="literal">null</span>)</span><br><span class="line">                    s += v;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    s += v.toLocaleString();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> s + <span class="string">"&#125;"</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        toArray: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> a = [];</span><br><span class="line">            <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                a.push(v);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;,</span><br><span class="line">        equals: <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(that <span class="keyword">instanceof</span> AbstractEnumerableSet))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 如果它们的大小不同，则它们不相等</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.size() != that.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 检查每一个元素是否也在that中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!that.contains(v))</span><br><span class="line">                        <span class="keyword">throw</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 所有的元素都匹配：集合相等</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(x) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x === <span class="literal">false</span>)</span><br><span class="line">                    <span class="comment">// 集合不相等</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 发生了其他的异常：重新抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SingletonSet是AbstractEnumerableSet的非抽象子类</span></span><br><span class="line"><span class="comment">singleton集合是只读的，它只包含一个成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> SingletonSet = AbstractEnumerableSet.extend(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SingletonSet</span>(<span class="params">member</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.member = member;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        contains: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x === <span class="keyword">this</span>.member;</span><br><span class="line">        &#125;,</span><br><span class="line">        size: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f, ctx</span>) </span>&#123;</span><br><span class="line">            f.call(ctx, <span class="keyword">this</span>.member);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AbstractWritableSet是AbstractEnumerableSet的抽象子类</span></span><br><span class="line"><span class="comment">它定义了抽象方法add()和remove()</span></span><br><span class="line"><span class="comment">然后实现了非抽象方法union()、intersection()和difference()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> AbstractWritableSet = AbstractEnumerableSet.extend(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Can't instantiate abstract classes"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        add: abstractmethod,</span><br><span class="line">        remove: abstractmethod,</span><br><span class="line">        union: <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">            that.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                self.add(v);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        intersection: <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!that.contains(v))</span><br><span class="line">                    self.remove(v);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        difference: <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">            that.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                self.remove(v);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ArraySet是AbstractWritableSet的非抽象子类</span></span><br><span class="line"><span class="comment">它以数组的形式表示集合中的元素</span></span><br><span class="line"><span class="comment">对于它的contains()方法使用了数组的线性查找</span></span><br><span class="line"><span class="comment">因为contains()方法的算法复杂度是o(n)而不是o(1)</span></span><br><span class="line"><span class="comment">它非常适用于相对小型的集合，注意，这里的实现用到了ES5的数组方法indexOf()和forEach()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> ArraySet = AbstractWritableSet.extend(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ArraySet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.values = [];</span><br><span class="line">        <span class="keyword">this</span>.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        contains: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.values.indexOf(v) != <span class="number">-1</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        size: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.values.length;</span><br><span class="line">        &#125;,</span><br><span class="line">        foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f, c</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.values.forEach(f, c);</span><br><span class="line">        &#125;,</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> arg = <span class="built_in">arguments</span>[i];</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.contains(arg)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.values.push(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> p = <span class="keyword">this</span>.values.indexOf(<span class="built_in">arguments</span>[i]);</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">this</span>.values.splice(p, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="八、ES5中的类"><a href="#八、ES5中的类" class="headerlink" title="八、ES5中的类"></a>八、ES5中的类</h3><p>ES5给属性特性增加了方法支持（<code>getter</code>、<code>setter</code>、<code>可枚举性</code>、<code>可写性</code>和<code>可配置性</code>），而且增加了对象可扩展性的限制，这些方法同时非常适合用于类的定义。</p><h4 id="1-让属性不可枚举"><a href="#1-让属性不可枚举" class="headerlink" title="1. 让属性不可枚举"></a>1. 让属性不可枚举</h4><p>上文中的<code>Set</code>类使用了一个小技巧，将对象存储为“集合”的成员：它给添加至这个“集合”的任何对象定义了“对象id”属性。之后如果在<code>for/in</code>循环中对这个对象做遍历，这个新添加的属性也会遍历到。ES5中可以通过设置属性为“不可枚举”（<code>nonenumerable</code>）来让属性不会遍历到。下文示例展示了如果通过<code>Object.defineProperty()</code>来做到这一点，同时也展示了如何定义一个<code>getter</code>函数以检测对象是否是可扩展的（<code>extensible</code>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将代码包装在一个匿名函数中，这样定义的变量就在这个函数作用域内</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个不可枚举的属性objectId，它可以被所有对象继承</span></span><br><span class="line">    <span class="comment">// 当读取这个属性时调用getter函数</span></span><br><span class="line">    <span class="comment">// 它没有定义setter，因此它是只读的</span></span><br><span class="line">    <span class="comment">// 它是不可配置的，因此它是不能删除的</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'objectId'</span>, &#123;</span><br><span class="line">        get: idGetter,                              <span class="comment">// 取值器</span></span><br><span class="line">        enumerable: <span class="literal">false</span>,                          <span class="comment">// 不可枚举的</span></span><br><span class="line">        configurable: <span class="literal">false</span>                         <span class="comment">// 不可配置的</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当读取objectId的时候直接调用这个getter函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">idGetter</span>(<span class="params"></span>) </span>&#123;                           <span class="comment">// getter函数返回该id</span></span><br><span class="line">        <span class="keyword">if</span> (!(idprop <span class="keyword">in</span> <span class="keyword">this</span>)) &#123;                    <span class="comment">// 如果对象中不存在id</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Object</span>.isExtensible(<span class="keyword">this</span>))         <span class="comment">// 并且可以增加属性</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"Can't define id for nonextensible objects"</span>);</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, idprop, &#123;</span><br><span class="line">                value: nextid++,                    <span class="comment">// 给属性赋值</span></span><br><span class="line">                writable: <span class="literal">false</span>,                    <span class="comment">// 只读</span></span><br><span class="line">                enumerable: <span class="literal">false</span>,                  <span class="comment">// 不可枚举</span></span><br><span class="line">                configurable: <span class="literal">false</span>                 <span class="comment">// 不可配置</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[idprop];                        <span class="comment">// 返回已有的或新的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// idGetter()用到了这些变量，这些都属于私有变量</span></span><br><span class="line">    <span class="keyword">var</span> idprop = <span class="string">"|**objectId**|"</span>;                  <span class="comment">// 假设这个属性没有用到</span></span><br><span class="line">    <span class="keyword">var</span> nextid = <span class="number">1</span>;                                 <span class="comment">// 设置初始值</span></span><br><span class="line">&#125;)();                                               <span class="comment">// 立即执行包装函数</span></span><br></pre></td></tr></table></figure><h4 id="2-定义不可变的类"><a href="#2-定义不可变的类" class="headerlink" title="2. 定义不可变的类"></a>2. 定义不可变的类</h4><p>除了可以设置属性为不可枚举的，ES5还可以设置属性为只读的，当我们希望类的实例都是不可变的，这个特性非常有帮助。下文示例使用<code>Object.defineProperties()</code>和<code>Object.create()</code>定义不可变的<code>Range</code>类。它同样适用<code>Object.defineProperties()</code>来为类创建原型对象，并将（原型对象的）实例方法设置为不可枚举的，就像内置类的方法一样。不仅如此，它还将这些实例方法设置为“只读”和“不可删除”的，这样就可以防止对类中做任何修改。最后还展示了一个有趣的技巧，其中实现的构造函数也可以用作工厂函数，这样不论调用函数之前是否带有<code>new</code>关键字，都可以正确的创建实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法可以使用new调用，也可以省略new，它可以用作构造函数也可以用作工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这些是对from和to只读属性的描述符</span></span><br><span class="line">    <span class="keyword">var</span> props = &#123;</span><br><span class="line">        <span class="keyword">from</span>: &#123;</span><br><span class="line">            value: <span class="keyword">from</span>,</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            writable: <span class="literal">false</span>,</span><br><span class="line">            configurable: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        to: &#123;</span><br><span class="line">            value: to,</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            writable: <span class="literal">false</span>,</span><br><span class="line">            configurable: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Range) &#123;                            <span class="comment">// 如果作为构造函数使用</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperties(<span class="keyword">this</span>, props);               <span class="comment">// 定义属性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                <span class="comment">// 如果作为工厂方法来调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(Range.prototype, props);       <span class="comment">// 返回新Range对象，并由props指定属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用同样的方法给Range.prototype对象添加属性</span></span><br><span class="line"><span class="comment">// 那么我们需要给这些属性设置它们的特性</span></span><br><span class="line"><span class="comment">// 因为我们无法识别出它们的可枚举性、可写性或可配置性，这些属性特性默认都是false</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(Range.prototype, &#123;</span><br><span class="line">    includes: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; ... &#125; </span><br><span class="line">    &#125;,</span><br><span class="line">    foreach: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; ... &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代码示例中用到了<code>Object.defineProperties()</code>和<code>Object.create()</code>来定义不可变的和不可枚举的属性。这两个方法非常强大，但属性描述符对象让代码的可读性变得更差。另一种改进的做法是将修改这个已定义属性的特性的操作定义为一个工具函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将o的指定名字（或所有）的属性设置为不可写的和不可配置的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">freezeProps</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> props = (<span class="built_in">arguments</span>.length == <span class="number">1</span>)                 <span class="comment">// 如果只有一个参数</span></span><br><span class="line">        ? <span class="built_in">Object</span>.getOwnPropertyNames(o)                 <span class="comment">// 使用所有的属性</span></span><br><span class="line">        : <span class="built_in">Array</span>.prototype.splice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);    <span class="comment">// 否则传入了指定名字的属性</span></span><br><span class="line">    props.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;                         <span class="comment">// 将它们都设置为只读的和不可变的</span></span><br><span class="line">        <span class="comment">// 忽略不可配置的属性</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Object</span>.getOwnPropertyDescriptor(o, n).configurable)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(o, n, &#123;</span><br><span class="line">            writable: <span class="literal">false</span>,</span><br><span class="line">            configurable: <span class="literal">false</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> o;                                           <span class="comment">// 我们可以继续使用o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将o的指定名字（或所有）的属性设置为不可枚举的和可配置的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hideProps</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> props = (<span class="built_in">arguments</span>.length == <span class="number">1</span>)                 <span class="comment">// 如果只有一个参数</span></span><br><span class="line">        ? <span class="built_in">Object</span>.getOwnPropertyNames(o)                 <span class="comment">// 使用所有的属性</span></span><br><span class="line">        : <span class="built_in">Array</span>.prototype.splice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);    <span class="comment">// 否则传入了指定名字的属性</span></span><br><span class="line">    props.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)) </span>&#123;                        <span class="comment">// 将它们设置为不可枚举的</span></span><br><span class="line">        <span class="comment">// 忽略不可配置的属性</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Object</span>.getOwnPropertyDescriptor(o, n).configurable) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(o, n, &#123; <span class="attr">enumerable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>可以用来创建新属性，也可以修改已有属性的特性。当用它们创建新属性时，默认的属性特性的值都是<code>false</code>。但当用它们修改已经存在的属性时，默认的属性特性依然保持不变。</p><p>使用这些工具函数，就可以充分利用ES5的特性来实现一个不可变的类，而且不用动态地修改这个类。下文示例的<code>Range</code>类就用到刚才定义的工具函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;                              <span class="comment">// 不可变的类Range的构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.from = <span class="keyword">from</span>;</span><br><span class="line">    <span class="keyword">this</span>.to = to;</span><br><span class="line">    freezeProps(<span class="keyword">this</span>);                                  <span class="comment">// 将属性设置为不可变的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Range.prototype = hideProps(&#123;                           <span class="comment">// 使用不可枚举的属性来定义原型</span></span><br><span class="line">    <span class="keyword">constructor</span>: Range,</span><br><span class="line">    includes: function(x) &#123; ... &#125;,</span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; ... &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-封装对象状态"><a href="#3-封装对象状态" class="headerlink" title="3. 封装对象状态"></a>3. 封装对象状态</h4><p>构造函数中的变量和参数可以用作它创建的对象的私有状态，该方法在ES3中的一个缺点是，访问这些私有状态的存取器方法是可以替换的，在ES5中可以通过定义属性<code>getter</code>和<code>setter</code>方法将状态变量更健壮地封装起来，这两个方法是无法删除的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个版本的Range类是可变的，但将端点变量进行了良好的封装</span></span><br><span class="line"><span class="comment">// 但端点的大小顺序还是固定的：from &lt;= to</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果from &gt; to</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">from</span> &gt; to)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Range: from must be &lt;= to"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义存取器方法以维持不变</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getFrom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">from</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setFrom</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f &lt;= to)</span><br><span class="line">            <span class="keyword">from</span> = f;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Range: from must be &lt;= to"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setTo</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= <span class="keyword">from</span>) </span><br><span class="line">            to = t;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Range: from must be &lt;= to"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将使用取值器的属性设置为可枚举的、不可配置的</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(<span class="keyword">this</span>, &#123;</span><br><span class="line">        <span class="keyword">from</span>: &#123;</span><br><span class="line">            get: getFrom,</span><br><span class="line">            set: setFrom,</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        to: &#123;</span><br><span class="line">            get: getTo,</span><br><span class="line">            set: setTo,</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和前面的例子比，原型对象没有做任何修改</span></span><br><span class="line"><span class="comment">// 实例方法可以像读取普通的属性一样读取from和to</span></span><br><span class="line">Range.prototype = hideProps(&#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Range,</span><br><span class="line">    includes: function(x) &#123; ... &#125;,</span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; ... &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-防止类的扩展"><a href="#4-防止类的扩展" class="headerlink" title="4. 防止类的扩展"></a>4. 防止类的扩展</h4><p>通常认为，通过给原型对象添加方法可以动态地对类进行扩展，这是JavaScript本身的特性。ES5可以根据需要对此特性加以限制。<code>Object.preventExtension()</code>方法可以将对象设置为不可扩展的，也就是说不能给对象添加任何新属性。<code>Object.seal()</code>则更加强大，它除了能阻止用户给对象添加新属性，还能将当前已有的属性设置为不可配置的，这样就不能删除属性了（但不可配置的属性可以是可写的，也可以转换为只读属性）。可以通过这样一句简单的代码来阻止对<code>Object.prototype</code>的扩展</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.seal(<span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure><p>JavaScript的另外一个动态特性是“对象的方法可以随时替换”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> original_sort_method = <span class="built_in">Array</span>.prototype.sort;</span><br><span class="line"><span class="built_in">Array</span>.prototype.sort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    original_sort_method.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Array sort took "</span> + (end - start) + <span class="string">" milliseconds"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以通过将实例方法设置为只读来防止这类修改，一种方法是使用上面代码所定义的<code>freezeProps()</code>工具函数，另外一种方法是使用<code>Object.freeze()</code>，它的功能和<code>Object.seal()</code>完全一样，它同样会把所有属性都设置为只读的和不可配置的。</p><p>理解类的只读属性的特性至关重要。如果对象<code>o</code>继承了只读属性<code>p</code>，那么给<code>o.p</code>的赋值操作将会失败，就不会给<code>o</code>创建新属性。如果你想重写一个继承来的只读属性，就必须使用<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>或<code>Object.create()</code>来创建这个新属性。也就是说，如果将类的实例方法设置为只读的，那么重写它的子类的方法的难度会更大。</p><p>这种锁定原型对象的做法往往没有必要，但的确有一些场景是需要阻止对象的扩展的。回想一下前文的<code>enumeration()</code>，这是一个类工厂函数。这个函数将枚举类型的每个实例都保存在构造函数对象的属性里，以及构造函数的<code>values</code>数组中。这些属性和数组是表示枚举类型实例的正式实例列表，是可以执行“冻结”（<code>freezing</code>）操作的，这样就不能给它添加新的实例，已有的实例也无法删除或修改。可以给<code>enumeration()</code>函数添加几行简单的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.freeze(enumeration.values);</span><br><span class="line"><span class="built_in">Object</span>.freeze(enumeration);</span><br></pre></td></tr></table></figure><p>需要注意的是，通过在枚举类型中调用<code>Object.freeze()</code>，示例中定义的<code>objectId</code>属性之后也无法使用了。这个问题的解决办法是，在枚举类型被“冻结”之前读取一次它的<code>objectId</code>属性（调用潜在的存取器方法并设置其内部属性）。</p><h4 id="5-子类和ES5"><a href="#5-子类和ES5" class="headerlink" title="5. 子类和ES5"></a>5. 子类和ES5</h4><p>下文示例中使用ES5的特性来实现子类，这里使用上文中<code>AbstractWritableSet</code>类来做进一步说明，来定义这个类的子类<code>StringSet</code>。下面这个例子的最大特点是使用<code>Object.create()</code>创建原型对象，这个原型对象继承自父类的原型，同时给新创建的对象定义属性。这种实现方法的困难之处在于，正如上文说提到的，它需要使用难看的属性描述符。</p><p>这个例子中另外一个有趣之处在于，使用<code>Object.create()</code>创建对象时传入了参数<code>null</code>，这个创建的对象没有继承任何成员。这个对象用来存储集合的成员，同时，这个对象没有原型，这样我们就能对它直接使用<code>in</code>操作符，而不须使用<code>hasOwnProperty()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringSet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.set = <span class="built_in">Object</span>.create(<span class="literal">null</span>);                     <span class="comment">// 创建一个不包含原型的对象</span></span><br><span class="line">    <span class="keyword">this</span>.n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，使用Object.create()可以继承父类的原型</span></span><br><span class="line"><span class="comment">// 而且可以定义单独调用的方法，因为我们没有指定属性的可写性、可枚举性和可配置性</span></span><br><span class="line"><span class="comment">// 因此这些属性特性的默认值都是false</span></span><br><span class="line"><span class="comment">// 只读方法让这个类难于子类化（被继承）</span></span><br><span class="line">StringSet.prototype = <span class="built_in">Object</span>.create(AbstractWritableSet.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: StringSet</span><br><span class="line">    &#125;,</span><br><span class="line">    contains: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> x <span class="keyword">in</span> <span class="keyword">this</span>.set;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    size: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    foreach: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">f, c</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.set).forEach(f, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    add: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(<span class="built_in">arguments</span>[i] <span class="keyword">in</span> <span class="keyword">this</span>.set)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.set[<span class="built_in">arguments</span>[i]] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">this</span>.n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    remove: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">arguments</span>[i] <span class="keyword">in</span> <span class="keyword">this</span>.set) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> <span class="keyword">this</span>.set[<span class="built_in">arguments</span>[i]];</span><br><span class="line">                    <span class="keyword">this</span>.n--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="6-属性描述符"><a href="#6-属性描述符" class="headerlink" title="6. 属性描述符"></a>6. 属性描述符</h4><p>本节给出一个例子，用来讲述基于ES5如何对属性描述进行各种操作，下文示例中给<code>Object.prototype</code>添加了<code>properties()</code>方法（这个方法是不可枚举的）。这个方法的返回值是一个对象，用以表示属性的列表，并定义了有用的方法用来输出属性和属性特性（对于调试非常有用），用来获得属性描述符（当复制属性同时复制属性特性时非常有用）以及用来设置属性的特性（是上文定义的<code>hideProps()</code>和<code>freezeProps()</code>函数不错的替代方案）。这个例子展示了ES5的大多数属性相关的特性，同时使用了一种模块编程技术。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给Object.prototype定义properties()方法，</span></span><br><span class="line"><span class="comment">这个方法返回一个表示调用它的对象上的属性名列表的对象</span></span><br><span class="line"><span class="comment">（如果不带参数调用它，就表示该对象的所有属性）</span></span><br><span class="line"><span class="comment">返回的对象定义了4个有用的方法：toString()、descriptors()、hide()和show()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">namespace</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这个函数成为所有对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">properties</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> names;                                      <span class="comment">// 属性名组成的数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">0</span>)                      <span class="comment">// 所有的自有属性</span></span><br><span class="line">            names = <span class="built_in">Object</span>.getOwnPropertyNames(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">1</span> &amp;&amp; <span class="built_in">Array</span>.isArray(<span class="built_in">arguments</span>[<span class="number">0</span>]))</span><br><span class="line">            names = <span class="built_in">arguments</span>[<span class="number">0</span>];                       <span class="comment">// 名字组成的数组</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            names = <span class="built_in">Array</span>.prototype.splice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个新的Properties对象，用以表示属性名字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Properties(<span class="keyword">this</span>, names);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将它设置为Object.prototype的新的不可枚举的属性</span></span><br><span class="line">    <span class="comment">// 这是从私有函数作用域导出的唯一一个值</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'properties'</span>, &#123;</span><br><span class="line">        value: properties,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个构造函数是由上面的properties()函数所调用的</span></span><br><span class="line">    <span class="comment">// Properties类表示一个对象的属性集合</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Properties</span>(<span class="params">o, names</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.o = o;                                     <span class="comment">// 属性所属的对象</span></span><br><span class="line">        <span class="keyword">this</span>.names = names;                             <span class="comment">// 属性的名字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将代表这些属性的对象设置为不可枚举的</span></span><br><span class="line">    Properties.prototype.hide = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> o = <span class="keyword">this</span>.o, </span><br><span class="line">        hidden = &#123;</span><br><span class="line">            enumerable: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.names.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o.hasOwnProperty(n)) &#123;</span><br><span class="line">                <span class="built_in">Object</span>.defineProperty(o, n, hidden);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将这些属性设置为只读的和不可配置的</span></span><br><span class="line">    Properties.prototype.freeze = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> o = <span class="keyword">this</span>,</span><br><span class="line">        frozen = &#123;</span><br><span class="line">            writable: <span class="literal">false</span>,</span><br><span class="line">            configurable: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.names.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o.hasOwnProperty(n)) &#123;</span><br><span class="line">                <span class="built_in">Object</span>.defineProperty(o, n, frozen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个对象，这个对象是名字到属性描述符的映射表</span></span><br><span class="line">    <span class="comment">// 使用它来复制属性，连同属性特性一起复制</span></span><br><span class="line">    <span class="comment">// Object.defineProperties(dest, src.properties().descriptors());</span></span><br><span class="line">    Properties.prototype.descriptors = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> o = <span class="keyword">this</span>.o,</span><br><span class="line">        desc = &#123;&#125;;</span><br><span class="line">        <span class="keyword">this</span>.names.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!o.hasOwnProperty(n))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            desc[n] = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, n);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个格式化良好的属性列表</span></span><br><span class="line">    <span class="comment">// 列表中包含名字、值和属性特性，使用“permanent”表示不可配置</span></span><br><span class="line">    <span class="comment">// 使用“readonly”表示不可写，使用“hidden”表示不可枚举</span></span><br><span class="line">    <span class="comment">// 普通的可枚举、可写和可配置属性不包含特性列表</span></span><br><span class="line">    Properties.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> o = <span class="keyword">this</span>.o;</span><br><span class="line">        <span class="keyword">var</span> lines = <span class="keyword">this</span>.names.map(nameToString);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;\n "</span> + lines.join(<span class="string">",\n "</span>) + <span class="string">"\n&#125;"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">nameToString</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> s = <span class="string">""</span>,</span><br><span class="line">            desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, n);</span><br><span class="line">            <span class="keyword">if</span> (!desc) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"nonexistent "</span> + n + <span class="string">": undefined"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!desc.configurable) &#123;</span><br><span class="line">                s += <span class="string">"permanent "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((!desc.get &amp;&amp; !desc.set) || !desc.writable) &#123;</span><br><span class="line">                s += <span class="string">"readonly "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!desc.enumerable) &#123;</span><br><span class="line">                s += <span class="string">"hidden "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (desc.get || desc.set) &#123;</span><br><span class="line">                s += <span class="string">"accessor "</span> + n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s += n + <span class="string">": "</span> + ((<span class="keyword">typeof</span> desc.value == <span class="string">'function'</span>) ? <span class="string">'function'</span> : desc.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，将原型对象中的实例方法设置为不可枚举的</span></span><br><span class="line">    <span class="comment">// 这里用到了刚定义的方法</span></span><br><span class="line">    Properties.prototype.properties().hide();</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><hr><h3 id="九、模块"><a href="#九、模块" class="headerlink" title="九、模块"></a>九、模块</h3><p>将代码组织到类中的一个重要原因是，让代码更加“模块化”，可以在很多不同场景中实现代码的重用。但类不是唯一的模块化代码的方式。一般来讲，模块是一个独立的JavaScript文件。模块文件可以包含一个类定义、一组相关的类、一个实用函数库或者是一些待执行的代码。只要以模块的形式编写代码，任何JavaScript代码段就可以当作是一个模块。</p><p>很多JavaScript库和客户端编程框架都包含一些模块系统，CommonJS服务器端JavaScript标准规范创建了一个模块规范，后者同样使用<code>require()</code>函数，这种模块系统通常用来处理模块加载和依赖性管理。</p><p>模块化的目标是支持大规模的程序开发，处理分散源中代码的组装，并且能让代码正确运行，哪怕包含了作者所不期望出现的模块代码，也可以正确执行代码。为了做到这一点，不同的模块必须避免修改全局执行上下文，因此后续模块应当在它们所期望运行的原始（或接近原始）上下文中执行。这实际上意味着模块应当尽可能少地定义全局标识，理想状况是，所有模块都不应当定义超过一个（全局标识）。接下来我们给出的一中简单的方法可以做到这一点，</p><h4 id="1-用作命名空间的对象"><a href="#1-用作命名空间的对象" class="headerlink" title="1. 用作命名空间的对象"></a>1. 用作命名空间的对象</h4><p>在模块创建过程中避免污染全局变量的一种方法是使用一个对象作为命名空间。它将函数和值作为命名空间并将属性存储起来（可以通过全局变量引用），而不是定义全局函数和变量。例如我们前文定义的<code>Set</code>类，它定义了一个全局构造函数<code>Set()</code>。然后给这个类定义了很多实例方法，但将这些实例方法存储为<code>Set.prototype</code>的属性，因此这些方法不是全局的。示例代码里也包含一个<code>_v2s()</code>工具函数，但也没有定义它为全局函数，而是把它存储为<code>Set</code>的属性。</p><p>模块的作者并不知道他的模块会和哪些其他模块一起工作，因此尤为注意这种命名空间的用法带来的命名冲突。然而，使用这个模块的开发者是知道它用了哪些模块、用到了哪些名字的。程序员并不一定要严格遵守命名空间的写法，只需要将常用的值“导入”到全局命名空间中。我们如果要经常使用<code>sets</code>命名空间中的<code>Set</code>类，可以这样导入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Set</span> = sets.Set;                             <span class="comment">// 将Set导入到全局命名空间中</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);                       <span class="comment">// 这样每次使用就不必加set前缀了</span></span><br></pre></td></tr></table></figure><p>有时模块作者会使用更深层嵌套的命名空间。如果<code>sets</code>模块是另外一组更大的模块集合的话，它的命名空间可能会是<code>collections.sets</code>，模块代码的开始会这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collections;                                <span class="comment">// 声明（或重新声明）这个全局变量</span></span><br><span class="line"><span class="keyword">if</span> (!collections)</span><br><span class="line">    collections = &#123;&#125;;                           <span class="comment">// 如果它原本不存在，创建一个顶层的命名空间对象</span></span><br><span class="line">collections.sets = &#123;&#125;;                          <span class="comment">// 将sets命名空间创建在它的内部</span></span><br><span class="line">collections.sets.AbstractSet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;     <span class="comment">// 在collections.sets内定义set类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最顶层的命名空间往往用来标识创建模块的作者或组织，并避免命名空间的明明冲突。使用很长的命名空间来导入模块的方式非常重要，然而程序员往往将整个模块导入全局命名空间，而不是导入单独的类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sets = collections.sets;</span><br></pre></td></tr></table></figure><h4 id="2-作为私有命名空间的函数"><a href="#2-作为私有命名空间的函数" class="headerlink" title="2. 作为私有命名空间的函数"></a>2. 作为私有命名空间的函数</h4><p>模块对外导出一些公用API，这些API是提供给其他程序员使用的，它包括函数、类、属性和方法。但模块的实现往往需要一些额外的辅助函数和方法，这些函数和方法并不需要在模块外部可见。比如，<code>Set</code>类中的<code>_v2s()</code>函数，模块作者不希望<code>Set</code>类的用户在某时刻调用这个函数，因此这个方法最好在类的外部是不可访问的。</p><p>可以通过将模块定义在某个函数的内部来实现。在一个函数中定义的变量和函数都属于函数的局部成员，在函数的外部是不可见的。实际上，可以将这个函数作用域用作模块的私有命名空间（有时称为“模块函数”）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明全局变量Set，使用一个函数的返回值给它赋值</span></span><br><span class="line"><span class="comment">// 函数结束时紧跟的一堆圆括号表示函数定义后立即执行</span></span><br><span class="line"><span class="comment">// 它的返回值将赋值给Set，而不是将这个函数赋值给Set</span></span><br><span class="line"><span class="comment">// 注意它是一个函数表达式，不是一条语句，因此函数“invocation”并没有创建全局变量</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">Set</span> = (<span class="function"><span class="keyword">function</span> <span class="title">invocation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;                                    <span class="comment">// 这个构造函数是局部变量</span></span><br><span class="line">        <span class="keyword">this</span>.values = &#123;&#125;;                               <span class="comment">// 这个对象的属性用来保存这个集合</span></span><br><span class="line">        <span class="keyword">this</span>.n = <span class="number">0</span>;                                     <span class="comment">// 集合中值的个数</span></span><br><span class="line">        <span class="keyword">this</span>.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);                <span class="comment">// 将所有的参数都添加至集合中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给Set.prototype定义实例方法</span></span><br><span class="line">    <span class="built_in">Set</span>.prototype.contains = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 注意我们调用了v2s()，而不是调用带有笨重的前缀的set._v2s()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.values.hasOwnProperty(v2s(value));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Set</span>.prototype.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.n;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Set</span>.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Set</span>.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Set</span>.prototype.foreach = <span class="function"><span class="keyword">function</span>(<span class="params">f, ctx</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是上面的方法用到的一些辅助函数和变量</span></span><br><span class="line">    <span class="comment">// 它们不属于模块的共有API，但它们都隐藏在这个函数作用域内</span></span><br><span class="line">    <span class="comment">// 因此我们不比将它们定义为Set的属性或使用下划线作为其前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">v2s</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">objectId</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> nextId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个模块的共有API是Set()构造函数</span></span><br><span class="line">    <span class="comment">// 我们需要把这个函数从私有命名空间中导出来</span></span><br><span class="line">    <span class="comment">// 以便在外部也可以使用它，在这种情况下，我们通过返回这个构造函数来导出它</span></span><br><span class="line">    <span class="comment">// 它变成第一行代码所指的表达式的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Set</span>;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>注意，这里使用了立即执行的匿名函数，这在JavaScript中是一种惯用法。如果想让代码在一个私有命名空间中运行，只需要给代码加上“<code>(function() { ... })</code>”。开始的做圆括号确保这是一个函数表达式，而不是函数定义语句，因此可以给该前缀添加一个函数名来让代码变得更加清晰。</p><p>一旦将模块代码封装进一个函数，就需要一些方法导出其公用API，以便在模块函数的外部调用它们。在上文实例中，模块函数返回构造函数，这个构造函数随后赋值给一个全局变量。将值返回已经清楚地表名API已经导出在函数作用域之外。如果模块API包含多个单元，则它可以返回命名空间对象。对于<code>sets</code>模块来说，可以将代码写成这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collections;</span><br><span class="line"><span class="keyword">if</span> (!collections) collections = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义sets模块</span></span><br><span class="line">collections.sets = (<span class="function"><span class="keyword">function</span> <span class="title">namespace</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里定义多种“集合类”，使用局部变量和函数</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过返回命名空间对象将API导出</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 导出的属性名：局部变量的名字</span></span><br><span class="line">        AbstractSet: AbstractSet,</span><br><span class="line">        NotSet: NotSet,</span><br><span class="line">        AbstractEnumerableSet: AbstractEnumerableSet,</span><br><span class="line">        SingletonSet: SingletonSet,</span><br><span class="line">        AbstractWritableSet: AbstractWritableSet,</span><br><span class="line">        ArraySet: ArraySet</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>另外一种类似的技术是将模块函数当作构造函数，通过<code>new</code>调用，通过将它们赋值给<code>this</code>来将其导出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collections;</span><br><span class="line"><span class="keyword">if</span> (!collections) collections = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">collections.sets = (<span class="keyword">new</span> <span class="function"><span class="keyword">function</span> <span class="title">namespace</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...省略代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将API导出至对象</span></span><br><span class="line">    <span class="keyword">this</span>.AbstractSet = Abstract;</span><br><span class="line">    <span class="keyword">this</span>.NotSet = NotSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，这里没有返回值</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>作为一种替代方案，如果已经定义了全局命名空间对象，这个模块函数可以直接设置那个对象的属性，不用返回任何内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collections;</span><br><span class="line"><span class="keyword">if</span> (!collections) collections = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">collections.sets = &#123;&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">namespace</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...省略代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将公用API导出到上面创建的命名空间对象上</span></span><br><span class="line">    collections.sets.AbstractSet = AbstractSet;</span><br><span class="line">    collections.sets.NotSet = NotSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出的操作已经执行了，这里不需要再写return语句了</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个JavaScript对象都是一个属性集合，相互之间没有任何联系。在JavaScript中也可以定义对象的类，让每个对象都共享某些属性，这种“共享”的特性是非常有用的。类的成员或实例都包含一些属性，用以存放或定义它们的状态，其中有些属性定义了它们的行为（通常称为方法）。这些行为通常是由类定义的，而且为所有实例所共享。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript类和模块" scheme="http://www.xiaoleon.cn/tags/JavaScript%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>JS(4) 函数</title>
    <link href="http://www.xiaoleon.cn/2018/01/28/js-4/"/>
    <id>http://www.xiaoleon.cn/2018/01/28/js-4/</id>
    <published>2018-01-28T02:26:20.000Z</published>
    <updated>2018-02-02T12:48:05.179Z</updated>
    
    <content type="html"><![CDATA[<p>函数是这样的一段JavaScript代码，它只定义一次，但可能被执行或调用任意次。JavaScript函数是参数化的：函数的定义会包括一个称为形参（<code>parameter</code>）的标识符列表，这些参数在函数体中像局部变量一样工作。函数调用会为形参提供实参的值。函数使用它们实参的值来计算返回值，称为该函数调用表达式的值。除了实参之外，每次调用还会拥有另外一个值——本次调用的上下文——就是<code>this</code>关键字的值。</p><a id="more"></a><p>如果函数挂载在一个对象上，作为对象的一个属性，就称他为对象的方法。当通过这个对象来调用函数时，该对象就是此次调用的上下文（<code>context</code>），也就是该函数的<code>this</code>的值。</p><p>在JavaScript里，函数即对象，程序可以随意操控它们。比如，JavaScript可以把函数赋值给变量，或者作为参数传递给其他函数。因为函数就是对象，所以可以给它们设置属性，甚至调用它们的方法。</p><p>JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。这意味着JavaScript函数构成了一个闭包（<code>closure</code>），它给JavaScript带来了非常强劲的编程能力。</p><h3 id="一、函数定义"><a href="#一、函数定义" class="headerlink" title="一、函数定义"></a>一、函数定义</h3><p>函数使用<code>function</code>关键字来定义，它可以用在函数定义表达式或者函数声明语句离。在两种形式中，函数定义都从<code>function</code>关键字开始，其后跟随这些组成部分：</p><ul><li><p>函数名称标识符</p><p>函数名称是函数声明语句必须的部分。它的用途就像变量的名字，新定义的函数对象会赋值给这个变量。对函数定义表达式来说，这个名字是可选的：如果存在，改名字只存在于函数体中，并指代该函数对象本身。</p></li><li><p>一对圆括号</p><p>其中包含由0个或者多个用逗号隔开的标识符组成的列表。这些标识符是函数的参数名称，它们就像函数体中的局部变量一样。</p></li><li><p>一对花括号</p><p>其中包含0条或多条JavaScript语句。这些语句构成了函数体：一旦调用函数，就会执行这些语句。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printprops</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(p + <span class="string">': '</span> + o[p] + <span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">x1, y1, x2, y2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dx = x2 - x1;</span><br><span class="line">    <span class="keyword">var</span> dy = y2 - y1;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：以表达式方式定义的函数，函数的名称是可选的。一条函数声明语句实际上声明了一个变量，并把一个函数对象赋值给它。相对而言，定义函数表达式时并没有声明一个变量。如果一个函数定义表达式包含名称，函数的局部作用域会包含一个绑定到函数对象的名称。实际上，函数的名称将会成为函数内部的一个局部变量。</p></blockquote><p><strong>函数命名</strong></p><p>任何合法的JavaScript标识符都可以用作一个函数的名称。命名时要尽量选择描述性强而又简洁的函数名。通常函数名的第一个字符为小写，这是一种编程约定。当函数名包含多个单词时，一种约定是将单词以下划线分隔，就像<code>like_this()</code>。还有另外一种约定，就是除了第一个单词之外的单词首字母使用大写字母，就像<code>likeThis()</code>。有些函数是用作内部函数或私有函数（不是作为公用API的一部分），这种函数名通常以一条下划线为前缀。</p><p>函数声明语句“被提前”到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用。不过，以表达式定义的函数就另当别论了，为了调用一个函数，必须要能引用它，而要使用一个以表达式方式定义的函数之前，必须把它赋值给一个变量。变量的声明提前了，但是变量赋值是不会提前的，所以，以表达式方式定义的函数在定义之前无法调用。</p><p>大多数函数都会包含一条<code>return</code>语句，<code>return</code>语句会导致函数停止执行，并返回它的表达式的值给调用者。如果<code>return</code>语句没有一个与之相关的表达式，则它返回undefined值。如果一个函数不包含<code>return</code>语句，那它就只执行函数体中的每条语句，并返回<code>undefined</code>给调用者。</p><hr><h3 id="二、嵌套函数"><a href="#二、嵌套函数" class="headerlink" title="二、嵌套函数"></a>二、嵌套函数</h3><p>在JavaScript里，函数可以嵌套在其他函数里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hypotenuse</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(square(a) + square(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套函数的有趣之处在于它的变量作用域规则：它们可以访问嵌套它们（或多重嵌套）的函数的参数和变量。这些作用于规则对内嵌函数非常重要。</p><p>上文提到，函数声明语句并非真正的语句，ES规范只是允许它们作为顶级语句。它们可以出现在全局代码里，或者内嵌在其他函数中，但它们不能出现在循环、条件判断，或者<code>try/catch/finally</code>以及<code>with</code>语句中。注意，此限制仅适用于以语句声明形式定义的函数。函数定义表达式可以出现在JavaScript代码的任何地方。</p><hr><h3 id="三、函数调用"><a href="#三、函数调用" class="headerlink" title="三、函数调用"></a>三、函数调用</h3><p>构成函数主体的JavaScript代码在定义之时并不会执行，只有调用该函数时，它们才会执行。有4种方式来调用JavaScript函数</p><ul><li><p>作为函数</p></li><li><p>作为方法</p></li><li><p>作为构造函数</p></li><li><p>通过它们的<code>call()</code>和<code>apply()</code>方法直接调用</p></li></ul><h4 id="1-函数调用"><a href="#1-函数调用" class="headerlink" title="1. 函数调用"></a>1. 函数调用</h4><p>使用调用表达式可以进行普通的函数调用也可进行方法调用。一个调用表达式由多个函数表达式组成，每个函数表达式都是由一个函数对象和左圆括号、参数列表和右圆括号组成，参数列表是由逗号分隔的零个或多个参数表达式组成。如果函数表达式是一个属性访问表达式，即该函数是一个对象的属性或属性中的一个元素，那么它就是一个方法调用表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printprops(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> total = distance(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>) + distance(<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> probability = factorial(<span class="number">5</span>) / factorial(<span class="number">13</span>);</span><br></pre></td></tr></table></figure><p>在一个调用中，每个参数表达式（圆括号之间的部分）都会计算出一个值，计算的结果作为参数传递给另外一个函数。这些值作为实参传递给声明函数时定义的形参。在函数体中存在一个形参的引用，指向当前传入的实参列表，通过它可以获得参数的值。</p><p>在ES3和非严格模式的ES5中，函数的调用上下文（this）是全局对象，然而在严格模式下，调用上下文则是undefined。</p><p>以函数形式调用的函数通常不使用this关键字，不过，this可以用来判断当前是否是严格模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并调用一个函数来确定当前脚本运行时是否为严格模式</span></span><br><span class="line"><span class="keyword">var</span> strict = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> !<span class="keyword">this</span>; &#125;());</span><br></pre></td></tr></table></figure><h4 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h4><p>一个方法无非是个保存在一个对象的属性里的JavaScript函数。如果有一个函数f和一个对象o，则可以用下面的代码给<code>o</code>定义一个名为<code>m()</code>的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o.m = f;</span><br><span class="line">o.m();</span><br><span class="line">o.m(x, y);</span><br></pre></td></tr></table></figure><p>对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致。但是，方法调用和函数调用有一个重要的区别，即调用上下文。属性访问表达式由两部分组成：一个对象（<code>o</code>）和属性名称（<code>m</code>），在像这样的方法调用表达式里，对象<code>o</code>称为调用上下文，函数体可以使用关键字<code>this</code>引用该对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculator = &#123;</span><br><span class="line">    operand1: <span class="number">1</span>,</span><br><span class="line">    operand2: <span class="number">1</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="keyword">this</span>.operand1 + <span class="keyword">this</span>.operand2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculator.add();</span><br><span class="line">calculator.result;                          <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure><p>大多数方法调用使用点符号来访问属性，使用方括号也可以进行属性访问操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o[<span class="string">'m'</span>](x, y);</span><br><span class="line">a[o](z)</span><br></pre></td></tr></table></figure><p>方法调用可能包括更复杂的属性访问表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">customer.surname.toUpperCase();</span><br><span class="line">f().m();</span><br></pre></td></tr></table></figure><p>方法和<code>this</code>关键字是面向对象编程范例的核心。任何函数只要作为方法调用实际上都会传入一个隐式的实参——这个实参是一个对象，方法调用的母体就是这个对象。通常来讲，基于那个对象的方法可以执行多种操作，方法调用的语法已经很清晰的表明了函数将基于一个对象进行操作。比较下面两行代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rect.setSize(width, height);</span><br><span class="line">setRectSize(rect, width, height);</span><br></pre></td></tr></table></figure><p>我们假设这两行代码的功能完全一样，它们都作用于一个假定的对象<code>rect</code>。可以看出，第一行的方法调用语法非常清晰地表明这个函数执行的载体是<code>rect</code>对象，函数中的所有操作都将基于这个对象。</p><p>需要注意的是，<code>this</code>是一个关键字，不是变量，也不是属性名。JavaScript的语法不允许给<code>this</code>赋值。</p><p>和变量不同，关键字<code>this</code>没有作用域的限制，嵌套的函数不会从调用它的函数中继承<code>this</code>。如果嵌套函数作为方法调用，其<code>this</code>指向调用它的对象。如果嵌套函数作为函数调用，其<code>this</code>值不是全局对象（非严格模式下）就是<code>undefined</code>（严格模式下）。很多人误以为调用嵌套函数时<code>this</code>会指向调用外层函数的上下文。如果你想访问这个外部函数的<code>this</code>值，需要将<code>this</code>的值保存在一个变量里，这个变量和内部函数都同在一个作用域内。通常使用<code>self</code>变量来保存<code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                         <span class="comment">// 对象中的方法m()</span></span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);            <span class="comment">// true  this的值就是这个对象o</span></span><br><span class="line">        f();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;                      <span class="comment">// 定义嵌套函数f()</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);        <span class="comment">// false  this的值是全局变量或undefined</span></span><br><span class="line">            <span class="built_in">console</span>.log(self === o);        <span class="comment">// true  self指外部函数的this值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">o.m();                                      <span class="comment">// 调用对象o中的方法m()</span></span><br></pre></td></tr></table></figure><h4 id="3-方法链"><a href="#3-方法链" class="headerlink" title="3. 方法链"></a>3. 方法链</h4><p>当方法的返回值是一个对象，这个对象还可以再调用它的方法。这种方法调用序列中（通常称为“链”或“级联”）每次的调用结果都是另外一个表达式的组成部分。比如基于jQuery库，我们常常会这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到所有的header，取得它们id的映射，转换为数组并对它们进行排序</span></span><br><span class="line">$(<span class="string">':header'</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.id; &#125;).get().sort();</span><br></pre></td></tr></table></figure><p>当方法不需要返回值时，最好直接返回<code>this</code>。如果在设计的API中一直采用这种方式，使用API就可以进行“链式调用”风格的变成，在这种编程风格中，只要指定一次要调用的对象即可，余下的方法都可以基于此进行调用。</p><h4 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4. 构造函数"></a>4. 构造函数</h4><p>如果函数或者方法调用之前带有关键字<code>new</code>，他就构成构造函数调用。构造函数调用和普通的函数调用以及方法调用在实参处理、调用上下文和返回值方面都有不同。</p><p>如果构造函数调用在圆括号内包含一组实参列表，先计算这些实参表达式，然后传入函数内，这和函数调用和方法调用是一致的。但如果构造函数没有形参，JavaScript调用的语法是允许省略实参列表和圆括号的。凡是没有形参的构造函数调用都可以省略圆括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两行代码是等价的</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure><p>构造函数调用创建一个新的空对象，这个对象继承自构造函数的<code>prototype</code>属性。构造函数试图初始化这个新创建的对象，并将这个对象用作其调用上下文，因此构造函数可以使用<code>this</code>关键字来引用这个新创建的对象。注意，尽管构造函数看起来像一个方法调用，它依然会使用这个新对象作为调用上下文。也就是说，在表达式<code>new o.m()</code>中，调用上下文并不是<code>o</code>，而是<code>m</code>。</p><p>构造函数通常不使用<code>return</code>关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式地使用<code>return</code>语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用<code>return</code>语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。</p><h4 id="5-间接调用"><a href="#5-间接调用" class="headerlink" title="5. 间接调用"></a>5. 间接调用</h4><p>JavaScript中的函数也是对象，和其他JavaScript对象没什么两样，函数对象也可以包含方法。其中的<code>call()</code>和<code>apply()</code>可以用来间接地调用函数，两个方法都允许显式地调用所需的<code>this</code>值。也就是说，任何函数可以作为任意对象的方法来调用，哪怕这个函数不是那对对象的方法。两个方法都可以指定调用的实参。<code>call()</code>方法使用它自有的实参列表作为函数的实参，<code>apply()</code>方法则要求以数组的形式传入参数。</p><hr><h3 id="四、函数的实参和形参"><a href="#四、函数的实参和形参" class="headerlink" title="四、函数的实参和形参"></a>四、函数的实参和形参</h3><p>JavaScript中的函数定义并未指定函数形参的类型，函数调用也未对传入的实参值作任何类型检查。实际上，JavaScript函数调用甚至不检查传入形参的个数。</p><h4 id="1-可选形参"><a href="#1-可选形参" class="headerlink" title="1. 可选形参"></a>1. 可选形参</h4><p>当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为<code>undefined</code>值。因此在调用函数时形参是否可选以及是否可以省略应当保持较好的适应性。为了做到这一点，应当给省略的参数赋一个合理的默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPropertyNames</span>(<span class="params">o, <span class="regexp">/* optional */</span> a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        a = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> o) &#123;</span><br><span class="line">        a.push(property);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = getPropertyNames(o);                <span class="comment">// 将o的属性存储到一个新数组中</span></span><br><span class="line">getPropertyNames(p, a);                     <span class="comment">// 将p的属性追加到数组a中</span></span><br></pre></td></tr></table></figure><p>如果在第一行代码中不使用<code>if</code>语句，可以使用“<code>||</code>”运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a || [];</span><br></pre></td></tr></table></figure><p>需要注意的是，当用这种可选实参来实现函数时，需要将可选实参放在实参列表的最后。那些调用你的函数的程序员是没法省略第一个实参并传入第二个实参的，它必须将<code>undefined</code>作为第一个实参显式传入。同样注意在函数定义中使用注释<code>/*optional*/</code>来强调形参是可以选的。</p><h4 id="2-可变长的实参列表：实参对象"><a href="#2-可变长的实参列表：实参对象" class="headerlink" title="2. 可变长的实参列表：实参对象"></a>2. 可变长的实参列表：实参对象</h4><p>当调用函数的时候传入的实参个数超过函数定义时的形参个数时，没有办法直接获得未命名的引用。参数对象解决了这个问题。在函数体内，标识符<code>arguments</code>是指向实参对象的引用，实参对象是一个类数组对象，这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。</p><p>实参对象在很多地方都非常有用，下面的例子展示了使用它来验证实参的个数，从而调用正确的逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'function f called with '</span> + <span class="built_in">arguments</span>.length + <span class="string">' arguments, but it expects 3 arguments.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数的其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，通常不必像这样检查实参个数。大多数情况下JavaScript的默认行为是可以满足需要的。省略的实参都将是<code>undefined</code>，多出的参数会自动省略。</p><p>实参对象有一个重要的用处，就是让函数可以操作任意数量的实参。下面的函数就可以接收任意数量的实参，并返回传入实参的最大值（内置函数<code>Max.max()</code>的功能与之类似）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params"><span class="regexp">/* ... */</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="built_in">Number</span>.NEGATIVE_INFINITY;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>[i] &gt; max) &#123;</span><br><span class="line">            max = <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> largest = max(<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1000</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10000</span>, <span class="number">6</span>);      <span class="comment">// =&gt; 10000</span></span><br></pre></td></tr></table></figure><p>类似这种函数可以接收任意个数的实参，这种函数也成为“不定实参函数”（<code>varargs function</code>）。注意，不定实参函数的实参个数不能为零，<code>arguments[]</code>对象最适合的应用场景是在这样一类函数中，这类函数包含固定个数的命名和必须参数，以及随后个数不定的可选实参。</p><p>数组对象包含一个非同寻常的特性。在非严格模式下，当一个函数包含若干形参，实参对象的数组元素是函数形参所对应实参的别名，实参对象中以数字索引，并且形参名称可以认为是相同变量的不同命名。通过实参名字来修改实参值的话，通过<code>arguments[]</code>数组也可以获取到更改后的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);         <span class="comment">// 输出实参的初始值</span></span><br><span class="line">    <span class="built_in">arguments</span>[o] = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x);         <span class="comment">// =&gt; null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果实参对象是一个普通数组的话，第二条<code>console.log(x)</code>语句的结果绝对不会是<code>null</code>，在这个例子中，<code>arguments[0]</code>和<code>x</code>指代同一个值，修改其中一个的值会影响到另一个。</p><p>在严格模式下还有一点（和非严格模式下相比的）不同，在非严格模式中，函数里的<code>arguments</code>仅仅是一个标识符，在严格模式中，它变成了一个保留字。严格模式中的函数无法使用<code>arguments</code>作为形参名或局部变量名，也不能给<code>arguments</code>赋值。</p><p><strong>callee和caller属性</strong></p><p>除了数组元素，实参对象还定义了<code>callee</code>和<code>caller</code>属性，在ES5严格模式中，对这两个属性的读写操作都会产生一个类型错误。而在非严格模式下，ES标准规范规定<code>callee</code>属性指代当前正在执行的函数。<code>caller</code>是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数。通过<code>caller</code>属性可以访问调用栈。<code>callee</code>属性在某些时候会非常有用，比如在匿名函数中通过<code>callee</code>来递归地调用自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="built_in">arguments</span>.callee(x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-将对象属性用作实参"><a href="#3-将对象属性用作实参" class="headerlink" title="3. 将对象属性用作实参"></a>3. 将对象属性用作实参</h4><p>当一个函数包含超过三个形参时，对于程序员来说，要记住调用函数中实参的正确顺序实在让人头疼。最好通过名值对的形式来传入参数，这样参数的顺序就无关紧要了。为了实现这种风格的方法调用，定义函数的时候，传入的实参都写入一个单独的对象之中，在调用的时候传入一个对象，对象中的名值对是真正需要的实参数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arraycopy</span>(<span class="params">from, from_start, to, to_start, length</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">easycopy</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    arraycopy(args.from,</span><br><span class="line">            args.from_start || <span class="number">0</span>,</span><br><span class="line">            args.to,</span><br><span class="line">            args.to_start || <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], b = [];</span><br><span class="line">easycopy(&#123; <span class="attr">from</span>: a, <span class="attr">to</span>: b, <span class="attr">length</span>: <span class="number">4</span> &#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="五、作为值的函数"><a href="#五、作为值的函数" class="headerlink" title="五、作为值的函数"></a>五、作为值的函数</h3><p>函数定义和调用是JavaScript的词法特性，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另外一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = square;</span><br><span class="line">square(<span class="number">4</span>);                              <span class="comment">// =&gt; 16</span></span><br><span class="line">s(<span class="number">4</span>);                                   <span class="comment">// =&gt; 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    square: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> y = o.square(<span class="number">16</span>);                   <span class="comment">// =&gt; 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x; &#125;, <span class="number">20</span>];</span><br><span class="line">a[<span class="number">0</span>](a[<span class="number">1</span>]);                             <span class="comment">// =&gt; 400</span></span><br></pre></td></tr></table></figure><p>考虑一下<code>Array.sort()</code>方法，这个方法可以接收一个函数作为参数，用来处理具体的排序操作。这个函数的作用非常简单，对于任意两个值都返回一个值，以指定它们在排序后的数组中的先后顺序。</p><h4 id="1-自定义函数属性"><a href="#1-自定义函数属性" class="headerlink" title="1. 自定义函数属性"></a>1. 自定义函数属性</h4><p>JavaScript中的函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。当函数需要一个“静态”变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量，显然定义全局变量会让命名空间变得更加杂乱无章。</p><p>比如，我们想写一个返回一个唯一整数的函数，不管在哪里调用函数都会返回这个整数。而函数不能两次返回同一个值，可以把这些信息存放到全局变量中，但这并不是必须的，因为这个信息仅仅是函数本身用到的。最好将这个信息保存到函数对象的一个属性中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uniqueInteger.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueInterger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniqueInterger.counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个函数<code>factorial()</code>使用了自身的属性来缓存上一次的计算结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isFinite</span>(n) &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; n == <span class="built_in">Math</span>.round(n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(n <span class="keyword">in</span> factorial)) &#123;</span><br><span class="line">            factorial[n] = n * factorial(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factorial[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial[<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="六、作为命名空间的函数"><a href="#六、作为命名空间的函数" class="headerlink" title="六、作为命名空间的函数"></a>六、作为命名空间的函数</h3><p><strong>函数作用域</strong>：在函数中声明的变量在整个函数体内都是可见的（包括在嵌套的函数中），在函数的外部是不可见的。不在任何函数内声明的变量是全局变量，在整个JavaScript程序中都是可见的。在JavaScript中是无法声明只在一个代码块内可见的变量的，基于这个原因，我们常常简单的定一个函数用作临时的命名空间，在这个命名空间内定义的变量都不会污染到全局命名空间。</p><p>比如，假设我们写了一段JavaScript模块代码，这段代码将要用在不同的JavaScript程序中。和大多数代码一样，假定这段代码定义了一个用以存储中间计算结果的变量。这样问题就来了，当模块代码放到不同的程序中运行时，我们无法得知这个变量是否已经创建了，如果已经存在这个变量，那么将会和代码发生冲突。解决办法当然是将代码放入一个函数内，然后调用这个函数。这样全局变量就变成了函数内的局部变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mymodule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模块代码</span></span><br><span class="line">    <span class="comment">// 这个模块所使用的所有变量都是局部变量</span></span><br><span class="line">    <span class="comment">// 而不是污染全局命名空间</span></span><br><span class="line">&#125;</span><br><span class="line">mymodule();</span><br></pre></td></tr></table></figure><p>这段代码仅仅定义了一个单独的全局变量，名叫“<code>mymodule</code>”的函数，这样还是太麻烦，可以直接定义一个匿名函数，并在单个表达式中调用它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模块代码</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>最外层的圆括号是习惯用法，尽管有些时候没有必要也不应当省略，这里定义的函数会立即调用。</p><p>下文示例中定义一个返回<code>extend()</code>函数的匿名函数，代码检测是否出现了一个众所周知的IE bug，如果出现了这个bug，就返回一个带补丁的函数版本。此外，这个匿名函数命名空间用来隐藏一组属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个扩展函数，用来将第二个以及后续参数复制至第一个参数</span></span><br><span class="line"><span class="comment">// 这里我们处理了IE bug：在多数IE版本中，如果o的属性拥有一个不可枚举的同名属性，则for/in循环</span></span><br><span class="line"><span class="comment">// 不会枚举对象o的可枚举性，也就是说，将不会正确地处理诸如toString的属性</span></span><br><span class="line"><span class="comment">// 除非我们显式检测它</span></span><br><span class="line"><span class="keyword">var</span> extend = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 修复bug之前，首先检测是否存在</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> &#123;<span class="attr">toString</span>: <span class="literal">null</span>&#125;) &#123;</span><br><span class="line">        <span class="comment">// 如果代码执行到这里，那么for/in循环会正确工作并返回</span></span><br><span class="line">        <span class="comment">// 一个简单版本的extend()函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> source = <span class="built_in">arguments</span>[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> source) &#123;</span><br><span class="line">                    o[prop] = source[prop];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果代码执行到这里，说明for/in循环不会枚举测试对象的toString属性</span></span><br><span class="line">    <span class="comment">// 因此返回另一个版本的extend()函数，这个函数显式测试</span></span><br><span class="line">    <span class="comment">// Object.prototype中的不可枚举属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patched_extend</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> source = <span class="built_in">arguments</span>[i];</span><br><span class="line">            <span class="comment">// 复制所有的可枚举属性</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> source) &#123;</span><br><span class="line">                o[prop] = source[prop];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在检查特殊属性</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; protoprops.length; j++) &#123;</span><br><span class="line">                prop = protoprops[j];</span><br><span class="line">                <span class="keyword">if</span> (source.hasOwnProperty(prop)) &#123;</span><br><span class="line">                    o[prop] = source[prop];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个列表列出了需要检查的特殊属性</span></span><br><span class="line">    <span class="keyword">var</span> protoprops = [<span class="string">'toString'</span>, <span class="string">'valueOf'</span>, <span class="string">'constructor'</span>, <span class="string">'hasOwnProperty'</span>, <span class="string">'isPrototypeOf'</span>, <span class="string">'propertyIsEnumerable'</span>, <span class="string">'toLocaleString'</span>];</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><hr><h3 id="七、闭包"><a href="#七、闭包" class="headerlink" title="七、闭包"></a>七、闭包</h3><p>和其他大多数现代编程语言一样，JavaScript也采用词法作用域（<code>lexical scoping</code>），也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现这种词法作用域，JavaScript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为 “<strong>闭包</strong>”。</p><p>从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链。定义大多数函数时的作用域链在调用函数时依然有效，但这并不影响闭包。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，事件就变得非常微妙。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数必报，以至于这种编程模式在JavaScript中非常常见。</p><p>理解闭包首先要了解嵌套函数的词法作用域规则，看一下这段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;                                 <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;                              <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;                                       <span class="comment">// 在作用域中返回这个值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();                                               <span class="comment">// =&gt; 'local scope'</span></span><br></pre></td></tr></table></figure><p><code>checkscope()</code>函数声明了一个局部变量，并定义了一个函数<code>f()</code>，函数<code>f()</code>返回了这个变量的值，最后将函数<code>f()</code>的执行结果返回。我们应当非常清楚为什么调用<code>checkscope()</code>会返回“<code>local scope</code>”。现在我们对这段代码做一点改动，看看会返回什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;                                 <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;                              <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;                                       <span class="comment">// 在作用域中返回这个值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();                                             <span class="comment">// 返回值是什么？</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们将函数内的一对圆括号移动到了<code>checkscope()</code>之后，<code>checkscope()</code>现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对圆括号）会发生什么事情呢？</p><p>回想一下词法作用域的基本规则：JavaScript函数的执行涌动阿勒作用域链，这个作用域链是函数定义的时候创建的。嵌套的函数定义在这个作用域链里，其中的变量<code>scope</code>一定是局部变量，不管在何时何地执行函数<code>f()</code>，这种绑定在执行<code>f()时</code>依然有效。因此最后一行代码返回<code>&quot;local scope&quot;</code>，而不是<code>&quot;global scope&quot;</code>。简而言之，闭包的这个恶性强大到让人吃惊：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了在其中定义它们的外部函数。</p><blockquote><p><strong>实现闭包</strong></p><p>如果我们理解了词法作用域的规则，我们就能很容易地理解闭包：函数定义时的作用域链到函数执行时依然有效。我们将作用域链描述为一个对象列表，不是绑定的栈。每次调用JavaScript函数的时候，都会为之创建一个新的对象用来保存局部变量，把这个对象添加至作用域链中。当函数返回的时候，就从作用域链中将这个绑定变量的对象删除。如果不存在嵌套的函数，也没有其他引用指向这个绑定对象，它就会被当作垃圾回收掉。如果定义了嵌套的函数，每个嵌套的函数都各自对应一个作用域链，并且这个作用域链指向一个变量绑定对象。但如果这些嵌套的函数对象在外部函数中保存下来，那么它们也会和所指向的变量绑定对象一样当作垃圾回收。但是如果这个函数定义了嵌套的函数，并将它作为返回值返回或者存储在某处的属性里，这时就会有一个外部引用指向这个嵌套的函数。它就不会被当作垃圾回收，并且它所指向的变量绑定对象也不会被当作垃圾回收。</p></blockquote><p>在前文定义的<code>uniqueInteger()</code>函数中，这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟踪上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致<code>uniqueInteger()</code>函数不一定能产生“唯一”的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用作私有状态。我们可以利用闭包这样重写<code>uniqueInteger()</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniqueInteger = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                           <span class="comment">// 定义函数并立即调用</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;                                        <span class="comment">// 函数的私有状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>粗略来看，第一行代码看起来像将函数赋值给一个变量<code>uniqueInteger</code>，实际上，这段代码定义了一个立即调用的函数（函数的开始带有左圆括号），因此是这个函数的返回值赋值给变量<code>uniqueInteger</code>。现在，我们来看函数体，这个函数返回另外一个函数，这是一个嵌套的函数，我们将它赋值给变量<code>uniqueInteger</code>，嵌套的函数是可以访问作用域内的变量的，而且可以访问外部函数中定义的<code>counter</code>变量。当外部函数返回之后，其他任何代码都无法访问<code>counter</code>变量，只有内部的函数才能访问到它。</p><p>像<code>counter</code>一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数定定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n++;</span><br><span class="line">        &#125;,</span><br><span class="line">        reset: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = counter(), d = counter();                           <span class="comment">// 创建两个计数器</span></span><br><span class="line">c.count();                                                  <span class="comment">// =&gt; 0</span></span><br><span class="line">d.count();                                                  <span class="comment">// =&gt; 0  它们互不干扰</span></span><br><span class="line">c.reset();                                                  <span class="comment">// reset()和count()方法共享状态</span></span><br><span class="line">c.count();                                                  <span class="comment">// =&gt; 0  因为我们重置了c</span></span><br><span class="line">d.count();                                                  <span class="comment">// =&gt; 1  没有重置d</span></span><br></pre></td></tr></table></figure><p><code>counter()</code>函数返回了一个“计数器”对象，这个对象包含两个方法：<code>count()</code>返回下一个整数，<code>reset()</code>将计数器重置为内部状态。首先要理解，这两个方法都可以访问私有变量<code>n</code>。再者，每次调用<code>counter()</code>都会创建爱你一个新的作用域链和一个新的私有变量。因此，如果调用<code>counter()</code>两次，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的<code>count()</code>或<code>reset()</code>不会影响到另外一个对象。</p><p>从技术角度看，其实可以将这个闭包合并为属性存取器方法<code>getter</code>和<code>setter</code>。下面这段代码所示的<code>counter()</code>函数，这里私有状态的实现是利用了闭包，而不是利用普通的对象属性来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">n</span>) </span>&#123;                                       <span class="comment">// 函数参数n是一个私有变量</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        get count() &#123;                                       <span class="comment">// 属性getter方法返回并给私有计数器递增1</span></span><br><span class="line">            <span class="keyword">return</span> n++;</span><br><span class="line">        &#125;,</span><br><span class="line">        set count(m) &#123;                                      <span class="comment">// 属性setter不允许n递减</span></span><br><span class="line">            <span class="keyword">if</span> (m &gt;= n)</span><br><span class="line">                n = m;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'count can only be set to a larger value'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = counter(<span class="number">1000</span>);</span><br><span class="line">c.count;                                                    <span class="comment">// =&gt; 1000</span></span><br><span class="line">c.count;                                                    <span class="comment">// =&gt; 1001</span></span><br><span class="line">c.count = <span class="number">2000</span>;</span><br><span class="line">c.count;                                                    <span class="comment">// =&gt; 2000</span></span><br><span class="line">c.count;                                                    <span class="comment">// =&gt; 2001</span></span><br><span class="line">c.count = <span class="number">2000</span>;                                             <span class="comment">// =&gt; Error!</span></span><br></pre></td></tr></table></figure><p>需要注意的是，这个版本的<code>counter()</code>函数并未生命局部变量，而只是使用参数<code>n</code>来保存私有状态，属性存取器方法可以访问<code>n</code>。这样的话，调用<code>counter()</code>的函数就可以指定私有变量的初始值了。</p><p>下文示例是使用闭包技术来共享私有状态的通用做法。这个例子定义了<code>addPrivateProperty()</code>函数，这个函数定义了一个私有变量，以及两个嵌套的函数用来获取和设置这个私有变量的值。它将这些嵌套函数添加为所指定对象的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数给对象o增加了属性存取器方法</span></span><br><span class="line"><span class="comment">// 方法名称为get&lt;name&gt;和set&lt;name&gt;。如果提供了一个判定函数</span></span><br><span class="line"><span class="comment">// setter方法就会用它来检测参数的合法性，然后再存储它</span></span><br><span class="line"><span class="comment">// 如果判定函数返回false，setter方法会抛出一个异常</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这个函数有一个非同寻常之处，就是getter和setter函数</span></span><br><span class="line"><span class="comment">// 所操作的属性值并没有存储在对象o中</span></span><br><span class="line"><span class="comment">// 相反，这个值仅仅是保存在函数的局部变量中</span></span><br><span class="line"><span class="comment">// getter和setter方法同样是局部函数，因此可以访问这个局部变量</span></span><br><span class="line"><span class="comment">// 也就是说，对于两个存取器方法来说这个变量是私有的</span></span><br><span class="line"><span class="comment">// 没有办法绕过存取器方法来设置或修改这个值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPrivateProperty</span>(<span class="params">o, name, predicate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value;                                              <span class="comment">// 这是一个属性值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter方法简单地将其返回</span></span><br><span class="line">    o[<span class="string">'get'</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter方法首先检查值是否合法，若不合法就抛出异常</span></span><br><span class="line">    o[<span class="string">'set'</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate &amp;&amp; !predicate(v))</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'set'</span> + name + <span class="string">': invalid value '</span> + v);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            value = v;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码展示了addPrivateProperty()方法</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;                                                 <span class="comment">// 设置一个空对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加属性存取器方法getName()和setName()</span></span><br><span class="line"><span class="comment">// 确保只允许字符串值</span></span><br><span class="line">addPrivateProperty(o, <span class="string">'Name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.setName(<span class="string">'Frank'</span>);                                         <span class="comment">// 设置属性值</span></span><br><span class="line"><span class="built_in">console</span>.log(o.getName());                                   <span class="comment">// 得到属性值</span></span><br><span class="line">o.setName(<span class="number">0</span>);                                               <span class="comment">// 试图设置一个错误类型的值</span></span><br></pre></td></tr></table></figure><p>我们已经给出了很多例子，在同一个作用域链中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是一种非常重要的技术，但还是要特别小心那些不希望共享的变量往往不经意间共享给了其他的闭包，了解这一点也很重要，看看下面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数返回一个总是返回v的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfunc</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个数组用来存储常数函数</span></span><br><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs[i] = constfunc(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第5个位置的元素所表示的函数返回值为5</span></span><br><span class="line">funcs[<span class="number">5</span>]();                                                 <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure><p>这段代码利用循环创建了很多个闭包，当写类似这种代码的时候往往会犯一个错误：那就是试图将循环代码移入定义这个闭包的函数之内，看一下这段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个函数组成的数组，它们的返回值是0~9</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfuncs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> funcs = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        funcs[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcs = constfuncs();</span><br><span class="line">funcs[<span class="number">5</span>]();                                                 <span class="comment">// 返回值是什么？</span></span><br></pre></td></tr></table></figure><p>上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些必报都是在同一个函数调用中定义的，因此它们可以共享变量<code>i</code>。当<code>constfuncs()</code>返回时，变量<code>i</code>的值是10，所有的闭包够共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是我们想要的结果。关联到闭包的作用域链都是“活动的”，记住这一点非常重要。嵌套的函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照（<code>static snapshot</code>）。</p><p>书写闭包的时候还需注意一件事情，<code>this</code>是JavaScript的关键字，而不是变量。正如之前讨论的，每个函数调用都包含一个<code>this</code>值，如果闭包在外部函数里是无法访问<code>this</code>的，除非外部函数将<code>this</code>转存为一个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;                                            <span class="comment">// 将this保存至一个变量中</span></span><br></pre></td></tr></table></figure><p>绑定<code>arguments</code>的问题与之类似，<code>arguments</code>并不是一个关键字，但在调用每个函数时都会自动声明它，由于闭包具有自己所绑定的<code>arguments</code>，因此闭包内无法直接访问外部函数的参数数组，除非外部函数将参数数组保存到另外一个变量中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outerArguments = <span class="built_in">arguments</span>;                             <span class="comment">// 保存起来以便嵌套的函数能使用它</span></span><br></pre></td></tr></table></figure><hr><h3 id="八、函数属性、方法和构造函数"><a href="#八、函数属性、方法和构造函数" class="headerlink" title="八、函数属性、方法和构造函数"></a>八、函数属性、方法和构造函数</h3><p>我们看到在JavaScript程序中，函数是值。对函数执行<code>typeof</code>运算符会返回字符串“<code>function</code>”，但是函数是JavaScript中特殊的对象。因为函数也是对象，它们也可以拥有属性和方法，就像普通的对象可以拥有属性和方法一样。甚至可以用<code>Function()</code>构造函数来创建新的对象。</p><h4 id="1-length属性"><a href="#1-length属性" class="headerlink" title="1. length属性"></a>1. length属性</h4><p>在函数体里，<code>arguments.length</code>表示传入函数的实参的个数。而函数本身的<code>length</code>属性则由不同含义。函数的<code>length</code>属性是只读属性，它代表函数实参的数量，这里的参数指的是“形参”而非“实参”，也就是在函数定义时给出的实参个数，通常也是在函数调用时期望传入函数的实参个数。</p><p>下面的代码定义了一个名叫<code>check()</code>的函数，从另外一个函数给它传入<code>arguments</code>数组，它比较<code>arguments.length</code>（实际传入的实参个数）和<code>arguments.callee.length</code>（期望传入的实参个数）来判断所传入的实参个数是否正确。如果个数不正确，则抛出异常。<code>check()</code>函数之后定义一个测试函数<code>f()</code>，用来展示<code>check()</code>的用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数使用arguments.callee，因此它不能在严格模式下工作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> actual = args.length;                               <span class="comment">// 实参的真实个数</span></span><br><span class="line">    <span class="keyword">var</span> expected = args.callee.length;                      <span class="comment">// 期望的实参个数</span></span><br><span class="line">    <span class="keyword">if</span> (actual !== expected) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Expeced '</span> + expected + <span class="string">' args; got '</span> + actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    check(<span class="built_in">arguments</span>);                                       <span class="comment">// 检查实参个数和期望的实参个数是否一致</span></span><br><span class="line">    <span class="keyword">return</span> x + y + z;                                       <span class="comment">// 再执行函数的后续逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-prototype属性"><a href="#2-prototype属性" class="headerlink" title="2. prototype属性"></a>2. prototype属性</h4><p>每一个函数都包含一个<code>prototype</code>属性，这个属性是指向一个对象的引用，这个对象称作“原型对象”（<code>prototype object</code>）。每一个函数都包含不同的原型对象，当将函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。</p><h4 id="3-call-方法和apply-方法"><a href="#3-call-方法和apply-方法" class="headerlink" title="3. call()方法和apply()方法"></a>3. call()方法和apply()方法</h4><p>我们可以将<code>call()</code>和<code>apply()</code>看作是某个对象的方法，通过调用方法的形式来间接调用函数。<code>call()</code>和<code>apply()</code>的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内通过<code>this</code>来获得对它的引用。要想以对象<code>o</code>的方法来调用函数<code>f()</code>，可以这样使用<code>call()</code>和<code>apply()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.call(o);</span><br><span class="line">f.apply(o);</span><br></pre></td></tr></table></figure><p>每行代码和下面代码的功能类似（假设对象<code>o</code>中预先不存在名为<code>m</code>的属性）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o.m = f;                                                    <span class="comment">// 将f存储为o的临时方法</span></span><br><span class="line">o.m();                                                      <span class="comment">// 调用它，不传入参数</span></span><br><span class="line"><span class="keyword">delete</span> o.m;                                                 <span class="comment">// 将临时方法删除</span></span><br></pre></td></tr></table></figure><p>在ES5的严格模式中，<code>call()</code>和<code>apply()</code>的第一个实参都会变为<code>this</code>的值，哪怕传入的实参是原始值甚至是<code>null</code>或<code>undefined</code>。在ES3和非严格模式中，传入的<code>null</code>和<code>undefined</code>都会被全局对象替代，而其他原始值则会被相应的包装对象（<code>wrapper object</code>）所替代。</p><p>对于<code>call()</code>来说，第一个调用上下文实参之后的所有实参就是要传入待调用函数的值。比如，以对象<code>o</code>的方法的形式调用函数<code>f()</code>，并传入两个参数，可以使用这样的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.call(o, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><code>apply()</code>方法和<code>call()</code>类似，但传入实参的形式和<code>call()</code>有所不同，它的实参都放入一个数组当中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.apply(o, [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>如果一个函数的实参可以是任意数量，给<code>apply()</code>传入的参数数组可以是任意长度的。比如，为了找出数组中最大的数值元素，调用<code>Math.max()</code>方法的时候可以给<code>apply()</code>传入一个包含任意元素的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> biggest = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, array_of_numbers);</span><br></pre></td></tr></table></figure><p>需要注意的是，传入<code>apply()</code>的参数数组可以是类数组对象也可以是真实数组。实际上，可以将当前函数的<code>arguments</code>数组直接传入（另一个函数的）<code>apply()</code>来调用另一个函数，参考如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将对象o中名为m()的方法替换为另一个方法</span></span><br><span class="line"><span class="comment">// 可以在调用原始的方法之前和之后记录日志消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>(<span class="params">o, m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> original = o[m];                                <span class="comment">// 在闭包中保存原始方法</span></span><br><span class="line">    o[m] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">'Entering:'</span>, m);        <span class="comment">// 输出日志消息</span></span><br><span class="line">        <span class="keyword">var</span> resut = original.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);    <span class="comment">// 调用原始函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">'Existing:'</span>, m);        <span class="comment">// 输入日志消息</span></span><br><span class="line">        <span class="keyword">return</span> result;                                  <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>trace()</code>函数接收两个参数，一个对象和一个方法名，它将指定的方法替换为一个新方法，这个新方法是“包裹”原始方法的另一个泛函数。这种动态修改已有方法的做法有时称作“<code>monkey-patching</code>”。</p><h4 id="4-bind-方法"><a href="#4-bind-方法" class="headerlink" title="4. bind()方法"></a>4. bind()方法</h4><p><code>bind()</code>是在ES5中新增的方法，但在ES3中可以轻易模拟<code>bind()</code>。从名字就可以看出，这个方法的主要作用就是将函数绑定至某个对象。当在函数<code>f()</code>上调用<code>bind()</code>方法并传入一个对象<code>o</code>作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数<code>f()</code>当作<code>o</code>的方法来调用。传入新函数的任何实参都将传入原始函数，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + y;                                  <span class="comment">// 这是个待绑定的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;                                       <span class="comment">// 将要绑定的对象</span></span><br><span class="line"><span class="keyword">var</span> g = f.bind(o);                                      <span class="comment">// 通过调用g(x)来调用o.f(x);</span></span><br><span class="line">g(<span class="number">2</span>);                                                   <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><p>可以通过如下代码轻易地实现这种绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个函数，通过调用它来调用o中的方法f()，传递它所有的实参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">f, o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f.bind) &#123;</span><br><span class="line">        <span class="keyword">return</span> f.bind(o);                               <span class="comment">// 如果bind()方法存在的话，使用bind()方法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> f.apply(o, <span class="built_in">arguments</span>);               <span class="comment">// 否则，这样绑定</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES5中的<code>bind()</code>方法不仅仅是将函数绑定至一个对象，它还附带一些其他应用：除了第一个实参之外，传入<code>bind()</code>的实参也会绑定至<code>this</code>，这个附带的应用是一种常见的函数式编程技术，有时也被称为“柯里化”（<code>currying</code>）。参照下面这个例子中的<code>bind()</code>方法的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;                                       <span class="comment">// 返回两个实参的和</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个类似sum的新函数，但this的值绑定到null</span></span><br><span class="line"><span class="comment">// 并且第一个参数绑定到1，这个新的函数期望只传入一个实参</span></span><br><span class="line"><span class="keyword">var</span> succ = sum.bind(<span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line">succ(<span class="number">2</span>);                                                <span class="comment">// =&gt; 3  x绑定到1，并传入2作为实参y</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + y + z;                              <span class="comment">// 另外一个做累加计算的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, <span class="number">2</span>);                              <span class="comment">// 绑定this和y</span></span><br><span class="line">g(<span class="number">3</span>);                                                   <span class="comment">// =&gt; 6  this.x绑定到1，y绑定到2，z绑定到3</span></span><br></pre></td></tr></table></figure><p>我们可以绑定<code>this</code>的值并在ES3中实现这个附带的应用，下面代码就模拟实现标准的<code>bind()</code>方法。注意我们将这个方法另存为<code>Function.prototype.bind</code>，以便所有的函数对象都继承它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">o <span class="regexp">/*, args */</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将this和arguments的值保存至变量中</span></span><br><span class="line">        <span class="comment">// 以便在后面嵌套的函数中可以使用它们</span></span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>, boundArgs = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bind()方法的返回值是一个函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 创建一个实参列表，将传入bind()的第二个及后续的实参都传入这个函数</span></span><br><span class="line">            <span class="keyword">var</span> args = [], i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; boundArgs.length; i++) &#123;</span><br><span class="line">                args.push(boundArgs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在将self作为o的方法来调用，传入这些实参</span></span><br><span class="line">            <span class="keyword">return</span> self.apply(o, args);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到，<code>bind()</code>方法返回的函数是一个闭包，在这个闭包的外部函数中声明了<code>self</code>和<code>boundArgs</code>变量，这两个变量在闭包里用到。尽管定义闭包的内部函数已经从外部函数中返回，而且调用这个闭包逻辑的时刻要在外部函数返回之后（在闭包中照样可以正确访问这两个变量）。</p><p>ES5定义的<code>bind()</code>方法也有一些特性是上述ES3代码无法模拟的。首先，真正的<code>bind()</code>方法返回的是一个函数对象，这个函数对象的<code>length</code>属性是绑定函数的形参个数减去绑定实参的个数（<code>length</code>的值不能小于0）。再者，ES5的<code>bind()</code>方法可以顺带用作构造函数。如果<code>bind()</code>返回的函数用作构造函数，将忽略传入<code>bind()</code>的<code>this</code>，原始函数就会以构造函数的形式调用，其实参也已经绑定。由<code>bind()</code>方法所返回的函数并不包含<code>prototype</code>属性（普通函数固有的<code>prototype</code>属性是不能删除的），并且将这些绑定的函数用作构造函数时所创建的对象从原始的未绑定的构造函数中继承<code>prototype</code>。同样，在使用<code>instanceof</code>运算符时，绑定构造函数和未绑定构造函数并无两样。</p><h4 id="5-toString-方法"><a href="#5-toString-方法" class="headerlink" title="5. toString()方法"></a>5. toString()方法</h4><p>和所有的JavaScript对象一样，函数也有<code>toString()</code>方法，ES规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数的<code>toString()</code>方法的实现都返回函数的完整源码。内置函数往往返回一个类似“<code>[native code]</code>”的字符串作为函数体。</p><h4 id="6-Function-构造函数"><a href="#6-Function-构造函数" class="headerlink" title="6. Function()构造函数"></a>6. Function()构造函数</h4><p>不管是通过函数定义语句还是函数直接量表达式，函数的定义都要使用<code>function</code>关键字。但函数还是可以通过<code>Function()</code>构造函数来定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x * y;'</span>);</span><br></pre></td></tr></table></figure><p>这行代码创建一个新的函数，这个函数和通过下面代码定义的函数几乎等价</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x * y; &#125;;</span><br></pre></td></tr></table></figure><p><code>Function()</code>构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体：它可以包含任意的JavaScript语句，每两条语句之间用分号分隔。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只需给构造函数简单地传入一个字符串——函数体——即可。</p><p>注意，<code>Function()</code>构造函数并不需要通过传入实参以指定函数名。就像函数直接量一样，<code>Function()</code>构造函数创建一个匿名函数。</p><p>关于<code>Function()</code>构造函数有几点需要特别注意：</p><ul><li><p><code>Function()</code>构造函数允许JavaScript在运行时动态地创建并编译函数。</p></li><li><p>每次调用<code>Function()</code>构造函数都会解析函数体，并创建新的函数对象。如果是在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响。相比之下，循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译。</p></li><li><p>最后一点，也是关于<code>Function()</code>构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译总是会在顶层函数执行，正如下面代码所示</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">'local'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'return scope;'</span>);               <span class="comment">// 无法捕获局部作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一行代码返回global，因为通过Function()构造函数</span></span><br><span class="line"><span class="comment">// 所返回的函数使用的不是局部作用域</span></span><br><span class="line">constructionFunction()();                               <span class="comment">// =&gt; 'global'</span></span><br></pre></td></tr></table></figure><p>我们可以将<code>Function()</code>构造函数认为是在全局作用域中执行的<code>eval()</code>，<code>eval()</code>可以在自己的私有作用域内定义新变量和函数，<code>Function()</code>构造函数在实际编程过程中很少会用到。</p><h4 id="7-可调用的对象"><a href="#7-可调用的对象" class="headerlink" title="7. 可调用的对象"></a>7. 可调用的对象</h4><p>我们在前面提到的“类数组对象”并不是真正的数组，但大部分场景下可以将其当作数组来对待。对于函数也存在类似的情况。“可调用对象”（<code>callable object</code>）是一个对象，可以在函数调用表达式中调用这个对象。所有的函数都是可调用的，但并非所有的可调用对象都是函数。</p><p>截至目前，可调用对象在两个JavaScript实现中不能算作函数：</p><ul><li><p>1) IE8及之前的版本实现了客户端方法（<code>window.alert()</code>和<code>document.getElementById()</code>），使用了可调用的宿主对象，而不是内置函数对象。IE中的这些方法在其他浏览器中也都存在，但它们本质上不是<code>Function</code>对象。IE9将它们实现为真正的函数，因此这类可调用的对象越来越罕见。</p></li><li><p>2) <code>RegExp</code>对象，可以直接调用<code>RegExp</code>对象，这比调用它的<code>exec()</code>方法更快捷一些。在JavaScript中这是一个彻头彻尾的非标准特性，代码最好不要对可调用的<code>RegExp</code>对象由太多依赖，这个特性在不久的将来可能会废弃并删除。</p></li></ul><p>如果想检测一个对象是否是真正的函数对象（并且具有函数方法），可以检测它的<code>class</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(x) === <span class="string">'[object Function]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="九、函数式编程"><a href="#九、函数式编程" class="headerlink" title="九、函数式编程"></a>九、函数式编程</h3><p>和Lisp、Haskell不同，JavaScript并非函数式编程语言，但在JavaScript中可以像操控对象一样操控函数，也就是说可以在JavaScript中应用函数式编程技术。ES5中的数组方法（诸如<code>map()</code>和<code>reduce()</code>）就可以非常适合用于函数式编程风格。</p><h4 id="1-使用函数处理数组"><a href="#1-使用函数处理数组" class="headerlink" title="1. 使用函数处理数组"></a>1. 使用函数处理数组</h4><p>假设有一个数组，数组元素都是数字，我们想要计算这些元素的平均值和标准差。若使用非函数式编程风格的话，代码会是这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>];                             <span class="comment">// 待处理数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平均数是所有元素的累加和值除以元素个数</span></span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    total += data[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mean = total / data.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算标准差，首先计算每个数据减去平均数之后偏差的平方然后求和</span></span><br><span class="line">total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> deviation = data[i] - mean;</span><br><span class="line">    total += deviation * deviation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stddev = <span class="built_in">Math</span>.sqrt(total / (data.length - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>可以使用数组方法<code>map()</code>和<code>reduce()</code>来实现同样的计算，这种实现极其简洁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先定义两个简单的函数</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x &#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将这些函数和数组方法配合使用计算出平均数和标准差</span></span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> mean = data.reduce(sum) / data.length;</span><br><span class="line"><span class="keyword">var</span> deviations = data.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x - mean; &#125;);</span><br><span class="line"><span class="keyword">var</span> stddev = <span class="built_in">Math</span>.sqrt(deviations.map(square).reduce(sum) / (data.length - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>如果我们基于ES3来如何实现呢？因为ES3中并不包含这些数组方法，如果不存在内置方法的话我们可以自定义<code>map()</code>和<code>reduce()</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个数组元素调用f()，并返回一个结果数组</span></span><br><span class="line"><span class="comment">// 如果Array.prototype.map定义了的话，就使用这个方法</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="built_in">Array</span>.prototype.map ? </span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a, f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.map(f);</span><br><span class="line">    &#125;:</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a, f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> results = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = a.length; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i <span class="keyword">in</span> a) &#123;</span><br><span class="line">                results[i] = f.call(<span class="literal">null</span>, a[i], i, a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数f()和可选的初始值将数组a减至一个值</span></span><br><span class="line"><span class="comment">// 如果Array.prototype.reduce存在的话，就使用这个方法</span></span><br><span class="line"><span class="keyword">var</span> reduce = <span class="built_in">Array</span>.prototype.reduce ?</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a, f, initial</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.reduce(f, initial);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.reduce(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;:</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a, f, initial</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span>, len = a.length, accumulator;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以特定的初始值开始，否则第一个值取自a</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            accumulator = initial;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i <span class="keyword">in</span> a) &#123;</span><br><span class="line">                    accumulator = a[i++];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == len) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于数组中剩下的元素依次调用f()</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i <span class="keyword">in</span> a) &#123;</span><br><span class="line">                accumulator = f.call(<span class="literal">undefined</span>, accumulator, a[i], i, a);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用定义的<code>map()</code>和<code>reduce()</code>函数，计算平均值和标准差的代码看起来像这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> mean = reduce(data, sum) / data.length;</span><br><span class="line"><span class="keyword">var</span> deviations = map(data, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - mean;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> stddev = <span class="built_in">Math</span>.sqrt(reduce(map(deviations, square), sum) / (data.length - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2. 高阶函数"></a>2. 高阶函数</h4><p>所谓高阶函数（<code>higher-order function</code>）就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个高阶函数返回一个新的函数，这个新函数将它的实参传入f()</span></span><br><span class="line"><span class="comment">// 并返回f的返回值的逻辑非</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">not</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = f.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);          <span class="comment">// 调用f()</span></span><br><span class="line">        <span class="keyword">return</span> !result;                                 <span class="comment">// 对结果求反</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> even = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> odd = not(even);                                    <span class="comment">// 一个新函数，所做的事情和even()相反</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>].every(odd);                             <span class="comment">// =&gt; true  每个元素都是奇数</span></span><br></pre></td></tr></table></figure><p>上面的<code>not()</code>函数就是一个高阶函数，因为它接收一个函数作为参数，并返回一个新函数。另外一个例子，来看下面的<code>mapper()</code>函数，它也是接收一个函数作为参数，并返回一个新函数，这个新函数将一个数组映射到另一个使用这个函数的数组上。这个函数使用了之前定义的<code>map()</code>函数，但要首先理解这两个函数有哪些不同，这一点至关重要</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所返回的函数的参数应当是一个实参数组，并对每个数组元素执行函数f()</span></span><br><span class="line"><span class="comment">// 并返回所有计算结果组成的数组</span></span><br><span class="line"><span class="comment">// 可以对比一下这个函数和上文提到的map()函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapper</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map(a, f);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increment = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> incrementer = mapper(increment);</span><br><span class="line"></span><br><span class="line">incrementer([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);                                 <span class="comment">// =&gt; [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>这里是一个更常见的例子，它接收两个函数<code>f()</code>和<code>g()</code>，并返回一个新的函数用以计算<code>f(g())</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个新的可以计算f(g(...))的函数</span></span><br><span class="line"><span class="comment">// 返回的函数h()将它所有的实参传入g()，然后将g()的返回值传入f()</span></span><br><span class="line"><span class="comment">// 调用f()和g()时的this值和调用h()时的this值是同一个this</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">f, g</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 需要给f()传入一个参数，所以使用f()的call()方法</span></span><br><span class="line">        <span class="comment">// 需要给g()传入很多参数，所以使用g()的apply()方法</span></span><br><span class="line">        <span class="keyword">return</span> f.call(<span class="keyword">this</span>, g.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> squareofsum = compose(square, sum);</span><br><span class="line"></span><br><span class="line">squareofsum(<span class="number">2</span>, <span class="number">3</span>);                                      <span class="comment">// =&gt; 25</span></span><br></pre></td></tr></table></figure><h4 id="3-不完全函数"><a href="#3-不完全函数" class="headerlink" title="3. 不完全函数"></a>3. 不完全函数</h4><p>函数<code>f()</code>的<code>bind()</code>方法返回一个新函数，给新函数传入特定的上下文和一组指定的参数，然后调用函数<code>f()</code>。我们说它把函数“绑定至”对象并传入一部分参数。<code>bind()</code>方法只是将实参放在（完整实参列表的）左侧，也就是说<code>bind()</code>的实参都是放在传入原始函数的实参列表开始的位置，但有时我们期望将传入<code>bind()</code>的实参放在（完整实参列表的）右侧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个工具函数将类数组对象（或对象）转换为真正的数组</span></span><br><span class="line"><span class="comment">// 在后面的示例代码中用到了这个方法将arguments对象转换为真正的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">array</span>(<span class="params">a, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(a, n || <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实参传递至左侧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialLeft</span>(<span class="params">f <span class="regexp">/*, ...*/</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;                               <span class="comment">// 保存外部的实参数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = array(args, <span class="number">1</span>);                         <span class="comment">// 开始处理外部的第一个args</span></span><br><span class="line">        a = a.concat(array(<span class="built_in">arguments</span>));                 <span class="comment">// 然后增加所有的内部实参</span></span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="keyword">this</span>, a);                        <span class="comment">// 然后基于这个实参列表调用f()</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实参传递至右侧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialRight</span>(<span class="params">f <span class="regexp">/*, ...*/</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;                               <span class="comment">// 保存外部实参数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = array(<span class="built_in">arguments</span>);                       <span class="comment">// 从内部参数开始</span></span><br><span class="line">        a = a.concat(array(args, <span class="number">1</span>));                   <span class="comment">// 然后从外部第一个args开始添加</span></span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="keyword">this</span>, a);                        <span class="comment">// 最后基于这个实参列表调用f()</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实参被用作模板</span></span><br><span class="line"><span class="comment">// 实参列表中的undefined值都被填充</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">f <span class="regexp">/*, ...*/</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;                               <span class="comment">// 保存外部实参数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = array(args, <span class="number">1</span>);                         <span class="comment">// 从外部args开始</span></span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历args，从内部实参填充undefined值</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                a[i] = <span class="built_in">arguments</span>[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 现在将剩下的内部实参都追加进去</span></span><br><span class="line">        a = a.concat(array(<span class="built_in">arguments</span>, j));</span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="keyword">this</span>, a);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数带有三个实参</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * (y - z);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个不完全调用</span></span><br><span class="line">partialLeft(f, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>);                                <span class="comment">// =&gt; -2  绑定第一个实参：2*(3-4)</span></span><br><span class="line">partialRight(f, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>);                               <span class="comment">// =&gt; 6  绑定最后一个实参：3*(4-2)</span></span><br><span class="line">partial(f, <span class="literal">undefined</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>);                         <span class="comment">// =&gt; -6  绑定中间的实参：3*(2-4)</span></span><br></pre></td></tr></table></figure><p>利用这种不完全函数的编程技巧，可以编写一些有意思的代码，利用已有的函数来定义新的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> increment = partialLeft(sum, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> cuberoot = partialRight(<span class="built_in">Math</span>.pow, <span class="number">1</span>/<span class="number">3</span>);</span><br><span class="line"><span class="built_in">String</span>.prototype.first = partial(<span class="built_in">String</span>.prototype.charAt, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">String</span>.prototype.last = partial(<span class="built_in">String</span>.prototype.substr, <span class="number">-1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当将不完全调用和其他高阶函数整合在一起的时候，事情就变得格外有趣了。比如，这里的例子定义了<code>not()</code>函数，它用到了刚才提到的不完全调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> not = partialLeft(compose, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !x;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> even = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> odd = not(even);</span><br><span class="line"><span class="keyword">var</span> isNumber = not(<span class="built_in">isNaN</span>);</span><br></pre></td></tr></table></figure><p>我们也可以使用不完全调用的组合来重新组织求平均数和标准差的代码，这种编码风格是非常纯粹的函数式编程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>];                                 <span class="comment">// 待处理的数据</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;                                  <span class="comment">// 两个初等函数</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> product = functon(x, y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> neg = partial(product, <span class="number">-1</span>);                             <span class="comment">// 定义其他函数</span></span><br><span class="line"><span class="keyword">var</span> square = partial(<span class="built_in">Math</span>.pow, <span class="literal">undefined</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> sqrt = partial(<span class="built_in">Math</span>.pow, <span class="literal">undefined</span>, <span class="number">.5</span>);</span><br><span class="line"><span class="keyword">var</span> reciprocal = partial(<span class="built_in">Math</span>.pow, <span class="literal">undefined</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在计算平均值和标准差，所有的函数调用都不带运算符</span></span><br><span class="line"><span class="keyword">var</span> mean = product(reduce(data, sum), reciprocal(data.length));</span><br><span class="line"><span class="keyword">var</span> stddev = sqrt(product(reduce(map(data, </span><br><span class="line">                                    compose(square, </span><br><span class="line">                                            partial(sum, neg(mean)))), </span><br><span class="line">                                sum), </span><br><span class="line">                        reciprocal(sum(data.length, <span class="number">-1</span>))));</span><br></pre></td></tr></table></figure><h4 id="4-记忆"><a href="#4-记忆" class="headerlink" title="4. 记忆"></a>4. 记忆</h4><p>在函数式编程中，采用缓存的方式记录结果的技巧称为“记忆”（<code>memorization</code>）。下面的代码展示了一个高阶函数，<code>memorize()</code>接收一个函数作为实参，并返回带有记忆能力的函数。</p><blockquote><p>需要注意的是，记忆只是一种编程技巧，本质上是牺牲算法的空间复杂度以换取更优的时间复杂度，在客户端JavaScript中代码的执行时间复杂度往往成为瓶颈，因此在大多数场景下，这种牺牲空间换取时间的做法以提升程序执行效率的做法是非常可取的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回f()的带有记忆功能的版本</span></span><br><span class="line"><span class="comment">// 只有当f()的实参的字符串表示都不相同时它才会工作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;                                         <span class="comment">// 将值保存在闭包内</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将实参转换为字符串形式，并将其用作缓存的键</span></span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">arguments</span>.length + <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">','</span>);</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[key];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[key] = f.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>memorize()</code>函数创建一个新的对象，这个对象被当作缓存（的宿主）并赋值给一个局部变量，因此对于返回的函数来说它是私有的（在闭包中）。所返回的函数将它的实参数组转换成字符串，并将字符串用作缓存对象的属性名。如果在缓存中存在这个值，则直接返回它。</p><p>否则，就调用既定的函数对实参进行计算，将计算结果换存起来并返回，下面的代码展示了如何使用<code>memorize()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回两个整数的最大公约数</span></span><br><span class="line"><span class="comment">// 使用欧几里德算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        t = b;</span><br><span class="line">        b = a;</span><br><span class="line">        a = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>) &#123;</span><br><span class="line">        t = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gcdmemo = memorize(gcd);</span><br><span class="line">gcdmemo(<span class="number">85</span>, <span class="number">187</span>);                                           <span class="comment">// =&gt; 187</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，当我们写一个递归函数时，往往需要实现记忆功能</span></span><br><span class="line"><span class="comment">// 我们更希望调用实现了记忆功能的递归函数，而不是原递归函数</span></span><br><span class="line"><span class="keyword">var</span> factorial = memorize(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>);                                               <span class="comment">// =&gt; 120  对于4~1的值也有缓存</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数是这样的一段JavaScript代码，它只定义一次，但可能被执行或调用任意次。JavaScript函数是参数化的：函数的定义会包括一个称为形参（&lt;code&gt;parameter&lt;/code&gt;）的标识符列表，这些参数在函数体中像局部变量一样工作。函数调用会为形参提供实参的值。函数使用它们实参的值来计算返回值，称为该函数调用表达式的值。除了实参之外，每次调用还会拥有另外一个值——本次调用的上下文——就是&lt;code&gt;this&lt;/code&gt;关键字的值。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript数组" scheme="http://www.xiaoleon.cn/tags/JavaScript%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JS(3) 数组</title>
    <link href="http://www.xiaoleon.cn/2018/01/27/js-3/"/>
    <id>http://www.xiaoleon.cn/2018/01/27/js-3/</id>
    <published>2018-01-27T09:48:25.000Z</published>
    <updated>2018-02-02T12:48:05.169Z</updated>
    
    <content type="html"><![CDATA[<p>数组是值的有序集合，每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。JavaScript数组的索引是基于零的32位数，第一个元素的索引为0，最大可能的索引为<code>4 294 967 294</code>（<code>2e32-2</code>），数组最大能容纳<code>4 294 967 295</code>个元素。</p><a id="more"></a><p>JavaScript数组可能是稀疏的：数组元素的索引不一定要连续的，它们之间可以有空缺。每个JavaScript数组都有一个<code>length</code>属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，<code>length</code>比所有元素的索引要大。</p><p>JavaScript数组是JavaScript对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。我们将在本文的其他地方更多地讨论特殊化的数组。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。</p><h3 id="一、创建数组"><a href="#一、创建数组" class="headerlink" title="一、创建数组"></a>一、创建数组</h3><p>使用数组直接量是创建数组最简单的方法，在方括号中将数组元素用逗号隔开即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = [];</span><br><span class="line"><span class="keyword">var</span> primes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> misc = [<span class="number">1.1</span>, <span class="literal">true</span>, <span class="string">'a'</span>, ];</span><br></pre></td></tr></table></figure><p>数组直接量中的值不一定要是常量，它们可以是任意的表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> base = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">var</span> table = [table, base+<span class="number">1</span>, base+<span class="number">2</span>, base+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = [[<span class="number">1</span>, &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;], [<span class="number">2</span>, &#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>:<span class="number">4</span>&#125;]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = [<span class="number">1</span>, ,<span class="number">3</span>];        <span class="comment">// 数组有3个元素，中间那个元素值为undefined</span></span><br><span class="line"><span class="keyword">var</span> undefs = [,,];          <span class="comment">// 数组有2个元素，都是undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>数组直接量的语法允许有可选的结尾的逗号，故<code>[,,]</code>只有两个元素而非三个。</p></blockquote><p>调用构造函数<code>Array()</code>是创建数组的另一种方法。可以用三种方式调用构造函数。</p><ul><li><p>调用时没有参数</p><p>  该方法创建一个没有任何元素的空数组，等同于数组直接量<code>[]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br></pre></td></tr></table></figure></li><li><p>调用时有一个数值参数，它指定长度</p><p>  该方法创建指定长度的数组。当预先知道所需元素个数时，这种形式的Array构造函数可以用来预分配一个数组空间。注意，数组中没有存储值，甚至数组的索引属性还未定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><p>显示指定两个或多个数组元素或者数组的一个非数值元素</p><p>  以这种形式，构造函数的参数将会称为新数组的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">'testing, testing'</span>);</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="二、数组元素的读和写"><a href="#二、数组元素的读和写" class="headerlink" title="二、数组元素的读和写"></a>二、数组元素的读和写</h3><p>使用<code>[]</code>操作符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。因此，下方代码都是合法的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'world'</span>];</span><br><span class="line"><span class="keyword">var</span> value = a[<span class="number">0</span>];</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">3.14</span>;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">a[i] = <span class="number">3</span>;</span><br><span class="line">a[i+<span class="number">1</span>] = <span class="string">'hello'</span>;</span><br><span class="line">a[a[i]] = a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><blockquote><p><strong>请记住，数组是对象的特殊形式</strong></p></blockquote><p>使用方括号访问数组元素就像用方括号访问对象的属性一样。JavaScript将指定的数字索引值转换成字符串——索引值<code>1</code>变成<code>“1”</code>——然后将其作为属性名来使用。关于索引值从数字转换为字符串没什么特别之处：对常规对象也可以这么做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o[<span class="number">1</span>] = <span class="string">'one'</span>;</span><br></pre></td></tr></table></figure><p>数组的特别之处在于，当使用小于<code>2e32</code>的非负整数作为属性名时，数组会自动维护其<code>length</code>属性值。</p><p>清晰地区分数组的索引和对象的属性名是非常有用的。所有的索引都是属性名，但只有<code>0~2e32-2</code>之间的整数属性名才是索引。所有的数组都是对象，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的<code>length</code>属性值。</p><p>注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当作常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负整数的字符串，它就当作数组索引，而非对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这将创建一个名为“-1.23”的属性</span></span><br><span class="line">a[<span class="number">-1.23</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 这是数组的第1001个元素</span></span><br><span class="line">a[<span class="string">'1000'</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 和a[1]相等</span></span><br><span class="line">a[<span class="number">1.000</span>];</span><br></pre></td></tr></table></figure><p>事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着JavaScript数组没有“越界”错误的概念。当试图查询任意对象中不存在的属性时，不会报错，只会得到<code>undefined</code>值。</p><p>既然数组是对象，那么它们可以从原型中继承元素。ES5中，数组可以定义元素的<code>getter</code>和<code>setter</code>方法。如果一个数组确实继承了元素或使用了元素的<code>getter</code>和<code>setter</code>方法，我们应该期望它使用非优化的代码路径：访问者中数组的元素的时间会与常规对象属性的查找时间相近。</p><hr><h3 id="三、稀疏数组"><a href="#三、稀疏数组" class="headerlink" title="三、稀疏数组"></a>三、稀疏数组</h3><p>稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的<code>length</code>属性值代表数组中元素的个数。如果数组是稀疏的，<code>length</code>属性值大于元素的个数。可以用<code>Array()</code>构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);       <span class="comment">// 数组没有元素，但是a.length=5</span></span><br><span class="line">a = [];                 <span class="comment">// 创建一个空数组，length=0</span></span><br><span class="line">a[<span class="number">1000</span>] = <span class="number">0</span>;            <span class="comment">// 赋值添加一个元素，但是length=1001</span></span><br></pre></td></tr></table></figure><p>足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。</p><p>需要注意的是，当省略数组直接量中的值时（使用连续的逗号，比如<code>[1,,3]</code>），这时所得到的数组也是稀疏数组，省略掉的值是不存在的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = [,,,];</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a1;                    <span class="comment">// false a1在索引0处有一个元素</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a2;                    <span class="comment">// false a2在索引0处没有元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、数组长度"><a href="#四、数组长度" class="headerlink" title="四、数组长度"></a>四、数组长度</h3><p>每个数组都有一个<code>length</code>属性，就是这个属性使其区别于常规的JavaScript对象。针对稠密数组（非稀疏数组），<code>length</code>属性值代表数组中元素的个数。其值比数组中最大的索引大1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[].length;                  <span class="comment">// 0 数组没有元素</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].length      <span class="comment">// 3 最大索引值为2，length=3</span></span><br></pre></td></tr></table></figure><p>在数组中肯定找不到一个元素的索引值大于或等于它的长度，为了维持此规则不变化，数组有两个特殊的行为</p><ul><li><p>如果为一个数组元素赋值，它的索引<code>i</code>大于或等于现有数组的长度是，<code>length</code>属性的值将设置为<code>i+1</code></p></li><li><p>设置<code>length</code>属性为一个小于当前长度的非负整数<code>n</code>时，当前数组中那些索引值大于或等于<code>n</code>的元素将从中删除</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.length = <span class="number">3</span>;               <span class="comment">// a = [1, 2, 3]</span></span><br><span class="line">a.length = <span class="number">0</span>;               <span class="comment">// a = []</span></span><br><span class="line">a.length = <span class="number">5</span>;               <span class="comment">// 长度为5，但是没有元素，就像new Array(5)</span></span><br></pre></td></tr></table></figure><p>还可以将数组的<code>length</code>属性值设置为大于其当前的长度，实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个空的区域。</p><p>在ES5中，可用用<code>Object.defineProperty()</code>让数组的<code>length</code>属性变成只读的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'length'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a.length = <span class="number">0</span>;               <span class="comment">// a不会改变</span></span><br></pre></td></tr></table></figure><p>类似的，如果让一个数组元素不能配置，就不能删除它。如果不能删除它，<code>length</code>属性就不能设置为小于不可配置元素的索引值。</p><hr><h3 id="五、数组元素的添加和删除"><a href="#五、数组元素的添加和删除" class="headerlink" title="五、数组元素的添加和删除"></a>五、数组元素的添加和删除</h3><ul><li><p>push()</p><p>我们可以使用<code>push()</code>方法在数组末尾增加一个或多个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [];</span><br><span class="line">a.push(<span class="string">'zero'</span>);             <span class="comment">// a = ['zero']</span></span><br><span class="line">a.push(<span class="string">'one'</span>, <span class="string">'two'</span>);       <span class="comment">// a = ['zero', 'one', 'two']</span></span><br></pre></td></tr></table></figure><p>在数组尾部压入一个元素与给数组<code>a[a.length]</code>赋值是一样的。</p></li><li><p>unshift()</p><p>可以使用<code>unshift()</code>方法在数组的首部插入一个元素，并且将其他元素依次移到更高的索引处。</p></li><li><p>delete</p><p>可以像删除对象属性一样使用<code>delete</code>运算符来删除数组元素。</p><p>删除数组元素与为其赋值<code>undefined</code>值是类似的（但有一些微妙的区别）。</p><p>注意，对一个数组元素使用<code>delete</code>不会修改数组的<code>length</code>属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，它就变成稀疏数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];</span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> a;                     <span class="comment">// false 数组索引1并未在数组中定义</span></span><br><span class="line">a.length;                   <span class="comment">// 3 delete操作不影响数组长度</span></span><br></pre></td></tr></table></figure></li><li><p>pop()</p><p>可以使用<code>pop()</code>方法，使长度减少1并返回被删除元素的值</p></li><li><p>shift()</p><p>可以使用<code>shift()</code>方法，从数组头部删除一个元素，和<code>delete</code>不同的是，<code>shift()</code>方法将所有元素下移到比当前索引低<code>1</code>的地方</p></li><li><p>splice()</p><p>可以使用<code>splice()</code>方法来插入、删除或替换数组元素，它会根据需要修改<code>length</code>属性并移动元素到更高或更低的索引处</p></li></ul><hr><h3 id="六、数组遍历"><a href="#六、数组遍历" class="headerlink" title="六、数组遍历"></a>六、数组遍历</h3><p>使用<code>for</code>循环是遍历数组元素最常见的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(o);</span><br><span class="line"><span class="keyword">var</span> values = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i= <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i];</span><br><span class="line">    values[i] = o[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在嵌套循环或其他性能非常重要的上下文中，可以看到这种基本的数组遍历需要优化，数组的长度应该只查询一次而非每次循环都要查询</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 循环体不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些例子假设数组是稠密的，并且所有的元素都是合法数组。否则，使用数组元素之前应该先检测它们。如果想要排除<code>null</code>、<code>undefined</code>和不存在的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!a[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果只想跳过undefined和不存在的元素</span></span><br><span class="line">    <span class="keyword">if</span> (a[i] === <span class="literal">undefined</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果只想跳过不存在的元素，仍然要处理存在的undefined元素</span></span><br><span class="line">    <span class="keyword">if</span> (!(i <span class="keyword">in</span> a)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用<code>for/in</code>循环处理稀疏数组。循环每次将一个可枚举的属性名（包括数组索引）赋值给循环变量，不存在索引将不会遍历到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> sparseArray) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = sparseArray[index];</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是由于<code>for/in</code>循环能够枚举继承的属性名，如添加到<code>Array.prototype</code>中的方法，在数组上不应该使用<code>for/in</code>循环，除非使用额外的检测方法来过滤不想要的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="comment">// 跳过继承的属性</span></span><br><span class="line">    <span class="keyword">if</span> (!a.hasOwnProperty(i)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="comment">// 跳过不是非负整数的属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">String</span>(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(i)))) !== i) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES规范允许<code>for/in</code>循环以不同的顺序遍历对象的属性，通常数组元素的遍历实现是升序的，但不能保证一定是这样。特别的，如果数序同时拥有对象属性和数组元素，返回的属性名很可能是按照创建的顺序而非数值的大小顺序。如何处理这个问题的实现各不相同，如果算法依赖于遍历的顺序，那么最好不要使用<code>for/in</code>而用常规的<code>for</code>循环。</p><p>ES5定义了一些遍历数组元素的新方法，按照索引的顺序按个传递给定义的一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sumOfSquares = <span class="number">0</span>;</span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    sumOfSquares += x * x;</span><br><span class="line">&#125;)</span><br><span class="line">sumOfSquares;</span><br></pre></td></tr></table></figure><hr><h3 id="七、多维数组"><a href="#七、多维数组" class="headerlink" title="七、多维数组"></a>七、多维数组</h3><p>JavaScript不支持真正的多维数组，但可以用数组的数组来近似。访问数组的数组中的元素，只要简单地使用两次<code>[]</code>操作符即可。例如，假设变量<code>matrix</code>是一个数组的数组，它的基本元素是数值，那么<code>matrix[x]</code>的每个元素是包含一个数值数组，访问数组中特定数值的代码为<code>matrix[x][y]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> row = <span class="number">0</span>; row &lt; table.length; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (col = <span class="number">0</span>; col &lt; table[row].length; col++) &#123;</span><br><span class="line">        table[row][col] = row * col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> product = table[<span class="number">5</span>][<span class="number">7</span>];              <span class="comment">// =&gt; 35</span></span><br></pre></td></tr></table></figure><hr><h3 id="八、数组方法"><a href="#八、数组方法" class="headerlink" title="八、数组方法"></a>八、数组方法</h3><p>ES3在<code>Array.prototype</code>中定义了一些很有用的操作数组的函数，这意味着这些函数作为任何数组的方法都是可用的。</p><ul><li><p>join()</p><p><code>Array.join()</code>方法将数组中的所有元素都转化为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生成的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。</p><p><code>Array.join()</code>是<code>String.split()</code>方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.join();                               <span class="comment">// =&gt; '1,2,3'</span></span><br><span class="line">a.join(<span class="string">' '</span>);                            <span class="comment">// =&gt; '1 2 3'</span></span><br><span class="line">a.join(<span class="string">''</span>);                             <span class="comment">// =&gt; '123'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line">b.join(<span class="string">'-'</span>);                            <span class="comment">// =&gt; '---------'</span></span><br></pre></td></tr></table></figure></li><li><p>reverse()</p><p><code>Array.reverse()</code>方法将数组中的元素颠倒顺序，返回逆序的数组。它采取了替换，换句话说，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列它们</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.reverse();                    <span class="comment">// =&gt; [3, 2, 1]</span></span><br><span class="line">a == b;                                 <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure></li><li><p>sort()</p><p><code>Array.sort()</code>方法将数组中的元素排序并返回排序后的数组，当不带参数调用<code>sort()</code>时，数组元素以字母表顺序排序（如有必要将临时转化为字符串进行比较）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'banana'</span>, <span class="string">'cherry'</span>, <span class="string">'apple'</span>);</span><br><span class="line">a.sort();</span><br><span class="line"><span class="keyword">var</span> s = a.join(<span class="string">','</span>);                    <span class="comment">// 'apple,banana,cherry'</span></span><br></pre></td></tr></table></figure><p>如果数组包含<code>undefined</code>元素，它们会被排到数组的尾部。</p><p>为了按照其他方式而非字母顺序进行数组排序，必须给<code>sort()</code>方法传递一个比较函数，该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小于0的数值。反之，假设第一个参数应该在后，函数应该返回一个大于0的数值。并且，假设两个值相等（也就是说，它们的顺序无关紧要），函数应该返回0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">33</span>, <span class="number">4</span>, <span class="number">1111</span>, <span class="number">222</span>];</span><br><span class="line">a.sort();                               <span class="comment">// [1111, 222, 33, 4]</span></span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);                                     <span class="comment">// [4, 33, 222, 1111]</span></span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b - a;               </span><br><span class="line">&#125;);                                     <span class="comment">// [1111, 222, 33, 4]</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意，这里使用匿名函数表达式非常方便，既然比较函数只使用一次，就没必要给它们命名了</p></blockquote><h4 id="4-concat"><a href="#4-concat" class="headerlink" title="4. concat()"></a>4. concat()</h4><p>Array.concat()方法创建并返回一个新书组，它的元素包括调用concat()的原是数组的元素和concat()的每个参数。如果这些参数中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，concat()不会递归扁平化的数组，concat()也不会修改调用的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.concat(<span class="number">4</span>, <span class="number">5</span>);                         <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>, <span class="number">5</span>]);                       <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>]);               <span class="comment">// [1,2,3,4,5,6,7]</span></span><br><span class="line">a.concat(<span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]]);               <span class="comment">// [1,2,3,4,5,[6,7]]</span></span><br></pre></td></tr></table></figure><h4 id="5-slice"><a href="#5-slice" class="headerlink" title="5. slice()"></a>5. slice()</h4><p>Array.slice()方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束位置。返回的数组包含第一个参数指定的位置和所有到但不含第二个参数指定的位置之间的所有数组元素。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如参数中出现负数，它表示相对于数组的最后一个元素的位置。</p><p>注意，slice()方法不会修改调用的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.slice(<span class="number">0</span>, <span class="number">3</span>);                          <span class="comment">// [1,2,3]</span></span><br><span class="line">a.slice(<span class="number">3</span>);                             <span class="comment">// [4,5]</span></span><br><span class="line">a.slice(<span class="number">1</span>, <span class="number">-1</span>);                         <span class="comment">// [2,3,4]</span></span><br><span class="line">a.slice(<span class="number">-3</span>, <span class="number">-2</span>);                        <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure><h4 id="6-splice"><a href="#6-splice" class="headerlink" title="6. splice()"></a>6. splice()</h4><p>Array.splice()方法是在数组中插入或删除元素的通用方法，不同于slice()和concat()，splice()会修改调用的数组。</p><p>splice()能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其它部分仍然保持连续的。splice()第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素的个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。splice()返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">a.splice(<span class="number">4</span>);                            <span class="comment">// return [5,6,7,8]  a = [1,2,3,4]</span></span><br><span class="line">a.splice(<span class="number">1</span>, <span class="number">2</span>);                         <span class="comment">// return [2,3]  a = [1,4]</span></span><br><span class="line">a.splice(<span class="number">1</span>, <span class="number">1</span>);                         <span class="comment">// return [4]  a = [1]</span></span><br></pre></td></tr></table></figure><p>splice()的前两个参数指定了需要删除的数组元素，紧随其后的任意个数的参数指定了需要插入到数组的元素，从第一个参数指定的位置开始插入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'b'</span>);               <span class="comment">// return []  a = [1,2,'a','b',3,4,5]</span></span><br><span class="line">a.splice(<span class="number">2</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>);              <span class="comment">// return ['a', 'b']  a = [1,2,[1,2],3,3,4,5]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，区别于concat()，splice()会插入数组本身，而非数组的元素</p></blockquote><h4 id="7-push-和pop"><a href="#7-push-和pop" class="headerlink" title="7. push()和pop()"></a>7. push()和pop()</h4><p>push()和pop()方法允许将数组当作栈来使用。push()方法在数组的尾部添加一个或多个元素，并返回数组新的长度。pop()方法则相反，它删除数组的最后一个元素，减小数组长度并返回它删除的值。组合使用push()和pop()能够用JavaScript数组实现先进后出的栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = [];</span><br><span class="line">stack.push(<span class="number">1</span>, <span class="number">2</span>);                       <span class="comment">// return 2  stack = [1,2]</span></span><br><span class="line">stack.pop();                            <span class="comment">// return 2  stack = [1]</span></span><br><span class="line">stack.push(<span class="number">3</span>);                          <span class="comment">// return 2  stack = [1,3]</span></span><br><span class="line">stack.pop();                            <span class="comment">// return 3  stack = [1]</span></span><br><span class="line">stack.push([<span class="number">4</span>, <span class="number">5</span>]);                     <span class="comment">// return 2  stack = [1,[4,5]]</span></span><br><span class="line">stack.pop();                            <span class="comment">// return [4,5]  stack = [1]</span></span><br><span class="line">stack.pop();                            <span class="comment">// return 1  stack = []</span></span><br></pre></td></tr></table></figure><h4 id="8-unshift-和shift"><a href="#8-unshift-和shift" class="headerlink" title="8. unshift()和shift()"></a>8. unshift()和shift()</h4><p>unshift()和shift()方法的行为类似于push()和pop()，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">a.unshift(<span class="number">1</span>);                           <span class="comment">// return 1  a = [1]</span></span><br><span class="line">a.unshift(<span class="number">22</span>);                          <span class="comment">// return 2  a = [22,1]</span></span><br><span class="line">a.shift();                              <span class="comment">// return 22  a = [1]</span></span><br><span class="line">a.unshift(<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]);                   <span class="comment">// return 3  a = [3,[4,5],1]</span></span><br><span class="line">a.shift();                              <span class="comment">// return 3  a = [[4,5],1]</span></span><br><span class="line">a.shift();                              <span class="comment">// return [4,5]  a = [1]</span></span><br><span class="line">a.shift();                              <span class="comment">// return 1  a = []</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，当使用多个参数调用unshift()时，参数是一次性插入的，而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致。</p></blockquote><h4 id="9-toString-和toLocaleString"><a href="#9-toString-和toLocaleString" class="headerlink" title="9. toString()和toLocaleString()"></a>9. toString()和toLocaleString()</h4><p>数组和其他JavaScript对象一样拥有toString()方法。针对数组，该方法将其每个元素转化为字符串（如有必要将调用元素的toString()方法）并且输出用逗号分隔的字符串列表。注意，输出不包括方括号或其他任何形式的包裹数组值的分隔符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toString();                     <span class="comment">// '1,2,3'</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].toString();               <span class="comment">// 'a,b,c'</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, <span class="string">'c'</span>]].toString();                 <span class="comment">// '1,2,c'</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，这里与不使用任何参数调用join()方法返回的字符串是一样的</p></blockquote><p>toLocaleString()是toString()方法的本地化版本，它调用元素的toLocaleString()方法将每个数组元素转化为字符串，并且使用本地化（和自定义实现的）分隔符将这些字符串连接起来生成最终的字符串</p><hr><h3 id="九、ES5中的数组方法"><a href="#九、ES5中的数组方法" class="headerlink" title="九、ES5中的数组方法"></a>九、ES5中的数组方法</h3><p>ES5定义了9个新的数组方法来遍历、映射、过滤、检测、简化和搜索数组。</p><p>ES5数组方法大多数的第一个参数接收一个函数，并且对数组的每个元素调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。在大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。第二个参数是可选的，如果由第二个参数，则调用的函数被看作是第二个参数的方法，也就是说，在调用函数时传递进度的第二个参数作为它的this关键字的值来使用。</p><h4 id="1-forEach"><a href="#1-forEach" class="headerlink" title="1. forEach()"></a>1. forEach()</h4><p>forEach()方法从头至尾遍历数组，为每个元素调用指定的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    sum += value;</span><br><span class="line">&#125;);</span><br><span class="line">sum;                                        <span class="comment">// =&gt; 15</span></span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v, i, a</span>) </span>&#123;</span><br><span class="line">    a[i] = v + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">data;                                       <span class="comment">// =&gt; [2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，forEach()无法在所有元素都传递给调用的函数之前中止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach()方法放在一个try块中，并能抛出一个异常。如果forEach()调用的函数抛出foreach.break异常，循环会提前终止</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foreach</span>(<span class="params">a, f, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        a.forEach(f, t);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e === foreach.break)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach.break = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'StopIteration'</span>);</span><br></pre></td></tr></table></figure><h4 id="2-map"><a href="#2-map" class="headerlink" title="2. map()"></a>2. map()</h4><p>map()方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">b = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);                                         <span class="comment">// b = [1,4,9]</span></span><br></pre></td></tr></table></figure><p>传递给map()的函数的调用方式和传递给forEach()的函数的调用方式一样。但传递给map()的函数应该由返回值。注意，map()返回的是新书组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素。</p><h4 id="3-filter"><a href="#3-filter" class="headerlink" title="3. filter()"></a>3. filter()</h4><p>filter()方法返回的数组元素是调用的数组的一个子集。传递的函数用来逻辑判定的：该函数返回true或false。调用判定函数就像调用forEach()和map()一样。如果返回值为true或能转化为true的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">smallvalues = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">3</span>; &#125;);          <span class="comment">// [2,1]</span></span><br><span class="line">everyother = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x, i</span>) </span>&#123; <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>; &#125;);   <span class="comment">// [5,3,1]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，filter()会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺，代码如下</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dense = sparse.filter(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;);</span><br></pre></td></tr></table></figure><p>甚至，压缩空缺并删除undefined和null元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x !== <span class="literal">undefined</span> &amp;&amp; x !== <span class="literal">null</span>; &#125;);</span><br></pre></td></tr></table></figure><h4 id="4-every-和some"><a href="#4-every-和some" class="headerlink" title="4. every()和some()"></a>4. every()和some()</h4><p>every()和some()方法是数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回true或false。</p><p>every()方法就像数学中的“针对所有”的量词：当且仅当针对数组中的所有元素调用判定方法都返回true，它才返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">10</span>; &#125;);        <span class="comment">// true  所有值都&lt;10</span></span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>; &#125;);   <span class="comment">// false  不是所有值都是偶数</span></span><br></pre></td></tr></table></figure><p>some()方法就像数学中的“存在”的量词：当数组中至少有一个元素调用判定函数返回true，它就返回true；并且当且仅当数值中的所有元素调用判定函数都返回false，它才返回false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>; &#125;);    <span class="comment">// true  a含有偶数值</span></span><br><span class="line">a.some(<span class="built_in">isNaN</span>);                                  <span class="comment">// false  a不包含非数值元素</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，一旦every()和some()确认该返回什么值它们就会停止遍历数组元素。some()在判定函数第一次返回true后就返回true，但如果判定函数一直返回false，它将会遍历整个数组。every()恰好相反：它在判定函数第一次返回false后就返回false，但如果判定函数一直返回true，它将会遍历整个数组。</p><p>根据数学上的惯例，在空数组上调用时，every()返回true，some()返回false</p></blockquote><h4 id="5-reduce-和reduceRight"><a href="#5-reduce-和reduceRight" class="headerlink" title="5. reduce()和reduceRight()"></a>5. reduce()和reduceRight()</h4><p>reduce()和reduceRight()方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作，也可以称为“注入”和“折叠”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;, <span class="number">0</span>);        <span class="comment">// 数组求和</span></span><br><span class="line"><span class="keyword">var</span> product = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x * y; &#125;, <span class="number">1</span>);    <span class="comment">// 数组求积</span></span><br><span class="line"><span class="keyword">var</span> max = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> (x &gt; y) ? x: y; &#125;);  <span class="comment">// 求最大值</span></span><br></pre></td></tr></table></figure><p>reduce()需要两个参数，第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简后的值。上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的参数是一个传递给函数的初始值。</p><p>当不指定初始值调用reduce()时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就是用了第一个和第二个数组元素作为其第一个和第二个参数。在上面求和与求积的例子中，可以省略初始值参数。</p><p>在空数组上，不带初始值参数调用reduce()将导致类型错误异常。如果调用它的时候只有一个值——数组只有一个元素并且没有指定初始值，或者有一个空数组并且指定一个初始值——reduce()只是简单地返回那个值而不会调用化简函数。</p><p>reduceRight()的工作原理和reduce()一样，不同的是它按照数组索引从高到低处理数组，而不是从低到高。</p><p>在对象章节中，我们定义了一个union()函数，它计算两个对象的“并集”，并返回另一个新对象，新对象具有二者的属性。该函数期待两个对象并返回另一个对象，所以它的工作原理和一个化简函数一样，并且可以使用reduce()来把它一般化，计算任意数目的对象的“并集”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">y</span>:<span class="number">2</span>&#125;, &#123;<span class="attr">z</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> merged = objects.reduce(union);                     <span class="comment">// &#123;x:1, y:2, z:3&#125;</span></span><br></pre></td></tr></table></figure><p>当两个对象拥有同名的属性时，union()函数使用了第一个参数的属性值，这样，reduce()和reduceRight()在使用union()时给出了不同的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">a</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">y</span>:<span class="number">2</span>, <span class="attr">a</span>:<span class="number">2</span>&#125;, &#123;<span class="attr">z</span>:<span class="number">3</span>, <span class="attr">a</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> leftunion = objects.reduce(union);                  <span class="comment">// &#123;x:1, y:2, z:3, a:1&#125;</span></span><br><span class="line"><span class="keyword">var</span> rightunion = objects.reduce(union);                 <span class="comment">// &#123;x:2, y:2, z:3, a:3&#125;</span></span><br></pre></td></tr></table></figure><h4 id="6-indexOf-和lastIndexOf"><a href="#6-indexOf-和lastIndexOf" class="headerlink" title="6. indexOf()和lastIndexOf()"></a>6. indexOf()和lastIndexOf()</h4><p>indexOf()和lastIndexOf()搜索整个数组中具有给定值的元素，返回找到的第一个或最后一个元素的索引，如果没有找到就返回-1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>];</span><br><span class="line">a.indexOf(<span class="number">1</span>);                               <span class="comment">// 1  a[1] == 1</span></span><br><span class="line">a.lastIndexOf(<span class="number">1</span>);                           <span class="comment">// 3  a[3] == 1</span></span><br><span class="line">a.indeOf(<span class="number">3</span>);                                <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p>indexOf()和lastIndexOf()方法不接收函数作为其参数，第一个参数是需要搜索的值，第二个参数是可选的，它指定数组中的一个索引，从指定位置开始搜索。第二个参数也可以是负数，它代表数组末尾的偏移量。</p><blockquote><p>注意，字符串也有indexOf()和lastIndexOf()方法，它们和数组方法的功能类似</p></blockquote><hr><h3 id="十、数组类型"><a href="#十、数组类型" class="headerlink" title="十、数组类型"></a>十、数组类型</h3><p>在ES5中，可以使用Array.isArray()函数来判断未知的对象是否为数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([]);                          <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;);                          <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>ES5以前，要区分数组和非数组对象却令人惊讶地困难。typeof操作符对数组返回“对象”（并且对于除了函数以外的所有对象都是如此）。instanceof操作符只能用于简单的情形</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>;                        <span class="comment">// true</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Array</span>;                      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>使用instanceof的问题是在web浏览器中有可能由多个窗口或窗体(frame)存在，每个窗口都有自己的JavaScript环境，有自己的全局对象。并且，每个全局对象有自己的一组构造函数。因此一个窗体中的对象将不可能是另外窗体中的构造函数的实例。窗体之间的混淆不常发生，但这个问题足以证明instanceof操作符不能视为一个可靠的数组检测方法。</p><p>解决方案是检查对象的类属性，对数组而言该属性的值总是“Array”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = <span class="built_in">Function</span>.isArray || <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> o === <span class="string">'object'</span> &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(o) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="十一、类数组对象"><a href="#十一、类数组对象" class="headerlink" title="十一、类数组对象"></a>十一、类数组对象</h3><p>我们已经看到，JavaScript数组的有一些特性是其他对象所没有的：</p><ul><li><p>当有新的元素添加到列表中时，自动更新length属性</p></li><li><p>设置length为一个较小值将截断数组</p></li><li><p>从Array.prototype中继承一些有用的方法</p></li><li><p>其类属性为“Array”</p></li></ul><p>这些特性让JavaScript数组和常规的对象有明显的区别，但是它们不是定义数组的本质特性。一种常常完全合理的看法把拥有一个数值length属性和对应非负整数属性的对象看作一种类型的数组。</p><p>实践中这些“类数组”对象实际上偶尔出现，虽然不能在它们之上直接调用数组方法或者期望length属性有什么特殊的行为，但是仍然可以用针对真正数组遍历的代码来遍历它们。结论就是很多数组算法针对类数组对象工作得很好，就像针对真正的数组一样。如果算法把数组看成只读的或者如果它们至少保持数组长度不变，也尤其是这种情况。以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的“元素”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="comment">// 添加一些属性，称为“类数组”</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">a.length = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，当作真正的数组遍历它</span></span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">    total += a[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，Arguments对象就是一个类数组对象。在客户端JavaScript中，一些dom方法（如document.getElementsByTagName()）也返回类数组对象。下面有一个函数可以用来检测类数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判定o是否是一个类数组对象</span></span><br><span class="line"><span class="comment">字符串和函数有length属性，但是它们可以用typeof检测将其排除。</span></span><br><span class="line"><span class="comment">在客户端JavaScript中，dom文本节点也有length属性，需要用额外判断o.nodeType != 3将其排除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp;                                        <span class="comment">// o不是null、undefined</span></span><br><span class="line">        <span class="keyword">typeof</span> o === <span class="string">'object'</span> &amp;&amp;                    <span class="comment">// o是对象</span></span><br><span class="line">        <span class="built_in">isFinite</span>(o.length) &amp;&amp;                       <span class="comment">// o.length是有限数值</span></span><br><span class="line">        o.length &gt;= <span class="number">0</span> &amp;&amp;                            <span class="comment">// o.length为非负值</span></span><br><span class="line">        o.length === <span class="built_in">Math</span>.floor(o.length) &amp;&amp;        <span class="comment">// o.length是整数</span></span><br><span class="line">        o.length &lt; <span class="number">4294967296</span>&gt;)                     <span class="comment">// o.length &lt; 2e32</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后文中我们可以看到在ES5中字符串的行为与数组类似，然而，类似上述的类数组对象的检测方法针对字符串常常返回false——它们最好当作字符串处理，而非数组。</p><p>JavaScript数组方法是特意定义为通用的，因此它们不仅应用在真正的数组而且在类数组对象上都能正确工作。除了toString()和toLocaleString()以外的方法都是通用的。</p><p>concat()方法是一个特例，虽然可以用在类数组对象上，但它没有将那个对象扩充进返回的数组中。</p><p>既然类数组对象没有继承自Array.prototype，那就不能在它们上面直接调用数组方法。尽管如此，可以间接地使用Function.call方法调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="string">'0'</span>: <span class="string">'a'</span>, <span class="string">'1'</span>: <span class="string">'b'</span>, <span class="string">'3'</span>: <span class="string">'c'</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(a, <span class="string">'+'</span>);                  <span class="comment">// 'a+b+c'</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(a, <span class="number">0</span>);                   <span class="comment">// ['a','b','c']  真正数组的副本</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.map.call(a, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.toUpperCase();</span><br><span class="line">&#125;);                                                 <span class="comment">// ['A','B','C']</span></span><br></pre></td></tr></table></figure><hr><h3 id="十二、作为数组的字符串"><a href="#十二、作为数组的字符串" class="headerlink" title="十二、作为数组的字符串"></a>十二、作为数组的字符串</h3><p>在ES5中，字符串的行为类似于只读的数组。除了用charAt()方法来访问单个的字符以外，还可以使用方括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'test'</span>;</span><br><span class="line">s.charAt(<span class="number">0</span>);                                    <span class="comment">// 't'</span></span><br><span class="line">s[<span class="number">1</span>];                                           <span class="comment">// 'e'</span></span><br></pre></td></tr></table></figure><p>当然，针对字符串的typeof操作符仍然返回”string”，但是如果给Array.isArray()传递字符串，它将会返回false。</p><p>可索引的字符串的最大的好处就是简单，用方括号代替了charAt()调用，这样更加简洁、可读并且可能更高效。不仅如此，字符串的行为类似于数组的事实使得通用的数组方法可以应用到字符串上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'JavaScript'</span>;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(s, <span class="string">' '</span>);              <span class="comment">// 'J a v a S c r i p t'</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.filter.call(s, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.match(<span class="regexp">/[^aeiou]/</span>);                 <span class="comment">// 只匹配非元音字母</span></span><br><span class="line">&#125;).join(<span class="string">''</span>);                                    <span class="comment">// 'JvScrpt'</span></span><br></pre></td></tr></table></figure><p>请记住，字符串是不可变值，故当把它们作为数组看待时，它们是只读的。如push()、sort()、reverse()和splice()等数组方法会修改数组，它们在字符串上是无效的。不仅如此，使用数组方法来修改字符串会导致错误：出错的时候没有提示。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组是值的有序集合，每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。JavaScript数组的索引是基于零的32位数，第一个元素的索引为0，最大可能的索引为&lt;code&gt;4 294 967 294&lt;/code&gt;（&lt;code&gt;2e32-2&lt;/code&gt;），数组最大能容纳&lt;code&gt;4 294 967 295&lt;/code&gt;个元素。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript数组" scheme="http://www.xiaoleon.cn/tags/JavaScript%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
