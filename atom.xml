<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张啸</title>
  
  <subtitle>世界上最快乐的事，莫过于为理想而奋斗。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaoleon.cn/"/>
  <updated>2019-05-13T09:48:55.445Z</updated>
  <id>http://www.xiaoleon.cn/</id>
  
  <author>
    <name>Leon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PMP(13) 项目相关方管理</title>
    <link href="http://www.xiaoleon.cn/2019/05/10/pmp-13/"/>
    <id>http://www.xiaoleon.cn/2019/05/10/pmp-13/</id>
    <published>2019-05-10T09:25:38.000Z</published>
    <updated>2019-05-13T09:48:55.445Z</updated>
    
    <content type="html"><![CDATA[<p>项目相关方管理包括用于开展下列工作的各个过程：识别能够影响项目或受项目影响的人员、团体或组织，分析相关方对项目的期望和影响，制定合适的管理策略来有效调动相关方参与项目决策和执行。用这些过程分析相关方期望，评估他们对项目或受项目影响的程度，以及制定策略来有效引导相关方支持项目决策、规划和执行。这些过程能够支持项目团队的工作。</p><a id="more"></a><p>项目相关方管理的过程是：</p><ul><li><p><strong>识别相关方</strong> —— 识别相关方是定期识别项目相关方，分析和记录他们的利益、参与度、相互依赖型、影响力和对项目成功的潜在影响的过程。</p></li><li><p><strong>规划相关方参与</strong> —— 规划相关方参与是根据相关方的需求、期望、利益和对项目的潜在影响，制定项目相关方参与项目的方法的过程。</p></li><li><p><strong>管理相关方参与</strong> —— 管理相关方参与始于相关方进行沟通和协作，以满足其需求与期望，处理问题，并促进相关方合理参与的过程。</p></li><li><p><strong>监督相关方参与</strong> —— 监督项目相关方关系，并通过修订参与策略和计划来引导相关方合理参与项目的过程。</p></li></ul><p>图13-1概括了项目相关方管理的各个过程。虽然在本《PMBOK指南》中，各项目相关方管理过程以界限分明和相互独立的形式出现，但在实践中它们会以本指南无法全面详述的方式相互交叠和相互作用。</p><p><img src="/images/pmp-13/13-1.png" alt="项目相关方管理概述"></p><p><strong>项目相关方管理的核心概念</strong></p><p>每个项目都有相关方，他们会受项目的积极或消极影响，或者能对项目施加积极或消极的影响。有些相关方影响项目工作或成果的能力有限，而有些相关方可能对项目对及其期望成果有重大影响。关于重大项目灾难的学术研究及分析强调了结构化方法对识别所有相关方、进行相关方优先级排序，以及引导相关方参与的重要性。项目经理和团队正确识别并合理引导所有相关方参与的能力，能决定着项目的成败。为提高成功的可能性，应该在项目章程被批准、项目经理被委任，以及团队开始组建之后，尽早开始识别相关方并引导相关方参与。</p><p>相关方满意度应作为项目目标加以识别和管理。有效引导相关方参与的关键是重视与所有相关方保持持续沟通（包括团队成员），以理解他们的需求和期望、处理所发生的问题、管理利益冲突，并促进相关方参与项目决策和活动。</p><p>为了实现项目收益，识别相关方和引导相关方参与的过程需要迭代开展。虽然在项目相关方管理中仅对这些过程讨论一次，但是，应该经常开展识别相关方、排列其优先级以及引导其参与等活动。至少要在以下时点开展这些活动：</p><ul><li><p>项目进入其生命周期的不同阶段；</p></li><li><p>当前相关方不再与项目工作有关，或者在项目的相关方社区中出现了新的相关方成员；</p></li><li><p>组织内部或更大区域的相关方社区发生重大变化。</p></li></ul><p><strong>项目相关方管理的发展趋势和新兴实践</strong></p><p>“相关方”一词的外延正在扩大，从传统意义上的员工、供应商和股东扩展到涵盖各式群体，包括监管机构、游说团队、环保人士、金融组织、媒体，以及那些自认为是相关方的人员（他们认为自己会受项目工作或成果的影响）。</p><p>项目相关方管理的发展趋势和新兴实践包括（但不限于）：</p><ul><li><p>识别所有相关方，而非在限定范围内；</p></li><li><p>确保所有团队成员都涉及引导相关方参与的活动；</p></li><li><p>定期审查相关方社区，往往与单个项目风险的审查并行开展；</p></li><li><p>应用“共创”概念，咨询最受项目工作或成果影响的相关方。该概念的重点是，将团队内受影响的相关方视为合作伙伴；</p></li><li><p>关注与相关方有效参与程度有关的正面及负面价值。正面价值是相关方（尤其是强大相关方）对项目的更积极支持所带来的效益；负面价值是因相关方未有效参与而造成的真实成本，包括产品召回、组织信誉损失或项目信誉损失。</p></li></ul><p><strong>裁剪时需要考虑的因素</strong></p><p>因为每个项目都是独特的，所以项目经理需要裁剪项目相关方管理过程。裁剪时应考虑的因素包括（但不限于）：</p><ul><li><p>相关方多样性。现有多少相关方？相关方群体中的文化多样性如何？</p></li><li><p>相关方关系的复杂性。相关方社区内的关系有多复杂？相关方或相关方群体加入的网络越多，与其相关的信息或误传网络就越复杂。</p></li><li><p>沟通技术。有哪些可用的沟通技术？为了实现技术的最大价值，目前采用怎样的支持机制？</p></li></ul><p><strong>在敏捷或适应型环境中需要考虑的因素</strong></p><p>高度变化的项目更需要项目相关方的有效互动和参与。为了开展及时且高效的讨论及决策，适应型团队会直接与相关方互动，而不是通过层层的管理级别。客户、用户和开发人员在动态的共创过程中交换信息，通常能实现更高的相关方参与和满意程度。在整个项目期间保持与相关方社区的互动，有利于降低风险、建立信任和尽早做出项目调整，从而节约成本，提高项目成功的可能性。</p><p>为加快组织内部和组织之间的信息分享，敏捷型方法提倡高度透明。例如，邀请所有相关方参与项目会议和审查，或将项目工件发布到公共空间，其目的在于让各方之间的不一致和依赖关系，或者与不断变化的项目有关的其它问题，都尽快浮现。</p><h3 id="一、识别相关方"><a href="#一、识别相关方" class="headerlink" title="一、识别相关方"></a>一、识别相关方</h3><p>识别相关方是定期识别项目相关方，分析和记录他们的利益、参与度、相互依赖型、影响力和对项目成功的潜在影响的过程。本过程的主要作用是，使项目团队能够建立对每个相关方或相关方群体的适度关注。本过程应根据需要在整个项目期间定期开展。图13-2描述本过程的输入、工具与技术和输出。图13-3是本过程的数据流向图。</p><p><img src="/image/pmp-13/13-2.png" alt="识别相关方：输入、工具与技术和输出"></p><p><img src="/image/pmp-13/13-3.png" alt="识别相关方：数据流向图"></p><p>本过程通常在编制和批准项目章程之前或同时首次开展。本过程需在必要时重复开展，至少应在每个阶段开始时，以及项目或组织出现重大变化时重复开展。每次重复开展本过程，都应通过查阅项目管理计划组件及项目文件，来识别有关的项目相关方。</p><h4 id="1-1-识别相关方：输入"><a href="#1-1-识别相关方：输入" class="headerlink" title="1.1 识别相关方：输入"></a>1.1 识别相关方：输入</h4><h5 id="1-1-1-项目章程"><a href="#1-1-1-项目章程" class="headerlink" title="1.1.1 项目章程"></a>1.1.1 项目章程</h5><p>项目章程会列出关键相关方清单，还可能包含与相关方职责有关的信息。</p><h5 id="1-1-2-商业文件"><a href="#1-1-2-商业文件" class="headerlink" title="1.1.2 商业文件"></a>1.1.2 商业文件</h5><p>在首次开展识别相关方过程时，商业文件和收益管理计划是项目相关方信息的来源。</p><ul><li><p>商业论证。商业论证确定项目目标，以及受项目影响的相关方的最初清单。</p></li><li><p>后以管理计划。收益管理计划描述了如何实现商业论证中所述收益。它可能指出姜葱项目成果交付中获益并因此被视为相关方的个人及群体。</p></li></ul><h5 id="1-1-3-项目管理计划"><a href="#1-1-3-项目管理计划" class="headerlink" title="1.1.3 项目管理计划"></a>1.1.3 项目管理计划</h5><p>在首次识别相关方时，项目管理计划并不存在；不过，一旦编制完成，项目管理计划组件包括（但不限于）：</p><ul><li><p>沟通管理计划。沟通与相关方参与之间存在密切联系。沟通管理计划中的信息是了解项目相关方的主要依据。</p></li><li><p>相关方参与计划。相关方参与计划确定了用于有效引导相关方参与的管理策略和措施。</p></li></ul><h5 id="1-1-4-项目文件"><a href="#1-1-4-项目文件" class="headerlink" title="1.1.4 项目文件"></a>1.1.4 项目文件</h5><p>并非任何项目文件都将成为首次识别相关方的输入。然而，需要在整个项目期间识别相关方。项目经理启动阶段以后，将会生成更多项目文件，用于后续的项目阶段。可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>变更日志。变更日志可能引入新的相关方，或改变相关方与项目的现有关系的性质。</p></li><li><p>问题日志。问题日志所记录的问题可能为项目带来新的相关方，或改变现有相关方的参与类型。</p></li><li><p>需求文件。需求文件可以提供关于潜在相关方的信息。</p></li></ul><h5 id="1-1-5-协议"><a href="#1-1-5-协议" class="headerlink" title="1.1.5 协议"></a>1.1.5 协议</h5><p>协议的各方都是项目相关方，还可涉及其他相关方。</p><h5 id="1-1-6-事业环境因素"><a href="#1-1-6-事业环境因素" class="headerlink" title="1.1.6 事业环境因素"></a>1.1.6 事业环境因素</h5><p>能够影响识别相关方过程的事业环境因素包括（但不限于）：</p><ul><li><p>组织文化、政治氛围，以及治理框架；</p></li><li><p>政府或行业标准（法规、产品标准和行为规范）；</p></li><li><p>全球、区域或当地的趋势、实践或习惯；</p></li><li><p>设施和资源的地理分布。</p></li></ul><h5 id="1-1-7-组织过程资产"><a href="#1-1-7-组织过程资产" class="headerlink" title="1.1.7 组织过程资产"></a>1.1.7 组织过程资产</h5><p>能够影响识别相关方过程的组织过程资产包括（但不限于）：</p><ul><li><p>相关方登记册模板和说明；</p></li><li><p>以往项目的相关方登记册；</p></li><li><p>经验教训知识库，包括与相关方偏好、行动和参与有关的信息。</p></li></ul><h4 id="1-2-识别相关方：工具与技术"><a href="#1-2-识别相关方：工具与技术" class="headerlink" title="1.2 识别相关方：工具与技术"></a>1.2 识别相关方：工具与技术</h4><h5 id="1-2-1-专家判断"><a href="#1-2-1-专家判断" class="headerlink" title="1.2.1 专家判断"></a>1.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>理解组织内的政治和权力结构；</p></li><li><p>了解所在组织和其他受影响组织（包括客户及其他组织）的环境和文化；</p></li><li><p>了解项目所在行业或项目可交付成果类型；</p></li><li><p>了解个体团队成员的贡献和专长。</p></li></ul><h5 id="1-2-2-数据收集"><a href="#1-2-2-数据收集" class="headerlink" title="1.2.2 数据收集"></a>1.2.2 数据收集</h5><p>适用于本过程的数据收集技术包括（但不限于）：</p><ul><li><p>问卷和调查。问卷和调查可以包括一对一调查、焦点小组讨论，或其他大规模信息收集技术。</p></li><li><p>头脑风暴。用于识别相关方的头脑风暴技术包括头脑风暴和头脑写作。</p><ul><li><p>头脑风暴。一种通用的数据收集和创意技术，用于向小组征求意见，如团队成员或主题专家。</p></li><li><p>头脑写作。头脑风暴的改良形式，让个人参与者有时间在小组创意讨论开始前单独思考问题。信息可通过面对面小组会议收集，或在由技术支持的虚拟环境中收集。</p></li></ul></li></ul><h5 id="1-2-3-数据分析"><a href="#1-2-3-数据分析" class="headerlink" title="1.2.3 数据分析"></a>1.2.3 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）：</p><ul><li><p>相关方分析。相关方分析会产生相关方清单和关于相关方的各种信息，例如，在组织内的位置、在项目中的角色、与项目的利害关系、期望、态度（对项目的支持程度），以及对项目信息的兴趣。相关方的利害关系可包括（但不限于）以下各条的组合：</p><ul><li><p>兴趣。个人或群体会受与项目有关的决策或成果的影响。</p></li><li><p>权利（合法权利或道德权利）。国家的法律框架可能已就相关方的合法权利作出规定，如职业健康和安全。道德权利可能涉及保护历史遗迹或环境的可持续性。</p></li><li><p>所有权。人员或群体对资产或财产拥有的法定所有权。</p></li><li><p>知识。专业知识有助于更有效地达成项目目标和组织成果，或有助于了解组织的权力结构，从而有益于项目。</p></li><li><p>贡献。提供资金或其他资源，包括人力资源，或者以无形方式为项目提供支持，例如，宣传项目目标，或在项目与组织权力结构及政治之间扮演缓冲角色。</p></li></ul></li><li><p>文件分析。评估现有项目文件及以往项目的经验教训，以识别相关方和其他支持性信息。</p></li></ul><h5 id="1-2-4-数据表现"><a href="#1-2-4-数据表现" class="headerlink" title="1.2.4 数据表现"></a>1.2.4 数据表现</h5><p>适用于本过程的数据表现技术包括（但不限于）相关方映射分析/表现。相关方映射分析和表现是一种利用不同方法对相关方进行分类的方法。对相关方进行分类有助于团队与已识别的项目相关方建立关系。常见的分类方法包括：</p><ul><li><p>权力利益方格、权力影响方格，或作用影响方格。基于相关方的职权级别（权力）、对项目成果的关心程度（利益）、对项目成果的影响能力（影响），或改变项目计划或执行的能力，每一种方格都可用于对相关方进行分类。对于小型项目、相关方与项目的关系很简单的项目，或相关方之间的关系很简单的项目，这些分类模型非常实用。</p></li><li><p>相关方立方体。这是上述方格模型的改良形式。本立方体把上述方格中的要素组合成三维模型，项目经理和团队可据此分析相关方并引导相关方参与项目。作为一个多维模型，它将相关方视为一个多维实体，更好地加以分析，从而有助于沟通策略的制定。</p></li><li><p>凸显模型。通过评估相关方的权力（职权级别或对项目成果的影响能力）、紧迫性（因时间约束或相关方对项目成果有重大利益诉求而导致需立即加以关注）和合法性（参与的适当性），对相关方进行分类。在凸显模型中，也可以用邻近性取代合法性，以便考察相关方参与项目工作的程度。这种凸显模型适用于复杂的相关方大型社区，或在相关方社区内部存在复杂的关系网络。凸显模型可用于确定已识别相关方的相对重要性。</p></li><li><p>影响方向。可以根据相关方对项目工作或项目团队本身的影响方向，对相关方进行分类。可以把相关方分类为：</p><ul><li><p>向上（执行组织或客户组织、发起人和指导委员会的高层级管理层）；</p></li><li><p>向下（临时贡献知识或技能的团队或专家）；</p></li><li><p>向外（项目团队外的相关方群体及其代表，如供应商、政府部门、公众、最终用户和监管部门）；</p></li><li><p>横向（项目经理的同级人员，如其他项目经理或中层管理人员，他们与项目经理竞争稀缺项目资源或者合作共享资源或信息）。</p></li></ul></li><li><p>优先级排序。如果项目有大量相关方、相关方社区的成员频繁变化，相关方和项目团队之间或相关方社区内部的关系复杂，可能有必要对相关方进行优先级排序。</p></li></ul><h5 id="1-2-5-会议"><a href="#1-2-5-会议" class="headerlink" title="1.2.5 会议"></a>1.2.5 会议</h5><p>会议可用于在重要项目相关方之间达成谅解。既可以召开引导式研讨会、指导式小组讨论会，也可以通过电子或媒体技术进行虚拟小组讨论，来分享想法和分析数据。</p><h4 id="1-3-识别相关方：输出"><a href="#1-3-识别相关方：输出" class="headerlink" title="1.3 识别相关方：输出"></a>1.3 识别相关方：输出</h4><h5 id="1-3-1-相关方登记册"><a href="#1-3-1-相关方登记册" class="headerlink" title="1.3.1 相关方登记册"></a>1.3.1 相关方登记册</h5><p>相关方登记册是识别相关方过程的主要输出。它记录关于已识别相关方的信息，包括（但不限于）：</p><ul><li><p>身份信息。姓名、组织职位、地点、联系方式，以及在项目中扮演的角色。</p></li><li><p>评估信息。主要需求、期望、影响项目成果的潜力，以及相关方最能影响或冲级的项目生命周期阶段。</p></li><li><p>相关方分类。用内部或外部，作用、影响、权力或利益，上级、下级、外围或横向，或者项目经理选择的其他分类模型，进行分类的结果。</p></li></ul><h5 id="1-3-2-变更请求"><a href="#1-3-2-变更请求" class="headerlink" title="1.3.2 变更请求"></a>1.3.2 变更请求</h5><p>首次开展识别相关方过程，不会提出任何变更请求。但随着在后续项目期间继续识别相关方，新出现的相关方或关于现有相关方的新信息可能导致对产品、项目管理计划或项目文件提出变更请求。</p><p>应该通过实施整体变更控制过程对变更请求进行审查和处理。</p><h5 id="1-3-3-项目管理计划更新"><a href="#1-3-3-项目管理计划更新" class="headerlink" title="1.3.3 项目管理计划更新"></a>1.3.3 项目管理计划更新</h5><p>在项目初始时识别相关方，不会导致项目管理计划更新。但随着项目进展，项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更的项目管理计划组件包括（但不限于）：</p><ul><li><p>需求管理计划。新识别的相关方可能会影响规划、跟踪和报告需求活动的方式。</p></li><li><p>沟通管理计划。沟通管理计划记录相关方的沟通要求和已商定的沟通策略。</p></li><li><p>风险管理计划。如果相关方的沟通要求和已商定的沟通策略会影响管理项目风险的方法，就应在风险管理计划中加以反映。</p></li><li><p>相关方参与计划。相关方参与计划记录针对已识别相关方的商定的沟通策略。</p></li></ul><h5 id="1-3-4-项目文件更新"><a href="#1-3-4-项目文件更新" class="headerlink" title="1.3.4 项目文件更新"></a>1.3.4 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>假设日志。大量关于相对权力、利益和相关方参与度的信息，都是基于一定的假设条件的。应该在假设日志中记录这些假设条件。此外，还要在假设日志中记录会影响与具体相关方互动的各种制约因素。</p></li><li><p>问题日志。在本过程中产生的新问题应该记录到问题日志中。</p></li><li><p>风险登记册。风险登记册记录在本过程中识别，并通过风险管理过程加以管理的新风险。</p></li></ul><hr><h3 id="二、规划相关方参与"><a href="#二、规划相关方参与" class="headerlink" title="二、规划相关方参与"></a>二、规划相关方参与</h3><p>规划相关方参与是根据相关方的需求、期望、利益和对项目的潜在影响，制定项目相关方参与项目的方法的过程。本过程的主要作用是，提供与相关方进行有效互动的可行计划。本过程应根据需要在整个项目期间定期开展。</p><p>图13-4描述本过程的输入、工具与技术和输出。图13-5是本过程的数据流向图。</p><p><img src="/images/pmp-13/13-4.png" alt="规划相关方参与：输入、工具与技术和输出"></p><p><img src="/images/pmp-13/13-5.png" alt="规划相关方参与：数据流向图"></p><p>为满足项目相关方的多样性信息需求，应该在项目生命周期的早期制定一份有效的计划；然后，随着相关方社区的变化，定期审查和更新该计划。在通过识别相关方过程明确最初的相关方社区之后，就应该编制第一版的相关方参与计划，然后定期更新相关方参与计划，以反映相关方社区的变化。会触发该计划更新的典型情况包括（但不限于）：</p><ul><li><p>项目新阶段开始；</p></li><li><p>组织结构或行业内部发生变化；</p></li><li><p>新的个人或群体成为相关方，现有相关方不再是相关方社区的成员，或特定相关方对项目成功的重要性发生变化；</p></li><li><p>当其他项目过程（如变更管理、风险管理或问题管理）的输出导致需要重新审查相关方参与策略。</p></li></ul><p>这些情况都可能导致已识别相关方的相对重要性发生变化。</p><h4 id="2-1-规划相关方参与：输入"><a href="#2-1-规划相关方参与：输入" class="headerlink" title="2.1 规划相关方参与：输入"></a>2.1 规划相关方参与：输入</h4><h5 id="2-1-1-项目章程"><a href="#2-1-1-项目章程" class="headerlink" title="2.1.1 项目章程"></a>2.1.1 项目章程</h5><p>项目章程包含与项目目的、目标和成功标准有关的信息，在规划如何引导相关方参与项目时应该考虑这些信息。</p><h5 id="2-1-2-项目管理计划"><a href="#2-1-2-项目管理计划" class="headerlink" title="2.1.2 项目管理计划"></a>2.1.2 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>资源管理计划。资源管理计划可能包含关于团队成员及其他相关方的角色和职责的信息。</p></li><li><p>沟通管理计划。用于相关方管理的沟通策略以及用于实施策略的计划，既是项目相关方管理中的各个过程的输入，又会收录癞子这些过程的相关信息。</p></li><li><p>风险管理计划。风险管理计划可能包含风险临界值或风险态度，有助于选择最佳的相关方参与策略组合。</p></li></ul><h5 id="2-1-3-项目文件"><a href="#2-1-3-项目文件" class="headerlink" title="2.1.3 项目文件"></a>2.1.3 项目文件</h5><p>可用作本过程输入的项目文件（尤其在初始规划之后）包括（但不限于）：</p><ul><li><p>假设日志。假设日志中关于假设条件和制约因素的信息，可能与特定相关方相关联。</p></li><li><p>变更日志。变更日志记录了对原始项目范围的变更。变更通常与具体相关方相关联，因为相关方可能是：变更请求的提出者，变更请求的审批者，或受变更实施影响者。</p></li><li><p>问题日志。为了管理和解决问题日志中的问题，需要与受影响的相关方进行额外沟通。</p></li><li><p>项目进度计划。进度计划中的活动可能需要与具体相关方相关联，即把特定相关方指定为活动责任人或执行者。</p></li><li><p>风险登记册。风险登记册包含项目的已识别风险，它通常会把这些风险与具体相关方相关联，即把特定相关方指定为风险责任人或受风险影响者。</p></li><li><p>相关方登记册。相关方登记册提供项目相关方的清单，以及分类情况和其他信息。</p></li></ul><h5 id="2-1-4-协议"><a href="#2-1-4-协议" class="headerlink" title="2.1.4 协议"></a>2.1.4 协议</h5><p>在规划承包商及供应商参与时，通常涉及与组织内的采购小组和（或）合同签署小组开展合作，以确保对承包商和供应商进行有效管理。</p><h5 id="2-1-5-事业环境因素"><a href="#2-1-5-事业环境因素" class="headerlink" title="2.1.5 事业环境因素"></a>2.1.5 事业环境因素</h5><p>能够影响规划相关方参与的事业环境因素包括（但不限于）：</p><ul><li><p>组织文化、政治氛围，以及治理框架；</p></li><li><p>人事管理政策；</p></li><li><p>相关方风险偏好；</p></li><li><p>已确立的沟通渠道；</p></li><li><p>全球、区域或当地的趋势、实践或习惯；</p></li><li><p>设施和资源的地理分布。</p></li></ul><h5 id="2-1-6-组织过程资产"><a href="#2-1-6-组织过程资产" class="headerlink" title="2.1.6 组织过程资产"></a>2.1.6 组织过程资产</h5><p>能够影响规划相关方参与过程的组织过程资产包括（但不限于）：</p><ul><li><p>企业的社交媒体、道德和安全政策及程序；</p></li><li><p>企业的问题、风险、变更和数据管理政策及程序；</p></li><li><p>组织对沟通的要求；</p></li><li><p>制作、交换、储存和检索信息的标准化指南；</p></li><li><p>经验教训知识库，包括与相关方偏好、行动和参与有关的信息；</p></li><li><p>支持有效相关方参与所需的软件工具。</p></li></ul><h4 id="2-2-规划相关方参与：工具与技术"><a href="#2-2-规划相关方参与：工具与技术" class="headerlink" title="2.2 规划相关方参与：工具与技术"></a>2.2 规划相关方参与：工具与技术</h4><h5 id="2-2-1-专家判断"><a href="#2-2-1-专家判断" class="headerlink" title="2.2.1 专家判断"></a>2.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>组织内部及外部的政治和权力结构；</p></li><li><p>组织及组织外部的环境和文化；</p></li><li><p>相关方参与过程使用的分析和评估技术；</p></li><li><p>沟通手段和策略；</p></li><li><p>来自以往项目的关于相关方、相关方群体及相关方组织（他们可能参与过以往的类似项目）的特征的知识。</p></li><li><p>支持有效相关方参与所需的软件工具。</p></li></ul><h4 id="2-2-规划相关方参与：工具与技术-1"><a href="#2-2-规划相关方参与：工具与技术-1" class="headerlink" title="2.2 规划相关方参与：工具与技术"></a>2.2 规划相关方参与：工具与技术</h4><h5 id="2-2-1-专家判断-1"><a href="#2-2-1-专家判断-1" class="headerlink" title="2.2.1 专家判断"></a>2.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>组织内部及外部的政治和权力结构；</p></li><li><p>组织及组织外部的环境和文化；</p></li><li><p>相关方参与过程使用的分析和评估技术；</p></li><li><p>沟通手段和策略；</p></li><li><p>来自以往项目的关于相关方、相关方群体及相关方组织（他们可能参与过以往的类似项目）的特征的知识。</p></li></ul><h5 id="2-2-2-数据收集"><a href="#2-2-2-数据收集" class="headerlink" title="2.2.2 数据收集"></a>2.2.2 数据收集</h5><p>适用于本过程的数据收集技术包括（但不限于）标杆对照。将相关方分析的结果与其它被视为世界级的组织或项目的信息进行比较。</p><h5 id="2-2-3-数据分析"><a href="#2-2-3-数据分析" class="headerlink" title="2.2.3 数据分析"></a>2.2.3 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）：</p><ul><li><p>假设条件和制约因素分析。可能需要分析当前的假设条件和制约因素，以合理剪裁相关方参与策略。</p></li><li><p>根本原因分析。开展根本原因分析，识别是什么根本原因导致了相关方对项目的某种支持水平，以便选择适当策略来改进其参与水平。</p></li></ul><h5 id="2-2-4-决策"><a href="#2-2-4-决策" class="headerlink" title="2.2.4 决策"></a>2.2.4 决策</h5><p>适用于本过程的决策技术包括（但不限于）优先级排序或分级。应该对相关方需求以及相关方本身进行优先级排序或分级。具有最大利益和最高影响的相关方，通常应该排在优先级清单的最前面。</p><h5 id="2-2-5-数据表现"><a href="#2-2-5-数据表现" class="headerlink" title="2.2.5 数据表现"></a>2.2.5 数据表现</h5><p>适用于本过程的数据表现技术包括（但不限于）：</p><ul><li><p>思维导图。思维导图用于对相关方信息、相互关系以及他们与组织的关系进行可视化整理。</p></li><li><p>相关方参与度评估矩阵。相关方参与度评估矩阵用于将相关方当前参与水平与期望参与水平进行比较。对相关方参与水平进行分类的方式之一，如图13-6所示。相关方参与水平可分为如下：</p><ul><li><p>不了解型。不知道项目及其潜在影响。</p></li><li><p>抵制型。指导项目及其潜在影响，但抵制项目工作或成果可能引发的任何变更。此类相关方不会支持项目工作或项目成果。</p></li><li><p>中立型。了解项目，但既不支持，也不反对。</p></li><li><p>支持型。了解项目及其潜在影响，并且会支持项目工作及其成果。</p></li><li><p>领导型。了解项目及其潜在影响，而且积极参与以确保项目取得成功。</p></li></ul></li></ul><p>在图13-6中，C代表每个相关方的当前参与水平，而D是项目团队评估出来的、为确保项目成功所必不可少的参与水平（期望的）。应根据每个相关方的当前与期望参与水平的差距，开展必要的沟通，有效引导相关方参与项目。弥合当前与期望参与水平的差距是监督相关方参与中的一项基本工作。</p><p><img src="/images/pmp-13/13-6.png" alt="相关方参与度评估矩阵"></p><h5 id="2-2-6-会议"><a href="#2-2-6-会议" class="headerlink" title="2.2.6 会议"></a>2.2.6 会议</h5><p>会议用于讨论与分析规划相关方参与过程所需的输入数据，以便制定良好的相关方参与计划。</p><h4 id="2-3-规划相关方参与：输出"><a href="#2-3-规划相关方参与：输出" class="headerlink" title="2.3 规划相关方参与：输出"></a>2.3 规划相关方参与：输出</h4><h5 id="2-3-1-相关方参与计划"><a href="#2-3-1-相关方参与计划" class="headerlink" title="2.3.1 相关方参与计划"></a>2.3.1 相关方参与计划</h5><p>相关方参与计划是项目管理计划的组成部分。它确定用于促进相关方有效参与决策和执行的策略和行动。基于项目的需要和相关方的期望，相关方参与计划可以是正式或非正式的，非常详细或高度概括的。</p><p>相关方参与计划可包括（但不限于）调动个人或相关方参与的特定策略或方法。</p><hr><h3 id="三、管理相关方参与"><a href="#三、管理相关方参与" class="headerlink" title="三、管理相关方参与"></a>三、管理相关方参与</h3><p>管理相关方参与是与相关方进行沟通和协作以满足其需求与期望、处理问题，并促进相关方合理参与的过程。本过程的主要作用是，让项目经理能够提高相关方的支持，并尽可能降低相关方的抵制。本过程需要在整个项目期间开展。图13-7描述本过程的输入、工具与技术和输出。图13-8是本过程的数据流向图。</p><p><img src="/images/pmp-13/13-7.png" alt="管理相关方参与：输入、工具与技术和输出"></p><p><img src="/images/pmp-13/13-8.png" alt="管理相关方参与：数据流向图"></p><p>在管理相关方参与过程中，需要开展多项活动，例如：</p><ul><li><p>在适当的项目阶段引导相关方参与，以便获取、确认或维持他们对项目成功的持续承诺；</p></li><li><p>通过谈判和沟通管理相关方期望；</p></li><li><p>处理与相关方管理有关的任何风险或潜在关注点，预测相关方可能在未来引发的问题；</p></li><li><p>澄清和解决已识别的问题。</p></li></ul><p>管理相关方参与有助于确保相关方明确了解项目目的、目标、收益和风险，以及他们的贡献将如何促进项目成功。</p><h4 id="3-1-管理相关方参与：输入"><a href="#3-1-管理相关方参与：输入" class="headerlink" title="3.1 管理相关方参与：输入"></a>3.1 管理相关方参与：输入</h4><h5 id="3-1-1-项目管理计划"><a href="#3-1-1-项目管理计划" class="headerlink" title="3.1.1 项目管理计划"></a>3.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>沟通管理计划。沟通管理计划描述与相关方沟通的方法、形式和技术。</p></li><li><p>风险管理计划。风险管理计划描述了风险类别、风险偏好和报告格式。这些内容都可用于管理相关方参与。</p></li><li><p>相关方参与计划。相关方参与计划为管理相关方期望提供指导和信息。</p></li><li><p>变更管理计划。变更管理计划描述了提交、评估和执行项目变更的过程。</p></li></ul><h5 id="3-1-2-项目文件"><a href="#3-1-2-项目文件" class="headerlink" title="3.1.2 项目文件"></a>3.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>变更日志。变更日志会记录变更请求及其状态，并将其传递给适当的相关方。</p></li><li><p>问题日志。问题日志会记录项目或相关方的关注点，以及关于处理问题的行动方案。</p></li><li><p>经验教训登记册。在项目早期获取的与管理相关方参与有关的经验教训，可用于项目后期阶段，以提高本过程的效率和效果。</p></li><li><p>相关方登记册。相关方登记册提供项目相关方清单，以及执行相关方参与计划所需的任何信息。</p></li></ul><h5 id="3-1-3-事业环境因素"><a href="#3-1-3-事业环境因素" class="headerlink" title="3.1.3 事业环境因素"></a>3.1.3 事业环境因素</h5><p>能够影响管理相关方参与的事业环境因素包括（但不限于）：</p><ul><li><p>组织文化、政治氛围，以及组织的治理结构；</p></li><li><p>人事管理政策；</p></li><li><p>相关方风险临界值；</p></li><li><p>已确立的沟通渠道；</p></li><li><p>全球、区域或当地的趋势、实践或习惯；</p></li><li><p>设施和资源的地理分布。</p></li></ul><h5 id="3-1-4-组织过程资产"><a href="#3-1-4-组织过程资产" class="headerlink" title="3.1.4 组织过程资产"></a>3.1.4 组织过程资产</h5><p>能够影响管理相关方参与过程的组织过程资产包括（但不限于）：</p><ul><li><p>企业的社交媒体、道德和安全政策及程序；</p></li><li><p>企业的问题、风险、变更和数据管理政策及程序；</p></li><li><p>组织对沟通的要求；</p></li><li><p>制作、交换、储存和检索信息的标准化指南；</p></li><li><p>以往类似项目的历史信息。</p></li></ul><h4 id="3-2-管理相关方参与：工具与技术"><a href="#3-2-管理相关方参与：工具与技术" class="headerlink" title="3.2 管理相关方参与：工具与技术"></a>3.2 管理相关方参与：工具与技术</h4><h5 id="3-2-1-专家判断"><a href="#3-2-1-专家判断" class="headerlink" title="3.2.1 专家判断"></a>3.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>组织内部及外部的政治和权力结构；</p></li><li><p>组织及组织外部的环境和文化；</p></li><li><p>相关方参与过程使用的分析和评估技术；</p></li><li><p>沟通方法和策略；</p></li><li><p>可能参与过以往类似项目的相关方、相关方群体及相关方组织的特征；</p></li><li><p>需求管理、供应商管理和变更管理。</p></li></ul><h5 id="3-2-2-沟通技能"><a href="#3-2-2-沟通技能" class="headerlink" title="3.2.2 沟通技能"></a>3.2.2 沟通技能</h5><p>再开展管理相关方参与过程时，应该根据沟通管理计划，针对每个相关方采取相应的沟通方法。项目管理团队应该使用反馈机制，来了解相关方对各种项目管理活动和关键决策的反应。反馈的收集方式包括（但不限于）：</p><ul><li><p>正式与非正式对话；</p></li><li><p>问题识别和讨论；</p></li><li><p>会议；</p></li><li><p>进展报告；</p></li><li><p>调查。</p></li></ul><h5 id="3-2-3-人际关系与团队技能"><a href="#3-2-3-人际关系与团队技能" class="headerlink" title="3.2.3 人际关系与团队技能"></a>3.2.3 人际关系与团队技能</h5><p>适用于本过程的人际关系与团队技能包括（但不限于）：</p><ul><li><p>冲突管理。项目经理应确保及时解决冲突。</p></li><li><p>文化意识。文化意识有助于项目经理和团队通过考虑文化差异和相关方需求，来实现有效沟通。</p></li><li><p>谈判。谈判用于获得支持或达成关于支持项目工作或成果的协议，并解决团队内部或团队与其他相关方之间的冲突。</p></li><li><p>观察和交谈。通过观察和交谈，及时了解项目团队成员和其他相关方的工作和态度。</p></li><li><p>政治意识。通过了解项目内外的权力关系，建立政治意识。</p></li></ul><h5 id="3-2-4-基本规则"><a href="#3-2-4-基本规则" class="headerlink" title="3.2.4 基本规则"></a>3.2.4 基本规则</h5><p>根据团队章程中定义的基本规则，来明确项目团队成员和其他相关方应该采取什么行为去引导相关方参与。</p><h5 id="3-2-5-会议"><a href="#3-2-5-会议" class="headerlink" title="3.2.5 会议"></a>3.2.5 会议</h5><p>会议用于讨论和处理任何与相关方参与有关的问题或关注点。在本过程中需要召开的会议类型包括（但不限于）：</p><ul><li><p>决策；</p></li><li><p>问题解决；</p></li><li><p>经验教训和回顾总结；</p></li><li><p>项目开工；</p></li><li><p>迭代规划；</p></li><li><p>状态更新。</p></li></ul><h4 id="3-3-管理相关方参与：输出"><a href="#3-3-管理相关方参与：输出" class="headerlink" title="3.3 管理相关方参与：输出"></a>3.3 管理相关方参与：输出</h4><h5 id="3-3-1-变更请求"><a href="#3-3-1-变更请求" class="headerlink" title="3.3.1 变更请求"></a>3.3.1 变更请求</h5><p>作为管理相关方参与的结果，项目范围或产品范围可能需要变更。应该通过实施整体变更控制过程对所有变更请求进行审查和处理。</p><h5 id="3-3-2-项目管理计划更新"><a href="#3-3-2-项目管理计划更新" class="headerlink" title="3.3.2 项目管理计划更新"></a>3.3.2 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更的项目管理计划组件包括（但不限于）：</p><ul><li><p>沟通管理计划。需要更新沟通管理计划，以反映新的或已变更的相关方需求。</p></li><li><p>相关方参与计划。需要更新相关方参与计划，以反映为有效引导相关方参与所需的新的或更改的管理策略。</p></li></ul><h5 id="3-3-3-项目文件更新"><a href="#3-3-3-项目文件更新" class="headerlink" title="3.3.3 项目文件更新"></a>3.3.3 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>变更日志。根据变更请求更新变更日志。</p></li><li><p>问题日志。可能需要更新问题日志，以反映问题日志条目的更新或添加。</p></li><li><p>经验教训登记册。更新经验教训登记册，记录管理相关方参与的有效或无效方法，以供当前或未来项目借鉴。</p></li><li><p>相关方登记册。可能需要基于提供给相关方的关于问题解决、变更审批和项目状态的新信息，来更新相关方的登记册。</p></li></ul><hr><h3 id="四、监督相关方参与"><a href="#四、监督相关方参与" class="headerlink" title="四、监督相关方参与"></a>四、监督相关方参与</h3><p>监督相关方参与是监督项目相关方关系，并通过修订参与策略和计划来引导相关方合理参与项目的过程。本过程的主要作用是，随着项目进展和环境变化，维持或提升相关方参与活动的效率和效果。本过程需要在整个项目期间开展。图13-9描述本过程的输入、工具与技术和输出。图13-10是本过程的数据流向图。</p><p><img src="/images/pmp-13/13-9.png" alt="监督相关方参与：输入、工具与技术和输出"></p><p><img src="/images/pmp-13/13-10.png" alt="监督相关方参与：数据流向图"></p><h4 id="4-1-监督相关方参与：输入"><a href="#4-1-监督相关方参与：输入" class="headerlink" title="4.1 监督相关方参与：输入"></a>4.1 监督相关方参与：输入</h4><h5 id="4-1-1-项目管理计划"><a href="#4-1-1-项目管理计划" class="headerlink" title="4.1.1 项目管理计划"></a>4.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>资源管理计划。资源管理计划确定了对团队成员的管理方法。</p></li><li><p>沟通管理计划。沟通管理计划描述了适用于项目相关方的沟通计划和策略。</p></li><li><p>相关方参与计划。定义了管理相关方需求和期望的计划。</p></li></ul><h5 id="4-1-2-项目文件"><a href="#4-1-2-项目文件" class="headerlink" title="4.1.2 项目文件"></a>4.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>问题日志。问题日志记录了所有与项目和相关方有关的已知问题。</p></li><li><p>经验教训登记册。在项目早期获取的经验教训，可用于项目后期阶段，以提高引导相关方参与的效率和效果。</p></li><li><p>项目沟通记录。根据沟通管理计划和相关方参与计划而与相关方开展的项目沟通，都已包括在项目沟通记录中。</p></li><li><p>风险登记册。风险登记册记录了与相关方参与及互动有关的风险，它们的分类，以及潜在的应对措施。</p></li><li><p>相关方登记册。相关方登记册记录了各种相关方信息，包括（但不限于）：相关方名单、评估结果和分类情况。</p></li></ul><h5 id="4-1-3-工作绩效数据"><a href="#4-1-3-工作绩效数据" class="headerlink" title="4.1.3 工作绩效数据"></a>4.1.3 工作绩效数据</h5><p>工作绩效数据包含项目状态数据，例如，哪些相关方支持项目，他们的参与水平和类型。</p><h5 id="4-1-4-事业环境因素"><a href="#4-1-4-事业环境因素" class="headerlink" title="4.1.4 事业环境因素"></a>4.1.4 事业环境因素</h5><p>能够监督相关方参与过程的事业环境因素包括（但不限于）：</p><ul><li><p>组织文化、政治氛围，以及治理框架；</p></li><li><p>人事管理政策；</p></li><li><p>相关方风险临界值；</p></li><li><p>已确立的沟通渠道；</p></li><li><p>全球、区域或当地的趋势、实践或习惯；</p></li><li><p>设施和资源的地理分布。</p></li></ul><h5 id="4-1-5-组织过程资产"><a href="#4-1-5-组织过程资产" class="headerlink" title="4.1.5 组织过程资产"></a>4.1.5 组织过程资产</h5><p>能够影响监督相关方参与过程的组织过程资产包括（但不限于）：</p><ul><li><p>企业的社交媒体、道德和安全政策及程序；</p></li><li><p>企业的问题、风险、变更和数据管理政策及程序；</p></li><li><p>组织对沟通的要求；</p></li><li><p>制作、交换、储存和检索信息的标准化指南；</p></li><li><p>以往项目的历史信息。</p></li></ul><h4 id="4-2-监督相关方参与：工具与技术"><a href="#4-2-监督相关方参与：工具与技术" class="headerlink" title="4.2 监督相关方参与：工具与技术"></a>4.2 监督相关方参与：工具与技术</h4><h5 id="4-2-1-数据分析"><a href="#4-2-1-数据分析" class="headerlink" title="4.2.1 数据分析"></a>4.2.1 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）：</p><ul><li><p>备选方案分析。在相关方参与效果没有达到期望要求时，应该开展备选方案分析，评估应对偏差的各种备选方案。</p></li><li><p>根本原因分析。开展根本原因分析，确定相关方参与未达预期效果的根本原因。</p></li><li><p>相关方分析。开展相关方分析，确定相关方群体和个人在项目任何特定时间的状态。</p></li></ul><h5 id="4-2-2-决策"><a href="#4-2-2-决策" class="headerlink" title="4.2.2 决策"></a>4.2.2 决策</h5><p>适用于本过程的决策技术包括（但不限于）：</p><ul><li><p>多标准决策分析。对考察相关方参与的成功程度的多种标准进行优先级排序和加权，识别出最适当的选项。</p></li><li><p>投票。通过投票，选出应对相关方参与水平偏差的最佳方案。</p></li></ul><h5 id="4-2-3-数据表现"><a href="#4-2-3-数据表现" class="headerlink" title="4.2.3 数据表现"></a>4.2.3 数据表现</h5><p>适用于本过程的数据表现技术包括（但不限于）相关方参与度评估矩阵。使用相关方参与度评估矩阵，来跟踪每个相关方参与水平的变化，对相关方参与加以监督。</p><h5 id="4-2-4-沟通技能"><a href="#4-2-4-沟通技能" class="headerlink" title="4.2.4 沟通技能"></a>4.2.4 沟通技能</h5><p>适用于本过程的沟通技能包括（但不限于）：</p><ul><li><p>反馈。反馈用于确保发送给相关方的信息被接收和理解。</p></li><li><p>演示。演示为相关方提供清晰的信息。</p></li></ul><h5 id="4-2-5-人际关系与团队技能"><a href="#4-2-5-人际关系与团队技能" class="headerlink" title="4.2.5 人际关系与团队技能"></a>4.2.5 人际关系与团队技能</h5><p>适用于本过程的人际关系技能包括（但不限于）：</p><ul><li><p>积极倾听。通过积极倾听，减少理解错误和沟通错误。</p></li><li><p>文化意识。文化意识和文化敏感性有助于项目经理依据相关方和团队成员的文化差异和文化需求对沟通进行规划。</p></li><li><p>领导力。成功地相关方参与，需要强有力的领导技能，以传递愿景并激励相关方支持项目工作和成果。</p></li><li><p>人际交往。通过人际交往了解关于相关方参与水平的信息。</p></li><li><p>政治意识。政治意识有助于理解组织战略，理解谁能行使权力和施加影响，以及培养与这些相关方沟通的能力。</p></li></ul><h5 id="4-2-6-会议"><a href="#4-2-6-会议" class="headerlink" title="4.2.6 会议"></a>4.2.6 会议</h5><p>会议的类型包括：为监督和评估相关方的参与水平而召开的状态会议、站会、回顾会，以及相关方参与计划中规定的其他任何会议。会议不再局限于面对面或声音互动。虽然面对面互动最为理想，但可能成本很高。电话会议和电信技术可以降低成本，并提供丰富的联系方法和会议方式。</p><h4 id="4-3-监督相关方参与：输出"><a href="#4-3-监督相关方参与：输出" class="headerlink" title="4.3 监督相关方参与：输出"></a>4.3 监督相关方参与：输出</h4><h5 id="4-3-1-工作绩效信息"><a href="#4-3-1-工作绩效信息" class="headerlink" title="4.3.1 工作绩效信息"></a>4.3.1 工作绩效信息</h5><p>工作绩效信息包括与相关方参与状态有关的信息，例如，相关方对项目的当前支持水平，以及与相关方参与度评估矩阵、相关方立方体或其他工具所确定的期望参与水平相比较的结果。</p><h5 id="4-3-2-变更请求"><a href="#4-3-2-变更请求" class="headerlink" title="4.3.2 变更请求"></a>4.3.2 变更请求</h5><p>变更请求可能包括用于改善相关方当前参与水平的纠正及预防措施。应该通过实施整体变更控制过程对变更请求进行审查和处理。</p><h5 id="4-3-3-项目管理计划更新"><a href="#4-3-3-项目管理计划更新" class="headerlink" title="4.3.3 项目管理计划更新"></a>4.3.3 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更的项目管理计划组件包括（但不限于）：</p><ul><li><p>资源管理计划。可能需要更新团队对引导相关方参与的职责。</p></li><li><p>沟通管理计划。可能需要更新项目的沟通策略。</p></li><li><p>相关方参与计划。可能需要更新关于项目相关方社区的信息。</p></li></ul><h5 id="4-3-4-项目文件更新"><a href="#4-3-4-项目文件更新" class="headerlink" title="4.3.4 项目文件更新"></a>4.3.4 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>问题日志。可能需要更新问题日志中与相关方态度有关的信息。</p></li><li><p>经验教训登记册。在质量规划过程中遇到的挑战及其本可采取的规避方法需要更新在经验教训登记册中。调动相关方参与效果好以及效果不佳的方法也要更新在经验教训登记册中。</p></li><li><p>风险登记册。可能需要更新风险登记册，以记录相关方风险应对措施。</p></li><li><p>相关方登记册。更新相关方登记册，以记录从监督相关方参与中得到的信息。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《PMBOK第六版》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目相关方管理包括用于开展下列工作的各个过程：识别能够影响项目或受项目影响的人员、团体或组织，分析相关方对项目的期望和影响，制定合适的管理策略来有效调动相关方参与项目决策和执行。用这些过程分析相关方期望，评估他们对项目或受项目影响的程度，以及制定策略来有效引导相关方支持项目决策、规划和执行。这些过程能够支持项目团队的工作。&lt;/p&gt;
    
    </summary>
    
      <category term="PMP抄书系列" scheme="http://www.xiaoleon.cn/categories/PMP%E6%8A%84%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="pmp" scheme="http://www.xiaoleon.cn/tags/pmp/"/>
    
  </entry>
  
  <entry>
    <title>PMP(12) 项目采购管理</title>
    <link href="http://www.xiaoleon.cn/2019/04/27/pmp-12/"/>
    <id>http://www.xiaoleon.cn/2019/04/27/pmp-12/</id>
    <published>2019-04-27T04:02:40.000Z</published>
    <updated>2019-05-13T09:48:47.193Z</updated>
    
    <content type="html"><![CDATA[<p>项目采购管理包括从项目团队外部采购或获取所需产品、服务或成果的各个过程。项目采购管理包括编制和管理协议所需的管理和控制过程，例如，合同、订购单、协议备忘录（MOA），或服务水平协议（SLA）。被授权采购项目所需货物和（或）服务的人员可以是项目团队、管理层或组织采购部（如果有）的成员。</p><a id="more"></a><p>项目采购管理过程包括：</p><ul><li><p><strong>规划采购管理</strong> —— 记录项目采购决策、明确采购方法，及识别潜在卖方的过程。</p></li><li><p><strong>实施采购</strong> —— 获取卖方应答、选择卖方并授予合同的过程。</p></li><li><p><strong>控制采购</strong> —— 管理采购关系、监督合同绩效、实施必要的变更和纠偏，以及关闭合同的过程。</p></li></ul><p>虽然在本指南中，采购过程以界限分明和相互独立的形式出现，但在实践中，采购过程相当复杂且相互作用，还与其他知识领域的过程相互作用。本指南无法全面详述这些相互作用。本章以从项目外部获取货物或服务的视角来叙述采购过程。</p><p>图12-1概括了项目采购管理的各个过程。虽然在本《PMBOK指南》中，各项目采购管理过程以界限分明和相互独立的形式出现，但在实践中它们会以本指南无法全面详述的方式相互交叠和相互作用。</p><p><img src="/images/pmp-12/12-1.png" alt="项目采购管理概述"></p><p><strong>项目采购管理的核心概念</strong></p><p>与采购过程相关的重大法律义务和惩罚，通常超出大多数其他的项目管理过程。虽然项目经理不比成为采购管理法律法规领域的专家，但应该对采购过程有足够了解，以便做出与合同及合同关系相关的明智决定。通常情况下，项目经理无权签署对组织有约束力的法律协议，这项工作仅由具备相关职权的人员执行。</p><p>项目采购管理过程涉及到用协议来描述买卖双方之间的关系。协议可以很简单，如以特定人工单价购买所需的工时，也可以很复杂，如多年的国际施工合同。合同签署的方法和合同本身应体现可交付成果或所需人力投入的简单性或复杂性，其书写形式也应符合当地、所在国或国际法中关于合同签署的规定。</p><p>合同应明确说明预期的可交付成果和结果，包括从卖方到买方的任何知识转移。合同中未规定的任何事项则不具法律强制力。开展国际合作的项目经理应牢记，无论合同规定如何详尽，文化和当地法律对合同及其可执行力均有影响。</p><p>采购合同中包括条款和条件，也可包括买方就卖方应实施工作或应交付产品的其他规定。在与采购办公室协作确保遵守组织的采购政策的同时，项目管理团队必须确定所有采购都能满足项目的具体需要。因应用领域不同，协议可以是合同、服务水平协议（SLA）、谅解备忘录、协议备忘录（MOA）或订购单。</p><p>大多数组织都有相关的书面政策和程序，来专门定义采购规则，并规定谁有权代表组织签署和管理协议。在世界各地，组织虽然用不同的名称来称呼负责采购的单位或部门，如购买部、合同部、采购部或收购部，但其实际职责大同小异。</p><p>虽然所有项目文件可能都要经过某种形式的审查与批准，但是，鉴于其法律约束力，合同或协议需要经过更多的审批程序，而且通常会涉及到法务部。在任何情况下，审批程序的主要目标都是确保合同充分描述将由卖方提供的产品、服务或成果，且符合法律法规关于采购的规定。通常把描述产品、服务或成果的文件作为独立的附件或附录，以便合同正文使用标准化的法律合同用语。</p><p>在复杂项目中，可能需要同时或先后管理多个合同。这种情况下，不同合同的生命周期可在项目生命周期的任何阶段开始与结束。买卖方关系是采购组织与外部组织之间的关系，可存在于项目的许多层次上。</p><p>因应用领域不同，卖方可以是承包商、供货商、服务提供商或供应商；买方可能为最终产品的所有人、分包商、收购机构、服务需求者或购买方。在合同生命周期中，卖方首先是投标人，然后是中标人，之后是签约供应商或供货商。</p><p>中标人可将所承揽的工作当做一个项目加以管理。在这种情况下：</p><ul><li><p>买方就变成了承包商、供应商及服务提供商的客户，因此也就是卖方的关键项目相关方。</p></li><li><p>卖方的项目管理团队就需要关注工作执行或服务提供所涉及的所有过程。</p></li><li><p>对于卖方来说，合同条款和条件以及采购工作说明书（SOW）都是其许多管理过程的重要输入。在合同中，可实际列出各种输入（如，主要可交付成果、关键里程碑、成本目标），或者可限制项目团队的选择余地（如，在IT整合项目中，关于人员配备的决定往往要征得买方的批准）。另外，采购工作说明书可能使用其他名称，如技术工作说明书。</p></li><li><p>卖方本身也可能成为更低层级的产品、服务和材料分包商及供应商的买方。</p></li></ul><p>本节假设项目所需物品或服务的买方是项目团队，或者是组织内部的某个部门，同时假设卖方是为项目提供物品或服务的一方，且通常来自执行组织外部。在某些项目上，卖方可能是项目执行组织内部但属于项目外部的某个小组或部门。在大型复杂的项目上，卖方可能在授予合同后才成为整合式项目团队的一部分，</p><p>在小型组织或初创企业，以及未设置购买、合同或采购部门的组织，项目经理可以拥有采购职权，能够直接谈判并签署和同（分散式采购）。在更成熟的组织中，由专设部门开展实际的采购和合同签署工作，即采购、谈判和签署合同（集中式采购）。</p><p>在签署国际合同时，应该在合同中明确规定对合同的法律管辖权。在大多数情况下，卖方是受正式合同关系约束的外部承包商。</p><p><strong>采购管理的发展趋势和新兴实践</strong></p><p>不同行业各方面（软件工具、风险、过程、物流和技术）的一些重大趋势，会影响项目的成功率。项目采购管理的发展趋势和新兴实践包括（但不限于）：</p><ul><li><p>工具的改进。用于管理项目采购和项目执行的工具已经取得重大发展。现在，买方能够使用在线工具集中发布采购广告；卖方也能够使用在线工具集中查找采购文件，并直接在线填写。在施工、工程和基础设施领域，建筑信息模型（BIM）软件的应用日益广泛，为工程项目节省了大量时间和资金。它能够大幅减少施工索赔，从而降低成本、缩短工期，因此世界各地的主要公司和政府都开始要求在大型项目中使用BIM。</p></li><li><p>更先进的风险管理。在风险管理领域日益流行的一个趋势，就是在编制合同时准确地将具体风险分配给最有能力对其加以管理的一方。没有任何承包商有能力管理项目的所有重大风险，买方因而必须接受承包商无法掌控的风险，例如，采购方公司政策的不断变化、法规要求的不断变化，以及项目以外的其他风险。在合同中可以明确规定风险管理是合同工作的一部分。</p></li><li><p>变化中的合同签署实践。在过去几年时间内，超大型项目的数量显著增加，尤其是在基础设施建设和工程项目领域。数十亿美元的项目现在已十分常见。大部分此类项目都要求与多个国家的多家承包商签署国际合同，因此肯定比仅使用当地承包商的项目具有更大的风险。承包商越来越重视在采购过程中与客户开展密切合作，以便对批量采购或有其他特殊关系的客户给予折扣优惠。对于此类项目来说，为了减少执行过程中的问题和索赔，采用国际公认的标准合同范本也日益普遍。</p></li><li><p>物流和供应链管理。因为如此多的大型工程、施工和基础设施建设项目都由多家跨国承包商来完成，材料物流管理对于项目成功完成至关重要。对采购周期较长的产品，制造环节和运输（到项目现场）环节都是项目进度的决定因素。在IT领域，有些产品可能需要提前2到3个月订购；在复杂的施工项目上，订购时间可能需要提前1-2年，甚至更长。在这些项目上，可能需要在签订其他采购合同之前就采购这些订购周期长的产品，以便项目如期完成。在最终产品的最终设计完成之前，就可能需要根据总体设计中已确定的要求开始订购采购周期较长的材料、用品或设备。供应链管理也是承包商的项目团队日益重视的一个领域。在项目早期，不仅要明确主要的采购渠道，通常还需要明确次要和备选渠道。全球很多国家会要求跨国承包商至少向当地供应商采购一定比例的材料和用品。</p></li><li><p>技术和相关方关系。公共资助的项目正受越来越多的关注。基础设置和商业建设项目正日益采用包括网络摄像（webcams）在内的技术，以改善与相关方的沟通和关系。在施工期间，施工现场会安装一台或多台网络摄像机，定期更新并发布到公开的网站上，方便所有相关方在互联网上查看项目进展。另外，视频资料可以储存，有助于在索赔发生时进行分析。有些项目显示，使用网络摄像机记录现场情况，能够避免对事实的分歧，从而能够把现场施工有关的争议降到最低程度。</p></li><li><p>试用采购。并非每一个卖方都能很好地适应买方组织的环境，因此，再决定大批量采购之前，有些项目会试用多个候选卖方，向他们采购少量的可交付成果和工作产品。这样一来，买方可以在推进项目工作的同时，对潜在合作伙伴进行评估。</p></li></ul><p><strong>裁剪时需要考虑的因素</strong></p><p>因为每个项目都是独特的，所以项目经理需要裁剪项目采购管理过程。裁剪时应考虑的因素包括（但不限于）：</p><ul><li><p>采购的复杂性。只开展一次主要的采购，或者需要在不同时间向不同卖方进行多次采购（会提高采购的复杂性）？</p></li><li><p>物理地点。买方和卖方在同一或临近地点，或者位于不同时区、国家或大洲？</p></li><li><p>治理和法规环境。组织的采购政策是否和当地相关的法律法规兼容？当地的法律法规会如何影响合同审计工作？</p></li><li><p>承包商的可用性。是否有具备工作执行能力的承包商可供选择？</p></li></ul><p><strong>在敏捷或适应型环境中需要考虑的因素</strong></p><p>在敏捷型环境中，可能需要与特定卖方协作来扩充团队。这种协作关系能够营造风险共担式采购模型，让买方和卖方共担项目风险和共享项目奖励。</p><p>在大型项目上，可能针对某些可交付成果采用适应型方法，而对其它部分则采用更稳定的方法。在这种情况下，可以通过主题协议，如主要服务协议（MSA），来管辖整体协作关系，而将适应型工作写入附录或补充文件。这样一来，变更只针对适应型工作，而不会对主体协议造成影响。</p><h3 id="一、规划采购管理"><a href="#一、规划采购管理" class="headerlink" title="一、规划采购管理"></a>一、规划采购管理</h3><p>规划采购管理是记录项目采购决策、明确采购方法，及识别潜在卖方的过程。本过程的主要作用是，确定是否从项目外部获取货物和服务，如果是，则还要确定将在什么时间、以什么方式获取什么货物和服务。货物和服务可从执行组织的其他部门采购，或者从外部渠道采购。本过程仅开展一次或仅在项目的预定义点开展。图12-2描述本过程的输入、工具与技术和输出。图12-3是本过程的数据流向图。</p><p><img src="/images/pmp-12/12-2.png" alt="规划采购：输入、工具与技术和输出"></p><p><img src="/images/pmp-12/12-3.png" alt="规划采购：数据流向图"></p><p>应该在规划采购管理过程的早期，确定与采购有关的角色和职责。项目经理应确保在项目团队中配备具有所需采购专业知识的人员。采购过程的参与者可能包括购买部或采购部的人员，以及采购组织法务部的人员。这些人员的职责也应记录在采购管理计划中。</p><p>典型的步骤可能有：</p><ul><li><p>准备采购工作说明书（SOW）或工作大纲（TOR）；</p></li><li><p>准备高层级的成本估算，制定预算；</p></li><li><p>发布招标广告；</p></li><li><p>确定合格卖方的短名单；</p></li><li><p>准备并发布招标文件；</p></li><li><p>由卖方准备并提交建议书；</p></li><li><p>对建议书开展技术（包括质量）评估；</p></li><li><p>对建议书开展成本评估；</p></li><li><p>准备最终的综合评估报告（包括质量及成本），选出中标建议书；</p></li><li><p>结束谈判，买方和卖方签署合同。</p></li></ul><p>项目进度计划对规划采购管理过程中的采购策略制定有重要影响。在制定采购管理计划时所做出的决定也会影响项目进度计划。在开展制定进度计划过程、估算活动资源过程以及自制或外购决策制定时，都需要考虑这些决定。</p><h4 id="1-1-规划采购管理：输入"><a href="#1-1-规划采购管理：输入" class="headerlink" title="1.1 规划采购管理：输入"></a>1.1 规划采购管理：输入</h4><h5 id="1-1-1-项目章程"><a href="#1-1-1-项目章程" class="headerlink" title="1.1.1 项目章程"></a>1.1.1 项目章程</h5><p>项目章程包括目标、项目描述、总体里程碑，以及预先批准的财务资源。</p><h5 id="1-1-2-商业文件"><a href="#1-1-2-商业文件" class="headerlink" title="1.1.2 商业文件"></a>1.1.2 商业文件</h5><p>商业文件包括：</p><ul><li><p>商业论证。采购策略需要和商业论证保持一致，以确保商业论证的有效性。</p></li><li><p>收益管理计划。收益管理计划描述应在何时产出具体的项目收益，这将影响采购日期和合同条款的确定。</p></li></ul><h5 id="1-1-3-项目管理计划"><a href="#1-1-3-项目管理计划" class="headerlink" title="1.1.3 项目管理计划"></a>1.1.3 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>范围管理计划。范围管理计划说明如何在项目的实施阶段管理承包商的工作范围。</p></li><li><p>质量管理计划。质量管理计划包含项目需要遵循的行业标准与准则。这些标准与准则应写入招标文件，如建议邀请书，并将最终在合同中引用。这些标准与准则也可用于供应商资格预审，或作为供应商甄选标准的一部分。</p></li><li><p>资源管理计划。资源管理计划包括关于哪些资源需要采购或租赁的信息，以及任何可能影响采购的假设条件或制约因素。</p></li><li><p>范围基准。范围基准包含范围说明书、WBS和WBS词典。在项目早期，项目范围可能仍要继续演进。应该针对项目范围中已知的工作，编制工作说明书（SOW）和工作大纲（TOR）。</p></li></ul><h5 id="1-1-4-项目文件"><a href="#1-1-4-项目文件" class="headerlink" title="1.1.4 项目文件"></a>1.1.4 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>里程碑清单。重要里程碑清单说明卖方需要在何时交付成果。</p></li><li><p>项目团队派工单。项目团队派工单包含关于项目团队技能和能力的信息，以及他们可用于支持采购活动的时间。如果项目团队不具备开展采购活动的能力，则需要外聘人员或对现有人员进行培训，或者二者同时进行。</p></li><li><p>需求文件。需求文件可能包括：</p><ul><li><p>卖方需要满足的技术要求；</p></li><li><p>具有合同和法律意义的需求，如健康、安全、安保、绩效、环境、保险、知识产权、同等就业机会、执照、许可证，以及其他非技术要求。</p></li></ul></li><li><p>需求跟踪矩阵。需求跟踪矩阵将产品需求从其来源连接到能满足需求的可交付成果。</p></li><li><p>资源需求。资源需求包含关于某些特定需求的信息，例如，可能需要采购的团队及实物资源。</p></li><li><p>风险登记册。风险登记册列明风险清单，以及风险分析和风险应对规划的结果。有些风险应通过采购协议转移给第三方。</p></li><li><p>相关方登记册。相关方登记册提供有关项目参与者及其项目利益的详细信息，包括监管机构、合同签署人员和法务人员。</p></li></ul><h5 id="1-1-5-事业环境因素"><a href="#1-1-5-事业环境因素" class="headerlink" title="1.1.5 事业环境因素"></a>1.1.5 事业环境因素</h5><p>能够影响规划采购管理过程的事业环境因素包括（但不限于）：</p><ul><li><p>市场条件；</p></li><li><p>可从市场获得的产品、服务和成果；</p></li><li><p>卖方，包括其以往绩效或声誉；</p></li><li><p>关于产品、服务和成果的典型条款和条件，或适用于特定行业的典型条款和条件；</p></li><li><p>特殊的当地要求，例如关于雇用当地员工或卖方的法规要求；</p></li><li><p>关于采购的法律建议；</p></li><li><p>合同管理系统，包括合同变更控制程序；</p></li><li><p>已有的多层级供应商系统，其中列出了基于以往经验而预审合格的卖方；</p></li><li><p>财务会计和合同支付系统。</p></li></ul><h5 id="1-1-6-组织过程资产"><a href="#1-1-6-组织过程资产" class="headerlink" title="1.1.6 组织过程资产"></a>1.1.6 组织过程资产</h5><p>组织是用的各种合同协议类型也会影响规划采购管理过程中的决策。能够影响规划采购管理过程的组织过程资产包括（但不限于）：</p><ul><li><p>预先批准的卖方清单。经过适当审查的卖方清单可以简化招标所需的步骤，并缩短卖方甄选过程的时间。</p></li><li><p>正式的采购政策、程序和指南。大多数组织都有正式的采购政策和采购机构。如果没有，项目团队就应该配备相关的资源和专业技能，来实施采购活动。</p></li><li><p>合同类型。所有法律合同关系通常可分为总价和成本补偿两大类。此外，还有第三种常用的混合类型，及工料合同。下文将分别讨论上述基类较常用的合同类型。但在实践中，单次采购合同使用两种或更多合同类型的情况也并不罕见。</p><ul><li><p>总价合同。此类合同为既定产品、服务或成果的采购设定一个总价。这种合同应在已明确定义需求，且不会出现重大范围变更的情况下使用。总价合同的类型包括：</p><ul><li><p>固定总价（FFP）。FFP是最常用的合同类型。大多数买房都喜欢这种合同，因为货物采购的价格在一开始就已确定，并且不允许改变（除非工作范围发生变更）。</p></li><li><p>总价加激励费用（FPIF）。这种总价合同为买房和卖方提供了一定的灵活性，允许一定的绩效偏离，并对实现既定目标给予相关的财务奖励（通常取决于卖方的成本、进度或技术绩效）。FPIF合同中会设置价格上限，高于此价格上限的全部成本将由卖方承担。</p></li><li><p>总价加经济价格调整（FPEPA）。这种合同适用于两种情况：卖方履约期将跨越几年时间，或将以不同货币支付价款。它是总价合同的一种类型，但合同中包含了特殊条款，允许根据条件变化，如通货膨胀、某些特殊商品的成本增加（或降低），以事先确定的方式对合同价格进行最终调整。</p></li></ul></li><li><p>成本补偿合同。此类合同向卖方支付为完成工作而发生的全部合法实际成本（可报销成本），外加一笔费用作为卖方的利润。这种合同适用于：工作范围预计会在合同执行期间发生重大变更。成本补偿合同又可分为：</p><ul><li><p>成本加固定费用（CPFF）。为卖方报销履行合同工作所发生的的一切可列支成本，并向卖方支付一笔固定费用。该费用以项目初始估算成本的某一百分比计列。除非项目范围发生变更，否则费用金额维持不变。</p></li><li><p>成本加激励费用（CPIF）。为卖方报销履行合同工作所发生的的一切可列支成本，并在卖方打到合同规定的绩效目标时，向卖方支付预先确定的激励费用。在CPIF合同中，如果最终成本低于或高于原始估算成本，则买方和卖方需要根据事先商定的成本分摊比例来分享节约部分或分担超支部分。例如，基于卖方的实际成本，按照80/20的比例分担（分享）超过（低于）目标成本的部分。</p></li><li><p>成本加奖励费用（CPAF）。为卖方报销一切合法成本，但只有在卖方满足合同规定的、某些笼统主观的绩效标准的情况下，才向卖方支付大部分费用。奖励费用完全由买方根据自己对卖方绩效的主观判断来决定，并且通常不允许申述。</p></li></ul></li><li><p>工料合同（T&amp;M）。工料合同（又称时间和手段合同），是兼具成本补偿合同和总价合同特点的混合型合同。这种合同往往适用于：在无法快速编制出准确地工作说明书的情况下扩充人员、聘用专家或寻求外部支持。</p></li></ul></li></ul><h4 id="1-2-规划采购管理：工具与技术"><a href="#1-2-规划采购管理：工具与技术" class="headerlink" title="1.2 规划采购管理：工具与技术"></a>1.2 规划采购管理：工具与技术</h4><h5 id="1-2-1-专家判断"><a href="#1-2-1-专家判断" class="headerlink" title="1.2.1 专家判断"></a>1.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>采购与购买；</p></li><li><p>合同类型和合同文件；</p></li><li><p>法规及合规性。</p></li></ul><h5 id="1-2-2-数据收集"><a href="#1-2-2-数据收集" class="headerlink" title="1.2.2 数据收集"></a>1.2.2 数据收集</h5><p>适用于本过程的数据收集技术包括（但不限于）市场调研。市场调研包括考察行业情况和具体卖方的能力。采购团队可运用从会议、在线评论和各种其他渠道得到的信息，来了解市场情况。采购团队也可以调整具体的采购目标，以便在平衡与有能力提供所需材料或服务的卖方的范围有关的风险的同时，利用成熟技术。</p><h5 id="1-2-3-数据分析"><a href="#1-2-3-数据分析" class="headerlink" title="1.2.3 数据分析"></a>1.2.3 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）自制或外购分析。自制或外购分析用于确定某项工作或可交付成果最好由项目团队自行完成，还是应该从外部采购。制定自制或外购决策时应考虑的因素包括：组织当前的资源配置及其技能和能力，对专业技术的需求，不远承担永久雇用的义务，以及对独特技术专长的需求；还要评估与每个自制或外购决策相关的风险。</p><p>在自制或外购分析中，可以使用回收期、投资回报率（ROI）、内部报酬率（IRR）、现金流贴现、净现值（NPV）、收益成本（BCA）或其他分析技术，来确定某种货物或服务是应该在项目内部自制，还是从外部购买。</p><h5 id="1-2-4-供方选择分析"><a href="#1-2-4-供方选择分析" class="headerlink" title="1.2.4 供方选择分析"></a>1.2.4 供方选择分析</h5><p>在确定选择方法前，有必要审查项目竞争性需求的优先级。由于竞争性选择方法可能要求卖方在事前投入大量时间和资源，因此，应该在采购文件中写明评估方法，让投标人了解将会被如何评估。常用的选择方法包括：</p><ul><li><p>最低成本。最低成本法适用于标准化或常规采购。此类采购有成熟的实践与标准，有具体明确的预期成果，可以用不同的成本来取得。</p></li><li><p>仅凭资质。仅凭资质的选择方法适用于采购价值相对较小，不值得花时间和成本开展完整选择过程的情况。买方会确定短名单，然后根据可信度、相关资质、经验、专业知识、专长领域和参考资料选择最佳的投标人。</p></li><li><p>基于质量或技术方案得分。邀请一些公司提交建议书，同时列明技术和成本详情；如果技术建议书可以接受，再邀请它们进行合同谈判。采用此方法，会先对技术建议书进行评估，考察技术方案的质量。如果经过谈判，证明他们的的财务建议书是可接受的，那么就会选择技术建议书得分最高的卖方。</p></li><li><p>基于质量和成本。在基于质量和成本的方法中，成本也是用于选择卖方的一个考虑因素。一般而言，如果项目的风险和（或）不确定性较高，相对于成本而言，质量就应该是一个关键因素。</p></li><li><p>独有来源。买方要求特定卖方准备技术和财务建议书，然后针对建议书开展谈判。由于没有竞争，因此仅在有适当理由时才可采取此方法，而且应将其视为特殊情况。</p></li><li><p>固定预算。固定预算法要求在建议邀请书中向受邀的卖方披露可用预算，然后在此预算内选择技术建议书得分最高的卖方。因为有成本限制，所以卖方会在建议书中调整工作的范围和质量，以适应该预算。买方应该确保固定预算与工作说明书相符，且卖方能够在该预算内完成相关任务。此方法仅适用于工作说明书定义精确、预期不会发生变更，而且预算固定且不得超出的情况。</p></li></ul><h5 id="1-2-5-会议"><a href="#1-2-5-会议" class="headerlink" title="1.2.5 会议"></a>1.2.5 会议</h5><p>不借助与潜在投标人的信息交流会，仅靠调研也许还不能获得制定采购策略所需的具体信息。采购方与潜在投标人合作，有利于卖方以互惠的方法提供产品或服务，从而使采购方从中受益。会议可用于确定管理和监督采购的策略。</p><h4 id="1-3-规划采购管理：输出"><a href="#1-3-规划采购管理：输出" class="headerlink" title="1.3 规划采购管理：输出"></a>1.3 规划采购管理：输出</h4><h5 id="1-3-1-采购管理计划"><a href="#1-3-1-采购管理计划" class="headerlink" title="1.3.1 采购管理计划"></a>1.3.1 采购管理计划</h5><p>采购管理计划包含要在采购过程中开展的各种活动。它应该记录是否要开展国际竞争性招标、国内竞争性招标、当地招标等。如果项目由外部资助，资金的来源和可用性应符合采购管理计划和项目进度计划的规定。</p><p>采购管理计划可包括以下内容：</p><ul><li><p>如何协调采购与项目的其他工作，例如，项目进度计划制定和控制；</p></li><li><p>开展重要采购活动的时间表；</p></li><li><p>用于管理合同的采购测量指标；</p></li><li><p>与采购有关的相关方角色和职责；如果执行组织有采购部，项目团队拥有的职权和受到的限制；</p></li><li><p>可能影响采购工作的制约因素和假设条件；</p></li><li><p>司法管辖权和付款货币；</p></li><li><p>是否需要编制独立估算，以及是否应将其作为评价标准；</p></li><li><p>风险管理事项，包括对履约保函或保险合同的要求，以减轻某些项目风险；</p></li><li><p>拟使用的预审合格的卖方（如果有）。</p></li></ul><p>根据每个项目的需要，采购管理计划可以是正式或非正式的，非常详细或高度概括的。</p><h5 id="1-3-2-采购策略"><a href="#1-3-2-采购策略" class="headerlink" title="1.3.2 采购策略"></a>1.3.2 采购策略</h5><p>一旦完成自制或外购分析，并决定从项目外部渠道采购，就应制定一套采购策略。应该在采购策略中规定项目交付方法、具有法律约束力的协议类型，以及如何在采购阶段推动采购进展。</p><ul><li><p>交付方法。对专业服务项目和建筑施工项目，应该采用不同的交付方法。</p><ul><li><p>专业服务项目的交付方法包括：买方或服务提供方不得分包、买方或服务提供方可以分包、买方或服务提供方设立合资企业、买方或服务提供方仅充当代表。</p></li><li><p>而工业或商业施工项目的交付方法包括（但不限于）：交钥匙式、设计-建造（DB）、设计-招标-建造（DBB）、设计-建造-运营（DBO）、建造-拥有-运营-转让（BOOT），及其他。</p></li></ul></li><li><p>合同支付类型。合同支付类型与项目交付方法无关，需要与采购组织的内部财务系统相协调。它们包括（但不限于）以下合同类型及其变种：总价、固定总价、成本加奖励费用、成本加激励费用、工料、目标成本及其他。</p><ul><li><p>总价合同适用于工作类型可预知、需求能清晰定义且不太可能变更的情况；</p></li><li><p>成本补偿合同适用于工作不断演进、很可能变更或未明确定义的情况；</p></li><li><p>激励和奖励费用可用与协调买方和卖方的目标。</p></li></ul></li><li><p>采购阶段。采购策略也可以包括与采购阶段有关的信息，这种信息可能包括：</p><ul><li><p>采购工作的顺序安排或阶段划分，每个阶段的描述，以及每个阶段的具体目标；</p></li><li><p>用于监督的采购绩效指标和里程碑；</p></li><li><p>从一个阶段过渡到下一个阶段的标准；</p></li><li><p>用于追踪采购进展的监督和评估计划；</p></li><li><p>向后续阶段转移知识的过程。</p></li></ul></li></ul><h5 id="1-3-3-招标文件"><a href="#1-3-3-招标文件" class="headerlink" title="1.3.3 招标文件"></a>1.3.3 招标文件</h5><p>招标文件用于向潜在卖方征求建议书。如果主要依据价格来选择卖方（如购买商业或标准产品时），通常就使用标书、投标或报价等术语；如果其他考虑因素（如技术能力或技术方法）至关重要，则通常使用建议书之类的术语。具体使用的采购术语也可能因行业或采购地点而异。</p><p>取决于所需的货物或服务，招标文件可以是信息邀请书、报价邀请书、建议邀请书，或其他适当的采购文件。使用不同文件的条件如下：</p><ul><li><p>信息邀请书（RFI）。如果需要卖方提供关于拟采购货物和服务的更多信息，就使用信息邀请书。随后一般还会使用报价邀请书或建议邀请书。</p></li><li><p>报价邀请书（RFQ）。如果需要供应商提供关于将如何满足需求和（或）将需要多少成本的更多信息，就使用报价邀请书。</p></li><li><p>建议邀请书（RFP）。如果项目中出现问题且解决办法难以确定，就使用建议邀请书。这是最正式的“邀请书”文件，需要遵守与内容、时间表，以及卖方应答有关的严格的采购规则。</p></li></ul><p>买方拟定的采购文件不仅应便于潜在卖方做出准确、完整的应答，还要便于买方对卖方应答进行评价。采购文件会包括规定的应答格式、相关的采购工作说明书，以及所需的合同条款。</p><p>采购文件的复杂和详细程度应与采购的价值及相关的风险相符。采购文件既需要具备足够详细的信息，以确保卖方做出一致且适当的应答，同时它又要有足够的灵活度，让卖方为满足相同的要求而提出更好的建议。</p><h5 id="1-3-4-采购工作说明书"><a href="#1-3-4-采购工作说明书" class="headerlink" title="1.3.4 采购工作说明书"></a>1.3.4 采购工作说明书</h5><p>依据项目范围基准，为每次采购编制工作说明书（SOW），仅对将要包含在相关合同中的那一部分项目范围进行定义。工作说明书会充分详细地描述拟采购的产品、服务或成果，以便潜在卖方确定是否有能力提供此类产品、服务或成果。根据采购品的性质、买方的需求、或拟采用的合同形式，工作说明书的详细程度会有较大不同。工作说明书的内容包括：规格、所需数量、质量水平、绩效数据、履约期间、工作地点和其他要求。</p><p>采购工作说明书应力求清晰、完整和简练。它需要说明所需的附加服务，例如，报告绩效，或对采购品的后续运营支持。在采购过程中，应根据需要对工作说明书进行修订，直到它成为所签协议的一部分。</p><p>对于服务采购，可能会用“工作大纲（TOR）”这个术语。与采购工作说明书类似，工作大纲通常包括以下内容：</p><ul><li><p>承包商需要执行的任务，以及所需的协调工作；</p></li><li><p>承包商必须达到的适用标准；</p></li><li><p>需要提交批准的数据；</p></li><li><p>由买方提供给承包商的，将用于合同履行的全部数据和服务的详细清单（若适用）；</p></li><li><p>关于初始成果提交和审查（或审批）的进度计划。</p></li></ul><h5 id="1-3-5-供方选择标准"><a href="#1-3-5-供方选择标准" class="headerlink" title="1.3.5 供方选择标准"></a>1.3.5 供方选择标准</h5><p>在确定评估标准时，买方要努力确保选出的建议书将提供最佳质量的所需服务。供方选择标准可包括（但不限于）：</p><ul><li><p>能力和潜能；</p></li><li><p>产品成本和生命周期成本；</p></li><li><p>交付日期；</p></li><li><p>技术专长和方法；</p></li><li><p>具体的相关经验；</p></li><li><p>用于响应工作说明书的工作方法和工作计划；</p></li><li><p>关键员工的资质、可用性和胜任力；</p></li><li><p>公司的财务稳定性；</p></li><li><p>管理经验；</p></li><li><p>知识转移计划，包括培训计划。</p></li></ul><p>针对国际项目，评估标准还可包括“本地内容”要求，例如，在提议的关键员工中要有本国人。</p><p>针对不同的标准，可以用数值分数、颜色代码或书面描述，来说明卖方满足采购组织需求的程度。这些标准是加权系统的组成部分，可据此以加权打分的方法排列所有建议书的顺序，以便确定谈判的顺序，并与某个卖方签订合同。</p><h5 id="1-3-6-自制或外购决策"><a href="#1-3-6-自制或外购决策" class="headerlink" title="1.3.6 自制或外购决策"></a>1.3.6 自制或外购决策</h5><p>通过自制或外购决策，做出某项特定工作最好由项目团队自己完成，还是需要从外部渠道采购的决策。</p><h5 id="1-3-7-独立成本估算"><a href="#1-3-7-独立成本估算" class="headerlink" title="1.3.7 独立成本估算"></a>1.3.7 独立成本估算</h5><p>对于大型的采购，采购组织可以自行准备独立估算，或聘用外部专业估算师做出成本估算，并将其作为评价卖方报价的对照基准。如果二者之间存在明显差异，则可能表明采购工作说明书存在缺陷或模糊，或者潜在卖方误解了或未能完全响应采购工作说明书。</p><h5 id="1-3-8-变更请求"><a href="#1-3-8-变更请求" class="headerlink" title="1.3.8 变更请求"></a>1.3.8 变更请求</h5><p>关于采购货物、服务或资源的决策，可能导致变更请求；规划采购期间的其他决策，也可能导致变更请求。对项目管理计划及其子计划和其他组件的修改都可能导致会影响采购行为的变更请求。应该通过实施整体变更控制过程对变更请求进行审查和处理。</p><h5 id="1-3-9-项目文件更新"><a href="#1-3-9-项目文件更新" class="headerlink" title="1.3.9 项目文件更新"></a>1.3.9 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。更新经验教训登记册，记录任何与法规和合规性、数据收集、数据分析和供方选择分析相关的经验教训。</p></li><li><p>里程碑清单。重要里程碑清单说明卖方需要在何时交付成果。</p></li><li><p>需求文件。需求文件可能包括：</p><ul><li><p>卖方需要满足的技术要求；</p></li><li><p>具有合同和法律意义的需求，如健康、安全、安保、绩效、环境、保险、知识产权、同等就业机会、执照、许可证，以及其他非技术要求。</p></li></ul></li><li><p>需求跟踪矩阵。需求跟踪矩阵将产品需求从其来源连接到能满足需求的可交付成果。</p></li><li><p>风险登记册。取决于卖方的组织、合同的持续时间、外部环境、项目交付方法、所选合同类型，以及最终商定的价格，任何被选中的卖方都会带来特殊的风险。</p></li><li><p>相关方登记册。更新相关方登记册，记录任何关于相关方的补充信息，尤其是监管机构、合同签署人员，以及法务人员的信息。</p></li></ul><h5 id="1-3-10-组织过程资产更新"><a href="#1-3-10-组织过程资产更新" class="headerlink" title="1.3.10 组织过程资产更新"></a>1.3.10 组织过程资产更新</h5><p>作为规划采购管理过程的结果，需要更新的组织过程资产包括（但不限于）关于合格卖方的信息。</p><p>对于采购次数少且相对简单的项目，作为本过程输出的有些文件可以合并。不过，对于采购规模较大、较复杂，而且大部分工作需由承包商完成的项目，就需要使用几种不同类型的文件。表12-1列出了采购中常用的文件类型及其部分内容。鉴于采购的法律性质，不应把表12-1的内容看成规定性描述，而只应该把它们看成关于所需文件的类型和内容的总体大纲，用于指导实施采购工作。组织、环境和法律规定会决定项目具体需要的文件类型和内容。</p><p><img src="/images/pmp-12/表12-1.png" alt="采购文件比较"></p><hr><h3 id="二、实施采购"><a href="#二、实施采购" class="headerlink" title="二、实施采购"></a>二、实施采购</h3><p>实施采购是获取卖方应答、选择卖方并授予合同的过程。本过程的主要作用是，选定合格卖方并签署关于货物或服务交付的法律协议。本过程的最后成果是签订的协议，包括正式合同。本过程应根据需要在整个项目期间定期开展。图12-4描述实施采购过程的输入、工具与技术和输出。图12-5是本过程的数据流向图。</p><p><img src="/images/pmp-12/12-4.png" alt="实施采购：输入、工具与技术和输出"></p><p><img src="/images/pmp-12/12-5.png" alt="实施采购：数据流向图"></p><h4 id="2-1-实施采购：输入"><a href="#2-1-实施采购：输入" class="headerlink" title="2.1 实施采购：输入"></a>2.1 实施采购：输入</h4><h5 id="2-1-1-项目管理计划"><a href="#2-1-1-项目管理计划" class="headerlink" title="2.1.1 项目管理计划"></a>2.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>范围管理计划。范围管理计划描述如何管理总体工作范围，包括由卖方负责的工作范围。</p></li><li><p>需求管理计划。需求管理计划描述将如何分析、记录和管理需求。它可能还包括卖方将如何管理按协议规定应该实现的需求。</p></li><li><p>沟通管理计划。沟通管理计划描述买方和卖方之间如何开展沟通。</p></li><li><p>风险管理计划。风险管理计划是项目管理计划的组成部分，描述如何安排和实施项目风险管理活动。</p></li><li><p>采购管理计划。采购管理计划包含在实施采购过程中应该开展的活动。</p></li><li><p>配置管理计划。配置管理计划定义了哪些是配置项，哪些配置项需要正式变更控制，以及针对这些配置项的变更控制过程。它包括卖方开展配置管理的形式和过程，以便与买方采取的方法保持一致。</p></li><li><p>成本基准。成本基准包括用于开展采购的预算，用于管理采购过程的成本，以及用于管理卖方的成本。</p></li></ul><h5 id="2-1-2-项目文件"><a href="#2-1-2-项目文件" class="headerlink" title="2.1.2 项目文件"></a>2.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。在项目早期获取的与实施的采购有关的经验教训，可用于项目后期阶段，以提高本过程的效率。</p></li><li><p>项目进度计划。项目进度计划确定项目活动的开始和结束时间，包括采购活动。它还会规定承包商最终的交付日期。</p></li><li><p>需求文件。需求文件可能包括：</p><ul><li><p>卖方需要满足的技术要求；</p></li><li><p>具有合同和法律意义的需求，如健康、安全、安保、绩效、环境、保险、知识产权、同等就业机会、执照、许可证，以及其他非技术要求。</p></li></ul></li><li><p>风险登记册。取决于卖方的组织、合同的持续时间、外部环境、项目交付方法、所选合同类型，以及最终商定的价格，任何被选中的卖方都会带来特殊的风险。</p></li><li><p>相关方登记册。此文件包含与已识别相关方有关的所有详细信息。</p></li></ul><h5 id="2-1-3-采购文档"><a href="#2-1-3-采购文档" class="headerlink" title="2.1.3 采购文档"></a>2.1.3 采购文档</h5><p>采购文档是用于达成法律协议的各种书面文件，其中可能包括当前项目启动之前的较旧文件。采购文档可包括：</p><ul><li><p>招标文件。招标文件包括发给卖方的信息邀请书、建议邀请书、报价邀请书，或其他文件，以便卖方编制应答文件。</p></li><li><p>采购工作说明书。采购工作说明书（SOW）向卖方清晰地说明目标、需求及成果，以便卖方据此做出量化应答。</p></li><li><p>独立成本估算。独立成本估算可由内部或外部人员编制，用于评价投标人提交的建议书的合理性。</p></li><li><p>供方选择标准。此类标准描述如何评估投标人的建议书，包括评估标准和权重。为了减轻风险，买方可能决定与多个卖方签署协议，以便在单个卖方出问题并影响整体项目时，降低由此导致的损失。</p></li></ul><h5 id="2-1-4-卖方建议书"><a href="#2-1-4-卖方建议书" class="headerlink" title="2.1.4 卖方建议书"></a>2.1.4 卖方建议书</h5><p>卖方为响应采购文件包而编制的建议书，其中包含的基本信息将被评估团队用于选定一个或多个投标人（卖方）。如果卖方将提交价格建议书，最好要求他们将价格建议书与技术建议书分开。评估团队会根据供方选择标准审查每一份建议书，然后选出最能满足采购组织需求的卖方。</p><h5 id="2-1-5-事业环境因素"><a href="#2-1-5-事业环境因素" class="headerlink" title="2.1.5 事业环境因素"></a>2.1.5 事业环境因素</h5><p>能够影响实施采购过程的事业环境因素包括：</p><ul><li><p>关于采购的当地法律和法规；</p></li><li><p>确保主要采购涉及当地卖方的当地法律和法规；</p></li><li><p>制约采购过程的外部经济环境；</p></li><li><p>市场条件；</p></li><li><p>以往与卖方合作的相关经验，包括正反两方面；</p></li><li><p>之前使用的协议；</p></li><li><p>合同管理系统。</p></li></ul><h5 id="2-1-6-组织过程资产"><a href="#2-1-6-组织过程资产" class="headerlink" title="2.1.6 组织过程资产"></a>2.1.6 组织过程资产</h5><p>能够影响实施采购过程的组织过程资产包括（但不限于）：</p><ul><li><p>预审合格的优先卖方清单；</p></li><li><p>会影响卖方选择的组织政策；</p></li><li><p>组织中关于协议起草及签订的具体模板或指南；</p></li><li><p>关于付款申请和支付过程的财务政策和程序。</p></li></ul><h4 id="2-2-实施采购：工具与技术"><a href="#2-2-实施采购：工具与技术" class="headerlink" title="2.2 实施采购：工具与技术"></a>2.2 实施采购：工具与技术</h4><h5 id="2-2-1-专家判断"><a href="#2-2-1-专家判断" class="headerlink" title="2.2.1 专家判断"></a>2.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>建议书评估；</p></li><li><p>技术或相关主题事宜；</p></li><li><p>相关的职能领域，如财务、工程、设计、开发、供应链管理等；</p></li><li><p>行业监管环境；</p></li><li><p>法律法规和合规性要求；</p></li><li><p>谈判。</p></li></ul><h5 id="2-2-2-广告"><a href="#2-2-2-广告" class="headerlink" title="2.2.2 广告"></a>2.2.2 广告</h5><p>广告是就产品、服务或成果与用户或潜在用户进行的沟通。在大众出版物（如指定的报纸）或专门行业出版物上刊登广告，往往可以扩充现有的潜在卖方名单。大多数政府机构都要求公开发布采购广告，或在网上公布拟签署的政府合同的信息。</p><h5 id="2-2-3-投标人会议"><a href="#2-2-3-投标人会议" class="headerlink" title="2.2.3 投标人会议"></a>2.2.3 投标人会议</h5><p>投标人会议（又称承包商会议，供应商会议或投标前会议）是在卖方提交建议书之前，在买方和潜在卖方之间召开的会议，其目的是确保所有潜在投标人对采购要求都有清楚且一致的理解，并确保没有任何投标人会得到特别优待。</p><h5 id="2-2-4-数据分析"><a href="#2-2-4-数据分析" class="headerlink" title="2.2.4 数据分析"></a>2.2.4 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）建议书评估。对建议书进行评估，确定它们是否对包含在招标文件包中的招标文件、采购工作说明书、供方选择标准和其他文件，都做出了完整且充分的响应。</p><h5 id="2-2-5-人际关系与团队技能"><a href="#2-2-5-人际关系与团队技能" class="headerlink" title="2.2.5 人际关系与团队技能"></a>2.2.5 人际关系与团队技能</h5><p>适用于本过程的人际关系与团队技能包括谈判。谈判是为达成协议而进行的讨论。采购谈判是指在合同签署之前，对合同的结构、各方的权力和义务，以及其他条款加以澄清，以便双方达成共识。最终的文件措辞应该反映双方达成的全部一致意见。谈判以签署买方和卖方均可执行的合同文件或其他正式协议而结束。</p><p>谈判应由采购团队中拥有合同签署职权的成员主导。项目经理和项目管理团队的其他成员可以参加谈判并提供必要的协助。</p><h4 id="2-3-实施采购：输出"><a href="#2-3-实施采购：输出" class="headerlink" title="2.3 实施采购：输出"></a>2.3 实施采购：输出</h4><h5 id="2-3-1-选定的卖方"><a href="#2-3-1-选定的卖方" class="headerlink" title="2.3.1 选定的卖方"></a>2.3.1 选定的卖方</h5><p>选定的卖方是在建议书评估或投标评估中被判断为最有竞争力的投标人。对于较复杂、高价值和高风险的采购，在授予合同前，要把选定的卖方报给组织高级管理人员审批。</p><h5 id="2-3-2-协议"><a href="#2-3-2-协议" class="headerlink" title="2.3.2 协议"></a>2.3.2 协议</h5><p>合同是对双方都有约束力的协议。它强制卖方提供规定的产品、服务或成果，强制买方向卖方支付相应的报酬。合同建立了受法律保护的买卖双方的关系。协议文本的主要内容会有所不同，可包括（但不限于）：</p><ul><li><p>采购工作说明书或主要的可交付成果；</p></li><li><p>进度计划、里程碑，或进度计划中规定的日期；</p></li><li><p>绩效报告；</p></li><li><p>定价和支付条款；</p></li><li><p>检查、质量和验收标准；</p></li><li><p>担保和后续产品支持；</p></li><li><p>激励和惩罚；</p></li><li><p>保险和履约保函；</p></li><li><p>下属分包商批准；</p></li><li><p>一般条款和条件；</p></li><li><p>变更请求处理；</p></li><li><p>终止条款和替代争议解决方法。</p></li></ul><h5 id="2-3-3-变更请求"><a href="#2-3-3-变更请求" class="headerlink" title="2.3.3 变更请求"></a>2.3.3 变更请求</h5><p>通过实施整体变更控制过程，来审查和处理对项目管理计划及其子计划和其他组件的变更请求。</p><h5 id="2-3-4-项目管理计划更新"><a href="#2-3-4-项目管理计划更新" class="headerlink" title="2.3.4 项目管理计划更新"></a>2.3.4 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更的项目管理计划组件包括（但不限于）：</p><ul><li><p>需求管理计划。项目需求可能因卖方的要求而变更。</p></li><li><p>质量管理计划。卖方可能提出备选质量标准或者备选解决方案，从而影响质量管理计划中规定的质量管理方法。</p></li><li><p>沟通管理计划。在选定卖方后，需要更新沟通管理计划，记录卖方的沟通需求和方法。</p></li><li><p>风险管理计划。每个协议和卖方都会带来独特的风险，从而需要更新风险管理计划。具体的风险应该记录到风险登记册中。</p></li><li><p>采购管理计划。可能需要基于合同谈判和签署的结果，而更新采购管理计划。</p></li><li><p>范围基准。在执行采购活动时，需明确考虑范围基准中的项目工作分解结构和可交付成果。本过程可能导致对任何一个或全部可交付成果的变更。</p></li><li><p>进度基准。如果卖方交付成果方面的变更影响了项目的整体进度绩效，则可能需要更新并审批基准进度计划，以反映当前的期望。</p></li><li><p>成本基准。在项目交付期间，承包商的材料价格和人力价格可能随外部经济环境而频繁变动。这种变动需要反映到成本基准中。</p></li></ul><h5 id="2-3-5-项目文件更新"><a href="#2-3-5-项目文件更新" class="headerlink" title="2.3.5 项目文件更新"></a>2.3.5 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。更新经验教训登记册，记录在实施采购期间所遇到的挑战、本可采取的规避方法，以及有效的方法。</p></li><li><p>需求文件。需求文件可能包括：</p><ul><li><p>卖方需要满足的技术要求；</p></li><li><p>具有合同和法律意义的需求，如健康、安全、安保、绩效、环境、保险、知识产权、同等就业机会、执照、许可证，以及其他非技术要求。</p></li></ul></li><li><p>需求跟踪矩阵。随着将卖方纳入项目计划，可能需要根据特定卖方的能力，变更需求登记册及跟踪矩阵。</p></li><li><p>资源日历。可能需要根据卖方的可用性更新与进度计划有关的资源日历。</p></li><li><p>风险登记册。取决于卖方的组织、合同的持续时间、外部环境、项目交付方法、所选合同类型，以及最终商定的价格，每个被选中的卖方都会带来特殊的风险。在合同签署过程中，应该对风险登记册进行变更，以反映每个卖方带来的具体风险。</p></li><li><p>相关方登记册。此文件包含与已识别相关方有关的所有详细信息。与具体卖方签订协议后，需要更新相关方登记册。</p></li></ul><h5 id="2-3-6-组织过程资产更新"><a href="#2-3-6-组织过程资产更新" class="headerlink" title="2.3.6 组织过程资产更新"></a>2.3.6 组织过程资产更新</h5><p>可在实施采购过程更新的组织过程资产包括：</p><ul><li><p>潜在和预审合格的卖方清单；</p></li><li><p>与卖方合作的相关经验，包括正反两方面；</p></li></ul><hr><h3 id="三、控制采购"><a href="#三、控制采购" class="headerlink" title="三、控制采购"></a>三、控制采购</h3><p>控制采购是管理采购关系，监督合同绩效，实施必要的变更和纠偏，以及关闭合同的过程。本过程的主要作用是，确保买卖双方履行法律协议，满足项目需求。本过程应根据需要在整个项目期间开展。图12-6描述本过程的输入、工具与技术和输出，图12-7是本过程的数据流向图。</p><p><img src="/images/pmp-12/12-6.png" alt="控制采购：输入、工具与技术和输出"></p><p><img src="/images/pmp-12/12-7.png" alt="控制采购：数据流向图"></p><p>买方和卖方都处于相似的目的来管理采购合同，每方都必须确保双方履行合同义务，确保各自的合法权利得到保护。合同关系的法律性质，要求项目管理团队必须了解在控制采购期间所采取的任何行动的法律后果。对于有多个供应商的较大项目，合同管理的一个重要方面就是管理各个供应商之间的沟通。</p><p>鉴于其法律意义，很多组织都将合同管理视为独立与项目的一种组织职能。虽然采购管理员可以是项目团队成员，但通常还向另一部门的经理报告。</p><p>在控制采购过程中，需要把适当的项目管理过程应用于合同关系，并且需要整合这些过程的输出，以用于对项目的整体管理。如果涉及多个卖方，以及多种产品、服务或成果，就往往需要在多个层级上开展这种整合。</p><p>合同管理活动可能包括：</p><ul><li><p>收集数据和管理项目记录，包括维护对实体和财务绩效的详细记录，以及建立可测量的采购绩效指标；</p></li><li><p>完善采购计划和进度计划；</p></li><li><p>建立与采购相关的项目数据的收集、分析和报告机制，并为组织编制定期报告；</p></li><li><p>监督采购环境，以便引导或调整实施；</p></li><li><p>向卖方付款。</p></li></ul><p>控制措施的质量，包括采购审计的独立性和可信度，是采购系统可靠性的关键决定因素。组织的道德规范、内部法律顾问和外部法律咨询，包括持续的反复计划，都有助于实现适当的采购控制。</p><p>在控制采购过程中，需要开展财务管理工作，包括监督向卖方付款。这是要确保合同中的支付条款得到遵循，确保按合同规定，把付款与卖方的工作进展联系起来。需要重点关注的一点是，确保向卖方的付款与卖方实际已经完成的工作量之间有密切的关系。如果合同规定了基于项目输出及可交付成果来付款，而不是基于项目输入（如工时），那么就可以更有效地开展采购控制。</p><p>在合同收尾前，若双方达成共识，可以根据协议中的变更控制条款，随时对协议进行修改。通常要书面记录对协议的修改。</p><h4 id="3-1-控制采购：输入"><a href="#3-1-控制采购：输入" class="headerlink" title="3.1 控制采购：输入"></a>3.1 控制采购：输入</h4><h5 id="3-1-1-项目管理计划"><a href="#3-1-1-项目管理计划" class="headerlink" title="3.1.1 项目管理计划"></a>3.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>需求管理计划。需求管理计划描述将如何分析、记录和管理承包商需求。</p></li><li><p>风险管理计划。风险管理计划描述如何安排和实施由卖方引发的项目风险管理活动。</p></li><li><p>采购管理计划。采购管理计划规定了在控制采购过程中需要开展的活动。</p></li><li><p>变更管理计划。变更管理计划包含关于如何处理由卖方引发的变更的信息。</p></li><li><p>进度基准。如果卖方的进度拖后影响了项目的整体进度绩效，则可能需要更新并审批进度计划，以反映当前的期望。</p></li></ul><h5 id="3-1-2-项目文件"><a href="#3-1-2-项目文件" class="headerlink" title="3.1.2 项目文件"></a>3.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>假设日志。假设日志记录了采购过程中做出的假设。</p></li><li><p>经验教训登记册。在项目早期获取的经验教训可供项目未来使用，以改进承包商绩效和采购过程。</p></li><li><p>里程碑清单。重要里程碑清单说明卖方需要在何时交付成果。</p></li><li><p>质量报告。质量报告用于识别不合规的卖方过程、程序或产品。</p></li><li><p>需求文件。需求文件可能包括：</p><ul><li><p>卖方需要满足的技术要求；</p></li><li><p>具有合同和法律意义的需求，如健康、安全、安保、绩效、环境、保险、知识产权、同等就业机会、执照、许可证，以及其他非技术要求。</p></li></ul></li><li><p>需求跟踪矩阵。需求跟踪矩阵将产品需求从其来源连接到能满足需求的可交付成果。</p></li><li><p>风险登记册。取决于卖方的组织、合同的持续时间、外部环境、项目交付方法、所选合同类型，以及最终商定的价格，每个被选中的卖方都会带来特殊的风险。</p></li><li><p>相关方登记册。相关方登记册包括关于已识别相关方的信息，例如，合同团队成员、选定的卖方、签署合同的专员，以及参与采购的其他相关方。</p></li></ul><h5 id="3-1-3-协议"><a href="#3-1-3-协议" class="headerlink" title="3.1.3 协议"></a>3.1.3 协议</h5><p>协议是双方之间达成的谅解，包括对各方义务的一致理解。对照相关协议，确认其中的条款和条件的遵守情况。</p><h5 id="3-1-4-采购文档"><a href="#3-1-4-采购文档" class="headerlink" title="3.1.4 采购文档"></a>3.1.4 采购文档</h5><p>采购文档包含用于管理采购过程的完整支持性记录，包括工作说明书、支付信息、承包商工作绩效信息、计划、图纸和其他往来函件。</p><h5 id="3-1-5-批准的变更请求"><a href="#3-1-5-批准的变更请求" class="headerlink" title="3.1.5 批准的变更请求"></a>3.1.5 批准的变更请求</h5><p>批准的变更请求可能包括对合同条款和条件的修改，例如，修改采购工作说明书、定价，以及对产品、服务或成果的描述。与采购相关的任何变更，在通过控制采购过程实施之前，都需要以书面形式正式记录，并取得正式批准。在复杂的项目和项目集中，变更请求可能由参与项目的卖方提出，并对参与项目的其他卖方造成影响。项目团队应该有能力去识别、沟通和解决会影响多个卖方的工作的变更。</p><h5 id="3-1-6-工作绩效数据"><a href="#3-1-6-工作绩效数据" class="headerlink" title="3.1.6 工作绩效数据"></a>3.1.6 工作绩效数据</h5><p>工作绩效数据包含与项目状态有关的卖方数据，例如，绩效数据，已启动、进展中或已结束的活动，已产生或投入的成本。工作绩效数据还可能包括已向卖方付款的情况。</p><h5 id="3-1-7-事业环境因素"><a href="#3-1-7-事业环境因素" class="headerlink" title="3.1.7 事业环境因素"></a>3.1.7 事业环境因素</h5><p>能够影响控制采购过程的事业环境因素包括（但不限于）：</p><ul><li><p>合同变更控制系统；</p></li><li><p>市场条件；</p></li><li><p>财务管理和应付账款系统；</p></li><li><p>采购组织的道德规范。</p></li></ul><h5 id="3-1-8-组织过程资产"><a href="#3-1-8-组织过程资产" class="headerlink" title="3.1.8 组织过程资产"></a>3.1.8 组织过程资产</h5><p>能够影响控制采购过程的组织过程资产包括（但不限于）采购政策。</p><h4 id="3-2-控制采购：工具与技术"><a href="#3-2-控制采购：工具与技术" class="headerlink" title="3.2 控制采购：工具与技术"></a>3.2 控制采购：工具与技术</h4><h5 id="3-2-1-专家判断"><a href="#3-2-1-专家判断" class="headerlink" title="3.2.1 专家判断"></a>3.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>相关的职能领域，如财务、工程、设计、开发、供应链管理等；</p></li><li><p>法律法规和合规性要求；</p></li><li><p>索赔管理。</p></li></ul><h5 id="3-2-2-索赔管理"><a href="#3-2-2-索赔管理" class="headerlink" title="3.2.2 索赔管理"></a>3.2.2 索赔管理</h5><p>如果买卖双方不能就变更补偿达成一致意见，或对变更是否发生存在分歧，那么被请求的变更就称为有争议的变更或潜在的推定变更。此类有争议的变更称为索赔。如果不能妥善解决，它们会成为争议并最终引发申诉。在整个合同生命周期中，通常会按照合同条款对索赔进行记录、处理、监督和管理。如果合同双方无法自行解决索赔问题，则可能不得不按合同中规定的程序，用替代争议解决方法（ADR）去处理。谈判是解决所有索赔和争议的首选方法。</p><h5 id="3-2-3-数据分析"><a href="#3-2-3-数据分析" class="headerlink" title="3.2.3 数据分析"></a>3.2.3 数据分析</h5><p>用于监督和控制采购的数据分析技术包括（但不限于）：</p><ul><li><p>绩效审查。对照协议，对质量、资源、进度和成本绩效进行测量、比较和分析，以审查合同工作的绩效。其中包括确定工作包提前或落后于进度计划、超出或低于预算，以及是否存在资源或质量问题。</p></li><li><p>挣值分析（EVA）。计算进度和成本偏差，以及禁毒和成本绩效指数，以确定偏离目标的程度。</p></li><li><p>趋势分析。趋势分析可用于编制关于成本绩效的完工估算（EAC），以确定绩效是正在改善还是恶化。</p></li></ul><h5 id="3-2-4-检查"><a href="#3-2-4-检查" class="headerlink" title="3.2.4 检查"></a>3.2.4 检查</h5><p>检查是指对承包商正在执行的工作进行结构化审查，可能涉及对可交付成果的简单审查，或对工作本身的实地审查。在施工、工程和基础设施建设项目中，检查包括买方和承包商联合巡检现场，以确保双方对正在进行的工作有共同的认识。</p><h5 id="3-2-5-审计"><a href="#3-2-5-审计" class="headerlink" title="3.2.5 审计"></a>3.2.5 审计</h5><p>审计是对采购过程的结构化审查。应该在采购合同中明确规定与审计有关的权利和义务。买方的项目经理和卖方的项目经理都应该关注审计结果，以便对项目进行必要调整。</p><h4 id="3-3-控制采购：输出"><a href="#3-3-控制采购：输出" class="headerlink" title="3.3 控制采购：输出"></a>3.3 控制采购：输出</h4><h5 id="3-3-1-采购关闭"><a href="#3-3-1-采购关闭" class="headerlink" title="3.3.1 采购关闭"></a>3.3.1 采购关闭</h5><p>买方通常通过其授权的采购管理员，向卖方发出合同已经完成的正式书面通知。关于正式关闭采购的要求，通常已在合同条款和条件中规定，并包括在采购管理计划中。一般而言，这些要求包括：已按时按质按技术要求交付全部可交付成果，没有未决索赔或发票，全部最终款项已经付清。项目管理团队应该在关闭采购之前批准所有的可交付成果。</p><h5 id="3-3-2-工作绩效信息"><a href="#3-3-2-工作绩效信息" class="headerlink" title="3.3.2 工作绩效信息"></a>3.3.2 工作绩效信息</h5><p>工作绩效信息是卖方正在履行的工作的绩效情况，包括与合同要求相比较的可交付成果完成情况和技术绩效达成情况，以及与SOW预算相比较的已完工作的成本产生和认可情况。</p><h5 id="3-3-3-采购文档更新"><a href="#3-3-3-采购文档更新" class="headerlink" title="3.3.3 采购文档更新"></a>3.3.3 采购文档更新</h5><p>采购文档更新可包括用于支持合同的全部进度计划、已提出但未批准的合同变更，以及已批准的变更请求。采购文档还包括由卖方编制的技术文件，以及其他工作绩效信息，例如，可交付成果的状况、卖方绩效报告和担保、财务文件（包括发票和支付记录），以及与合同相关的检查结果。</p><h5 id="3-3-4-变更请求"><a href="#3-3-4-变更请求" class="headerlink" title="3.3.4 变更请求"></a>3.3.4 变更请求</h5><p>在控制采购过程中，可能提出对项目管理计划及其子计划和其他组件的变更请求，例如，成本基准、进度基准和采购管理计划。应该通过实施整体变更控制过程对变更请求进行审查和处理。</p><p>已提出而未解决的变更，可能包括买方发布的指示或卖方采取的行动，而对方认为该指示或行动已构成对合同的推定变更。因为双方可能对推定变更存在争议，并可能引起一方向另一方索赔，所以通常应该在项目往来函件中对推定变更进行专门识别和记录。</p><h5 id="3-3-5-项目管理计划更新"><a href="#3-3-5-项目管理计划更新" class="headerlink" title="3.3.5 项目管理计划更新"></a>3.3.5 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更的项目管理计划组件包括（但不限于）：</p><ul><li><p>风险管理计划。每个协议和卖方都会带来独特的风险，因此可能需要更新风险管理计划。如何在执行合同期间发生重大的以外风险，则风险管理计划可能需要更新。应该把具体的风险记录到风险登记册中。</p></li><li><p>采购管理计划。采购管理计划包含在采购过程中需要开展的活动。可能需要基于卖方执行工作的绩效情况，对采购管理计划进行更新。</p></li><li><p>进度基准。如果卖方的重大进度变更影响到了项目的整体进度绩效，则可能需要更新并审批基准进度计划，以反映当前的期望。买方应该注意某个卖方的进度拖延，可能对其他卖方的工作造成连锁影响。</p></li><li><p>成本基准。在项目交付期间，承包商的材料价格和人力价格可能随外部经济环境而频繁变动。这种变动需要反映到成本基准中。</p></li></ul><h5 id="3-3-6-项目文件更新"><a href="#3-3-6-项目文件更新" class="headerlink" title="3.3.6 项目文件更新"></a>3.3.6 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。更新经验教训登记册，记录能有效维护采购工作的范围、进度和成本的技术。对于出现的偏差，经验教训登记册应该记录曾采取的纠正措施及其有效性。如果已经发生索赔，则应记录相关信息以避免重蹈覆辙，其他关于如何改善采购过程的信息也应记录在内。</p></li><li><p>资源需求。随着承包商的工作进展，可能因工作执行不符合原定计划而需要变更资源需求。</p></li><li><p>需求跟踪矩阵。更新需求跟踪矩阵，记录已实现的需求。</p></li><li><p>风险登记册。取决于卖方的组织、合同的持续时间、外部环境、项目交付方法、所选合同类型，以及最终商定的价格，每个被选中的卖方都会带来特殊的风险。随着早期风险的过时以及新风险的出现，在项目执行期间对风险登记册进行变更。</p></li><li><p>相关方登记册。随着执行阶段的工作进展，承包商和供应商可能发生变更，应该把承包商和供应商的变更情况记录在相关方登记册中。</p></li></ul><h5 id="3-3-7-组织过程资产更新"><a href="#3-3-7-组织过程资产更新" class="headerlink" title="3.3.7 组织过程资产更新"></a>3.3.7 组织过程资产更新</h5><p>作为控制采购过程的结果，需要更新的组织过程资产包括（但不限于）：</p><ul><li><p>支付计划和请求。所有支付都应按合同条款和条件进行。</p></li><li><p>卖方绩效评估文件。卖方绩效评估文件由买方准备，用于记录卖方继续执行当前合同工作的能力，说明是否允许卖方承接未来的项目，或对卖方现在的项目执行工作或过去的执行工作进行评级。</p></li><li><p>预审合格卖方清单更新。预审合格卖方清单是以前已经通过资格审查（获得批准）的潜在卖方的清单。因为卖方可能因绩效不佳而被取消资格并从清单中删除，所以应该根据控制采购过程的结果来更新这个清单。</p></li><li><p>经验教训知识库。经验教训应该归档到经验教训知识库中，以改善未来项目的采购工作。在合同执行终了时，应该采购的世纪城郭与原始采购管理计划中的预期成果进行比较。应该在经验教训中说明项目目标是否达成；若未达成，则说明原因。</p></li><li><p>采购档案。应该准备好带索引的全套合同文档，包括已关闭的合同，并将其纳入最终的项目档案。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《PMBOK第六版》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目采购管理包括从项目团队外部采购或获取所需产品、服务或成果的各个过程。项目采购管理包括编制和管理协议所需的管理和控制过程，例如，合同、订购单、协议备忘录（MOA），或服务水平协议（SLA）。被授权采购项目所需货物和（或）服务的人员可以是项目团队、管理层或组织采购部（如果有）的成员。&lt;/p&gt;
    
    </summary>
    
      <category term="PMP抄书系列" scheme="http://www.xiaoleon.cn/categories/PMP%E6%8A%84%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="pmp" scheme="http://www.xiaoleon.cn/tags/pmp/"/>
    
  </entry>
  
  <entry>
    <title>PMP(11) 项目风险管理</title>
    <link href="http://www.xiaoleon.cn/2019/04/04/pmp-11/"/>
    <id>http://www.xiaoleon.cn/2019/04/04/pmp-11/</id>
    <published>2019-04-04T13:25:39.000Z</published>
    <updated>2019-05-13T09:48:38.578Z</updated>
    
    <content type="html"><![CDATA[<p>项目风险管理包括规划风险管理、识别风险、开展风险分析、规划风险应对、实施风险应对和监督风险的各个过程。项目风险管理的目标在于提高正面风险的概率和（或）影响，降低负面风险的概率和（或）影响，从而提高项目成功的可能性。</p><a id="more"></a><p>项目风险管理的过程是：</p><ul><li><p><strong>规划风险管理</strong> —— 定义如何实施项目风险管理活动的过程。</p></li><li><p><strong>识别风险</strong> —— 识别单个项目风险，以及整体项目风险的来源，并记录风险特征的过程。</p></li><li><p><strong>实施定性风险分析</strong> —— 通过评估单个项目风险发生的概率和影响以及其他特征，对风险进行优先级排序，从而为后续分析或行动提供基础的过程。</p></li><li><p><strong>实施定量风险分析</strong> —— 就已识别的单个项目风险和其他不确定性的来源对整体项目目标的综合影响进行定量分析的过程。</p></li><li><p><strong>规划风险应对</strong> —— 为处理整体项目风险敞口，以及应对单个项目风险，而制定可选方案、选择应对策略并商定应对行动的过程。</p></li><li><p><strong>实施风险应对</strong> —— 执行商定的风险应对计划的过程。</p></li><li><p><strong>监督风险</strong> —— 在整个项目期间，监督商定的风险应对计划的实施、跟踪已识别风险、识别和分析新风险，以及评估风险管理有效性的过程。</p></li></ul><p>图11-1概括了项目风险管理的各个过程。虽然在本《PMBOK指南》中，各项目管理风险过程以界限分明和相互独立的形式出现，但在实践中它们会以本指南无法全面详述的方式相互交叠和相互作用。</p><p><img src="/images/pmp-11/11-1.png" alt="项目风险管理概述"></p><p><strong>项目风险管理的核心概念</strong></p><p>既然项目是为交付收益而开展的、具有不同复杂程度的独特性工作，那自然就会充满风险。开展项目，不仅要面对各种制约因素和假设条件，而且还要应对可能相互冲突和不断变化的相关方期望。组织应该有目的地以可控方式去冒项目风险，以便平衡风险和回报，并创造价值。</p><p>项目风险管理旨在识别和管理未被其他项目管理过程所管理的风险。如果不妥善管理，这些风险有可能导致项目偏离计划，无法达成既定的项目目标。因此，项目风险管理的有效性直接关乎项目成功与否。</p><p>每个项目都在两个层面上存在风险。每个项目都有会影响项目达成目标的单个风险，以及由单个项目风险和不确定性的其它来源联合导致的整体项目风险。考虑整体项目风险，也非常重要。项目风险管理过程同时兼顾这两个层面的风险。它们的定义如下：</p><ul><li><p>单个项目风险是一旦发生，会对一个或多个项目目标产生正面或负面影响的不确定事件或条件。</p></li><li><p>整体项目风险是不确定性对项目整体的影响，是相关方面临的项目结果正面和负面变异区间。它源于包括单个风险在内的所有不确定性。</p></li></ul><p>一旦发生，单个项目风险会对项目目标产生正面或负面的影响。项目风险管理旨在利用或强化正面风险（机会），规避或减轻负面风险（威胁）。未妥善管理的威胁可能引发各种问题，如工期延误、成本超支、绩效不佳或声誉受损。把握好机会则能够获得众多好处，如工期缩短、成本节约、绩效改善或声誉提升。</p><p>整体项目风险也有正面或负面之分。管理整体项目风险旨在通过削弱负面变异的驱动因素，加强正面变异的驱动因素，以及最大化实现整体项目目标的概率，把项目风险敞口保持在可接受的范围之内。</p><p>因为风险会在项目生命周期内持续发生，所以，项目风险管理过程也应不断迭代开展。在项目规划期间，就应该通过调整项目策略对风险做初步处理。接着，应该随着项目进展，监督和管理风险，确保项目处于正轨，并且突发性风险也得到处理。</p><p>为有效管理特定项目的风险，项目团队需要知道，相对于要追求的项目目标，可接受的风险敞口究竟是多大。这通常用可测量的风险临界值来定义。风险临界值反映了组织与项目相关方的风险偏好程度，是项目目标的可接受的变异程度。应该明确规定风险临界，并传达给项目团队，同时反映在项目的风险影响级别定义中。</p><p><strong>项目风险管理的发展趋势和新兴实践</strong></p><p>项目风险管理的关注面正在扩大，以便确保考虑所有类型的风险，并在更广泛的背景中理解项目风险。项目风险管理的发展趋势和新兴实践包括（但不限于）：</p><ul><li><p>非事件类风险。大多数项目只关注作为可能发生或不发生的不确定性未来事件的风险。例如：关键卖方可能在项目期间停业，客户可能在设计完成后变更需求，或分包商可能要求对标准化操作流程进行优化。</p><p>  不过，识别并管理非事件类风险的意识正在不断加强。非事件类风险有两种主要类型：</p><ul><li><p>变异性风险。已规划事件、活动或决策的某些关键方面存在不确定性，就导致变异性风险。例如，生产率可能高于或低于目标值，测试发现的错误数量可能多于或少于预期，或施工阶段可能出现反常的天气情况。</p></li><li><p>模糊性风险。对未来可能发生什么，存在不确定性。知识不足可能影响项目达成目标的能力，例如，不太了解需求或技术解决方案的要素、法规框架的未来发展，或项目内在的系统复杂性。</p><p>变异性风险可通过蒙特卡洛分析加以处理，即：用概率分布表示变异的可能区间，然后采取行动去缩小可能结果的区间。管理模糊性风险，则需要先定义认知或理解不足之处，进而通过获取外部专家意见或以最佳实践为标杆来填补差距。也可以采用增量开发、原型搭建或模拟等方法来处理模糊性风险。</p></li></ul></li><li><p>项目韧性。随着对所谓“未知-未知”因素的意识的增强，人们也越来越明确地知道确实存在突发性风险。这种风险只有在发生后才能被发现。可以通过加强韧性来应对突发性风险。这就要求每个项目：</p><ul><li><p>除了为已知风险列出具体风险预算，还要为突发性风险预留合理的应急预算和时间；</p></li><li><p>采用灵活的项目过程，包括强有力的变更管理，以便在保持朝项目目标推进的正确方向的同时，应对突发性风险；</p></li><li><p>授权目标明确且值得信赖的项目团队在商定限制范围内完成工作；</p></li><li><p>经常留意早期预警信号，以尽早识别突发性风险；</p></li><li><p>明确征求相关方的意见，以明确为应对突发性风险而可以调整项目范围或策略的领域。</p></li></ul></li><li><p>整合式风险管理。项目存在与组织背景中，可能是项目集或项目组合的一部分。在项目、项目集、项目组合和组织这些层面上，都存在风险。应该在适当的层面上承担和管理风险。在较高层面识别出的某些风险，将被授权给项目团队去管理；而在较低层面识别出的某些风险，有可能上交给较高层面去管理（如果在项目之外管理最有效）。应该采用协调式企业级风险管理方法，来确保所有层面的风险管理工作的一致性和连贯性。这样就能使项目集和项目组合的解构具有风险效率，有利于在给定的风险敞口水平下创造最大的整体价值。</p></li></ul><p><strong>裁剪时需要考虑的因素</strong></p><p>因为每个项目都是独特的，所以有必要对项目风险管理过程的应用方式进行裁剪。裁剪时应考虑的因素包括（但不限于）：</p><ul><li><p>项目规模。由预算、持续时间、范围或团队人数所体现的项目规模，要求采取更详细的风险管理方法吗？或者项目小到只需要用简化的风险管理过程吗？</p></li><li><p>项目复杂性。由高水平创新、新技术采用、商务安排、界面或外部依赖关系导致的项目复杂性提高，是否要求采用更稳健的风险管理方法？或者项目是否简单到只需要用简化的风险管理过程？</p></li><li><p>项目重要性。项目的战略重要性有多大？项目的风险级别因旨在创造突破性机会、克服组织经营的重大障碍或涉及重大产品创新而提高了吗？</p></li><li><p>开发方法。它是否是瀑布式项目，风险管理过程可以相继或重复开展；或者此项目是否采取敏捷型方法，需在每个重复过程的开始阶段以及执行期间处理风险？</p></li></ul><p>根据上述需考虑的因素来裁剪项目风险管理过程，这是规划风险管理过程的一部分工作。裁剪结果将被记录在风险管理计划中。</p><p><strong>在敏捷或适应型环境中需要考虑的因素</strong></p><p>从本质上讲，越是变化的环境就存在越多的不确定性和风险。要应对快速变化，就需要采用适应型方法管理项目，即：通过跨职能项目团队和经常审查增量式工作产品，来加快知识分享，确保对风险的认知和管理。再选择每个迭代期的工作内容时，应该考虑风险；在每个迭代期间应该识别、分析和管理风险。</p><p>此外，应该根据对当前风险敞口的理解的加深，定期更新需求文件，并随项目进展重新排列工作优先级。</p><h3 id="一、规划风险管理"><a href="#一、规划风险管理" class="headerlink" title="一、规划风险管理"></a>一、规划风险管理</h3><p>规划风险管理是定义如何实施项目风险管理活动的过程。本过程的主要作用是，确保风险管理的水平、方法和可见度与项目风险程度，以及项目对组织和其他相关方的重要程度相匹配。本过程仅开展一次或仅在项目的预定义点开展。图11-2描述本过程的输入、工具与技术和输出。图11-3是本过程的数据流向图。</p><p><img src="/images/pmp-11/11-2.png" alt="规划风险管理：输入、工具与技术和输出"></p><p><img src="/images/pmp-11/11-3.png" alt="规划风险管理：数据流向图"></p><p>规划风险管理过程在项目构思阶段就应开始，并在项目早期完成。在项目生命周期的后期，可能有必要重新开展本过程，例如，在发生重大阶段变更时，在项目范围显著变化时，或者后续对风险管理有效性进行审查且确定需要调整项目风险管理过程时。</p><h4 id="1-1-规划风险管理：输入"><a href="#1-1-规划风险管理：输入" class="headerlink" title="1.1 规划风险管理：输入"></a>1.1 规划风险管理：输入</h4><h5 id="1-1-1-项目章程"><a href="#1-1-1-项目章程" class="headerlink" title="1.1.1 项目章程"></a>1.1.1 项目章程</h5><p>项目章程记录了高层级的项目描述和边界、高层级的需求和风险。</p><h5 id="1-1-2-项目管理计划"><a href="#1-1-2-项目管理计划" class="headerlink" title="1.1.2 项目管理计划"></a>1.1.2 项目管理计划</h5><p>在规划项目风险管理时，应该考虑所有已批准的子管理计划，使风险管理计划与之相协调；同时，其他项目管理计划组件中所列出的方法论可能也会影响规划风险管理过程。</p><h5 id="1-1-3-项目文件"><a href="#1-1-3-项目文件" class="headerlink" title="1.1.3 项目文件"></a>1.1.3 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）相关方登记册。相关方登记册包含项目相关方的详细信息，并概述其在项目中的角色和对项目风险的态度；可用于确定项目风险管理的角色和职责，以及为项目设定风险临界值。</p><h5 id="1-1-4-事业环境因素"><a href="#1-1-4-事业环境因素" class="headerlink" title="1.1.4 事业环境因素"></a>1.1.4 事业环境因素</h5><p>会影响规划风险管理过程的事业环境因素包括（但不限于）由组织或关键相关方设定的整体风险临界值。</p><h5 id="1-1-5-组织过程资产"><a href="#1-1-5-组织过程资产" class="headerlink" title="1.1.5 组织过程资产"></a>1.1.5 组织过程资产</h5><p>会影响规划风险管理过程的组织过程资产包括（但不限于）：</p><ul><li><p>组织的风险政策；</p></li><li><p>风险类别，可能用风险分解结构来表示；</p></li><li><p>风险概念和术语的通用定义；</p></li><li><p>风险描述的格式；</p></li><li><p>风险管理计划、风险登记册和风险报告的模板；</p></li><li><p>角色与职责；</p></li><li><p>决策所需的职权级别；</p></li><li><p>经验教训知识库，其中包含以往类似项目的信息。</p></li></ul><h4 id="1-2-规划风险管理：工具与技术"><a href="#1-2-规划风险管理：工具与技术" class="headerlink" title="1.2 规划风险管理：工具与技术"></a>1.2 规划风险管理：工具与技术</h4><h5 id="1-2-1-专家判断"><a href="#1-2-1-专家判断" class="headerlink" title="1.2.1 专家判断"></a>1.2.1 专家判断</h5><p>应考虑具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>熟悉组织所采取的管理风险的方法，包括该方法所在的企业风险管理体系；</p></li><li><p>裁剪风险管理以适应项目的具体需求；</p></li><li><p>在相同领域的项目上可能遇到的风险类型。</p></li></ul><h5 id="1-2-2-数据分析"><a href="#1-2-2-数据分析" class="headerlink" title="1.2.2 数据分析"></a>1.2.2 数据分析</h5><p>可用于本过程的数据分析技术包括（但不限于）相关方分析。可通过相关方分析确定项目相关方的风险偏好。</p><h5 id="1-2-3-会议"><a href="#1-2-3-会议" class="headerlink" title="1.2.3 会议"></a>1.2.3 会议</h5><p>风险管理计划的编制可以是项目开工会议上的一项工作，或者可以举办专门的规划会议来编制风险管理计划。参会者可能包括项目经理、指定项目团队成员、关键相关方，或者负责管理项目风险管理过程的团队成员；如果需要，也可邀请其他外部人员参加，包括客户、卖方和监管机构。熟练的会议引导者能够帮助参会者专注于会议事项，就风险管理方法的关键方面达成共识，识别和克服偏见，以及解决任何可能出现的分歧。</p><p>在此类会议上确定开展风险管理活动的计划，并将其记录在风险管理计划中。</p><h4 id="1-3-规划风险管理：输出"><a href="#1-3-规划风险管理：输出" class="headerlink" title="1.3 规划风险管理：输出"></a>1.3 规划风险管理：输出</h4><h5 id="1-3-1-风险管理计划"><a href="#1-3-1-风险管理计划" class="headerlink" title="1.3.1 风险管理计划"></a>1.3.1 风险管理计划</h5><p>风险管理计划是项目管理计划的组成部分，描述如何安排与实施风险管理活动。风险管理计划可包括以下部分或全部内容：</p><ul><li><p>风险管理战略。描述用于管理本项目的风险的一般方法。</p></li><li><p>方法论。确定用于开展本项目的风险管理的具体方法、工具及数据来源。</p></li><li><p>角色与职责。确定每项风险管理活动的领导者、支持者和团队成员，并明确他们的职责。</p></li><li><p>资金。确定开展项目风险管理活动所需的资金，并制定应急储备和管理储备的使用方案。</p></li><li><p>时间安排。确定在项目生命周期中实施项目风险管理过程的时间和频率，确定风险管理活动并将其纳入项目进度计划。</p></li><li><p>风险类别。确定对单个项目风险进行分类的方式。通常借助风险分解结构（RBS）来构建风险类别。风险分解结构是潜在风险来源的层级展现（示例见图11-4）。风险分解结构有助于项目团队考虑单个项目风险的全部可能来源，对识别风险或归类已识别风险特别有用。组织可能有适用于所有项目的通用风险分解结构，也可能针对不同类型项目使用几种不同的风险分解结构框架，或者允许项目量身定制专用的风险分解结构。如果未使用风险分解结构，组织则可能采用某种常见的风险分类框架，既可以是简单的类别清单，也可以使基于项目目标的某种类别结构。</p></li></ul><p><img src="/images/pmp-11/11-4.png" alt="风险分解结构（RBS）示例"></p><ul><li><p>相关方风险偏好。应在风险管理计划中记录项目关键相关方的风险偏好。他们的风险偏好会影像规划风险管理过程的细节。特别是，应该针对每个项目目标，把相关方的风险偏好表述成可测量的风险临界值。这些临界值不仅将联合决定可接受的整体项目风险敞口水平，而且也用于指定概率和影响定义。以后将根据概率和影响定义，对单个项目风险进行评估和排序。</p></li><li><p>风险概率和影响定义。根据具体的项目环境，组织和关键相关方的风险偏好和临界值，来制定风险概率和影响定义。项目可能自行制定关于概率和影响级别的具体定义，或者用组织提供的通用定义作为出发点。应该根据拟开展项目风险管理过程的详细程度，来确定概率和影响级别的数量，即：更多级别（通常为五级）对应于更详细的的风险管理方法，更少级别（通常为三级）对应于更简单的方法。表11-1针对三个项目目标提供了概率和影响定义的示例。通过将影响定义为负面威胁（工期延误、成本增加和绩效不佳）和正面机会（工期缩短、成本节约和绩效改善），表格所示的量表可同时用于评估威胁和机会。</p></li></ul><p><img src="/images/pmp-11/表11-1.png" alt="概率和影响定义示例"></p><ul><li>概率和影响矩阵。组织科在项目开展前确定优先级排序顺序，并将其纳入组织过程资产，或者也可为具体项目量身定制优先级排序规则。在常见的概率和影响矩阵中，会同时列出机会和威胁；以正面影响定义机会，以负面影响定义威胁。概率和影响可以用描述性术语（如很高、高、中、低和很低）或数值来表达。如果使用数值，就可以把两个数值相乘，得出每个风险的概率-影响分值，以便据此在每个优先级组别之内排列单个风险相对优先级。图11-5是概率和影响矩阵的示例，其中也有数值风险评分的可能方法。</li></ul><p><img src="/images/pmp-11/11-5.png" alt="概率和影响矩阵示例（有评分方法）"></p><ul><li><p>报告格式。确定将如何记录、分析和沟通项目风险管理过程的结果。在这一部分，描述风险登记册、风险报告以及项目风险管理过程的其他输出的内容和格式。</p></li><li><p>跟踪。跟踪是确定将如何记录风险活动，以及将如何审计风险的管理过程。</p></li></ul><hr><h3 id="二、识别风险"><a href="#二、识别风险" class="headerlink" title="二、识别风险"></a>二、识别风险</h3><p>识别风险是识别单个项目风险以及整体项目风险的来源，并记录风险特征的过程。本过程的主要作用是，记录现有的单个项目风险，以及整体项目风险的来源；同时，汇集相关信息，以便项目团队能够恰当应对已识别的风险。本过程需要在整个项目期间开展。图11-6描述本过程的输入、工具与技术和输出。图11-7是本过程的数据流向图。</p><p><img src="/images/pmp-11/11-6.png" alt="识别风险：输入、工具与技术和输出"></p><p><img src="/images/pmp-11/11-7.png" alt="识别风险：数据流向图"></p><p>识别风险时，要同时考虑单个项目风险，以及整体项目风险的来源。风险识别活动的参与者可能包括：项目经理、项目团队成员、项目风险专家（若已指定）、客户、项目团队外部的主题专家、最终用户、其他项目经理、运营经理、相关方和组织内的风险管理专家。虽然这些人员通常是风险识别活动的关键参与者，但是还应鼓励所有项目相关方参与单个项目风险的识别工作。项目团队的参与尤其重要，以便培养和保持他们对已识别单个项目风险、整体项目风险级别和相关风险应对措施的主人翁意识和责任感。</p><p>应该采取统一的风险描述格式，来描述和记录单个项目风险，以确保每一项风险都被清楚、明确地理解，从而为有效的分析和风险应对措施制定提供支持。可以在识别风险过程中为单个项目风险指定风险责任人，待实施定性风险分析过程确认。也可以识别和记录初步的风险应对措施，待规划风险应对过程审查和确认。</p><p>在整个项目生命周期中，单个项目风险可能随项目进展而不断出现，整体项目风险的级别也会发生变化。因此，识别风险是一个迭代的过程。迭代的频率和每次迭代所需的参与程度因情况而异，应在风险管理计划中做出相应规定。</p><h4 id="2-1-识别风险：输入"><a href="#2-1-识别风险：输入" class="headerlink" title="2.1 识别风险：输入"></a>2.1 识别风险：输入</h4><h5 id="2-1-1-项目管理计划"><a href="#2-1-1-项目管理计划" class="headerlink" title="2.1.1 项目管理计划"></a>2.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>需求管理计划。需求管理计划可能指出了特别有风险的项目目标。</p></li><li><p>进度管理计划。进度管理计划可能列出了受不确定性或模糊性影响的一些领域。</p></li><li><p>成本管理计划。成本管理计划可能列出了受不确定性或模糊性影响的一些领域。</p></li><li><p>质量管理计划。质量管理计划可能列出了受不确定性或模糊性影响的一些领域，或者关键假设可能引发风险的一些领域。</p></li><li><p>资源管理计划。资源管理计划可能列出了受不确定性或模糊性影响的一些领域，或者关键假设可能引发风险的一些领域。</p></li><li><p>风险管理计划。风险管理计划规定了风险管理的角色和职责，说明了如何将风险管理活动纳入预算和进度计划，并描述了风险类别（可用风险分解结构表述）。</p></li><li><p>范围基准。范围基准包括可交付成果及其验收标准，其中有些可能引发风险；还包括工作分解结构，可用作安排风险识别工作的框架。</p></li><li><p>进度基准。可以查看进度基准，找出存在不确定性或模糊性的里程碑日期和可交付成果交付日期，或者可能引发风险的关键假设条件。</p></li><li><p>成本基准。可以查看成本基准，找出存在不确定性或模糊性的成本估算或资金需求，或者关键假设可能引发风险的方面。</p></li></ul><h5 id="2-1-2-项目文件"><a href="#2-1-2-项目文件" class="headerlink" title="2.1.2 项目文件"></a>2.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>假设日志。假设日志所记录的假设条件和制约因素可能引发单个项目风险，还可能影响整体项目风险的级别。</p></li><li><p>成本估算。成本估算是对项目成本的定量评估，理想情况下用区间表示，区间的大小预示着风险程度。对成本估算文件进行结构化审查，可能显示当前估算不足，从而引发项目风险。</p></li><li><p>持续时间估算。持续时间估算是对项目持续时间的定量评估，理想情况下用区间表示，区间的大小预示着风险程度。对持续时间估算进行结构化审查，可能显示当前估算不足，从而引发项目风险。</p></li><li><p>问题日志。问题日志所记录的问题可能引发单个项目风险，还可能影响整体项目风险的级别。</p></li><li><p>经验教训登记册。可以查看与项目早期所识别的风险相关的经验教训，以确定类似风险是否可能在项目的剩余时间再次出现。</p></li><li><p>需求文件。需求文件列明了项目需求，使团队能够确定哪些需求存在风险。</p></li><li><p>资源需求。资源需求是对项目所需资源的定量评估，理想情况下用区间表示，区间的大小预示着风险程度。对资源需求文件进行结构化审查，可能显示当前估算不足，从而引发项目风险。</p></li><li><p>相关方登记册。相关方登记册规定了哪些个人或小组可能参与项目的风险识别工作，还会详细说明哪些个人适合扮演风险责任人角色。</p></li></ul><h5 id="2-1-3-协议"><a href="#2-1-3-协议" class="headerlink" title="2.1.3 协议"></a>2.1.3 协议</h5><p>如果需要从外部采购项目资源，协议所规定的里程碑日期、合同类型、验收标准和奖罚条款等，都可能造成威胁或创造机会。</p><h5 id="2-1-4-采购文档"><a href="#2-1-4-采购文档" class="headerlink" title="2.1.4 采购文档"></a>2.1.4 采购文档</h5><p>如果需要从外部采购项目资源，就应该审查初始采购文档，因为从组织外部采购商品和服务可能提高或降低整体项目风险，并可能引发更多的单个项目风险。随着采购文档在项目期间的不断更新，还应该审查最新的文档，例如，卖方绩效报告、核准的变更请求和与检查相关的信息。</p><h5 id="2-1-5-事业环境因素"><a href="#2-1-5-事业环境因素" class="headerlink" title="2.1.5 事业环境因素"></a>2.1.5 事业环境因素</h5><p>会影响识别风险过程的事业环境因素包括（但不限于）：</p><ul><li><p>已发布的材料，包括商业风险数据库或核对单；</p></li><li><p>学术研究资料；</p></li><li><p>标杆对照成果；</p></li><li><p>类似项目的行业研究资料。</p></li></ul><h5 id="2-1-6-组织过程资产"><a href="#2-1-6-组织过程资产" class="headerlink" title="2.1.6 组织过程资产"></a>2.1.6 组织过程资产</h5><p>会影响识别风险过程的组织过程资产包括（但不限于）：</p><ul><li><p>项目文档，包括实际数据；</p></li><li><p>组织和项目的过程控制资料；</p></li><li><p>风险描述的格式；</p></li><li><p>以往类似项目的核对单。</p></li></ul><h4 id="2-2-识别风险：工具与技术"><a href="#2-2-识别风险：工具与技术" class="headerlink" title="2.2 识别风险：工具与技术"></a>2.2 识别风险：工具与技术</h4><h5 id="2-2-1-专家判断"><a href="#2-2-1-专家判断" class="headerlink" title="2.2.1 专家判断"></a>2.2.1 专家判断</h5><p>应考虑了解类似项目或业务领域的个人或小组的专业意见。项目经理应该选择相关专家，邀请他们根据以往经验和专业知识来考虑单个项目风险的方方面面，以及整体项目风险的各种来源。项目经理应该注意专家可能持有的偏见。</p><h5 id="2-2-2-数据收集"><a href="#2-2-2-数据收集" class="headerlink" title="2.2.2 数据收集"></a>2.2.2 数据收集</h5><p>适用于本过程的数据收集技术包括（但不限于）：</p><ul><li><p>头脑风暴。头脑风暴的目标是获取一份全面的单个项目风险和整体项目风险来源的清单。通常由项目团队开展头脑风暴，同时邀请团队以外的多学科专家参与。可以采用自由或结构化形式开展头脑风暴，在引导者的指引下产生各种创意。可以用风险类别（如风险分解结构）作为识别风险的框架。因为头脑风暴生成的创意并不成型，所以应该特别注意对头脑风暴识别的风险进行清晰描述。</p></li><li><p>核对单。核对单是包括需要考虑的项目、行动或要点的清单。它常被用作提醒。基于从类似项目和其他信息来源积累的历史信息和知识来编制核对单。编制核对单，列出过去曾出现且可能与当前项目相关的具体单个项目风险，这是吸取已完成的类似项目的经验教训的有效方式。组织可能基于自己已完成的项目来编制核对单，或者可能采用特定行业的通用风险核对单。虽然核对单简单易用，但它不可能穷尽所有风险。所以，必须确保不要用核对单来取代所需的风险识别工作；同时，项目团队也应该注意考察未在核对单中列出的事项。此外，还应该不时地审查核对单，增加新信息，删除或存档过时信息。</p></li><li><p>访谈。可以通过对资深项目参与者、相关方和主题专家的访谈，来识别单个项目风险以及整体项目风险的来源。应该在信任和保密的环境下开展访谈，以获得真实可信、不带偏见的意见。</p></li></ul><h5 id="2-2-3-数据分析"><a href="#2-2-3-数据分析" class="headerlink" title="2.2.3 数据分析"></a>2.2.3 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）：</p><ul><li><p>根本原因分析。根本原因分析常用于发现导致问题的深层原因并制定预防措施。可以用问题陈述（如项目可能延误或超支）作为出发点，来探讨哪些威胁可能导致该问题，从而识别出相应的威胁。也可以用收益陈述（如提前交付或低于预算）作为出发点，来探讨哪些机会可能有利于实现该效益，从而识别出相应的机会。</p></li><li><p>假设条件和制约因素分析。每个项目及其项目管理计划的构思和开发都基于一系列的假设条件，并受一系列制约因素的限制。这些假设条件和制约因素往往都已纳入范围基准和项目估算。开展假设条件和制约因素分析，来探索假设条件和制约因素的有效性，确定其中哪些会引发项目风险。从假设条件的不确定、不稳定、不一致或不完整，可以识别出威胁，通过清除或放松会影响项目火锅城执行的制约因素，可以创造出机会。</p></li><li><p>SWOT分析。这是对项目的优势、劣势、机会和威胁（SWOT）进行逐个检查。在识别风险时，它会将内部产生的风险包含在内，从而拓宽识别风险的范围。首先，关注项目、组织或一般业务领域，识别出组织的优势和劣势；然后，找出组织优势可能为项目带来的机会，组织劣势可能造成的威胁。还可以分析组织优势能在多大程度上克服威胁，组织劣势是否会妨碍机会的产生。</p></li><li><p>文件分析。通过对项目文件的结构化审查，可以识别出一些风险。可供审查的文件包括（但不限于）计划、假设条件、制约因素、以往项目档案、合同、协议和技术文件。项目文件中的不确定性或模糊性，以及同一文件内部或不同文件之间的不一致，都可能是项目风险的指示信号。</p></li></ul><h5 id="2-2-4-人际关系与团队技能"><a href="#2-2-4-人际关系与团队技能" class="headerlink" title="2.2.4 人际关系与团队技能"></a>2.2.4 人际关系与团队技能</h5><p>适用于本过程的人际关系与团队技能包括（但不限于）引导。引导能提高用于识别单个项目风险和整体项目风险来源的许多技术的有效性。熟练的引导者可以帮助参会者专注于风险识别任务、准确遵循与技术相关的方法，有助于确保风险描述清晰、找到并克服偏见，以及解决任何可能出现的分歧。</p><h5 id="2-2-5-提示清单"><a href="#2-2-5-提示清单" class="headerlink" title="2.2.5 提示清单"></a>2.2.5 提示清单</h5><p>提示清单是关于可能引发单个项目风险以及可作为整体项目风险来源的风险类别的预设清单。在采用风险识别技术时，提示清单可作为框架用于协助项目团队形成想法。可以用风险分解结构底层的风险类别作为提示清单，来识别单个项目风险。某些常见的战略框架更适用于识别整体项目风险的来源，如PESTLE（政治、经济、社会、技术、法律、环境）、TECOP（技术、环境、商业、运营、政治），或VUCA（易变性、不确定性、复杂性、模糊性）。</p><h5 id="2-2-6-会议"><a href="#2-2-6-会议" class="headerlink" title="2.2.6 会议"></a>2.2.6 会议</h5><p>为了开展风险识别工作，项目团队可能要召开专门的会议（通常称为风险研讨会）。在大多数风险研讨会中，都会开展某种形式的头脑风暴。根据风险管理计划中对开展风险管理过程的要求，还有可能采用其他风险识别技术。配备一名经验丰富的引导者将会提高会议的有效性；确保适当的人员参加风险研讨会也至关重要。对于较大型项目，可能需要邀请项目发起人、主题专家、卖方、客户代表，或其他项目相关方参加会议；而对于较小型项目，可能仅限部分项目团队成员参加。</p><h4 id="2-3-识别风险：输出"><a href="#2-3-识别风险：输出" class="headerlink" title="2.3 识别风险：输出"></a>2.3 识别风险：输出</h4><h5 id="2-3-1-风险登记册"><a href="#2-3-1-风险登记册" class="headerlink" title="2.3.1 风险登记册"></a>2.3.1 风险登记册</h5><p>风险登记册记录已识别单个项目风险的详细信息。随着实施定性风险分析、规划风险应对、实施风险应对和监督风险等过程的开展，这些过程的结果也要记进风险登记册。取决于具体的项目变量（如规模和复杂性），风险登记册可能包含有限或广泛的风险信息。</p><p>当完成识别风险过程时，风险登记册的内容可能包括（但不限于）：</p><ul><li><p>已识别风险的清单。在风险登记册中，每项单个项目风险都被赋予一个独特的标识号。要以所需的详细程度对已识别风险进行描述，确保明确理解。可以使用结构化的风险描述，来把风险本身与风险原因及风险影响区分开来。</p></li><li><p>潜在风险责任人。如果已在识别风险过程中识别出潜在的风险责任人，就要把该责任人记录到风险登记册中。随后将由实施定性风险分析过程进行确认。</p></li><li><p>潜在风险应对措施清单。如果已在识别风险过程中识别出某种潜在的风险应对措施，就要把它记录到风险登记册中。随后将由规划风险应对过程进行确认。</p></li></ul><p>根据风险管理计划规定的风险登记册格式，可能还要记录关于每项已识别风险的其他数据，包括：简短的风险名称、风险类别、当前风险状态、一项或多项原因、一项或多项对目标的影响、风险触发条件（显示风险即将发生的事件或条件）、受影响的WBS组件，以及时间信息（风险何时识别、可能何时发生、何时可能不再相关，以及采取行动的最后期限）。</p><h5 id="2-3-2-风险报告"><a href="#2-3-2-风险报告" class="headerlink" title="2.3.2 风险报告"></a>2.3.2 风险报告</h5><p>风险报告提供关于整体项目风险的信息，以及关于已识别的单个项目风险的概述信息。在项目风险管理过程中，风险报告的编制是一项渐进式的工作。随着实施定性风险分析、实施定量风险分析、规划风险应对、实施风险应对和监督风险过程的完成，这些过程的结果也需要记录在风险登记册中。在完成识别风险过程时，风险报告的内容可能包括（但不限于）：</p><ul><li><p>整体项目风险的来源。说明哪些是整体项目风险敞口的最重要驱动因素。</p></li><li><p>关于已识别单个项目风险的概述信息。例如，已识别的威胁与机会的数量、风险在风险类别中的分布情况、测量指标和发展趋势。</p></li></ul><p>根据风险管理计划中规定的报告要求，风险报告中可能还包含其他信息。</p><h5 id="2-3-3-项目文件更新"><a href="#2-3-3-项目文件更新" class="headerlink" title="2.3.3 项目文件更新"></a>2.3.3 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>假设日志。在识别风险过程中，可能做出新的假设，识别出新的制约因素，或者现有的假设条件或制约因素可能被重新审查和修改。应该更新假设日志，记录这些新信息。</p></li><li><p>问题日志。应该更新问题日志，记录发现的新问题或当前问题的变化。</p></li><li><p>经验教训登记册。为了改善后期阶段或其他项目的绩效，而更新经验教训登记册，记录关于行之有效的风险识别技术的信息。</p></li></ul><hr><h3 id="三、实施定性风险分析"><a href="#三、实施定性风险分析" class="headerlink" title="三、实施定性风险分析"></a>三、实施定性风险分析</h3><p>实施定性风险分析是通过评估单个项目风险发生的概率和影响以及其他特征，对风险进行优先级排序，从而为后续分析或行动提供基础的过程。本过程的主要作用是重点关注高优先级的风险。本过程需要在整个项目期间开展。图11-8描述本过程的输入、工具与技术和输出。图11-9是本过程的数据流向图。</p><p><img src="/images/pmp-11/11-8.png" alt="实施定性风险分析：输入、工具与技术和输出"></p><p><img src="/images/pmp-11/11-9.png" alt="实施定性风险分析：数据流向图"></p><p>实施定性风险分析，使用项目风险的发生概率、风险发生时对项目目标的相应影响以及其他因素，来评估已识别单个项目风险的优先级。这种评估基于项目团队和其他相关方对风险的感知程度，从而具有主观性。所以，为了实现有效评估，就需要认清和管理本过程关键参与者对风险所持的态度。风险感知会导致评估已识别风险时出现偏见，所以应该注意找出偏见并加以纠正。如果由引导者来引导本过程的开展，那么找出并纠正偏见就是该引导者的一项重要工作。同时，评估单个项目风险的现有信息的质量，也有助于澄清每个风险对项目的重要性的评估。</p><p>实施定性风险分析能为规划风险应对过程确定单个项目风险的相对优先级。本过程会为每个风险识别出责任人，以便由他们负责规划风险应对措施，并确保应对措施的实施。如果需要开展实施定量风险分析过程，那么实施定性风险分析也能为其奠定基础。</p><p>根据风险管理计划的规定，在整个项目生命周期中要定期开展实施定性风险分析过程。在敏捷开发环境中，实施定性风险分析过程通常要在每次迭代开始前进行。</p><h4 id="3-1-实施定性风险分析：输入"><a href="#3-1-实施定性风险分析：输入" class="headerlink" title="3.1 实施定性风险分析：输入"></a>3.1 实施定性风险分析：输入</h4><h5 id="3-1-1-项目管理计划"><a href="#3-1-1-项目管理计划" class="headerlink" title="3.1.1 项目管理计划"></a>3.1.1 项目管理计划</h5><p>项目管理计划组件包括风险管理计划。本过程需要特别注意的是风险管理的角色和职责、预算和进度活动安排，以及风险类别（通常在风险分解结构中定义）、概率和影响定义、概率和影响矩阵和相关方的风险临界值。通常已经在规划风险管理过程中把这些内容裁剪成适合具体项目的需要。如果还没有这些内容，则可以在实施定性风险分析过程中编制，并经项目发起人批准之后用于本过程。</p><h5 id="3-1-2-项目文件"><a href="#3-1-2-项目文件" class="headerlink" title="3.1.2 项目文件"></a>3.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>假设日志。假设日志用于识别、管理和监督可能影响项目的关键假设条件和制约因素，它们可能影响对单个项目风险的优先级的评估。</p></li><li><p>风险登记册。风险登记册包括将在本过程评估的、每个已识别的单个项目风险的详细信息。</p></li><li><p>相关方登记册。它包括可能被指定为风险责任人的项目相关方的详细信息。</p></li></ul><h5 id="3-1-3-事业环境因素"><a href="#3-1-3-事业环境因素" class="headerlink" title="3.1.3 事业环境因素"></a>3.1.3 事业环境因素</h5><p>能够影响实施定性风险分析的事业环境因素包括（但不限于）：</p><ul><li><p>类似项目的行业研究资料；</p></li><li><p>已发布的材料，包括商业风险数据库或核对单。</p></li></ul><h5 id="3-1-4-组织过程资产"><a href="#3-1-4-组织过程资产" class="headerlink" title="3.1.4 组织过程资产"></a>3.1.4 组织过程资产</h5><p>能够影响实施定性风险分析的组织过程资产包括（但不限于）已完成的类似项目的信息。</p><h4 id="3-2-实施定性风险分析：工具与技术"><a href="#3-2-实施定性风险分析：工具与技术" class="headerlink" title="3.2 实施定性风险分析：工具与技术"></a>3.2 实施定性风险分析：工具与技术</h4><h5 id="3-2-1-专家判断"><a href="#3-2-1-专家判断" class="headerlink" title="3.2.1 专家判断"></a>3.2.1 专家判断</h5><p>应考虑具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>以往类似项目；</p></li><li><p>定性风险分析。</p></li></ul><p>专家判断往往可通过引导式风险研讨会或访谈获取。应该注意专家可能持续有偏见。</p><h5 id="3-2-2-数据收集"><a href="#3-2-2-数据收集" class="headerlink" title="3.2.2 数据收集"></a>3.2.2 数据收集</h5><p>适用于本过程的数据收集技术包括（但不限于）访谈。结构化或半结构化的访谈可用于评估单个项目风险的概率和影响，以及其他因素。访谈者应该营造信任和保密的访谈环境，以鼓励被访者提出诚实和无偏见的意见。</p><h5 id="3-2-3-数据分析"><a href="#3-2-3-数据分析" class="headerlink" title="3.2.3 数据分析"></a>3.2.3 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）：</p><ul><li><p>风险数据质量评估。风险数据是开展定性风险分析的基础。风险数据质量评估旨在评价关于单个项目风险的数据的准确性和可靠性。使用低质量的风险数据，可能导致定性风险分析对项目来说基本没用。如果数据质量不可接受，就可能需要收集更好的数据。可以开展问卷调查，了解项目相关方对数据质量各方面的评价，包括数据的完整性、客观性、相关性和及时性，进而对风险数据的质量进行综合评估。可以计算这些方面的加权平均数，将其作为数据质量的总体分数。</p></li><li><p>风险概率和影响评估。风险概率评估考虑的是特定风险发生的可能性，而风险影响评估考虑的是风险对一项或多项项目目标的潜在影响，如进度、成本、质量或绩效。威胁将产生负面的影响，机会将产生正面的影响。要对每个已识别的单个项目风险进行概率和影响评估。风险评估可以采用访谈或会议的形式，参加者将依照他们对风险登记册中所记录的风险类型的熟悉程度而定。项目团队成员和项目外部资深人员应该参加访谈或会议。在访谈或会议期间，评估每个风险的概率水平及其对每项目标的影响级别。如果相关方对概率水平和影响级别的感知存在差异，则应对差异进行探讨。此外，还应记录相应的说明性细节，例如，确定概率水平或影响级别所依据的假设条件。应该采用风险管理计划中的概率和影响定义（表11-1），来评估风险的概率和影响。低概率和影响的风险将被列入风险登记册中的观察清单，以供未来监控。</p></li><li><p>其他风险参数评估。为了方便未来分析和行动，在对单个项目风险进行优先级排序时，项目团队可能考虑（除概率和影响以外的）其他风险特征。此类特征可能包括（但不限于）：</p><ul><li><p>紧迫性。为有效应对风险而必须采取应对措施的时间段。时间短就说明紧迫性高。</p></li><li><p>邻近性。风险在多长时间后会影响一项或多项项目目标。时间短就说明邻近性高。</p></li><li><p>潜伏期。从风险发生到影响显现之间可能的时间段。时间短就说明潜伏期短。</p></li><li><p>可管理性。风险责任人（或责任组织）管理风险发生或影响的容易程度。如果容易管理，可管理性就高。</p></li><li><p>可控性。风险责任人（或责任组织）能够控制风险后果的程度。如果后果很容易控制，可控性就高。</p></li><li><p>可监测性。对风险发生或即将发生进行监测的容易程度。如果风险发生很容易监测，可监测性就高。</p></li><li><p>连通性。风险与其他单个项目风险存在关联的程度大小。如果风险与多个其他风险存在关联，连通性就高。</p></li><li><p>战略影响力。风险对组织战略目标潜在的正面或负面影响。如果风险对战略目标有重大影响，战略影响力就大。</p></li><li><p>密切度。风险被一名或多名相关方认为要紧的程度。被认为很要紧的风险，密切度就高。</p></li></ul></li></ul><p>相对于仅评估概率和影响，考虑上述某些特征有助于进行更稳健的风险优先级排序。</p><h5 id="3-2-4-人际关系与团队技能"><a href="#3-2-4-人际关系与团队技能" class="headerlink" title="3.2.4 人际关系与团队技能"></a>3.2.4 人际关系与团队技能</h5><p>适用于本过程的人际关系与团队技能包括（但不限于）引导。开展引导，能够提高对单个项目风险的定性分析的有效性。熟练的引导者可以帮助参会者专注于风险分析任务、准确遵循与技术相关的方法、就概率和影响评估达成共识、找到并克服偏见，以及解决任何可能出现的分歧。</p><h5 id="3-2-5-风险分类"><a href="#3-2-5-风险分类" class="headerlink" title="3.2.5 风险分类"></a>3.2.5 风险分类</h5><p>项目风险可依据风险来源（如采用风险分解结构（RBS））、受影响的项目领域（如采用工作分解结构（WBS）），以及其他实用类别（如项目阶段、项目预算、角色和职责）来分类，确定哪些项目领域最容易被不确定性影响；风险还可以根据共同的根本原因进行分类。应该在风险管理计划中规定可用于项目的风险分类方法。</p><p>对风险进行分类，有助于把注意力和精力集中到风险敞口最大的领域，或针对一组相关的风险制定通用的风险应对措施，从而有利于更有效地开展风险应对。</p><h5 id="3-2-6-数据表现"><a href="#3-2-6-数据表现" class="headerlink" title="3.2.6 数据表现"></a>3.2.6 数据表现</h5><p>适用于本过程的数据表现技术包括（但不限于）：</p><ul><li><p>概率和影响矩阵。概率和影响矩阵是把每个风险发生的概率和一旦发生对项目目标的影响映射起来的表格。此矩阵对概率和影响进行组合，以便于把单个项目风险划分成不同的优先级组别。基于风险的概率和影响，对风险进行优先级排序，以便未来进一步分析并制定应对措施。采用风险管理计划中规定的风险概率和影响定义，逐一对单个项目风险的发生概率及其对一项或多项项目目标的影响（如发生）进行评估。然后，基于所得到的概率和影响的组合，使用概率和影响矩阵，来为单个项目风险分配优先级别。</p><p>  组织可针对每个项目目标（如成本、时间和范围）制定单独的概率和影响矩阵，并用它们来评估风险针对每个目标的优先级别。组织还可以用不同的方法为每个风险确定一个总体优先级别。即可综合针对不同目标的评估结果，也可采用最高优先级别（无论针对哪个目标），作为风险的总体优先级别。</p></li><li><p>层级图。如果使用了两个以上的参数对风险进行分类，那就不能使用概率和影响矩阵，而需要使用其他图形。例如，气泡图能显示三维数据。在气泡图中，把每个风险都绘制成一个气泡，并用X轴值、Y轴值和气泡大小来表示风险的三个参数。图11-10是气泡图的示例，其中，X轴代表可监测性，Y轴代表邻近性，影响值则以气泡大小表示。</p></li></ul><p><img src="/images/pmp-11/11-10.png" alt="列出可监测性、邻近性和影响值的气泡图示例"></p><h5 id="3-2-7-会议"><a href="#3-2-7-会议" class="headerlink" title="3.2.7 会议"></a>3.2.7 会议</h5><p>要开展定性风险分析，项目团队可能要召开专门会议（通常称为风险研讨会），对已识别单个项目风险进行讨论。会议的目标包括审查已识别的风险、评估概率和影响（及其他可能的风险参数）、对风险进行分类和优先级排序。在实施定性风险分析过程中，要逐一为单个项目风险分配风险责任人。以后，将由风险责任人负责规划风险应对措施和报告风险管理工作的进展情况。会议可从审查和确认拟使用的概率和影响量表开始。在会议讨论中，也可能识别出其他风险。应该记录这些风险，供后续分析。配备一名熟练的引导者能够提高会议的有效性。</p><h4 id="3-3-实施定性风险分析：输出"><a href="#3-3-实施定性风险分析：输出" class="headerlink" title="3.3 实施定性风险分析：输出"></a>3.3 实施定性风险分析：输出</h4><h5 id="3-3-1-项目文件更新"><a href="#3-3-1-项目文件更新" class="headerlink" title="3.3.1 项目文件更新"></a>3.3.1 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>假设日志。在实施定性风险分析过程中，可能做出新的假设、识别出新的制约因素，或者现有的假设条件或制约因素可能被重新审查和修改。应该更新假设日志，应记录这些新信息。</p></li><li><p>问题日志。应该更新问题日志，记录发现的新问题或当前问题的变化。</p></li><li><p>风险登记册。用实施定性风险分析过程生成的新信息，去更新风险登记册。风险登记册的更新内容可能包括：每项单个项目风险的概率和影响评估、优先级别或风险分值、指定风险责任人、风险紧迫性信息或风险类别，以及低优先级风险的观察清单或需要进一步分析的风险。</p></li><li><p>风险报告。更新风险报告，记录最重要的单个项目风险（通常为概率和影响最高的风险）、所有已识别风险的优先级列表以及简要的结论。</p></li></ul><hr><h3 id="四、实施定量风险分析"><a href="#四、实施定量风险分析" class="headerlink" title="四、实施定量风险分析"></a>四、实施定量风险分析</h3><p>实施定量风险分析是就已识别的单个项目风险和不确定性的其它来源对整体项目目标的影响进行定量分析的过程。本过程的主要作用是，量化整体项目风险敞口，并提供额外的定量风险信息，以支持风险应对规划。本过程并非每个项目必需，但如果采用，它会在整个项目期间持续开展。图11-11描述了本过程的输入、工具与技术和输出。图11-12是本过程的数据流向图。</p><p><img src="/images/pmp-11/11-11.png" alt="实施定量风险分析：输入、工具与技术和输出"></p><p><img src="/images/pmp-11/11-12.png" alt="实施定量风险分析：数据流向图"></p><p>并非所有项目都需要实施定量风险分析。能够开展稳健的分析取决于是否有关于单个项目风险和其他不确定性来源的高质量数据，以及与范围、进度和成本相关的扎实项目基准。定量风险分析通常需要运用专门的风险分析软件，以及编制和解释风险模式的专业知识，还需要额外的时间和成本投入。项目风险管理计划会规定是否需要使用定量风险分析，定量风险分析可能适用于大型或复杂的项目、具有战略重要性的项目、合同要求进行定量风险分析的项目，或主要相关方要求进行定量分析的项目。通过评估所有单个项目风险和其他不确定性来源对项目结果的综合影响，定量风险分析就成为评估整体项目风险的唯一可靠的方法。</p><p>在实施定量风险分析过程中，要使用被定性风险分析过程评估为对项目目标存在重大潜在影响的单个项目风险的信息。</p><p>实施定量风险分析过程的输出，则要用作规划风险应对过程的输入，特别是要据此为整体项目风险和关键单个项目风险推荐应对措施。定量风险分析也可以在规划风险应对过程之后开展，以分析已规划的应对措施对降低整体项目风险敞口的有效性。</p><h4 id="4-1-实施定量风险分析：输入"><a href="#4-1-实施定量风险分析：输入" class="headerlink" title="4.1 实施定量风险分析：输入"></a>4.1 实施定量风险分析：输入</h4><h5 id="4-1-1-项目管理计划"><a href="#4-1-1-项目管理计划" class="headerlink" title="4.1.1 项目管理计划"></a>4.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>风险管理计划。风险管理计划确定项目是否需要定量风险分析，还会详述可用与分析的资源，以及预期的分析频率。</p></li><li><p>范围基准。范围基准提供了对单个项目风险和其他不确定性来源的影响开展评估的起始点。</p></li><li><p>进度基准。进度基准提供了对单个项目风险和其他不确定性来源的影响开展评估的起始点。</p></li><li><p>成本基准。成本基准提供了对单个项目风险和其他不确定性来源的影响开展评估的起始点。</p></li></ul><h5 id="4-1-2-项目文件"><a href="#4-1-2-项目文件" class="headerlink" title="4.1.2 项目文件"></a>4.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>假设日志。如果认为假设条件会引发项目风险，那么就应该把它们列作定量风险分析的输入。在定量风险分析期间，也可以建立模型来分析制约因素的影响。</p></li><li><p>估算依据。开展定量风险分析时，可以把用于项目规划的估算依据反映在所建立的变异性模型中。可能包括估算目的、分类、准确性、方法论和资料来源。</p></li><li><p>成本估算。成本估算提供了对成本变化性进行评估的起始点。</p></li><li><p>成本预测。成本预测包括项目的完工尚需估算（ETC）、完工估算（EAC）、完工预算（BAC）和完工尚需绩效指数（TCP）。把这些预测指标与定量成本风险分析的结果进行比较，以确定与实现这些指标相关的置信水平。</p></li><li><p>持续时间估算。持续时间估算提供了对进度变化性进行评估的起始点。</p></li><li><p>里程碑清单。项目的重大事件决定着进度目标。把这些进度目标与定量进度风险分析的结果进行比较，以确定与实现这些目标相关的置信水平。</p></li><li><p>资源需求。资源需求提供了对变化性进行评估的起始点。</p></li><li><p>风险登记册。风险登记册包含了用作定量风险分析的输入的单个项目风险的详细信息。</p></li><li><p>风险报告。风险报告描述了整体项目风险的来源，以及当前的整体项目风险状态。</p></li><li><p>进度预测。可以将预测与定量进度风险分析的结果进行比较，以确定与实现预测目标相关的置信水平。</p></li></ul><h5 id="4-1-3-事业环境因素"><a href="#4-1-3-事业环境因素" class="headerlink" title="4.1.3 事业环境因素"></a>4.1.3 事业环境因素</h5><p>能够影响实施定量风险分析过程的事业环境因素包括（但不限于）：</p><ul><li><p>类似项目的行业研究资料；</p></li><li><p>已发布的材料，包括商业风险数据库或核对单。</p></li></ul><h5 id="4-1-4-组织过程资产"><a href="#4-1-4-组织过程资产" class="headerlink" title="4.1.4 组织过程资产"></a>4.1.4 组织过程资产</h5><p>能够影响实施定量风险分析过程的组织过程资产包括已完成的类似项目的信息。</p><h4 id="4-2-实施定量风险分析：工具与技术"><a href="#4-2-实施定量风险分析：工具与技术" class="headerlink" title="4.2 实施定量风险分析：工具与技术"></a>4.2 实施定量风险分析：工具与技术</h4><h5 id="4-2-1-专家判断"><a href="#4-2-1-专家判断" class="headerlink" title="4.2.1 专家判断"></a>4.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>将单个项目风险和其他不确定性来源的信息转化成用于定量风险分析模型的数值输入；</p></li><li><p>选择最适当的方式表示不确定性，以便为特定风险或其他不确定性来源建立模型；</p></li><li><p>用适合项目环境的技术建立模型；</p></li><li><p>识别最适用于所选建模技术的工具；</p></li><li><p>解释定量风险分析的输出。</p></li></ul><h5 id="4-2-2-数据收集"><a href="#4-2-2-数据收集" class="headerlink" title="4.2.2 数据收集"></a>4.2.2 数据收集</h5><p>访谈可用于针对单个项目风险和其他不确定性来源，生成定量风险分析的输入。当需要向专家征求信息时，访谈尤其适用。访谈者应该营造信任和保密的访谈环境，以鼓励被访者提出诚实和无偏见的意见。</p><h5 id="4-2-3-人际关系与团队技能"><a href="#4-2-3-人际关系与团队技能" class="headerlink" title="4.2.3 人际关系与团队技能"></a>4.2.3 人际关系与团队技能</h5><p>适用于本过程的人际关系与团队技能包括（但不限于）引导。在由项目团队成员和其他相关方参加的专门风险研讨会中，配备一名熟练的引导者，有助于更好地收集输入数据。可以通过阐明研讨会的目的，在参会者之间建立共识，确保持续关注任务，并以创新方式处理人际冲突或偏见来源，来改善引导式研讨会的有效性。</p><h5 id="4-2-4-不确定性表示方式"><a href="#4-2-4-不确定性表示方式" class="headerlink" title="4.2.4 不确定性表示方式"></a>4.2.4 不确定性表示方式</h5><p>要开展定量风险分析，就需要建立能够反映单个项目风险和其他不确定性来源的定量风险分析模型，并为之提供输入。</p><p>如果活动的持续时间、成本或资源需求是不确定的，就可以在模型中用概率分布来表示其数值的可能区间。概率分布可能有多种形式，最常用的有三角分布、正态分布、对数正态分布、贝塔分布、均匀分布或离散分布。应该谨慎选择用于表示活动数值的可能区间的概率分布形式。</p><p>单个项目风险可以用概率分布图表示，或者，也可以作为概率分支包括在定量分析模型中。在后一种情况下，应在概率分支上添加风险发生的时间和（或）成本影响，以及在特定模拟中风险发生的概率情况。如果风险的发生与任何计划活动都没有关系，就最适合将其作为概率分支。如果风险之间存在相关性，例如有某个共同原因或逻辑依赖关系，那么应该在模型中考虑这种相关性。</p><p>其他不确定性来源也可以用概率分支来表示，以描述贯穿项目的其他路径。</p><h5 id="4-2-5-数据分析"><a href="#4-2-5-数据分析" class="headerlink" title="4.2.5 数据分析"></a>4.2.5 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）：</p><ul><li><p>模拟。在定量风险分析中，使用模型来模拟单个项目风险和其他不确定性来源的综合影响，以评估它们对项目目标的潜在影响。模拟通常采用蒙特卡洛分析。对成本风险进行蒙特卡洛分析时，使用项目成本估算作为模拟的输入；对进度风险进行蒙特卡洛分析时，使用进度网络图和持续时间估算作为模拟的输入。开展综合定量成本-进度风险分析时，同时使用这两种输入。其输出就是定量风险分析模型。</p><p>  用计算机软件数千次迭代运行定量风险分析模型。每次运行，都要随机选择输入值（如成本估算、持续时间估算或概率分支发生频率）。这些运行的输出构成了项目可能结果（如项目结束日期、项目完工成本）的区间。典型的输出包括：表示模拟得到特定结果的次数的直方图，或表示获得等于或小于特定数值的结果的累积概率分布曲线（S曲线）。蒙特卡洛成本风险分析所得到的S曲线示例，见图11-13。</p><p>  <img src="/images/pmp-11/11-13.png" alt="定量成本风险分析S曲线示例"></p><p>  在定量进度风险分析中，还可以执行关键性分析，以确定风险模型的哪些活动对项目关键路径的影响最大。对风险模型中的每一项活动计算关键性指标，即：在全部模拟中，该活动出现在关键路径上的频率，通常以百分比表示。通过关键性分析，项目团队就能够重点针对那些对项目整体进度绩效存在最大潜在影响的活动，来规划风险应对措施。</p></li><li><p>敏感性分析。敏感性分析有助于确定哪些单个项目风险或其他不确定性来源对项目结果具有最大的潜在影响。它在项目结果变异与定量风险分析模型中的要素变异之间建立联系。</p><p>  敏感性分析的结果通常用龙卷风图来表示。在该图中，标出定量风险分析模型中的每项要素与其能影响的项目结果之间的关联系数。这些要素可包括单个项目风险、易变的项目活动，或具体的不明确性来源。每个要素按关联强度降序排列，形成典型的龙卷风形状。龙卷风图示例，见图11-14。</p><p>  <img src="/images/pmp-11/11-14.png" alt="龙卷风图示例"></p></li><li><p>决策树分析。用决策树在若干备选行动方案中选择一个最佳方案。在决策树中，用不同的分支代表不同的决策或事件，即项目的备选路径。每个决策或事件都有相关的成本和单个项目风险（包括威胁和机会）。决策树分支的终点表示沿特定路径发展的最后结果，可以是负面或正面的结果。</p><p>  在决策树分析中，通过计算每条分支的预期货币价值，就可以选出最优的路径。决策树示例，见图11-15。</p><p>  <img src="/images/pmp-11/11-15.png" alt="决策树示例"></p></li><li><p>影响图。影响图是不确定条件下决策制定的图形辅助工具。它将一个项目或项目中的一种情境表现为一系列实体、结果和影响，以及它们之间的关系和相互影响。如果因为存在单个项目风险或其他不确定性来源而使影响图中以区间或概率分布的形式表示这些要素；然后，借助模拟技术（如蒙特卡洛分析）来分析哪些要素对重要结果具有最大的影响。影响图分析，可以得出类似于其他定量风险分析的结果，如S曲线图和龙卷风图。</p></li></ul><h4 id="4-3-实施定量风险分析：输出"><a href="#4-3-实施定量风险分析：输出" class="headerlink" title="4.3 实施定量风险分析：输出"></a>4.3 实施定量风险分析：输出</h4><h5 id="4-3-1-项目文件更新"><a href="#4-3-1-项目文件更新" class="headerlink" title="4.3.1 项目文件更新"></a>4.3.1 项目文件更新</h5><p>可作为本过程输出的项目文件包括（但不限于）风险报告。更新风险报告，反映定量风险分析的结果，通常包括：</p><ul><li><p>对整体项目风险敞口的评估结果。整体项目风险有两种主要的测试方式：</p><ul><li><p>项目成功的可能性。基于已识别的单个项目风险和其他不确定性来源，项目实现其主要目标（例如，既定的结束日期或中间里程碑、既定的成本目标）的概率。</p></li><li><p>项目固有的变异性。在开展定量分析之时，可能的项目结果的分布区间。</p></li></ul></li><li><p>项目详细概率分析的结果。列出定量风险分析的重要输出，如S曲线、龙卷风图和关键性指标，以及对它们的叙述性解释。定量风险分析的详细结果可能包括：</p><ul><li><p>所需的应急储备，以达到实现目标的特定置信水平；</p></li><li><p>对项目关键路径有最大影响的单个项目风险或其他不确定性来源的清单；</p></li><li><p>整体项目风险的主要驱动因素，即：对项目结果的不确定性有最大影响的因素。</p></li></ul></li><li><p>单个项目风险优先级清单。根据敏感性分析的结果，列出对项目造成最大威胁或产生最大机会的单个项目风险。</p></li><li><p>定量风险分析结果的趋势。随着在项目生命周期的不同时间重复开展定量风险分析，风险的发展趋势可能逐渐清晰。发展趋势会影响对风险应对措施的规划。</p></li><li><p>风险应对建议。风险报告可能根据定量风险分析的结果，针对整体项目风险敞口或关键单个项目风险提出应对建议。这些建议将成为规划风险应对过程的输入。</p></li></ul><hr><h3 id="五、规划风险应对"><a href="#五、规划风险应对" class="headerlink" title="五、规划风险应对"></a>五、规划风险应对</h3><p>规划风险应对是为处理整体项目风险敞口，以及应对单个项目风险，而制定可选方案、选择应对策略并商定应对行动的过程。本过程的主要作用是，制定应对整体项目风险和单个项目风险的适当方法；本过程还将分配资源，并根据需要将相关活动添加进项目文件和项目管理计划。本过程需要在整个项目期间开展。图11-16描述本过程的输入、工具与技术和输出。图11-17是本过程的数据流向图。</p><p><img src="/images/pmp-11/11-16.png" alt="规划风险应对：输入、工具与技术和输出"></p><p><img src="/images/pmp-11/11-17.png" alt="规划风险应对：数据流向图"></p><p>有效和适当的风险应对可以最小化单个威胁，最大化单个机会，并降低整体项目风险敞口；不恰当的风险应对则会适得其反。一旦完成对风险的识别、分析和排序，指定的风险责任人就应该编制计划，以应对项目团队认为足够重要的每项单个项目风险。这些风险会对项目目标的实现造成威胁或提供机会。项目经理也应该思考如何针对整体项目风险的当前级别做出适当的应对。</p><p>风险应对方案应该与风险的重要性相匹配、能经济有效地应对挑战、在当前项目背景下现实可行、能获得全体相关方的同意，并由一名责任人具体负责。往往需要从几套可选方案中选出最优的风险应对方案。应该为每个风险选择最可能有效的策略或策略组合。可用结构化的决策技术来选择最适当的应对策略。对于大型或复杂项目，可能需要以教学优化模型或实际方案分析为基础，进行更加稳健的备选风险应对策略经济分析。</p><p>要为实施商定的风险应对策略，包括主要策略和备用策略（若必要），制定具体的应对行动。如果选定的策略并不完全有效，或者发生了已接受的风险，就需要制定应急计划（或弹回计划）。同时，也需要识别次生风险。次生风险是实施风险应对措施而直接导致的风险。往往需要为风险分配时间或成本应急储备，并可能需要说明动用应急储备的条件。</p><h4 id="5-1-规划风险应对：输入"><a href="#5-1-规划风险应对：输入" class="headerlink" title="5.1 规划风险应对：输入"></a>5.1 规划风险应对：输入</h4><h5 id="5-1-1-项目管理计划"><a href="#5-1-1-项目管理计划" class="headerlink" title="5.1.1 项目管理计划"></a>5.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>资源管理计划。资源管理计划有助于确定该如何协调用于风险应对的资源和其他项目资源。</p></li><li><p>风险管理计划。本过程会用到其中的风险管理角色和职责，以及风险临界值。</p></li><li><p>成本基准。成本基准包含了拟用于风险应对的应急资金的信息。</p></li></ul><h5 id="5-1-2-项目文件"><a href="#5-1-2-项目文件" class="headerlink" title="5.1.2 项目文件"></a>5.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。查看关于项目早期的风险应对的经验教训，确定类似的应对是否适用于项目后期。</p></li><li><p>项目进度计划。进度计划可用于确定如何同时规划商定的风险应对活动和其他项目活动。</p></li><li><p>项目团队派工单。项目团队派工单列明了可用于风险应对的人力资源。</p></li><li><p>资源日历。资源日历确定了潜在的资源何时可用于风险应对。</p></li><li><p>风险登记册。风险登记册包含了已识别并排序的、需要应对的单个项目风险的详细信息。每项风险的优先级有助于选择适当的风险应对措施。例如，针对高优先级的威胁或机会，可能需要采取优先措施和积极主动的应对策略；而针对低优先级的威胁和机会，可能只需要把它们列入风险登记册的观察清单部分，或者只需要为之增加应急储备，而不必采取主动的管理措施。</p><p>  风险登记册列出了每项风险的指定风险责任人，还可能包含在早期的项目风险管理过程中识别的初步风险应对措施。风险登记册可能还会提供有助于规划风险应对的、关于已识别风险的其他信息，包括根本原因、风险触发因素和预警信号、需要在短期内应对的风险，以及需要进一步分析的风险。</p></li><li><p>风险报告。风险报告中的项目整体风险敞口的当前级别，会影响选择适当的风险应对策略。风险报告也可能按优先级顺序列出了单个项目风险，并对单个项目风险的分布情况进行了更多分析；这些信息都会影响风险应对策略的选择。</p></li><li><p>相关方登记册。相关方登记册列出了风险应对的潜在责任人。</p></li></ul><h5 id="5-1-3-事业环境因素"><a href="#5-1-3-事业环境因素" class="headerlink" title="5.1.3 事业环境因素"></a>5.1.3 事业环境因素</h5><p>能够影响规划风险应对过程的事业环境因素包括（但不限于）关键相关方的风险偏好和风险临界值。</p><h5 id="5-1-4-组织过程资产"><a href="#5-1-4-组织过程资产" class="headerlink" title="5.1.4 组织过程资产"></a>5.1.4 组织过程资产</h5><p>能够影响规划风险应对过程的组织过程资产包括（但不限于）：</p><ul><li><p>风险管理计划、风险登记册和风险报告的模板；</p></li><li><p>历史数据库；</p></li><li><p>类似项目的经验教训知识库。</p></li></ul><h4 id="5-2-规划风险应对：工具与技术"><a href="#5-2-规划风险应对：工具与技术" class="headerlink" title="5.2 规划风险应对：工具与技术"></a>5.2 规划风险应对：工具与技术</h4><h5 id="5-2-1-专家判断"><a href="#5-2-1-专家判断" class="headerlink" title="5.2.1 专家判断"></a>5.2.1 专家判断</h5><p>应征求具备以下专业知识的个人或小组的意见：</p><ul><li><p>威胁应对策略；</p></li><li><p>机会应对策略；</p></li><li><p>应急应对策略；</p></li><li><p>整体项目风险应对策略。</p></li></ul><p>可以就具体单个项目风险向特定主体专家征求意见，例如在需要专家的技术知识时。</p><h5 id="5-2-2-数据收集"><a href="#5-2-2-数据收集" class="headerlink" title="5.2.2 数据收集"></a>5.2.2 数据收集</h5><p>适用于本过程的数据收集技术包括（但不限于）访谈。单个项目风险和整体项目风险的应对措施可以在与风险责任人的结构化或半结构化的访谈中制定。必要时，也可访谈其他相关方。访谈者应该营造信任和保密的访谈环境，以鼓励被访者提出诚实和无偏见的意见。</p><h5 id="5-2-3-人际关系与团队技能"><a href="#5-2-3-人际关系与团队技能" class="headerlink" title="5.2.3 人际关系与团队技能"></a>5.2.3 人际关系与团队技能</h5><p>适用于本过程的人际关系与团队技能包括（但不限于）引导。开展引导，能够提高单个项目风险和整体项目风险应对策略制定的有效性。熟练的引导者可以帮助风险责任人理解风险、识别并比较备选的风险应对策略、选择适当的应对策略，以及找到并克服偏见。</p><h5 id="5-2-4-威胁应对策略"><a href="#5-2-4-威胁应对策略" class="headerlink" title="5.2.4 威胁应对策略"></a>5.2.4 威胁应对策略</h5><p>针对威胁，可以考虑以下五种备选策略：</p><ul><li><p>上报。如果项目团队或项目发起人认为某威胁不在项目范围内，或提议的应对措施超出了项目经理的权限，就应该采用上报策略。被上报的风险将在项目集层面、项目组合层面或组织的其他相关部门加以管理，而不在项目层面。项目经理确定应就威胁通知哪些人员，并向该人员或组织部门传达关于该威胁的详细信息。对于被上报的威胁，组织中的相关人员必须愿意承担应对责任，这一点非常重要。威胁通常要上报给其目标会受该威胁影响的那个层级。威胁一旦上报，就不再由项目团队做进一步监督，虽然仍可出现在风险登记册中供参考。</p></li><li><p>规避。风险规避是指项目团队采取行动来消除威胁，或保护项目免受威胁的影响。它可能适用于发生概率较高，且具有严重负面影响的高优先级威胁。规避策略可能涉及变更项目管理计划的某些方面，或改变会受负面影响的目标，以便于彻底消除威胁，将它的发生概率降低到零。风险责任人也可以采取措施，来分离项目目标与风险万一发生的影响。规避措施可能包括消除威胁的原因、延长进度计划、改变项目策略，或缩小范围。有些风险可以通过澄清需求、获取信息、改善沟通或取得专有技能来加以规避。</p></li><li><p>转移。转移涉及到将应对威胁的责任转移给第三方，让第三方管理风险并承担威胁发生的影响。采用转移策略，通常需要向承担威胁的一方支付风险转移费用。风险转移可能需要通过一系列行动才得以实现，包括（但不限于）购买保险、使用履约保函、使用担保书、使用保证书等。也可以通过签订协议，把具体风险的归属和责任转移给第三方。</p></li><li><p>减轻。风险减轻是指采取措施来降低威胁发生的概率和（或）影响。提前采取减轻措施通常比威胁出现后尝试进行弥补更加有效。减轻措施包括采用较简单的流程，进行更多次测试，或者选用更可靠的卖方。还可能涉及原型开发，以降低从实验台模型放大到实际工艺或产品中的风险。如果无法降低概率，也许可以从决定风险严重性的因素入手，来减轻风险发生的影响。例如，在一个系统中加入冗余部件，可以减轻原始部件故障所造成的影响。</p></li><li><p>接受。风险接受是指承认威胁的存在，但不主动采取措施。此策略可用于低优先级威胁，也可用于无法以任何其它方式加以经济有效地应对威胁。接受策略又分为主动或被动方式。最常见的主动接受策略是建立应急储备，包括预留时间、资金或资源以应对出现的威胁；被动接受策略则不会主动采取行动，而只是定期对威胁进行审查，确保其并未发生重大改变。</p></li></ul><h5 id="5-2-5-机会应对策略"><a href="#5-2-5-机会应对策略" class="headerlink" title="5.2.5 机会应对策略"></a>5.2.5 机会应对策略</h5><p>针对计划，可以考虑下列五种备选策略：</p><ul><li><p>上报。如果项目团队或项目发起人认为某机会不在项目范围内，或提议的应对措施超出了项目经理的权限，就应该取用上报策略。被上报的机会将在项目集层面、项目组合层面或组织的其他相关部门加以管理，而不在项目层面。项目经理确定应就机会通知哪些人员，并向该人员或组织部门传达关于该机会的详细信息。对于被上报的机会，组织中的相关人员必须愿意承担应对责任，这一点非常重要。机会通常要上报给其目标会受该机会影响的那个层级。机会一旦上报，就不再由项目团队做进一步监督，虽然仍可出现在风险登记册中供参考。</p></li><li><p>开拓。如果组织想确保把握住高优先级的机会，就可以选择开拓策略。此策略将特定机会的出现概率提高到100%，确保其肯定出现，从而获得与其相关的收益。开拓措施可能包括：把组织中最有能力的资源分配给项目来缩短完工时间，或采用全新技术或技术升级来节约项目成本并缩短项目持续时间。</p></li><li><p>分享。分享涉及到将应对机会的责任转移给第三方，使其享有机会所带来的部分收益。必须仔细为已分享的机会安排新的风险责任人，让那些最有能力为项目抓住机会的人担任新的风险责任人。采用风险分享策略，通常需要向承担机会应对责任的一方支付风险费用。分享措施包括建立合伙关系、合作团队、特殊公司或合资企业来分享机会。</p></li><li><p>提高。提高策略用于提高机会出现的概率和（或）影响。提前采取提高措施通常比机会出现后尝试改善收益更加有效。通过关注其原因，可以提高机会出现的概率；如果无法提高概率，也许可以针对决定其在潜在收益规模的因素来提高机会发生的影响。机会提高措施包括为早日完成活动而增加资源。</p></li><li><p>接受。接受机会是指承认机会的存在，但不主动采取措施。此策略可用于低优先级机会，也可用于无法以任何其它方式加以经济有效地应对的机会。接受策略又分为主动或被动方式。最常见的主动接受策略是建立应急储备，包括预留时间、资金或资源，以便在机会出现时加以利用；被动接受策略则不会主动采取行动，而只是定期对机会进行审查，确保其并未发生重大改变。</p></li></ul><h5 id="5-2-6-应急应对策略"><a href="#5-2-6-应急应对策略" class="headerlink" title="5.2.6 应急应对策略"></a>5.2.6 应急应对策略</h5><p>可以设计一些仅在特定事件发生时才采用的应对措施。对于某些风险，如果项目团队相信其发生会有充分的预警信号，那么就应该制定仅在某些预定条件出现时才执行的应对计划。应该定义并跟踪应急应对策略的触发条件，例如，未实现中间的里程碑，或获得卖方更高程度的重视。采用此技术制定的风险应对计划，通常称为应急计划或弹回计划，其中包括已识别的、用于启动计划的触发条件。</p><h5 id="5-2-7-整体项目风险应对策略"><a href="#5-2-7-整体项目风险应对策略" class="headerlink" title="5.2.7 整体项目风险应对策略"></a>5.2.7 整体项目风险应对策略</h5><p>风险应对措施的规划和实施不应只针对单个项目风险，还应针对整体项目风险。用于应对单个项目风险的策略也适用于整体项目风险：</p><ul><li><p>规避。如果整体项目风险有严重的负面影响，并已超出商定的项目风险临界值，就可以采用规避策略。此策略涉及采取集中行动，弱化不确定性对项目整体的负面影响，并将项目拉回到临界值以内。例如，取消项目范围中的高风险工作，就是一种整个项目层面的规避措施。如果无法将项目来回到临界值以内，则可能取消项目。这是最极端的风险规避措施，仅适用于威胁的整体级别在当前和未来都不可接受。</p></li><li><p>开拓。如果整体项目风险有显著的正面影响，并已超出商定的项目风险临界值，就可以采用开拓策略。此策略涉及采取集中行动，去获得不确定性对整体项目的正面影响。例如，在项目范围中增加高收益的工作，以提高项目对相关方的价值或效益；或者，也可以与关键相关方协商修改项目的风险临界值，以便将机会包含在呢。</p></li><li><p>转移或分享。如果整体项目风险的级别很高，组织无法有效加以应对，就可能需要让第三方代表组织对风险进行管理。若整体项目风险是负面的，就需要采取转移策略，这可能涉及支付风险费用；如果整体项目风险高度正面，则由多方分享，以获得相关受益。整体项目风险的转移和分享策略包括（但不限于）：建立买方和卖方分享整体项目风险的协作式业务结构、成立合资企业或特殊目的公司，或对项目的关键工作进行分包。</p></li><li><p>减轻或提高。本策略涉及变更整体项目风险的级别，以优化实现项目目标的可能性。减轻策略适用于负面的整体项目风险，而提高策略则适用于正面的整体项目风险。减轻或提高策略包括重新规划项目、改变项目范围和边界、调整项目优先级、改变资源配置、调整交付时间等。</p></li><li><p>接受。即使整体项目风险已超出商定的临界值，如果无法针对整体项目风险采取主动的应对策略，组织可能选择继续按当前的定义推动项目进展。接受策略又分为主动或被动方式。最常见的主动接受策略是为项目建立整体应急储备，包括预留时间、资金或资源，以便在项目风险超出临界值时使用；被动接受策略则不会主动采取行动，而只是定期对整体项目风险的级别进行审查，确保其未发生重大改变。</p></li></ul><h5 id="5-2-8-数据分析"><a href="#5-2-8-数据分析" class="headerlink" title="5.2.8 数据分析"></a>5.2.8 数据分析</h5><p>可以考虑多种备选风险应对策略。可用于选择首选风险应对策略的数据分析技术包括（但不限于）：</p><ul><li><p>备选方案分析。对备选风险应对方案的特征和要求进行简单比较，进而确定哪个应对方案最为适用。</p></li><li><p>成本收益分析。如果能够把单个项目风险的影响进行货币量化，那么就可以通过成本收益分析来确定备选风险应对策略的成本有效性。把应对策略将导致的风险影响级别变更除以策略的实施成本，所得到的比率，就代表了应对策略的成本有效性。比率越高，有效性就越高。</p></li></ul><h5 id="5-2-9-决策"><a href="#5-2-9-决策" class="headerlink" title="5.2.9 决策"></a>5.2.9 决策</h5><p>适用于风险应对策略选择的决策技术包括（但不限于）多标准决策分析，例如考虑范围的风险应对策略可能是一种或多种。决策技术有助于对多种风险应对策略进行优先级排序。多标准决策分析借助决策矩阵，提供建立关键决策标准、评估备选方案并加以评级，以及选择首选方案的系统分析方法。风险应对策略的选择标准可能包括（但不限于）：应对成本、应对策略在改变概率和（或）影响方面的预计有效性、资源可用性、时间限制（紧迫性、邻近性和潜伏期）、风险发生的影响级别、应对措施对相关风险的作用、导致的次生风险等。如果原定的应对策略被证明无效，可在项目后期采取不同的应对策略。</p><h4 id="5-3-规划风险应对：输出"><a href="#5-3-规划风险应对：输出" class="headerlink" title="5.3 规划风险应对：输出"></a>5.3 规划风险应对：输出</h4><h5 id="5-3-1-变更请求"><a href="#5-3-1-变更请求" class="headerlink" title="5.3.1 变更请求"></a>5.3.1 变更请求</h5><p>规划风险应对后，可能会就成本基准和进度基准，或项目管理计划的其他组件提出变更请求，应该通过实施整体变更控制过程对变更请求进行审查和处理。</p><h5 id="5-3-2-项目管理计划更新"><a href="#5-3-2-项目管理计划更新" class="headerlink" title="5.3.2 项目管理计划更新"></a>5.3.2 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更的项目管理计划组件包括（但不限于）：</p><ul><li><p>进度管理计划。对进度管理计划的变更包括：资源负荷和资源平衡变更，或进度策略更新等。</p></li><li><p>成本管理计划。对成本管理计划的变更包括：成本会计、跟踪和报告变更，以及预算策略和应急储备使用方法更新等。</p></li><li><p>质量管理计划。对质量管理计划的变更包括：满足需求的方法、质量管理方法、或质量控制过程的变更等。</p></li><li><p>资源管理计划。对资源管理计划的变更包括：资源配置变更，以及资源策略更新等。</p></li><li><p>采购管理计划。对采购管理计划的变更包括：自制或外购决策或合同类型的更改等。</p></li><li><p>范围基准。如果商定的风险应对策略导致了范围变更，且这种变更已经获得批准，那么就要对范围基准做出相应的变更。</p></li><li><p>进度基准。如果商定的风险应对策略导致了进度估算变更，且这种变更已经获得批准，那么就要对进度基准做出相应的变更。</p></li><li><p>成本基准。如果商定的风险应对策略导致了成本估算变更，且这种变更已经获得批准，那么就要对成本基准做出相应的变更。</p></li></ul><h5 id="5-3-3-项目文件更新"><a href="#5-3-3-项目文件更新" class="headerlink" title="5.3.3 项目文件更新"></a>5.3.3 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>假设日志。在规划风险应对过程中，可能做出新的假设、识别出新的制约因素，或者现有的假设条件或制约因素可能被重新审查和修改。应该更新假设日志，记录这些新信息。</p></li><li><p>成本预测。成本预测可能因规划的风险应对策略而发生变更。</p></li><li><p>经验教训登记册。更新经验教训登记册，记录适用于项目的未来阶段或未来项目的风险应对信息。</p></li><li><p>项目进度计划。可以把用于执行已商定的风险应对策略的活动添加到项目进度计划中。</p></li><li><p>项目团队派工单。一旦确定应对策略，应为每项与风险应对计划相关的措施分配必要的资源，包括用于执行商定的措施的具有适当资质和经验的人员（通常在项目团队中）、合理的资金和时间，以及必要的技术手段。</p></li><li><p>风险登记册。需要更新风险登记册，记录选择和商定的风险应对措施。风险登记册的更新可能包括（但不限于）：</p><ul><li><p>商定的应对策略；</p></li><li><p>实施所选应对策略所需要的具体行动；</p></li><li><p>风险发生的触发条件、征兆和预警信号；</p></li><li><p>实施所选应对策略所需要的预算和进度活动；</p></li><li><p>应急计划，以及启动该计划所需的风险触发条件；</p></li><li><p>弹回计划，供风险发生却主要应对措施不足以应对时使用；</p></li><li><p>在采取预定应对措施之后仍然存在的残余风险，以及有意接受的风险；</p></li><li><p>由实施风险应对措施而直接导致的次生风险。</p></li></ul></li><li><p>风险报告。更新风险报告，记录这对当前整体项目风险敞口和高优先级风险的经商定的应对措施，以及实施这些措施之后的预期变化。</p></li></ul><hr><h3 id="六、实施风险应对"><a href="#六、实施风险应对" class="headerlink" title="六、实施风险应对"></a>六、实施风险应对</h3><p>实施风险应对是执行商定的风险应对计划的过程。本过程的主要作用是，确保按计划执行商定的风险应对措施，来管理整体项目风险敞口、最小化单个项目威胁，以及最大化单个项目机会。本过程需要在整个项目期间开展。图11-18描述本过程的输入、工具与技术和输出。图11-19是本过程的数据流向图。</p><p><img src="/images/pmp-11/11-18.png" alt="实施风险应对：输入、工具与技术和输出"></p><p><img src="/images/pmp-11/11-19.png" alt="实施风险应对：数据流向图"></p><p>适当关注实施风险应对过程，能够确保已商定的风险应对措施得到实际执行。项目风险管理的一个常见问题是，项目团队努力识别和分析风险并制定应对措施，然后把经商定的应对措施记录在风险登记册和风险报告中，但是不采取实际行动去管理风险。</p><p>只有风险责任人以必要的努力去实施商定的应对措施，项目的整体风险敞口和单个威胁及机会才能得到主动管理。</p><h4 id="6-1-实施风险应对：输入"><a href="#6-1-实施风险应对：输入" class="headerlink" title="6.1 实施风险应对：输入"></a>6.1 实施风险应对：输入</h4><h5 id="6-1-1-项目管理计划"><a href="#6-1-1-项目管理计划" class="headerlink" title="6.1.1 项目管理计划"></a>6.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）风险管理计划。风险管理计划列明了与风险管理相关的项目团队成员和其他相关方的角色和职责。应根据这些信息为已商定的风险应对措施分配责任人。风险管理计划还会定义适用于本项目的风险管理方法论的详细程度，还会基于关键相关方的风险偏好规定项目的风险临界值。风险临界值代表了实施风险应对所需实现的可接受目标。</p><h5 id="6-1-2-项目文件"><a href="#6-1-2-项目文件" class="headerlink" title="6.1.2 项目文件"></a>6.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。项目早期获得的与实施风险应对有关的经验教训，可用于项目后期提高本过程的有效性。</p></li><li><p>风险登记册。风险登记册记录了每项单个风险的商定风险应对措施，以及负责应对的指定责任人。</p></li><li><p>风险报告。风险报告包括对当前整体项目风险敞口的评估，以及商定的风险应对策略，还会描述重要的单个项目风险及其应对计划。</p></li></ul><h5 id="6-1-3-组织过程资产"><a href="#6-1-3-组织过程资产" class="headerlink" title="6.1.3 组织过程资产"></a>6.1.3 组织过程资产</h5><p>能够影响实施风险应对过程的组织过程资产包括（但不限于）已完成的类似项目的经验教训知识库，其中会说明特定风险应对的有效性。</p><h4 id="6-2-实施风险应对：工具与技术"><a href="#6-2-实施风险应对：工具与技术" class="headerlink" title="6.2 实施风险应对：工具与技术"></a>6.2 实施风险应对：工具与技术</h4><h5 id="6-2-1-专家判断"><a href="#6-2-1-专家判断" class="headerlink" title="6.2.1 专家判断"></a>6.2.1 专家判断</h5><p>在确认或修改（如必要）风险应对措施，以及决定如何以最有效率和最有效果的方式加以实施时，应征求具备相应专业知识的个人或小组的意见。</p><h5 id="6-2-2-人际关系与团队技能"><a href="#6-2-2-人际关系与团队技能" class="headerlink" title="6.2.2 人际关系与团队技能"></a>6.2.2 人际关系与团队技能</h5><p>适用于本过程的人际关系与团队技能包括（但不限于）影响力。有些风险应对措施可能由直属项目团队以外的人员去执行，或由存在其他竞争性需求的人员去执行。这种情况下，负责引导风险管理过程的项目经理或人员就需要施展影响力，去鼓励指定的风险责任人采取所需的行动。</p><h5 id="6-2-3-项目管理信息系统（PMIS）"><a href="#6-2-3-项目管理信息系统（PMIS）" class="headerlink" title="6.2.3 项目管理信息系统（PMIS）"></a>6.2.3 项目管理信息系统（PMIS）</h5><p>项目管理信息系统可能包括进度、资源和成本软件，用于确保把商定的风险应对计划及其相关活动，连同其他项目活动，一并纳入整个项目。</p><h4 id="6-3-实施风险应对：输出"><a href="#6-3-实施风险应对：输出" class="headerlink" title="6.3 实施风险应对：输出"></a>6.3 实施风险应对：输出</h4><h5 id="6-3-1-变更请求"><a href="#6-3-1-变更请求" class="headerlink" title="6.3.1 变更请求"></a>6.3.1 变更请求</h5><p>实施风险应对后，可能会就成本基准和进度基准，或项目管理计划的其他组件提出变更请求。应该通过实施整体变更控制过程对变更请求进行审查和处理。</p><h5 id="6-3-2-项目文件更新"><a href="#6-3-2-项目文件更新" class="headerlink" title="6.3.2 项目文件更新"></a>6.3.2 项目文件更新</h5><p>可在本过程跟新的项目文件包括（但不限于）：</p><ul><li><p>问题日志。作为实施风险应对过程的一部分，已识别的问题会被记录到问题日志中。</p></li><li><p>经验教训登记册。更新经验教训登记册，记录在实施风险应对时遇到的挑战、本可采取的规避方法，以及实施风险应对的有效方式。</p></li><li><p>项目团队派工单。一旦确定风险应对策略，应为每项与风险应对计划相关的措施分配必要的资源，包括用于执行商定的措施的具有适当资质和经验的人员、合理的资金和时间，以及必要的技术手段。</p></li><li><p>风险登记册。可能需要更新风险登记册，反应开展本过程所导致的对单个项目风险的已商定应对措施的任何变更。</p></li><li><p>风险报告。可能需要风险报告，反映开展本过程所导致的对整体项目风险敞口的已商定应对措施的任何变更。</p></li></ul><hr><h3 id="七、监督风险"><a href="#七、监督风险" class="headerlink" title="七、监督风险"></a>七、监督风险</h3><p>监督风险是在整个项目期间，监督商定的风险应对计划的实施、跟踪已识别风险、识别和分析新风险，以及评估风险管理有效性的过程。本过程的主要作用是，使项目决策都基于关于整体项目风险敞口和单个项目风险的当前信息。本过程需要在整个项目期间开展。图11-20描述本过程的输入、工具与技术和输出。图11-21是本过程的数据流向图。</p><p><img src="/images/pmp-11/11-20.png" alt="监督风险：输入、工具与技术和输出"></p><p><img src="/images/pmp-11/11-21.png" alt="监督风险：数据流向图"></p><p>为了确保项目团队和关键相关方了解当前的风险敞口级别，应该通过监督风险过程对项目工作进行持续监督，来发现新出现、正变化和已过时的单个项目风险。监督风险过程采用项目执行期间生成的绩效信息，以确定：</p><ul><li><p>实施的风险应对是否有效；</p></li><li><p>整体项目风险级别是否已改变；</p></li><li><p>已识别单个项目风险的状态是否已改变；</p></li><li><p>是否出现新的单个项目风险；</p></li><li><p>风险管理方法是否依然适用；</p></li><li><p>项目假设条件是否仍然成立；</p></li><li><p>风险管理政策和程序是否已得到遵守；</p></li><li><p>成本或进度应急储备是否需要修改；</p></li><li><p>项目策略是否仍然有效。</p></li></ul><h4 id="7-1-监督风险：输入"><a href="#7-1-监督风险：输入" class="headerlink" title="7.1 监督风险：输入"></a>7.1 监督风险：输入</h4><h5 id="7-1-1-项目管理计划"><a href="#7-1-1-项目管理计划" class="headerlink" title="7.1.1 项目管理计划"></a>7.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）风险管理计划。风险管理计划规定了应如何及何时审查风险，应遵守哪些政策和程序，与本监督过程有关的角色和职责安排，以及报告格式。</p><h5 id="7-1-2-项目文件"><a href="#7-1-2-项目文件" class="headerlink" title="7.1.2 项目文件"></a>7.1.2 项目文件</h5><p>应作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>问题日志。问题日志用于检查未决问题是否已更新，并对风险登记册进行必要更新。</p></li><li><p>经验教训登记册。在项目早期获得的与风险相关的经验教训可用于项目后期阶段。</p></li><li><p>风险登记册。风险登记册的主要内容包括：已识别单个项目风险、风险责任人、商定的风险应对策略，以及具体的应对措施。它可能还会提供其他详细信息，包括用于评估应对计划有效性的控制措施、风险的症状和预警信号、残余及次生风险，以及低优先级风险观察清单。</p></li><li><p>风险报告。风险报告包括对当前整体项目风险敞口的评估，以及商定的风险应对策略，还会描述重要的单个项目风险及其应对计划和风险责任人。</p></li></ul><h5 id="7-1-3-工作绩效数据"><a href="#7-1-3-工作绩效数据" class="headerlink" title="7.1.3 工作绩效数据"></a>7.1.3 工作绩效数据</h5><p>工作绩效数据包含关于项目状态的信息，例如，已实施的风险应对措施、已发生的风险、仍活跃及已关闭的风险。</p><h5 id="7-1-4-工作绩效报告"><a href="#7-1-4-工作绩效报告" class="headerlink" title="7.1.4 工作绩效报告"></a>7.1.4 工作绩效报告</h5><p>工作绩效报告是通过分析绩效测量结果而得到的，能够提供关于项目工作绩效的信息，包括偏差分析结果、挣值数据和预测数据。在监督与绩效相关的风险时，需要使用这些信息。</p><h4 id="7-2-监督风险：工具与技术"><a href="#7-2-监督风险：工具与技术" class="headerlink" title="7.2 监督风险：工具与技术"></a>7.2 监督风险：工具与技术</h4><h5 id="7-2-1-数据分析"><a href="#7-2-1-数据分析" class="headerlink" title="7.2.1 数据分析"></a>7.2.1 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）：</p><ul><li><p>技术绩效分析。开展技术绩效分析，把项目执行期间所取得的技术成果与取得相关技术成果的计划进行比较。它要求定义关于技术绩效的客观的、量化的测量指标，以便据此比较实际结果与计划要求。技术绩效测量指标可能包括：重量、处理时间、缺陷数量、储存容量等。实际结果偏离计划的程度可以代表威胁或机会的潜在影响。</p></li><li><p>储备分析。在整个项目执行期间，可能发生某些单个项目风险，对预算和进度应急储备产生正面或负面的影响。储备分析是指项目的任一时点比较剩余应急储备与剩余风险量，从而确定剩余储备是否仍然合理。可以用各种图形（如燃尽图）来显示应急储备的消耗情况。</p></li></ul><h5 id="7-2-2-审计"><a href="#7-2-2-审计" class="headerlink" title="7.2.2 审计"></a>7.2.2 审计</h5><p>风险审计是一种审计类型，可用于评估风险管理过程的有效性。项目经理负责确保按项目风险管理计划所规定的频率开展风险审计。风险审计可以在日常项目审查会上开展，可以在风险审查会上开展，团队也可以召开专门的风险审计会。在实施审计前，应明确定义风险审计的程序和目标。</p><h5 id="7-2-3-会议"><a href="#7-2-3-会议" class="headerlink" title="7.2.3 会议"></a>7.2.3 会议</h5><p>适用于本过程的会议包括（但不限于）风险审查会。应该定期安排风险审查，来检查和记录风险应对在处理整体项目风险和已识别单个项目风险方面的有效性。在风险审查中，还可以识别出新的单个项目风险（包括已商定应对措施所引发的次生风险），重新评估当前风险，关闭已过时风险，讨论风险发生所引发的问题，以及总结可用于当前项目后续阶段或未来类似项目的经验教训。根据风险管理计划的规定，风险审查可以是定期项目状态会中的一项议程，或者也可以召开专门的风险审查会。</p><h4 id="7-3-监督风险：输出"><a href="#7-3-监督风险：输出" class="headerlink" title="7.3 监督风险：输出"></a>7.3 监督风险：输出</h4><h5 id="7-3-1-工作绩效信息"><a href="#7-3-1-工作绩效信息" class="headerlink" title="7.3.1 工作绩效信息"></a>7.3.1 工作绩效信息</h5><p>工作绩效信息是经过比较单个风险的实际发生情况和预计发生情况，所得到的关于项目风险管理执行绩效的信息。它可以说明风险应对规划和应对实施过程的有效性。</p><h5 id="7-3-2-变更请求"><a href="#7-3-2-变更请求" class="headerlink" title="7.3.2 变更请求"></a>7.3.2 变更请求</h5><p>执行监督风险过程后，可能会就成本基准和进度基准，或项目管理计划的其他组件提出变更请求，应该通过实施整体变更控制过程对变更请求进行审查和处理。</p><p>变更请求可能包括：建议的纠正与预防措施，以处理当前整体项目风险级别或单个项目风险。</p><h5 id="7-3-3-项目管理计划更新"><a href="#7-3-3-项目管理计划更新" class="headerlink" title="7.3.3 项目管理计划更新"></a>7.3.3 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。项目管理计划的任何组件都可能受本过程的影响。</p><h5 id="7-3-4-项目文件更新"><a href="#7-3-4-项目文件更新" class="headerlink" title="7.3.4 项目文件更新"></a>7.3.4 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>假设日志。在监督风险过程中，可能做出新的假设、识别出新的制约因素，或者现有假设条件或制约因素可能被重新审查和修改。需要更新假设日志，记录这些新信息。</p></li><li><p>问题日志。作为监督风险过程的一部分，已识别的问题会记录到问题日志中。</p></li><li><p>经验教训登记册。更新经验教训登记册，记录风险审查期间得到的任何与风险相关的经验教训，以便用于项目的后期阶段或未来项目。</p></li><li><p>风险登记册。更新风险登记册，记录在监督风险过程中产生的关于单个项目风险的信息，可能包括添加新风险、更新已过时风险或已发生风险，以及更新风险应对措施，等等。</p></li><li><p>风险报告。应该随着监督风险过程生成新信息，而更新风险报告，反映重要单个项目风险的当前状态，以及整体项目风险的当前级别。风险报告还可能包括有关的详细信息，诸如最高优先级单个项目风险、已商定的应对措施和责任人，以及结论与建议。风险报告也可以收录风险审计给出的关于风险管理过程有效性的结论。</p></li></ul><h5 id="7-3-5-组织过程资产更新"><a href="#7-3-5-组织过程资产更新" class="headerlink" title="7.3.5 组织过程资产更新"></a>7.3.5 组织过程资产更新</h5><p>可在本过程更新的组织过程资产包括（但不限于）：</p><ul><li><p>风险管理计划、风险登记册和风险报告的模版；</p></li><li><p>风险分解结构。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《PMBOK第六版》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目风险管理包括规划风险管理、识别风险、开展风险分析、规划风险应对、实施风险应对和监督风险的各个过程。项目风险管理的目标在于提高正面风险的概率和（或）影响，降低负面风险的概率和（或）影响，从而提高项目成功的可能性。&lt;/p&gt;
    
    </summary>
    
      <category term="PMP抄书系列" scheme="http://www.xiaoleon.cn/categories/PMP%E6%8A%84%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="pmp" scheme="http://www.xiaoleon.cn/tags/pmp/"/>
    
  </entry>
  
  <entry>
    <title>PMP(10) 项目沟通管理</title>
    <link href="http://www.xiaoleon.cn/2019/03/11/pmp-10/"/>
    <id>http://www.xiaoleon.cn/2019/03/11/pmp-10/</id>
    <published>2019-03-11T14:35:35.000Z</published>
    <updated>2019-05-13T09:48:28.155Z</updated>
    
    <content type="html"><![CDATA[<p>项目沟通管理包括开发工件，以及执行用于有效交换信息的各种活动，来确保项目及其相关方的信息需求得以满足的各个过程。项目沟通管理由两个部分组成：第一部分是制定策略，确保沟通对相关方行之有效；第二部分是执行必要活动，以落实沟通策略。</p><a id="more"></a><p>项目沟通管理的过程包括：</p><ul><li><p><strong>规划沟通管理</strong> —— 基于每个相关方或相关方群体的信息需求、可用的组织资产，以及具体项目的需求，为项目沟通活动制定恰当的方法和计划的过程。</p></li><li><p><strong>管理沟通</strong> —— 确保项目信息及时且恰当地收集、生成、发布、存储、检索、管理、监督和最终处置的过程。</p></li><li><p><strong>监督沟通</strong> —— 确保满足项目及其相关方的信息需求的过程。</p></li></ul><p>图10-1概括了项目沟通管理的各个过程。虽然在本《PMBOK指南》中，各项目沟通管理过程以界限分明和相互独立的形式出现，但在实践中它们会以本指南无法全面详述的方式相互交叠和相互作用。</p><p><img src="/images/pmp-10/10-1.png" alt="项目沟通管理概述"></p><p><strong>项目沟通管理的核心概念</strong></p><p>沟通是指有意或无意的信息交换。交换的信息可以是想法、指示或情绪。信息交换的方法包括：</p><ul><li><p>书面形式。实物或电子形式。</p></li><li><p>口头形式。面对面或远程形式。</p></li><li><p>正式或非正式形式（用正式纸质或社交媒体）。</p></li><li><p>手势动作。语调或面部表情。</p></li><li><p>媒体形式。图片、行动，甚至只是遣词造句。</p></li><li><p>遣词造句。表达一种想法的词语往往不止一个，且各词语的含义会存在细微差异。</p></li></ul><p>沟通是指用各种可能的方式来发送或接受信息，或者通过沟通活动（如会议和演讲），或者以工件的方式（如电子邮件、社交媒体、项目报告或项目文档）。</p><p>项目经理的大多数时间用于与团队成员和其他项目相关方沟通，包括来自组织内部（组织的各个层级）和组织外部的人员。不同相关方可能有不同的文化和组织背景，以及不同的专业水平、观点和兴趣，而有效的沟通能够在他们之间架起一座桥梁。</p><p>沟通活动可按多种维度进行分类，包括（但不限于）：</p><ul><li><p>内部。针对项目内部或组织内部的相关方。</p></li><li><p>外部。针对外部相关方，如客户、供应商、其他项目、组织、政府，公众和环保倡导者。</p></li><li><p>正式。报告、正式会议（定期及临时）、会议议程和记录、相关方简报和演示。</p></li><li><p>非正式。采用电子邮件、社交媒体、网站，以及非正式临时讨论的一般沟通活动。</p></li><li><p>层级沟通。相关方或相关方群体相对于项目团队的位置将会以如下方式影响信息传递的形式和内容：</p><ul><li><p>向上沟通。针对高层相关方。</p></li><li><p>向下沟通。针对承担项目工作的团队和其他人员。</p></li><li><p>横向沟通。针对项目经理或团队的同级人员。</p></li></ul></li><li><p>官方沟通。年报，成交监管机构或政府部门的报告。</p></li><li><p>非官方沟通。采用灵活（往往为非正式）的手段，来建立和维护项目团队及其相关方对项目情况的了解和认可，并在他们之间建立强有力的关系。</p></li><li><p>书面与口头沟通。口头（用词和音调变化）及非口头（肢体语言和行为），社交媒体和网站、媒体发布。</p></li></ul><p>沟通可以为成功完成项目与项目集建立必要的关系。用于开展沟通的活动和工件多种多样，从电子邮件和非正式对话，到正式会议和定期项目报告。通过言语、面部表情、手势动作和其他行动有意或无意地发送和接收信息。为了成功管理与相关方的项目关系，沟通既包括制定策略和计划，以便创建合适的沟通工件和开展合适的沟通活动，也包括运用相关技能来提升计划和即兴的沟通的效果。</p><p>成功的沟通包括两个部分。第一部分是根据项目及其相关方的需求而制定适当的沟通策略。从该策略出发，制定沟通管理计划，来确保用各种形式和手段把恰当的信息传递给相关方。这些信息构成项目沟通-成功沟通的第二部分。项目沟通是规划过程的产物，在沟通管理计划中有相关规定。沟通管理计划定义了信息的收集、生成、发布、储存、检索、管理、追踪和处置。最终，沟通策略和沟通管理计划将成为监督沟通效果的依据。</p><p>在项目沟通中，需要尽力预防理解错误和沟通错误，并从规划过程所规定的的各种方法、发送方、接收方和信息中作出谨慎选择。</p><p>在编制传统（非社交媒体）的书面或口头信息的时候，应用书面沟通的5C原则，可以减轻但无法消除理解错误：</p><ul><li><p>正确的语法和拼写。语法不当或拼写错误会分散注意力，还有可能扭曲信息含义，降低可信度。</p></li><li><p>简洁的表述和无多余字。简洁且精心组织的信息能降低误解信息意图的可能性。</p></li><li><p>清晰的目的和表述（适合读者的需要）。确保在信息中包含能满足受众需求与激发其兴趣的内容。</p></li><li><p>连贯的思维逻辑。写作思路连贯，以及在整个书面文件中使用诸如“引言”和“小结”的小标题。</p></li><li><p>受控的语句和想法承接。可能需要使用图表或小结来控制语句和想法的承接。</p></li></ul><p>书面沟通的5C原则需要用下列沟通技巧来配合。</p><ul><li><p>积极倾听。与说话人保持互动，并总结对话内容，以确保有效的信息交换。</p></li><li><p>理解文化和个人差异。提升团队对文化及个人差异的认识，以减少误解并提升沟通能力。</p></li><li><p>识别、设定并管理相关方期望。与相关方磋商，减少相关方社区中的自相矛盾的期望。</p></li><li><p>强化技能。强化所有团队成员开展以下活动的技能：</p><ul><li><p>说服个人、团队或组织采取行动；</p></li><li><p>激励和鼓励人们，或帮助人们重塑自信；</p></li><li><p>指导人们改进绩效和取得期望结果；</p></li><li><p>通过磋商达成共识以及减轻审批或决策延误；</p></li><li><p>解决冲突，防止破坏性影响。</p></li></ul></li></ul><p>有效的沟通活动和工件创建具有如下基本属性：</p><pre><code>* 沟通目的明确；* 尽量了解沟通接收方，满足其需求及偏好；* 监督并衡量沟通的效果。</code></pre><p><strong>项目沟通管理的发展趋势和新兴实践</strong></p><p>在关注相关方，以及认可相关方的有效参与对项目及组织的价值的同时，也要认识到制定和落实适当的沟通策略，对维系与相关方的有效关系是至关重要的。项目沟通管理的发展趋势和新兴实践包括（但不限于）：</p><ul><li><p>将相关方纳入项目评审范围。每个项目的相关方社区中都包括被项目团队确定为对成功达成项目目标和组织成果不可或缺的个人、群体和组织。有效的沟通策略要求定期且及时地评审相关方社区，以管理成员及其态度的变化。</p></li><li><p>让相关方参与项目会议。项目会议应邀请项目外部甚至组织外部（若适当）的相关方参与。敏捷方法中的一些做法适用于任何类型的项目，例如，简短的每日站会。在每日站会上，项目团队的主要相关方就前一天的成绩和问题以及当天的工作计划展开讨论。</p></li><li><p>社交工具的使用日益增多。以硬件平台、社交媒体服务和个人便捷设备为代表的的社交工具已经改变组织及其人员的沟通和业务方式。在公共IT基础设施的支持下，社交工具将不同的协作方式融合在一起。网络社交是指用户建立关系网络，与他人共同拓展兴趣和活动。社交媒体工具不仅能支持信息交换，而且也有助于建立更深层次的新人和社群关系。</p></li><li><p>多面性沟通方法。制定项目相关方沟通策略时，通常应考虑所有可用技术，并从中作出选择；同时也应尊重因文化、实践和个人背景而产生的对沟通语言、媒介、内容和方式的偏好。可以根据需要采用社交媒体和其他先进的电脑技术。多面性方法能够提高与不同年代和文化背景的相关方沟通的效果。</p></li></ul><p><strong>裁剪时需要考虑的因素</strong></p><p>因为每个项目都是独特的，所以项目团队需要裁剪项目沟通管理过程。裁剪时应考虑的因素包括（但不限于）：</p><ul><li><p>相关方。相关方是属于组织内部或外部，或者二者都是？</p></li><li><p>物理地点。团队成员身处何地？团队是否集中办公？团队是否位于相同地理区域？团队是否分散于多个时区？</p></li><li><p>沟通技术。哪项技术可用于创建、记录、传输、检索、追踪和储存沟通工件？哪些技术最适用于与相关方沟通且成本效益最高？</p></li><li><p>语言。语言是沟通活动中要考虑的主要因素。使用的是一种语言，还是多种语言？是否已为适应多语种团队的复杂情况安排了资金？</p></li><li><p>知识管理。组织是否有正式的知识管理库？是否采用管理库？</p></li></ul><p><strong>在敏捷或适应型环境中需要考虑的因素</strong></p><p>在模糊不定的项目环境中，必然需要对不断演变和出现的细节情况，进行更频繁和快速的沟通。因此，应该尽量简化团队成员获取信息的通道，频繁进行团队检查，并让团队成员集中办公。</p><p>此外，为了促进与高级管理层和相关方的沟通，还需要以透明的方式发布项目工件，并定期邀请相关方评审项目工件。</p><h3 id="一、规划沟通管理"><a href="#一、规划沟通管理" class="headerlink" title="一、规划沟通管理"></a>一、规划沟通管理</h3><p>规划沟通管理是基于每个相关方或相关方群体的信息需求、可用的组织资产，以及具体项目的需求，为项目沟通活动制定恰当的方法和计划的过程。本过程的主要作用是，为及时向相关方提供相关信息，引导相关方有效参与项目，而编制书面沟通计划。本过程应根据需要在整个项目期间定期开展。图10-2描述本过程的输入、工具与技术和输出。图10-3是本过程的数据流向图。</p><p><img src="/images/pmp-10/10-2.png" alt="规划沟通管理：输入、工具与技术和输出"></p><p><img src="/images/pmp-10/10-3.png" alt="规划沟通管理：数据流向图"></p><p>需在项目生命周期的早期，针对项目相关方多样性的信息需求，制定有效的沟通管理计划。应该定期审核沟通管理计划，并进行必要的修改，例如在相关方社区发生变化或每个新项目阶段开始时。</p><p>在大多数项目中，都需要很早就开始沟通规划工作，例如在识别相关方及制定项目管理计划期间。</p><p>虽然所有项目都需要进行信息沟通，但是各项目的信息需求和信息发布方式可能差别很大。此外，在本过程中，需要考虑并合理记录用来存储、检索和最终处置项目信息的方法。应该在整个项目期间，定期审查规划沟通管理过程的成果并做必要修改，以确保其持续适用。</p><h4 id="1-1-规划沟通管理：输入"><a href="#1-1-规划沟通管理：输入" class="headerlink" title="1.1 规划沟通管理：输入"></a>1.1 规划沟通管理：输入</h4><h5 id="1-1-1-项目章程"><a href="#1-1-1-项目章程" class="headerlink" title="1.1.1 项目章程"></a>1.1.1 项目章程</h5><p>项目章程会列出主要相关方清单，其中可能还包含与相关方角色及职责有关的信息。</p><h5 id="1-1-2-项目管理计划"><a href="#1-1-2-项目管理计划" class="headerlink" title="1.1.2 项目管理计划"></a>1.1.2 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>资源管理计划。指导如何对项目资源进行分类、分配、管理和释放。团队成员和小组可能有沟通要求，应该在沟通管理计划中列出。</p></li><li><p>相关方参与计划。相关方参与计划确定了有效吸引相关方参与所需的管理策略，而这些策略通过沟通来落实。</p></li></ul><h5 id="1-1-3-项目文件"><a href="#1-1-3-项目文件" class="headerlink" title="1.1.3 项目文件"></a>1.1.3 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>需求文件。需求文件可能包含项目相关方对沟通的需求。</p></li><li><p>相关方登记册。相关方登记册用于规划与相关方的沟通活动。</p></li></ul><h5 id="1-1-4-事业环境因素"><a href="#1-1-4-事业环境因素" class="headerlink" title="1.1.4 事业环境因素"></a>1.1.4 事业环境因素</h5><p>能够影响规划沟通管理过程的事业环境因素包括（但不限于）：</p><ul><li><p>组织文化、政治氛围和治理框架；</p></li><li><p>人事管理政策；</p></li><li><p>相关方风险临界值；</p></li><li><p>已确立的沟通渠道、工具和系统；</p></li><li><p>全球、区域或当地的趋势、实践或习俗；</p></li><li><p>设施和资源的地理分布。</p></li></ul><h5 id="1-1-5-组织过程资产"><a href="#1-1-5-组织过程资产" class="headerlink" title="1.1.5 组织过程资产"></a>1.1.5 组织过程资产</h5><p>能够影响规划沟通过程的组织过程资产包括（但不限于）：</p><ul><li><p>组织的社交媒体、道德和安全政策及程序；</p></li><li><p>组织的问题、风险、变更和数据管理政策及程序；</p></li><li><p>组织对沟通的要求；</p></li><li><p>制作、交换、储存和检索信息的标准化指南；</p></li><li><p>历史信息和经验教训知识库；</p></li><li><p>以往项目的相关方及沟通数据和信息。</p></li></ul><h4 id="1-2-规划沟通管理：工具与技术"><a href="#1-2-规划沟通管理：工具与技术" class="headerlink" title="1.2 规划沟通管理：工具与技术"></a>1.2 规划沟通管理：工具与技术</h4><h5 id="1-2-1-专家判断"><a href="#1-2-1-专家判断" class="headerlink" title="1.2.1 专家判断"></a>1.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>组织内的政治和权力结构；</p></li><li><p>组织及其他客户组织的环境和文化；</p></li><li><p>组织变革管理方法和实践；</p></li><li><p>项目可交付成果所属的行业或类型；</p></li><li><p>组织沟通技术；</p></li><li><p>关于遵守与企业沟通有关法律要求的组织政策与程序；</p></li><li><p>与安全有关的组织政策与程序；</p></li><li><p>相关方，包括客户或发起人。</p></li></ul><h5 id="1-2-2-沟通需求分析"><a href="#1-2-2-沟通需求分析" class="headerlink" title="1.2.2 沟通需求分析"></a>1.2.2 沟通需求分析</h5><p>分析沟通需求，确定项目相关方的信息需求，包括所需信息的类型和格式，以及信息对相关方的价值。</p><p>常用于识别和确定项目沟通需求的信息包括（但不限于）：</p><ul><li><p>相关方登记册及相关方参与计划中的相关信息和沟通需求；</p></li><li><p>潜在沟通渠道或途径数量，包括一对一、一对多和多对多沟通；</p></li><li><p>组织结构图；</p></li><li><p>项目组织与相关方的职责、关系与相互依赖；</p></li><li><p>开发方法；</p></li><li><p>项目所涉及的学科、部门和专业；</p></li><li><p>有多少人在什么地点参与项目；</p></li><li><p>内部信息需要（如何时在组织内部沟通）；</p></li><li><p>外部信息需要（如何时与媒体、公众或承包商沟通）；</p></li><li><p>法律要求。</p></li></ul><h5 id="1-2-3-沟通技术"><a href="#1-2-3-沟通技术" class="headerlink" title="1.2.3 沟通技术"></a>1.2.3 沟通技术</h5><p>用于在项目相关方之间传递信息的方法很多。信息交换和协作的常见方法包括对话、会议、书面文件、数据库、社交媒体和网站。</p><p>可能影响沟通技术的因素包括：</p><ul><li><p>信息需求的紧迫性。信息传递的紧迫性、频率和形式可能因项目而异，也可能因项目阶段而异。</p></li><li><p>技术的可用性与可靠性。用于发布项目沟通工件的技术，应该在整个项目期间都具备兼容性和可得性，且对所有相关方都可用。</p></li><li><p>易用性。沟通技术的选择应适合项目参与者，而且应在合适的时候安排适当的培训活动。</p></li><li><p>项目环境。团队会议与工作是面对面还是在虚拟环境中开展，成员处于一个还是多个时区，他们是否使用多语种沟通，是否还有能影响沟通效率的其他环境因素（如与文化有关的各个方面）？</p></li><li><p>信息的敏感性和保密性。需要考虑的一些方面有：</p><ul><li><p>拟传递的信息是否属于敏感或机密信息？如果是，可能需要采取合理的安全措施。</p></li><li><p>为员工制定社交媒体政策，以确保行为适当、信息安全和知识产权保护。</p></li></ul></li></ul><h5 id="1-2-4-沟通模型"><a href="#1-2-4-沟通模型" class="headerlink" title="1.2.4 沟通模型"></a>1.2.4 沟通模型</h5><p>沟通模型可以是最基本的线性（发送方和接收方）沟通过程，也可以是增加了反馈元素（发送方、接收方和反馈）、更具互动性的沟通形式，甚至可以是融合了发送方或接收方的人性因素、试图考虑沟通复杂性的更加复杂的沟通模型。</p><ul><li><p>基本的发送方和接收方沟通模型示例。此模型将沟通描述为一个过程，并由发送方和接收方两方参与；其关注的是确保信息送达，而非信息理解。基本沟通模型中的步骤顺序为：</p><ul><li><p>编码。把信息编码为各种符号，如文本、声音或其他可供传递（发送）的形式。</p></li><li><p>传递信息。通过沟通渠道发送信息。信息传递可能受各种物理因素的不利影响，如不熟悉的技术，或不完备的基础设施。可能存在噪音和其他因素，导致信息传递和（或）接收过程中的信息损耗。</p></li><li><p>解码。接收方将收到的数据还原为对自己有用的形式。</p></li></ul></li><li><p>互动沟通模型示例。此模型也将沟通描述为由发送方与接收方参与的沟通过程，但它还强调确保信息理解的必要性。此模型包括任何可能干扰或阻碍信息理解的噪音，如接收方注意力分散、接收方的认知差异，或缺少适当的知识或兴趣。互动沟通模型中的新增步骤有：</p><ul><li><p>确认已收到。收到信息时，接收方需告知对方已收到信息（确认已收到）。这并不一定意味着同意或理解信息的内容，仅表示已收到信息。</p></li><li><p>反馈/响应。对收到的信息进行解码并理解之后，接收方把还原出来的思想或观点编码成信息，再传递给最初的发送方。如果发送方认为反馈与原来的信息相符，代表沟通已成功完成。在沟通中，可以通过积极倾听实现反馈。</p><p>作为沟通过程的一部分，发送方负责信息的传递，确保信息的清晰性和完整性，并确认信息已被正确理解；接收方负责确保完整地接收信息，正确地理解信息，并需要告知已收到或做出适当的回应。在发送方和接收方所处的环境中，都可能存在会干扰有效沟通的各种噪音和其他障碍。</p></li></ul></li></ul><p>在跨文化沟通中，确保信息理解会面临挑战。沟通风格的差异可源于工作方法、年龄、国籍、专业学科、民族、种族或性别差异。不同文化的人们会以不同的语言（如技术设计文档、不同的风格）沟通，并喜欢采用不同的沟通过程和礼节。</p><p>图10-4所示的沟通模型展示了发送方的当前情绪、知识、背景、个性、文化和偏见会如何影响信息本身及其传递方式。类似地，接收方的当前情绪、知识、背景、个性、文化和偏见也会影响信息的接收和解读方式，导致沟通中的障碍或噪音。</p><p>此沟通模型及其强化版有助于制定人对人或小组对小组的沟通策略和计划，但不可用于制定采用其他沟通工件（如电子邮件、广播信息或社交媒体）的沟通策略和计划。</p><p><img src="/images/pmp-10/10-4.png" alt="适用于跨文化沟通的沟通模型"></p><h5 id="1-2-5-沟通方法"><a href="#1-2-5-沟通方法" class="headerlink" title="1.2.5 沟通方法"></a>1.2.5 沟通方法</h5><p>项目相关方之间用于分享信息的沟通方法有几种。这些方法可以大致分为：</p><ul><li><p>互动沟通。在两方或多方之间进行的实时多向信息交换。它使用诸如会议、电话、即时信息、社交媒体和视频会议等沟通工件。</p></li><li><p>推式沟通。向需要接收信息的特定接收方发送或发布信息。这种方法可以确保信息的发送，但不能确保信息送达目标受众或被目标受众理解。在推式沟通中，可以采用的沟通工件包括信件、备忘录、报告、电子邮件、传真、语音邮件、博客、新闻稿。</p></li><li><p>拉式沟通。适用于大量复杂信息或大量信息受众的情况。它要求接收方在遵守有关安全规定的前提之下自行访问相关内容。这种方法包括门户网站、企业内网、电子在线课程、经验教训数据库或知识库。</p></li></ul><p>应该采用不同方法来实现沟通管理计划所规定的的主要沟通需求：</p><ul><li><p>人际沟通。个人之间交换信息，通常以面对面的方式进行。</p></li><li><p>小组沟通。在三到六名人员的小组内部开展。</p></li><li><p>公众沟通。单个演讲者面向一群人。</p></li><li><p>大众传播。信息发送人员或小组与大量目标受众（有时为匿名）之间只有最低程度的联系。</p></li><li><p>网络和社交工具沟通。借助社交工具和媒体，开展多对多的沟通。</p></li></ul><p>可用的沟通工件和方法包括（但不限于）：</p><ul><li><p>公告板；</p></li><li><p>新闻通讯、内部杂志、电子杂志；</p></li><li><p>致员工或志愿者的信件；</p></li><li><p>新闻稿；</p></li><li><p>年度报告；</p></li><li><p>电子邮件和内部局域网；</p></li><li><p>门户网站和其他信息库（适用于拉式沟通）；</p></li><li><p>电话交流；</p></li><li><p>演示；</p></li><li><p>团队简述或小组会议；</p></li><li><p>焦点小组；</p></li><li><p>相关方之间的正式或非正式的面对面会议；</p></li><li><p>咨询小组或员工论坛；</p></li><li><p>社交工具和媒体。</p></li></ul><h5 id="1-2-6-人际关系与团队技能"><a href="#1-2-6-人际关系与团队技能" class="headerlink" title="1.2.6 人际关系与团队技能"></a>1.2.6 人际关系与团队技能</h5><p>适用于本过程的人际关系与团队技能包括（但不限于）：</p><ul><li><p>沟通风格评估。规划沟通活动时，用于评估沟通风格并识别偏好的沟通方法、形式和内容的一种技术。产用于不支持项目的相关方。可以先开展相关方参与度评估，再开展沟通风格评估。在相关方参与度评估中，找出相关方参与度的差距。为弥补这种差距，就需要特别裁剪沟通活动和工件。</p></li><li><p>政治意识。政治意识有助于项目经理根据项目环境和组织的政治环境来规划沟通。政治意识是指对正式和非正式权力关系的认识，以及在这些关系中工作的意愿。理解组织战略、了解谁能行使权力和施加影响，以及培养与这些相关方沟通的能力，都属于政治意识的范畴。</p></li><li><p>文化意识。文化意识指理解个人、群体和组织之间的差异，并据此调整项目的沟通策略。具有文化意识并采取后续行动，能够最小化因项目相关方社区内的文化差异而导致的理解错误和沟通错误。文化意识和文化敏感性有助于项目经理依据相关方和团队成员的文化差异和文化需求对沟通进行规划。</p></li></ul><h5 id="1-2-7-数据表现"><a href="#1-2-7-数据表现" class="headerlink" title="1.2.7 数据表现"></a>1.2.7 数据表现</h5><p>适用于本过程的数据表现技术包括（但不限于）相关方参与度评估矩阵。如图13-6所示，相关方参与度评估矩阵显示了个体相关方当前和期望参与度之间的差距。在本过程中，可进一步分析该评估矩阵，以便为填补参与度差距而识别额外的沟通需求（除常规报告以外的）。</p><h5 id="1-2-8-会议"><a href="#1-2-8-会议" class="headerlink" title="1.2.8 会议"></a>1.2.8 会议</h5><p>项目会议可包括虚拟（网络）或面对面会议，且可用文档协同技术进行辅助，包括电子邮件信息和项目网站。在规划沟通管理过程中，需要与项目团队展开讨论，确定最合适的项目信息更新和传递方式，以及回应各相关方的信息请求的方式。</p><h4 id="1-3-规划沟通管理：输出"><a href="#1-3-规划沟通管理：输出" class="headerlink" title="1.3 规划沟通管理：输出"></a>1.3 规划沟通管理：输出</h4><h5 id="1-3-1-沟通管理计划"><a href="#1-3-1-沟通管理计划" class="headerlink" title="1.3.1 沟通管理计划"></a>1.3.1 沟通管理计划</h5><p>沟通管理计划是项目管理计划的组成部分，描述将如何规划，结构化、执行与监督项目沟通，以提高沟通的有效性。该计划包括如下信息：</p><ul><li><p>相关方的沟通需求；</p></li><li><p>需沟通的信息，包括语言、形式、内容和详细程度；</p></li><li><p>上报步骤；</p></li><li><p>发布信息的原因；</p></li><li><p>发布所需信息、确认已收到，或作出回应（若适用）的时限和频率；</p></li><li><p>负责沟通相关信息的人员；</p></li><li><p>负责授权保密信息发布的人员；</p></li><li><p>接收信息的人员或群体，包括他们的需要、需求和期望；</p></li><li><p>用于传递信息的方法或技术，如备忘录、电子邮件、新闻稿，或社交媒体；</p></li><li><p>为沟通活动分配的资源，包括时间和预算；</p></li><li><p>随着项目进展，如项目不同阶段相关方社区的变化，而更新与优化沟通管理计划的方法；</p></li><li><p>通用术语表；</p></li><li><p>项目信息流向图、工作流程（可能包含审批程序）、报告清单和会议计划等；</p></li><li><p>来自法律法规、技术、组织政策等的制约因素。</p></li></ul><p>沟通管理计划中还包括关于项目状态会议、项目团队会议、网络会议和电子邮件等的指南和模板。如果项目要使用项目网站和项目管理软件，那就要把它们写进沟通管理计划。</p><h5 id="1-3-2-项目管理计划更新"><a href="#1-3-2-项目管理计划更新" class="headerlink" title="1.3.2 项目管理计划更新"></a>1.3.2 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更的项目管理计划组件包括（但不限于）相关方参与计划。需要更新相关方参与计划，反映会影响相关方参与项目决策和执行的任何过程、程序、工具或技术。</p><h5 id="1-3-3-项目文件更新"><a href="#1-3-3-项目文件更新" class="headerlink" title="1.3.3 项目文件更新"></a>1.3.3 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>项目进度计划。可能需要更新项目进度计划，以反映沟通活动。</p></li><li><p>相关方登记册。可能需要更新相关方登记册，以反映计划好的沟通。</p></li></ul><hr><h3 id="二、管理沟通"><a href="#二、管理沟通" class="headerlink" title="二、管理沟通"></a>二、管理沟通</h3><p>管理沟通是确保项目信息及时且恰当地收集、生成、发布、存储、检索、管理、监督和最终处置的过程。本过程的主要作用是，促成项目团队与相关方之间的有效信息流动。本过程需要在整个项目期间开展。</p><p>管理沟通过程会涉及与开展有效沟通有关的所有方面，包括使用适当的技术、方法和技巧。此外，它还应允许沟通活动具有灵活性，允许对方法和技术进行调整，以满足相关方及项目不断变化的需求。图10-5描述本过程的输入、工具与技术和输出。图10-6是管理沟通过程的数据流向图。</p><p><img src="/images/pmp-10/10-5.png" alt="管理沟通：输入、工具与技术和输出"></p><p><img src="/images/pmp-10/10-6.png" alt="管理沟通：数据流向图"></p><p>本过程不局限于发布相关信息，它还设法确保信息以适当的格式正确生成和送达目标受众。本过程也为相关方提供机会，允许他们请求更多信息、澄清和讨论。有效的沟通管理需要借助相关技术并考虑相关事宜，包括（但不限于）：</p><ul><li><p>发送方-接收方模型。运用反馈循环，为互动和参与提供机会，并清除妨碍有效沟通的障碍。</p></li><li><p>媒介选择。为满足特定的项目需求而使用合理的沟通工件，例如，何时进行书面沟通或口头沟通、合适准备非正式备忘录或正式报告、何时使用推式或拉式沟通，以及该选择何种沟通技术。</p></li><li><p>写作风格。合理使用主动或被动语态、句子结构，以及合理选择词汇。</p></li><li><p>会议管理。准备议程，邀请重要参会者并确保他们出席；处理会议现场发生的冲突，或因对会议纪要和后续行动跟进不力而导致的的冲突，或因不当人员与会而导致的冲突。</p></li><li><p>演示。了解肢体语言和视觉辅助设计的作用。</p></li><li><p>引导。达成共识、克服障碍（如小组缺乏活力），以及维持小组成员的兴趣和热情。</p></li><li><p>积极倾听。积极倾听包括告知已收到、澄清与确认信息、理解，以及消除妨碍理解的障碍。</p></li></ul><h4 id="2-1-管理沟通：输入"><a href="#2-1-管理沟通：输入" class="headerlink" title="2.1 管理沟通：输入"></a>2.1 管理沟通：输入</h4><h5 id="2-1-1-项目管理计划"><a href="#2-1-1-项目管理计划" class="headerlink" title="2.1.1 项目管理计划"></a>2.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>资源管理计划。资源管理计划描述为管理团队或物质资源所需开展的沟通。</p></li><li><p>沟通管理计划。沟通管理计划描述将如何对项目沟通进行规划、结构化和监控。</p></li><li><p>相关方参与计划。相关方参与计划描述如何用适当的沟通策略引导相关方参与项目。</p></li></ul><h5 id="2-1-2-项目文件"><a href="#2-1-2-项目文件" class="headerlink" title="2.1.2 项目文件"></a>2.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>变更日志。变更日志用于向受影响的相关方传达变更，以及变更请求的批准、推迟和否决情况。</p></li><li><p>问题日志。将于问题有关的信息传达给受影响的相关方。</p></li><li><p>经验教训登记册。项目早期获取的与管理沟通有关的经验教训，可用于项目后期阶段改进沟通过程，提高沟通效率与效果。</p></li><li><p>质量报告。质量报告包括与质量问题、项目和产品改进，以及过程改进相关的信息。这些信息应交给能够采取纠正措施的人员，以便达成项目的质量期望。</p></li><li><p>风险报告。风险报告提供关于整体项目风险的来源的信息，以及关于已识别的单个项目风险的概述信息。这些信息应传达给风险责任人及其他受影响的相关方。</p></li><li><p>相关方登记册。相关方登记册确定了需要各类信息的人员、群体或组织。</p></li></ul><h5 id="2-1-3-工作绩效报告"><a href="#2-1-3-工作绩效报告" class="headerlink" title="2.1.3 工作绩效报告"></a>2.1.3 工作绩效报告</h5><p>根据沟通管理计划的定义，工作绩效报告会通过本过程传递给项目相关方。工作绩效报告的典型实例包括状态报告和进展报告。工作绩效报告可以包含挣值图表和信息、趋势线和预测、储备燃尽图、缺陷直方图、合同绩效信息以及风险概述信息。可以表现为有助于引起关注、制定决策和采取行动的仪表指示图、热点报告、信号灯图或其他形式。</p><h5 id="2-1-4-事业环境因素"><a href="#2-1-4-事业环境因素" class="headerlink" title="2.1.4 事业环境因素"></a>2.1.4 事业环境因素</h5><p>会影响本过程的事业环境因素包括（但不限于）：</p><ul><li><p>组织文化、政治氛围和治理框架；</p></li><li><p>人事管理政策；</p></li><li><p>相关方风险临界值；</p></li><li><p>已确立的沟通渠道、工具和系统；</p></li><li><p>全球、区域或当地的趋势、实践或习俗；</p></li><li><p>设施和资源的地理分布。</p></li></ul><h5 id="2-1-5-组织过程资产"><a href="#2-1-5-组织过程资产" class="headerlink" title="2.1.5 组织过程资产"></a>2.1.5 组织过程资产</h5><p>会影响本过程的组织过程资产包括（但不限于）：</p><ul><li><p>企业的社交媒体、到的和安全政策及程序；</p></li><li><p>企业的问题、风险、变更和数据管理政策及程序；</p></li><li><p>组织对沟通的要求；</p></li><li><p>制作、交换、储存和检索信息的标准化指南；</p></li><li><p>以往项目的历史信息，包括经验教训知识库。</p></li></ul><h4 id="2-2-管理沟通：工具与技术"><a href="#2-2-管理沟通：工具与技术" class="headerlink" title="2.2 管理沟通：工具与技术"></a>2.2 管理沟通：工具与技术</h4><h5 id="2-2-1-沟通技术"><a href="#2-2-1-沟通技术" class="headerlink" title="2.2.1 沟通技术"></a>2.2.1 沟通技术</h5><p>会影响技术选用的因素包括团队是否集中办公、需要分享的信息是否需要保密、团队成员的可用资源，以及组织文化会如何影响会议和讨论的正常开展。</p><h5 id="2-2-2-沟通方法"><a href="#2-2-2-沟通方法" class="headerlink" title="2.2.2 沟通方法"></a>2.2.2 沟通方法</h5><p>沟通方法的选择应具有灵活性，以应对相关方社区的成员变化，或成员的需求和期望变化。</p><h5 id="2-2-3-沟通技能"><a href="#2-2-3-沟通技能" class="headerlink" title="2.2.3 沟通技能"></a>2.2.3 沟通技能</h5><p>适用于本过程的沟通技能包括（但不限于）：</p><ul><li><p>沟通胜任力。经过裁剪的沟通技能的组合，有助于明确关键信息的目的、建立有效关系、实现信息共享和采取领导行为。</p></li><li><p>反馈。反馈是关于沟通、可交付成果或情况的反应信息。反馈支持项目经理和团队及所有其他项目相关方之间的互动沟通。例如，指导、辅导和磋商。</p></li><li><p>非口头技能。例如，通过示意、语调和面部表情等适当的肢体语言来表达意思。镜像模仿和眼神交流也是重要的技能。团队成员应该知道如何通过说什么和不说什么来表达自己的想法。</p></li><li><p>演示。演示是信息和（或）文档的正式交付。向项目相关方明确有效地演示项目信息可包括（但不限于）：</p><ul><li><p>向相关方报告项目进度和信息更新；</p></li><li><p>提供背景信息以支持决策制定；</p></li><li><p>提供关于项目及其目标的通用信息，以提升项目工作和项目团队的形象；</p></li><li><p>提供具体信息，以提升对项目工作和目标的理解和支持力度。</p><p>为获得演示成功，应该从内容和形式上考虑以下因素：</p></li><li><p>受众及其期望和需求；</p></li><li><p>项目和项目团队的需求及目标。</p></li></ul></li></ul><h5 id="2-2-4-项目管理信息系统（PMIS）"><a href="#2-2-4-项目管理信息系统（PMIS）" class="headerlink" title="2.2.4 项目管理信息系统（PMIS）"></a>2.2.4 项目管理信息系统（PMIS）</h5><p>项目管理信息系统能够确保相关方及时便利地获取所需信息。用来管理和分发项目信息的工具很多，包括：</p><ul><li><p>电子项目管理工具。项目管理软件、会议和虚拟办公支持软件、网络界面、专门的项目门户网站和状态仪表盘，以及协同工作管理工具。</p></li><li><p>电子沟通管理。电子邮件、传真和语音邮件，音频、视频和网络会议，以及网站和网络发布。</p></li><li><p>社交媒体管理。网站和网络发布；以及为促进相关方参与和形成在线社区而建立博客和应用程序。</p></li></ul><h5 id="2-2-5-项目报告发布"><a href="#2-2-5-项目报告发布" class="headerlink" title="2.2.5 项目报告发布"></a>2.2.5 项目报告发布</h5><p>项目报告发布是收集和发布项目信息的行为。项目信息应发布给众多相关方群体。应针对每种相关方来调整项目信息发布的适当层次、形式和细节。从简单的沟通到详尽的定制报告和演示，报告的形式各不相同。可以定期准备信息或基于例外情况准备。虽然工作绩效报告是监控项目工作过程的输出，但是本过程会编制临时报告、项目演示、博客，以及其他类型的信息。</p><h5 id="2-2-6-人际关系与团队技能"><a href="#2-2-6-人际关系与团队技能" class="headerlink" title="2.2.6 人际关系与团队技能"></a>2.2.6 人际关系与团队技能</h5><p>适用于本过程的人际关系与团队技能包括（但不限于）：</p><ul><li><p>积极倾听。积极倾听技术包括告知已收到、澄清与确认信息、理解，以及消除妨碍理解的障碍。</p></li><li><p>冲突管理。</p></li><li><p>文化意识。</p></li><li><p>会议管理。会议管理是采取步骤确保会议有效并高效地达到预期目标。规划会议时应采取以下步骤：</p><ul><li><p>准备并发布会议议程（其中包含会议目标）；</p></li><li><p>确保会议在规定的时间开始和结束；</p></li><li><p>确保适当参与者受邀并出席；</p></li><li><p>切题；</p></li><li><p>处理会议中的期望、问题和冲突；</p></li><li><p>记录所有行动以及所分配的行动责任人。</p></li></ul></li><li><p>人际交往。人际交往是通过与他人互动交流信息，建立联系。人际交往有利于项目经理及其团队通过非正式组织解决问题，影响相关方的行动，以及提高相关方对项目工作和成果的支持，从而改善绩效。</p></li><li><p>政治意识。政治意识有助于项目经理在项目期间引导相关方参与，以保持相关方的支持。</p></li></ul><h5 id="2-2-7-会议"><a href="#2-2-7-会议" class="headerlink" title="2.2.7 会议"></a>2.2.7 会议</h5><p>可以召开会议，支持沟通策略和沟通计划所定义的行动。</p><h4 id="2-3-管理沟通：输出"><a href="#2-3-管理沟通：输出" class="headerlink" title="2.3 管理沟通：输出"></a>2.3 管理沟通：输出</h4><h5 id="2-3-1-项目沟通记录"><a href="#2-3-1-项目沟通记录" class="headerlink" title="2.3.1 项目沟通记录"></a>2.3.1 项目沟通记录</h5><p>项目沟通工件可包括（但不限于）：绩效报告、可交付成果的状态、进度进展、产生的成本、演示，以及相关方需要的其他信息。</p><h5 id="2-3-2-项目管理计划更新"><a href="#2-3-2-项目管理计划更新" class="headerlink" title="2.3.2 项目管理计划更新"></a>2.3.2 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可在本过程更新的项目管理计划包括（但不限于）：</p><ul><li><p>沟通管理计划。如果本过程导致了项目沟通方法发生变更，就要把这种变更反映在项目沟通计划中。</p></li><li><p>相关方参与计划。本过程将导致相关方的沟通需求以及商定的沟通策略需要更新。</p></li></ul><h5 id="2-3-3-项目文件更新"><a href="#2-3-3-项目文件更新" class="headerlink" title="2.3.3 项目文件更新"></a>2.3.3 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>问题日志。更新问题日志，反映项目的沟通问题，或如何沟通来解决实际问题。</p></li><li><p>经验教训登记册。更新经验教训登记册，记录在项目中遇到的挑战、本可采取的规避方法，以及适用和不适用于管理沟通的方法。</p></li><li><p>项目进度计划。可能需要更新项目进度计划，以反映沟通活动的状态。</p></li><li><p>风险登记册。更新风险登记册，记录与管理沟通相关的风险。</p></li><li><p>相关方登记册。更新相关方登记册，记录关于项目相关方沟通活动的信息。</p></li></ul><h5 id="2-3-4-组织过程资产更新"><a href="#2-3-4-组织过程资产更新" class="headerlink" title="2.3.4 组织过程资产更新"></a>2.3.4 组织过程资产更新</h5><p>可在本过程更新的组织过程资产包括（但不限于）：</p><ul><li><p>项目记录，例如往来函件、备忘录、会议记录及项目中使用的其他文档；</p></li><li><p>计划内的和临时的项目报告和演示。</p></li></ul><hr><h3 id="三、监督沟通"><a href="#三、监督沟通" class="headerlink" title="三、监督沟通"></a>三、监督沟通</h3><p>监督沟通是确保满足项目及其相关方的信息需求的过程。本过程的主要作用是，按沟通管理计划和相关方参与计划的要求优化信息传递流程。本过程需要在整个项目期间开展。图10-7描述本过程的输入、工具与技术和输出。图10-8是本过程的数据流向图。</p><p><img src="/images/pmp-10/10-7.png" alt="监督沟通：输入、工具与技术和输出"></p><p><img src="/images/pmp-10/10-8.png" alt="监督沟通：数据流向图"></p><p>通过监督沟通过程，来确定规划的沟通工件和沟通活动是否如预期提高或保持了相关方对项目可交付成果与预计结果的支持力度。项目沟通的影响和结果应该接受认真的评估和监督，以确保在正确的时间，通过正确的渠道，将正确的内容（发送方与接收方对其理解一致）传递给正确的受众。监督沟通可能需要采取各种方法，例如，开展客户满意度调查、整理经验教训、开展团队观察、审查问题日志中的数据，或评估相关方参与度评估矩阵中的变更。</p><p>监督沟通过程可能触发规划沟通管理和（或）管理沟通过程的迭代，以便修改沟通计划并开展额外的沟通活动，来提升沟通的效果。这种迭代体现了项目沟通管理各过程的持续性质。问题、关键绩效指标、风险或冲突，都可能立即触发重新开展这些过程。</p><h4 id="3-1-监督沟通：输入"><a href="#3-1-监督沟通：输入" class="headerlink" title="3.1 监督沟通：输入"></a>3.1 监督沟通：输入</h4><h5 id="3-1-1-项目管理计划"><a href="#3-1-1-项目管理计划" class="headerlink" title="3.1.1 项目管理计划"></a>3.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>资源管理计划。通过描述角色和职责，以及项目组织结构图，资源管理计划可用于理解实际的项目组织及其任何变更。</p></li><li><p>沟通管理计划。沟通管理计划是关于及时收集、生成和发布信息的现行计划，它确定了沟通过程中的团队成员、相关方和有关工作。</p></li><li><p>相关方参与计划。相关方参与计划确定了计划用以引导相关方参与的沟通策略。</p></li></ul><h5 id="3-1-2-项目文件"><a href="#3-1-2-项目文件" class="headerlink" title="3.1.2 项目文件"></a>3.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>问题日志。问题日志提供项目的历史信息、相关方参与问题的记录，以及它们如何得以解决。</p></li><li><p>经验教训登记册。在项目早期获取的经验教训可用于项目后期阶段，以改进沟通效果。</p></li><li><p>项目沟通记录。提供关于已开展的沟通的信息。</p></li></ul><h5 id="3-1-3-工作绩效数据"><a href="#3-1-3-工作绩效数据" class="headerlink" title="3.1.3 工作绩效数据"></a>3.1.3 工作绩效数据</h5><p>工作绩效数据包含关于实际已开展的沟通类型和数量的数据。</p><h5 id="3-1-4-事业环境因素"><a href="#3-1-4-事业环境因素" class="headerlink" title="3.1.4 事业环境因素"></a>3.1.4 事业环境因素</h5><p>能够影响监督沟通过程的事业环境因素包括（但不限于）：</p><ul><li><p>组织文化、政治氛围和治理框架；</p></li><li><p>已确立的沟通渠道、工具和系统；</p></li><li><p>全球、区域或当地的趋势、实践或习俗；</p></li><li><p>设施和资源的地理分布。</p></li></ul><h5 id="3-1-5-组织过程资产"><a href="#3-1-5-组织过程资产" class="headerlink" title="3.1.5 组织过程资产"></a>3.1.5 组织过程资产</h5><p>可能影响监督沟通过程的组织过程资产包括（但不限于）：</p><ul><li><p>企业的社交媒体、道德和安全政策及程序；</p></li><li><p>组织对沟通的要求；</p></li><li><p>制作、交换、储存和检索信息的标准化指南；</p></li><li><p>以往项目的历史信息和经验教训知识库；</p></li><li><p>以往项目的相关方及沟通数据和信息。</p></li></ul><h4 id="3-2-监督沟通：工具与技术"><a href="#3-2-监督沟通：工具与技术" class="headerlink" title="3.2 监督沟通：工具与技术"></a>3.2 监督沟通：工具与技术</h4><h5 id="3-2-1-专家判断"><a href="#3-2-1-专家判断" class="headerlink" title="3.2.1 专家判断"></a>3.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>与公众、社区和媒体的沟通，在国际环境中的沟通，以及虚拟小组之间的沟通；</p></li><li><p>沟通和项目管理系统。</p></li></ul><h5 id="3-2-2-项目管理信息系统（PMIS）"><a href="#3-2-2-项目管理信息系统（PMIS）" class="headerlink" title="3.2.2 项目管理信息系统（PMIS）"></a>3.2.2 项目管理信息系统（PMIS）</h5><p>项目管理信息系统为项目经理提供了一系列标准化工具，以根据沟通计划为内部和外部的相关方收集、储存和发布所需的信息。应监控该系统中的信息以评估其有效性和效果。</p><h5 id="3-2-3-数据表现"><a href="#3-2-3-数据表现" class="headerlink" title="3.2.3 数据表现"></a>3.2.3 数据表现</h5><p>适用的数据表现技术包括（但不限于）相关方参与度评估矩阵。它可以提供与沟通活动效果有关的信息。应该检查相关方的期望与当前参与度的变化情况，并对沟通进行必要调整。</p><h5 id="3-2-4-人际关系与团队技能"><a href="#3-2-4-人际关系与团队技能" class="headerlink" title="3.2.4 人际关系与团队技能"></a>3.2.4 人际关系与团队技能</h5><p>适用于本过程的人际关系与团队技能包括（但不限于）观察和交谈。与项目团队展开讨论和对话，有助于确定最合适的方法，用于更新和沟通项目绩效，以及回应相关方的信息请求。通过观察和交谈，项目经理能够发现团队内的问题、人员间的冲突，或个人绩效问题。</p><h5 id="3-2-5-会议"><a href="#3-2-5-会议" class="headerlink" title="3.2.5 会议"></a>3.2.5 会议</h5><p>面对面或虚拟会议适用于制定决策，回应相关方请求，与提供方、供应方及其他项目相关方讨论。</p><h4 id="3-3-监督沟通：输出"><a href="#3-3-监督沟通：输出" class="headerlink" title="3.3 监督沟通：输出"></a>3.3 监督沟通：输出</h4><h5 id="3-3-1-工作绩效信息"><a href="#3-3-1-工作绩效信息" class="headerlink" title="3.3.1 工作绩效信息"></a>3.3.1 工作绩效信息</h5><p>工作绩效信息包括与计划相比较的沟通的实际开展情况；它也包括对沟通的反馈，例如关于沟通效果的调查结果。</p><h5 id="3-3-2-变更请求"><a href="#3-3-2-变更请求" class="headerlink" title="3.3.2 变更请求"></a>3.3.2 变更请求</h5><p>监督沟通过程往往会导致需要对沟通管理计划所定义的沟通活动进行调整、采取行动和进行干预。变更请求需要通过实施整体变更控制过程进行处理。</p><p>此类变更请求可能导致：</p><ul><li><p>修正相关方的沟通要求，包括相关方对信息发布、内容或形式，以及发布方式的要求；</p></li><li><p>建立消除瓶颈的新程序。</p></li></ul><h5 id="3-3-3-项目管理计划更新"><a href="#3-3-3-项目管理计划更新" class="headerlink" title="3.3.3 项目管理计划更新"></a>3.3.3 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更的项目管理计划组件包括（但不限于）：</p><ul><li><p>沟通管理计划。需要更新沟通管理计划，记录能够让沟通更有效的新信息。</p></li><li><p>相关方参与计划。需要更新相关方参与计划，反映相关方的实际情况、沟通需求和重要性。</p></li></ul><h5 id="3-3-4-项目文件更新"><a href="#3-3-4-项目文件更新" class="headerlink" title="3.3.4 项目文件更新"></a>3.3.4 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>问题日志。可能需要更新问题日志，记录与出现的问题及其处理进展和解决办法相关的新信息。</p></li><li><p>经验教训登记册。可能需要更新经验教训登记册，记录问题的原因、所选纠正措施的理由，以及其他与沟通有关的经验教训。</p></li><li><p>相关方登记册。可能需要更新相关方登记册，加入修订的相关方沟通要求。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《PMBOK第六版》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目沟通管理包括开发工件，以及执行用于有效交换信息的各种活动，来确保项目及其相关方的信息需求得以满足的各个过程。项目沟通管理由两个部分组成：第一部分是制定策略，确保沟通对相关方行之有效；第二部分是执行必要活动，以落实沟通策略。&lt;/p&gt;
    
    </summary>
    
      <category term="PMP抄书系列" scheme="http://www.xiaoleon.cn/categories/PMP%E6%8A%84%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="pmp" scheme="http://www.xiaoleon.cn/tags/pmp/"/>
    
  </entry>
  
  <entry>
    <title>PMP(9) 项目资源管理</title>
    <link href="http://www.xiaoleon.cn/2019/02/28/pmp-9/"/>
    <id>http://www.xiaoleon.cn/2019/02/28/pmp-9/</id>
    <published>2019-02-28T13:44:52.000Z</published>
    <updated>2019-05-13T09:48:18.892Z</updated>
    
    <content type="html"><![CDATA[<p>项目资源管理包括识别、获取和管理所需资源以成功完成项目的各个过程，这些过程有助于确保项目经理和项目团队在正确的时间和地点使用正确的资源。</p><a id="more"></a><p>项目资源管理过程包括：</p><ul><li><p><strong>规划资源管理</strong> —— 定义如何估算、获取、管理和利用实物以及团队项目资源的过程。</p></li><li><p><strong>估算活动资源</strong> —— 估算执行项目所需的团队资源，以及材料、设备和用品的类型和数量的过程。</p></li><li><p><strong>获取资源</strong> —— 获取项目所需的团队成员、设施、设备、材料、用品和其他资源的过程。</p></li><li><p><strong>建设团队</strong> —— 提高工作能力，促进团队成员互动，改善团队整体氛围，以提高项目绩效的过程。</p></li><li><p><strong>管理团队</strong> —— 跟踪团队成员工作表现，提供反馈，解决问题并管理团队变更，以优化项目绩效的过程。</p></li><li><p><strong>控制资源</strong> —— 确保按计划为项目分配实物资源，以及根据资源使用计划监督资源实际使用情况，并采取必要纠正措施的过程。</p></li></ul><p>图9-1概括了项目资源管理的各个过程。虽然在本《PMBOK指南》中，各项目资源管理过程以界限分明和相互独立的形式出现，但在实践中它们会以本指南无法全面详述的方式相互交叠和相互作用。</p><p><img src="/images/pmp-9/9-1.png" alt="项目资源管理概述"></p><p>团队资源管理相对于实物资源管理，对项目经理提出了不同的技能和能力要求。实物资源包括设备、材料、设施和基础设施，而团队资源或人员指的是人力资源。项目团队成员可能具备不同的技能，可能是全职或兼职的，可能随项目进展而增加或减少。项目资源管理与项目相关方管理之间有重叠的部分，本节则重点关注组成项目团队的部分相关方。</p><p><strong>项目资源管理的核心概念</strong></p><p>项目团队由承担特定角色和职责的个人组成，他们为实现项目目标而共同努力。项目经理因此应在获取、管理、激励和增强项目团队方面投入适当的努力。尽管项目团队成员被分派了特定的角色和职责，但让他们全员参与项目规划和决策仍是有益的。团队成员参与规划阶段，既可使他们对项目规划工作贡献专业技能，又可以增强他们对项目的责任感。</p><p>项目经理既是项目团队的领导者又是项目团队的管理者。除了项目管理活动，例如启动、规划、执行、监控和关闭各个项目阶段，项目经理还负责建设高效的团队。项目经理应留意能够影响团队的不同因素，例如：</p><ul><li><p>团队环境；</p></li><li><p>团队成员的地理位置；</p></li><li><p>相关方之间的沟通；</p></li><li><p>组织变更管理；</p></li><li><p>内外部政治氛围；</p></li><li><p>文化问题和组织的独特性；</p></li><li><p>其他可能改变项目绩效的因素。</p></li></ul><p>作为领导者，项目经理还负责积极培养团队技能和能力，同时提高并保持团队的满意度和积极性，项目经理还应留意并支持职业与道德行为，确保所有团队成员都遵守这些行为。</p><p>实物资源管理着眼于以有效和高效的方式，分配和使用成功完成项目所需的实物资源，如材料、设备和用品。为此，组织应当拥有如下数据：（当前和合理的未来的）资源需求、（可以满足这些需求的）资源配置，以及资源供应。不能有效管理和控制资源是项目成功完成的风险来源。例如：</p><ul><li><p>未能确保关键设备或基础设施按时到位，可能会推迟最终产品的制造；</p></li><li><p>订购低质量材料可能会损害产品质量，导致大量召回或返工；</p></li><li><p>保存太多库存可能会导致高运营成本，使组织盈利下降；另一方面，如果库存量太低，就可能无法满足客户需求，同样会造成组织盈利下降。</p></li></ul><p><strong>项目资源管理的趋势和新兴实践</strong></p><p>项目管理风格正在从管理项目的命令和控制结构，转向更加协作和支持性的管理方法，通过将决策权分配给团队成员来提高团队能力。此外，现代的项目资源管理方法致力于寻求优化资源使用。有关项目资源管理的趋势和新兴实践包括（但不限于）：</p><ul><li><p>资源管理方法。过去几年，由于关键资源稀缺，在某些行业中出现了一些普遍的趋势，涌现出很多关于精益管理、准时制（JIT）生产、Kaizen（持续改善）、全员生产维护（TPM）、约束理论等方法的文献资料。项目经理应确定执行组织是否采用了一种或多种资源管理工具，从而对项目做出相应的调整。</p></li><li><p>情商（EI）。项目经理应提升内在（如自我管理和自我意识）和外在（如关系管理）能力，从而提高个人情商。研究表明，提高项目团队的情商或情绪能力可提高团队效率，还可以降低团队成员离职率。</p></li><li><p>自组织团队。随着敏捷方法在IT项目中的应用越来越普遍，自组织团队（无需集中管控运作）越来越多。对于拥有自组织团队的项目，“项目经理”（可能不称为“项目经理”）的角色主要是为团队创造环境、提供支持并信任团队可以完成工作。成功的自组织团队通常由通用的专才而不是主题专家组成，他们能够不断适应变化的环境并采纳建设性反馈。</p></li><li><p>虚拟团队/分布式团队。项目全球化推动了虚拟团队的需求的增长。这些团队成员致力于同一个项目，却分布在不同的地方。沟通技术（如电子邮件、电话会议、社交媒体、网络会议和视频会议等）的使用，使虚拟团队变得可行。虚拟团队管理有独特的优势，例如能够利用项目团队的专业技术，即使相应的专家不在同一地理区域；将在家办公的员工纳入团队；以及将行动不便者或残疾人纳入团队。而虚拟团队管理者面临的挑战主要在于沟通，包括可能产生孤立感、团队成员之间难以分享知识和经验、难以跟进进度和生产率，以及可能存在时区和文化差异。</p></li></ul><p><strong>裁剪考虑因素</strong></p><p>由于每个项目都是独特的，项目经理需要裁剪项目资源管理过程。裁剪时应考虑的因素包括（但不限于）：</p><ul><li><p>多元化。团队的多元化背景是什么？</p></li><li><p>物理位置。团队成员和实物资源的物理位置在哪里？</p></li><li><p>行业特定资源。所在行业需要哪些特殊资源？</p></li><li><p>团队成员的获得。如何获得项目团队成员？项目团队资源是全职还是兼职？</p></li><li><p>团队管理。如何管理项目团队建设？组织是否有管理团队建设的工具或是否需要创建新工具？是否存在有特殊需求的团队成员？是否需要为团队提供有关多元化管理的特别培训？</p></li><li><p>生命周期方法。项目采用哪些生命周期方法？</p></li></ul><p><strong>在敏捷或适应型环境中需要考虑的因素</strong></p><p>易变性高的项目得益于最大限度地集中和协作的团队结构，例如拥有通才的自组织团队。</p><p>协作旨在提高生产率和促进创新的问题解决方式。协作性团队可以促进不同工作活动的加速整合、改善沟通、增加知识分享，以及提供工作分配的灵活性和其他优势。</p><p>虽然协作的优势也适用于其他项目环境，协作型团队对于易变性高且快速变化的项目成功而言通常是至关重要的，因为集中分配任务和决策所需的时间更少。</p><p>对于易变性高的项目，实物和人力资源规划的可预测性要低得多。在这些环境中，关于快速供应和精益方法的协议，对控制成本和实现进度而言至关重要。</p><h3 id="一、规划资源管理"><a href="#一、规划资源管理" class="headerlink" title="一、规划资源管理"></a>一、规划资源管理</h3><p>规划资源管理是定义如何估算、获取、管理和利用团队以及实物资源的过程。本过程的主要作用是，根据项目类型和复杂程度确定适用于项目资源的管理方法和管理程度。本过程仅开展一次或仅在项目的预定义点开展。图9-2描述本过程的输入、工具与技术和输出。图9-3是本过程的数据流向图。</p><p><img src="/images/pmp-9/9-2.png" alt="规划资源管理：输入、工具与技术和输出"></p><p><img src="/images/pmp-9/9-3.png" alt="规划资源管理：数据流向图"></p><p>资源规划用于确定和识别一种方法，以确保项目的成功完成有足够的可用资源。项目资源可能包括团队成员、用品、材料、设备、服务和设施。有效的资源规划需要考虑稀缺资源的可用性和竞争，并编制相应的计划。</p><p>这些资源可以从组织内部资产获得，或者通过采购过程从组织外部获取。其他项目可能在同一时间和地点竞争项目所需的相同资源，从而对项目成本、进度、风险、质量和其他项目领域造成显著影响。</p><h4 id="1-1-规划资源管理：输入"><a href="#1-1-规划资源管理：输入" class="headerlink" title="1.1 规划资源管理：输入"></a>1.1 规划资源管理：输入</h4><h5 id="1-1-1-项目章程"><a href="#1-1-1-项目章程" class="headerlink" title="1.1.1 项目章程"></a>1.1.1 项目章程</h5><p>项目章程提供项目的高层级描述和要求，此外还包括可能影响项目资源管理的关键相关方名单、里程碑概况，以及预先批准的财务资源。</p><h5 id="1-1-2-项目管理计划"><a href="#1-1-2-项目管理计划" class="headerlink" title="1.1.2 项目管理计划"></a>1.1.2 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>质量管理计划。质量管理计划有助于定义项目所需的资源水平，以实现和维护已定义的质量水平并达到项目测量指标。</p></li><li><p>范围基准。范围基准识别了可交付成果，决定了需要管理的资源的类型和数量。</p></li></ul><h5 id="1-1-3-项目文件"><a href="#1-1-3-项目文件" class="headerlink" title="1.1.3 项目文件"></a>1.1.3 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>项目进度计划。项目进度计划提供了所需资源的时间轴。</p></li><li><p>需求文件。需求文件指出了项目所需的资源的类型和数量，并可能影响管理资源的方式。</p></li><li><p>风险登记册。风险登记册包含可能影响资源规划的各种威胁和机会的信息。</p></li><li><p>相关方登记册。相关方登记册有助于识别对项目所需资源有特别兴趣或影响的那些相关方，以及会影响资源使用偏好的相关方。</p></li></ul><h5 id="1-1-4-事业环境因素"><a href="#1-1-4-事业环境因素" class="headerlink" title="1.1.4 事业环境因素"></a>1.1.4 事业环境因素</h5><p>能够影响规划资源管理过程的事业环境因素包括（但不限于）：</p><ul><li><p>组织文化和结构；</p></li><li><p>设施和资源的地理分布；</p></li><li><p>现有资源的能力和可用性；</p></li><li><p>市场条件。</p></li></ul><h5 id="1-1-5-组织过程资产"><a href="#1-1-5-组织过程资产" class="headerlink" title="1.1.5 组织过程资产"></a>1.1.5 组织过程资产</h5><p>能够影响规划资源管理过程的组织过程资产包括（但不限于）：</p><ul><li><p>人力资源政策和程序；</p></li><li><p>物质资源管理政策和程序；</p></li><li><p>安全政策；</p></li><li><p>安保政策；</p></li><li><p>资源管理计划模板；</p></li><li><p>类似项目的历史信息。</p></li></ul><h4 id="1-2-规划资源管理：工具与技术"><a href="#1-2-规划资源管理：工具与技术" class="headerlink" title="1.2 规划资源管理：工具与技术"></a>1.2 规划资源管理：工具与技术</h4><h5 id="1-2-1-专家判断"><a href="#1-2-1-专家判断" class="headerlink" title="1.2.1 专家判断"></a>1.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>协调组织内部的最佳资源；</p></li><li><p>人才管理和员工发展；</p></li><li><p>确定为实现项目目标所需的初步投入水平；</p></li><li><p>根据组织文化确定报告要求；</p></li><li><p>根据经验教训和市场条件，评估获取资源所需的提前量；</p></li><li><p>识别与资源获取、留用和遣散计划有关的风险；</p></li><li><p>遵循适用的政府和工会法规；</p></li><li><p>管理卖方和物流工作，确保在需要时能够提供材料和用品。</p></li></ul><h5 id="1-2-2-数据表现"><a href="#1-2-2-数据表现" class="headerlink" title="1.2.2 数据表现"></a>1.2.2 数据表现</h5><p>适用于本过程的数据表现技术包括（但不限于）图表。数据表现有多种格式来记录和阐明团队成员的角色与职责。大多数格式属于层级型、矩阵型或文本型。有些项目人员安排可以在子计划（如风险、质量或沟通管理计划）中列出。无论使用什么方法来记录团队成员的角色，目的都是要确保每个工作包都有明确的责任人，确保全体团队成员都清楚地理解其角色和职责。层级型可用于表示高层级角色，而文本型则更适合用于记录详细职责。</p><ul><li><p>层级型。可以采用传统的组织结构图，自上而下地显示各种职位及其相互关系。</p><ul><li><p>工作分解结构（WBS）。WBS用来显示如何把项目可交付成果分解为工作包，有助于明确高层级的职责。</p></li><li><p>组织分解结构（OBS）。WBS显示项目可交付成果的分解，而OBS则按照组织现有的部门、单元或团队排列，并在每个部门下列出项目活动或工作包。运营部门（如信息技术部或采购部）只需要找到其所在的OBS部门，就能看到自己的全部项目职责。</p></li><li><p>资源分解结构。资源分解结构是按资源类别和类型，对团队和实物资源的层级列表，用于规划、管理和控制项目工作。每向下一个层次都代表对资源的更详细描述，直到信息细到可以与工作分解结构（WBS）相结合，用来规划和监控项目工作。</p></li></ul></li><li><p>责任分配矩阵。责任分配矩阵展示项目资源在各个工作包中的任务分配。矩阵型图表的一个例子是职责分配矩阵（RAM），它显示了分配给每个工作包的项目资源，用于说明工作包或活动与项目团队成员之间的关系。在大型项目中，可以制定多个层次的RAM。例如，高层次的RAM可定义项目团队、小组或部门负责WBS中的哪部分工作，而低层次的RAM则可在各小组内为具体活动分配角色、职责和职权。矩阵图能反映与每个人相关的所有活动，以及与每项活动相关的所有人员，它也可确保任何一项任务都只有一个人负责，从而避免职权不清。RAM的一个例子是RACI（执行、负责、咨询和知情）矩阵，如图9-4所示。图中最左边的一列表示有待完成的工作（活动）。分配给每项工作的资源可以是个人或小组，项目经理也可根据项目需要，选择“领导”或“资源”等适用词汇，来分配项目责任。如果团队是由内部和外部人员组成，RACI矩阵对明确划分角色和职责特别有用。</p></li><li><p>文本型。如果需要详细描述团队成员的职责，就可以采用文本型。文本型文件通常以概述的形式，提供诸如职责、职权、能力和资格等方面的信息。这种文件有多种名称，如职位描述、角色——职责——职权表，该文件可作为未来项目的模板，特别是在根据当前项目的经验教训对其内容进行更新之后。</p></li></ul><p><img src="/images/pmp-9/9-4.png" alt="RACI矩阵示例"></p><h5 id="1-2-3-组织理论"><a href="#1-2-3-组织理论" class="headerlink" title="1.2.3 组织理论"></a>1.2.3 组织理论</h5><p>组织理论阐述个人、团队和组织部门的行为方式。有效利用组织理论中的常用技术，可以节约规划资源管理过程的时间、成本及人力投入，提高规划工作的效率。此外，可以根据相关的组织理论灵活使用领导风格，以适应项目生命周期中团队成熟度的变化。重要的是要认识到，组织的结构和文化影响项目组织结构。</p><h5 id="1-2-4-会议"><a href="#1-2-4-会议" class="headerlink" title="1.2.4 会议"></a>1.2.4 会议</h5><p>项目团队可召开会议来规划项目资源管理。</p><h4 id="1-3-规划资源管理：输出"><a href="#1-3-规划资源管理：输出" class="headerlink" title="1.3 规划资源管理：输出"></a>1.3 规划资源管理：输出</h4><h5 id="1-3-1-资源管理计划"><a href="#1-3-1-资源管理计划" class="headerlink" title="1.3.1 资源管理计划"></a>1.3.1 资源管理计划</h5><p>作为项目管理计划的一部分，资源管理计划提供了关于如何分类、分配、管理和释放项目资源的指南。资源管理计划可以根据项目的具体情况分为团队管理计划和实物资源管理计划。资源管理计划可能包括（但不限于）：</p><ul><li><p>识别资源。用于识别和量化项目所需的团队和实物资源的方法。</p></li><li><p>获取资源。关于如何获取项目所需的团队和实物资源的指南。</p></li><li><p>角色与职责。</p><ul><li><p>角色。在项目中，某人承担的职务或分配给某人的职务，如土木工程师、商业分析师和测试协调员。</p></li><li><p>职权。使用项目资源、做出决策、签字批准、验收可交付成果并影响他人开展项目工作的权力。例如，下列事项都需要由具有明确职权的人来做决策：选择活动的实施方法，质量验收标准，以及如何应对项目偏差等。当个人的职权水平与职责相匹配时，团队成员就能最好地开展工作。</p></li><li><p>职责。为完成项目活动，项目团队成员必须履行的职责和工作。</p></li><li><p>能力。为完成项目活动，项目团队成员需具备的技能和才干。如果项目团队成员不具备所需的能力，就不能有效地履行职责。一旦发现成员的能力与职责不匹配，就应主动采取措施，如安排培训、招募新成员、调整进度计划或工作范围。</p></li></ul></li><li><p>项目组织图。项目组织图以图形方式展示项目团队成员及其报告关系。基于项目的需要，项目组织图可以是正式或非正式的，非常详细或高度概括的。例如，一个3000人的灾害应急团队的项目组织图，要比仅有20人的内部项目的组织图详尽得多。</p></li><li><p>项目团队资源管理。关于如何定义、配备、管理和最终遣散项目团队资源的指南。</p></li><li><p>培训。针对项目成员的培训策略。</p></li><li><p>团队建设。建设项目团队的方法。</p></li><li><p>资源控制。依据需要确保实物资源充足可用、并为项目需求优化实物资源采购，而采用的方法。包括有关整个项目生命周期期间的库存、设备和用品管理的信息。</p></li><li><p>认可计划。将给予团队成员哪些认可和奖励，以及何时给予。</p></li></ul><h5 id="1-3-2-团队章程"><a href="#1-3-2-团队章程" class="headerlink" title="1.3.2 团队章程"></a>1.3.2 团队章程</h5><p>团队章程是为团队创建团队价值观、共识和工作指南的文件。团队章程可能包括（但不限于）：</p><ul><li><p>团队价值观；</p></li><li><p>沟通指南；</p></li><li><p>决策标准和过程；</p></li><li><p>冲突处理过程；</p></li><li><p>会议指南；</p></li><li><p>团队共识。</p></li></ul><p>团队章程对项目团队成员的可接受行为确定了明确的期望。尽早认可并遵守明确的规则，有助于减少误解，提高生产力；讨论诸如行为规划、沟通、决策、会议礼仪等领域，团队成员可以了解彼此重要的价值观。由团队制定或参与制定的团队章程可发挥最佳效果。所有项目团队成员都分担责任，确保遵守团队章程中规定的规则。可定期审查和更新团队章程，确保团队始终了解团队基本规则，并指导新成员融入团队。</p><h5 id="1-3-3-项目文件更新"><a href="#1-3-3-项目文件更新" class="headerlink" title="1.3.3 项目文件更新"></a>1.3.3 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>假设日志。更新假设日志时可增加关于实物资源的可用性、物流要求和位置信息以及团队资源的技能集和可用性的假设条件。</p></li><li><p>风险登记册。关于团队和实物资源可用性的风险，以及其他已知资源的相关风险，更新在风险登记册中。</p></li></ul><hr><h3 id="二、估算活动资源"><a href="#二、估算活动资源" class="headerlink" title="二、估算活动资源"></a>二、估算活动资源</h3><p>估算活动资源是估算执行项目所需的团队资源，以及材料、设备和用品的类型和数量的过程。本过程的主要作用是，明确完成项目所需的资源种类、数量和特性。本过程应根据需要在整个项目期间定期开展。图9-5描述本过程的输入、工具与技术和输出，图9-6描述是本过程的数据流向图。</p><p><img src="/images/pmp-9/9-5.png" alt="估算活动资源：输入、工具与技术和输出"></p><p><img src="/images/pmp-9/9-6.png" alt="估算活动资源：数据流向图"></p><p>估算活动资源过程与其他过程紧密相关，例如估算成本过程。例如：</p><ul><li><p>建筑项目团队需要熟悉当地建筑法规。这类知识可从当地卖方获取，但是，如果内部劳动力资源对不常用或专门的建筑技术缺乏经验，那么支付额外费用聘请咨询专家，可能就是了解当地建筑法规的最有效的方法。</p></li><li><p>汽车设计团队需要熟悉最新的自动装配技术。这些必要的知识可以通过聘请顾问、派设计人员参加机器人技术研讨会，或者邀请制造人员加入项目团队等方式来获取。</p></li></ul><h4 id="2-1-估算活动资源：输入"><a href="#2-1-估算活动资源：输入" class="headerlink" title="2.1 估算活动资源：输入"></a>2.1 估算活动资源：输入</h4><h5 id="2-1-1-项目管理计划"><a href="#2-1-1-项目管理计划" class="headerlink" title="2.1.1 项目管理计划"></a>2.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>资源管理计划。资源管理计划定义了识别项目所需不同资源的方法，还定义了量化各个活动所需的资源并整合这些信息的方法。</p></li><li><p>范围基准。范围基准识别了实现项目目标所需的项目和产品范围，而范围决定了对团队和实物资源的需求。</p></li></ul><h5 id="2-1-2-项目文件"><a href="#2-1-2-项目文件" class="headerlink" title="2.1.2 项目文件"></a>2.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>活动属性。活动属性为估算活动清单中每项活动所需的团队和实物资源提供了主要数据来源，这些属性的例子包括资源需求、强制日期、活动地点、假设条件和制约因素。</p></li><li><p>活动清单。活动清单识别了需要资源的活动。</p></li><li><p>假设日志。假设日志可能包含有关生产力因素、可用性、成本估算以及工作方法的信息，这些因素会影响团队和实物资源的性质和数量。</p></li><li><p>成本估算。资源成本从数量和技能水平方面会影响资源选择。</p></li><li><p>资源日历。资源日历识别了每种具体资源可用时的工作日、班次、正常营业的上下班时间、周末和公共假期。在规划活动期间，潜在的可用资源信息（如团队资源、设备和材料）用于估算资源可用性。资源日历还规定了在项目期间确定的团队和实物资源何时可用、可用多久。这些信息可以在活动或项目层面建立，这考虑了诸如资源经验和（或）技能水平以及不同地理位置等属性。</p></li><li><p>风险登记册。风险登记册描述了可能影响资源选择和可用性的各个风险。</p></li></ul><h5 id="2-1-3-事业环境因素"><a href="#2-1-3-事业环境因素" class="headerlink" title="2.1.3 事业环境因素"></a>2.1.3 事业环境因素</h5><p>能够影响估算活动资源过程的事业环境因素包括（但不限于）：</p><ul><li><p>资源的位置；</p></li><li><p>资源可用性；</p></li><li><p>团队资源的技能；</p></li><li><p>组织文化；</p></li><li><p>发布的估算数据；</p></li><li><p>市场条件。</p></li></ul><h5 id="2-1-4-组织过程资产"><a href="#2-1-4-组织过程资产" class="headerlink" title="2.1.4 组织过程资产"></a>2.1.4 组织过程资产</h5><p>能够影响估算活动资源过程的组织过程资产包括（但不限于）：</p><ul><li><p>关于人员配备的政策和程序；</p></li><li><p>关于用品和设备的政策与程序；</p></li><li><p>关于以往项目中类似工作所使用的资源类型的历史信息。</p></li></ul><h4 id="2-2-估算活动资源：工具与技术"><a href="#2-2-估算活动资源：工具与技术" class="headerlink" title="2.2 估算活动资源：工具与技术"></a>2.2 估算活动资源：工具与技术</h4><h5 id="2-2-1-专家判断"><a href="#2-2-1-专家判断" class="headerlink" title="2.2.1 专家判断"></a>2.2.1 专家判断</h5><p>应征求具备团队和物质资源的规划和估算方面的专业知识或接受过相关培训的个人或小组的意见。</p><h5 id="2-2-2-自下而上估算"><a href="#2-2-2-自下而上估算" class="headerlink" title="2.2.2 自下而上估算"></a>2.2.2 自下而上估算</h5><p>团队和实物资源在活动级别上估算，然后汇总成工作包、控制账户和总体项目层级上的估算。</p><h5 id="2-2-3-类比估算"><a href="#2-2-3-类比估算" class="headerlink" title="2.2.3 类比估算"></a>2.2.3 类比估算</h5><p>类比估算将以往类似项目的资源相关信息作为估算未来项目的基础。这是一种快速估算方法，适用于项目经理只能识别WBS的几个高层级的情况下。</p><h5 id="2-2-4-参数估算"><a href="#2-2-4-参数估算" class="headerlink" title="2.2.4 参数估算"></a>2.2.4 参数估算</h5><p>参数估算基于历史数据和项目参数，使用某种算法或历史数据与其他变量之间的统计关系，来计算活动所需的资源数量。例如，如果一项活动需要4000个小时的编码时间，而且需要在1年之内完成，则需要两个人来编码（每人每年付出2000小时）。参数估算的准确性取决于参数模型的成熟度和基础数据的可靠性。</p><h5 id="2-2-5-数据分析"><a href="#2-2-5-数据分析" class="headerlink" title="2.2.5 数据分析"></a>2.2.5 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）备选方案分析。备选方案分析是一种对已识别的可选方案进行评估的技术，用来决定选择哪种方案或使用何种方法来执行项目工作。很多活动有多个备选的实施方案，例如使用能力或技能水平不同的资源、不同规模或类型的机器、不同的工具（手工或自动），以及关于资源自制、租赁或购买的决策。备选方案分析有助于提供在定义的制约因素范围内执行项目活动的最佳方案。</p><h5 id="2-2-6-项目管理信息系统（PMIS）"><a href="#2-2-6-项目管理信息系统（PMIS）" class="headerlink" title="2.2.6 项目管理信息系统（PMIS）"></a>2.2.6 项目管理信息系统（PMIS）</h5><p>项目管理信息系统可以包括资源管理软件，这些软件有助于规划、组织与管理资源库，以及编制资源估算。根据软件的复杂程度，可以确定资源分解结构、资源可用性、资源费率和各种资源日历，有助于优化资源使用。</p><h5 id="2-2-7-会议"><a href="#2-2-7-会议" class="headerlink" title="2.2.7 会议"></a>2.2.7 会议</h5><p>项目经理可以和职能经理一起举行规划会议，以估算每项活动所需的资源、支持型活动（LoE）、团队资源的技能水平，以及所需材料的数量。参会者可能包括项目经理、项目发起人、选定的项目团队成员、选定的相关方，以及其他必要人员。</p><h4 id="2-3-估算活动资源：输出"><a href="#2-3-估算活动资源：输出" class="headerlink" title="2.3 估算活动资源：输出"></a>2.3 估算活动资源：输出</h4><h5 id="2-3-1-资源需求"><a href="#2-3-1-资源需求" class="headerlink" title="2.3.1 资源需求"></a>2.3.1 资源需求</h5><p>资源需求识别了各个工作包或工作包中每个活动所需的资源类型和数量，可以汇总这些需求，以估算每个工作包、每个WBS分支以及整个项目所需的资源。资源需求描述的细节数量与具体程度因应用领域而异，而资源需求文件也可包含为确定所用资源的类型、可用性和所需数量所做的假设。</p><h5 id="2-3-2-估算依据"><a href="#2-3-2-估算依据" class="headerlink" title="2.3.2 估算依据"></a>2.3.2 估算依据</h5><p>资源估算所需的支持信息的数量和种类，因应用领域而异。但不论其详细程度如何，支持性文件都应该清晰完整地说明资源估算是如何得出的。</p><p>资源估算的支持信息可包括：</p><ul><li><p>估算方法；</p></li><li><p>用于估算的资源，如以往类似项目的信息；</p></li><li><p>与估算有关的假设条件；</p></li><li><p>已知的制约因素；</p></li><li><p>估算范围；</p></li><li><p>估算的置信水平；</p></li><li><p>有关影响估算的已识别风险的文件。</p></li></ul><h5 id="2-3-3-资源分解结构"><a href="#2-3-3-资源分解结构" class="headerlink" title="2.3.3 资源分解结构"></a>2.3.3 资源分解结构</h5><p>资源分解结构是资源易类别和类型的层级展现（见图9-7）。资源类别包括（但不限于）人力、材料、设备和用品，资源类型则包括技能水平、要求证书、等级水平或适用于项目的其他类型。在规划资源管理过程中，资源分解结构用于指导项目的分类活动。在这一过程中，资源分解结构是一份完整的文件，用于获取和监督资源。</p><p><img src="/images/pmp-9/9-7.png" alt="资源分解结构示例"></p><h5 id="2-3-4-项目文件更新"><a href="#2-3-4-项目文件更新" class="headerlink" title="2.3.4 项目文件更新"></a>2.3.4 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>活动属性。活动属性依据资源需求而更新。</p></li><li><p>假设日志。关于项目所需资源的类型和数量的假设条件，更新在假设日志中。此外，任何资源制约因素，包括集体劳资协议、连续工作时间、计划休假等，也应当相应更新。</p></li><li><p>经验教训登记册。能够有效和高效地估算资源的技术，以及有关那些无效或低效的技术信息，更新在经验教训登记册中。</p></li></ul><hr><h3 id="三、获取资源"><a href="#三、获取资源" class="headerlink" title="三、获取资源"></a>三、获取资源</h3><p>获取资源是获取项目所需的团队成员、设施、设备、材料、用品和其他资源的过程。本过程的主要作用是，概述和指导资源的选择，并将其分配给相应的活动。本过程应根据需要在整个项目期间定期开展。图9-8描述本过程的输入、工具与技术和输出。图9-9是本过程的数据流向图。</p><p><img src="/images/pmp-9/9-8.png" alt="获取资源：输入、工具与技术和输出"></p><p><img src="/images/pmp-9/9-9.png" alt="获取资源：数据流向图"></p><p>项目所需资源可能来自项目执行组织的内部或外部。内部资源由职能经理或资源经理负责获取（分配），外部资源则是通过采购过程获得。</p><p>因为集体劳资协议、分包商人员使用、矩阵型项目环境、内外部报告关系或其他原因，项目管理团队可能不对资源选择有直接控制权。重要的是，在获取项目资源过程中应注意下列事项：</p><ul><li><p>项目经理或项目团队应该进行有效谈判，并影响那些能为项目提供所需团队和实物资源的人员。</p></li><li><p>不能获得项目所需的资源时，可能会影响项目进度、预算、客户满意度、质量和风险；资源或人员能力不足会降低项目成功的概率，最坏的情况可能导致项目取消。</p></li><li><p>如因制约因素（如经济因素或其他项目对资源的占用）而无法获得所需团队资源，项目经理或项目团队可能不得不使用也许能力和成本不同的替代资源。在不违反法律、规章、强制性规定或其他具体标准的前提下可以使用替代资源。</p></li></ul><p>在项目规划阶段，应该对上述因素加以考虑并做出适当安排。项目经理或项目管理团队应该在项目进度计划、项目预算、项目风险计划、项目质量计划、培训计划及其他相关项目管理计划中，说明缺少所需资源的后果。</p><h4 id="3-1-获取资源：输入"><a href="#3-1-获取资源：输入" class="headerlink" title="3.1 获取资源：输入"></a>3.1 获取资源：输入</h4><h5 id="3-1-1-项目管理计划"><a href="#3-1-1-项目管理计划" class="headerlink" title="3.1.1 项目管理计划"></a>3.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>资源管理计划。资源管理计划为如何获取项目资源提供指南。</p></li><li><p>采购管理计划。采购管理计划提供了关于将从项目外部获取的资源的信息，包括如何将采购与其他项目工作整合起来以及涉及资源采购工作的相关方。</p></li><li><p>成本基准。成本基准提供了项目活动的总体预算。</p></li></ul><h5 id="3-1-2-项目文件"><a href="#3-1-2-项目文件" class="headerlink" title="3.1.2 项目文件"></a>3.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>项目进度计划。项目进度计划展示了各项活动及其开始和结束日期，有助于确定需要提供和获取资源的时间。</p></li><li><p>资源日历。资源日历记录了每个项目资源在项目中的可用时间段。编制出可靠地进度计划，应依据对各个资源的可用性和时间限制（包括时区、工作时间、休假时间、当地节假日、维护计划和在其他项目的工作时间）的良好了解。资源日历需要在整个项目过程中渐进明细和更新。资源日历是本过程的输出，在重复本过程时随时可用。</p></li><li><p>资源需求。资源需求识别了需要获取的资源。</p></li><li><p>相关方登记册。相关方登记册可能会发现相关方对项目特定资源的需求或期望，在获取资源过程中应加以考虑。</p></li></ul><h5 id="3-1-3-事业环境因素"><a href="#3-1-3-事业环境因素" class="headerlink" title="3.1.3 事业环境因素"></a>3.1.3 事业环境因素</h5><p>能够影响获取资源过程的事业环境因素包括（但不限于）：</p><ul><li><p>现有组织资源信息，包括可用性、能力水平、以及有关团队资源和资源成本的以往经验；</p></li><li><p>市场条件；</p></li><li><p>组织结构；</p></li><li><p>地理位置。</p></li></ul><h5 id="3-1-4-组织过程资产"><a href="#3-1-4-组织过程资产" class="headerlink" title="3.1.4 组织过程资产"></a>3.1.4 组织过程资产</h5><p>能够影响获取资源过程的组织过程资产包括（但不限于）：</p><ul><li><p>有关项目资源的采购、配置和分配的政策和程序；</p></li><li><p>历史信息和经验教训知识库。</p></li></ul><h4 id="3-2-获取资源：工具与技术"><a href="#3-2-获取资源：工具与技术" class="headerlink" title="3.2 获取资源：工具与技术"></a>3.2 获取资源：工具与技术</h4><h5 id="3-2-1-决策"><a href="#3-2-1-决策" class="headerlink" title="3.2.1 决策"></a>3.2.1 决策</h5><p>适用于获取资源过程的决策技术包括（但不限于）多标准决策分析。选择标准常用于选择项目的实物资源或项目团队。使用多标准决策分析工具制定出标准，用于对潜在资源进行评级或打分（例如，在内部和外部团队资源之间进行选择）。根据标准的相对重要性对标准进行加权，加权值可能因资源类型的不同而发生变化。可使用的选择标准包括：</p><ul><li><p>可用性。确认资源能够在项目所需时段内为项目所用。</p></li><li><p>成本。确认增加资源的成本是否在规定的预算内。</p></li><li><p>能力。确认团队成员是否提供了项目所需的能力。</p></li></ul><p>有些选择标准对团队资源来说是独特的，包括：</p><ul><li><p>经验。确认团队成员具备项目成功所需的相关经验。</p></li><li><p>知识。团队成员是否掌握关于客户、执行过的类似项目和项目环境细节的相关知识。</p></li><li><p>技能。确认团队成员拥有使用项目工具的相关技能。</p></li><li><p>态度。团队成员能否与他人协同工作，以形成有凝聚力的团队。</p></li><li><p>国际因素。团队成员的位置、时区和沟通能力。</p></li></ul><h5 id="3-2-2-人际关系与团队技能"><a href="#3-2-2-人际关系与团队技能" class="headerlink" title="3.2.2 人际关系与团队技能"></a>3.2.2 人际关系与团队技能</h5><p>适用于本过程的人际关系与团队技能包括（但不限于）谈判。很多项目需要针对所需资源进行谈判，项目管理团队需要与下列各方谈判：</p><ul><li><p>职能经理。确保项目在要求的时限内获得最佳资源，直到完成职责。</p></li><li><p>执行组织中的其他项目管理团队。合理分配稀缺或特殊资源。</p></li><li><p>外部组织和供应商。提供合适的、稀缺的、特殊的、合格的、经认证的或其他特殊的团队或实物资源。特别需要注意与外部谈判有关的政策、惯例、流程、指南、法律及其他标准。</p></li></ul><p>在资源分配谈判中，项目管理团队影响他人的能力很重要，如同在组织中的政治能力一样重要。例如，说服职能经理，让他/她看到项目具有良好的前景，会影响他/她把最佳资源分配给这个项目而不是竞争项目。</p><h5 id="3-2-3-预分派"><a href="#3-2-3-预分派" class="headerlink" title="3.2.3 预分派"></a>3.2.3 预分派</h5><p>预分派指事先确定项目的实物或团队资源，可在下列情况下发生：在竞标过程中承诺分派特定人员进行项目工作；项目取决于特定人员的专有技能；在完成资源管理计划的前期工作之前，制定项目章程过程或其他过程已经指定了某些团队成员的工作分派。</p><h5 id="3-2-4-虚拟团队"><a href="#3-2-4-虚拟团队" class="headerlink" title="3.2.4 虚拟团队"></a>3.2.4 虚拟团队</h5><p>虚拟团队的使用为招募团队成员提供了新的可能性。虚拟团队可定义为具有共同目标、在完成角色任务的过程中很少或没有时间面对面的一群人。现代沟通技术（如电子邮件、电话会议、社交媒体、网络会议和视频会议等）使虚拟团队成为可行。虚拟团队模式使人们有可能：</p><ul><li><p>在组织内部地处不同地理位置的员工之间组建团队；</p></li><li><p>为项目团队增加特殊技能，即使相应的专家不在同一地理区域；</p></li><li><p>将在办公的员工纳入团队；</p></li><li><p>在工作班次、工作小时或工作日不同的员工之间组建团队；</p></li><li><p>将行动不便者或残疾人纳入团队；</p></li><li><p>执行那些原本会因差旅费用过高而被搁置或取消的项目；</p></li><li><p>节省员工所需的办公室和所有实物设备的开支。</p></li></ul><p>在虚拟团队的环境中，沟通规划变得日益重要。可能需要花更多时间，来设定明确的期望、促进沟通、制定冲突解决方法、召集人员参与决策、理解文化差异，以及共享成功喜悦。</p><h4 id="3-3-获取资源：输出"><a href="#3-3-获取资源：输出" class="headerlink" title="3.3 获取资源：输出"></a>3.3 获取资源：输出</h4><h5 id="3-3-1-实物资源分配单"><a href="#3-3-1-实物资源分配单" class="headerlink" title="3.3.1 实物资源分配单"></a>3.3.1 实物资源分配单</h5><p>实物资源分配单记录了项目将使用的材料、设备、用品、地点和其他实物资源。</p><h5 id="3-3-2-项目团队派工单"><a href="#3-3-2-项目团队派工单" class="headerlink" title="3.3.2 项目团队派工单"></a>3.3.2 项目团队派工单</h5><p>项目团队派工单记录了团队成员及其在项目中的角色和职责，可包括项目团队名录，还需要把人员姓名插入项目管理计划的其它部分，如项目组织图和进度计划。</p><h5 id="3-3-3-资源日历"><a href="#3-3-3-资源日历" class="headerlink" title="3.3.3 资源日历"></a>3.3.3 资源日历</h5><p>资源日历识别了每种具体资源可用时的工作日、班次、正常营业的上下班时间、周末和公共假期。在规划活动期间，潜在的可用资源信息（如团队资源、设备和材料）用于估算资源可用性。资源日历规定了在项目期间确定的团队和实物资源何时可用、可用多久。这些信息可以在活动或项目层面建立，这考虑了诸如资源经验和（或）技能水平以及不同地理位置等属性。</p><h5 id="3-3-4-变更请求"><a href="#3-3-4-变更请求" class="headerlink" title="3.3.4 变更请求"></a>3.3.4 变更请求</h5><p>如果获取资源过程中出现变更请求（例如影响了进度），或者推荐措施、纠正措施或预防措施影响了项目管理计划的任何组成部分或项目文件，项目经理应提交变更请求，且应该通过实施整体变更控制过程对变更请求进行审查和处理。</p><h5 id="3-3-5-项目管理计划更新"><a href="#3-3-5-项目管理计划更新" class="headerlink" title="3.3.5 项目管理计划更新"></a>3.3.5 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。开展本过程可能导致项目管理计划更新的内容包括（但不限于）：</p><ul><li><p>资源管理计划。更新资源管理计划，以反映获取项目资源的实际经验，包括在项目早期获取资源的经验教训，这些经验会影响项目后期的资源获取过程。</p></li><li><p>成本基准。在项目资源采购期间，成本基准可能发生变更。</p></li></ul><h5 id="3-3-6-项目文件更新"><a href="#3-3-6-项目文件更新" class="headerlink" title="3.3.6 项目文件更新"></a>3.3.6 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。项目中遇到的挑战、本可以规避这些条件的方法，以及良好的资源获取方式更新在经验教训登记册中。</p></li><li><p>项目进度计划。所需资源的可用性可能会导致项目进度的变更。</p></li><li><p>资源分解结构。在本过程中获取的资源应记录到资源分解结构中。</p></li><li><p>资源需求。可更新资源需求文件，以反映获取的项目资源。</p></li><li><p>风险登记册。本过程中识别的新风险记录在风险登记册中，并通过风险管理过程进行管理。</p></li><li><p>相关方登记册。增加的任何新的相关方，以及在本过程中获得的有关现有相关方的新信息更新在相关方登记册中。</p></li></ul><h5 id="3-3-7-事业环境因素更新"><a href="#3-3-7-事业环境因素更新" class="headerlink" title="3.3.7 事业环境因素更新"></a>3.3.7 事业环境因素更新</h5><p>需要更新的事业环境因素包括（但不限于）：</p><ul><li><p>组织内资源的可用性；</p></li><li><p>组织已使用的消耗资源的数量。</p></li></ul><h5 id="3-3-8-组织过程资产更新"><a href="#3-3-8-组织过程资产更新" class="headerlink" title="3.3.8 组织过程资产更新"></a>3.3.8 组织过程资产更新</h5><p>作为获取资源过程的结果，需要更新的组织过程资产包括（但不限于）有关采购、配置和分配资源的文件。</p><hr><h3 id="四、建设团队"><a href="#四、建设团队" class="headerlink" title="四、建设团队"></a>四、建设团队</h3><p>建设团队是提高工作能力，促进团队成员互动，改善团队整体氛围，以提高项目绩效的过程。本过程的主要作用是，改进团队协作、增强人际关系技能、激励员工、减少摩擦以及提升整体项目绩效。本过程需要在整个项目期间开展。</p><p>图9-10描述本过程的输入、工具与技术和输出。图9-11是本过程的数据流向图。</p><p><img src="/images/pmp-9/9-10.png" alt="建设团队：输入、工具与技术和输出"></p><p><img src="/images/pmp-9/9-11.png" alt="建设团队：数据流向图"></p><p>项目经理应该能够定义、建立、维护、激励、领导和鼓舞项目团队，使团队高效运行，并实现项目目标。团队协作是项目成功的关键因素，而建设高效的项目团队是项目经理的主要职责之一。项目经理应创建一个能促进团队协作的环境，并通过给予挑战和机会、提供及时反馈与所需支持，以及认可与奖励优秀绩效，不断激励团队。通过以下行为可以实现团队的高效运行。</p><ul><li><p>使用开放与有效的沟通；</p></li><li><p>创造团队建设机遇；</p></li><li><p>建立团队成员间的信任；</p></li><li><p>以建设性方式管理冲突；</p></li><li><p>鼓励合作型的问题解决方法；</p></li><li><p>鼓励合作型的决策方法。</p></li></ul><p>项目经理在全球化环境和富有文化多样性的项目中工作：团队成员经常来自不同的行业，将不同的语言，有时甚至会在工作中使用一种特别的“团队语言”或文化规范，而不是使用他们的母语；项目管理团队应该利用文化差异，在整个项目生命周期中致力于发展和维护项目团队，并促进在相互信任的氛围中充分协作；通过建设项目团队，可以改进人机技巧、技术能力、团队环境及项目绩效。在整个项目生命周期中，团队成员之间都要确保明确、及时、有效（包括效果和效率两个方面）的沟通。建设项目团队的目标包括（但不限于）：</p><ul><li><p>提高团队成员的知识和技能，以提高他们完成项目可交付成果的能力，并降低成本、缩短工期和提高质量；</p></li><li><p>提高团队成员之间的信任和认同感，以提高士气、减少冲突和增进团队协作；</p></li><li><p>创建富有生气、凝聚力和协作性的团队文化，从而：1）提高个人和团队生产率，振奋团队精神，促进团队合作；2）促进团队成员之间的交叉培训和辅导，以分享知识和经验；</p></li><li><p>提高团队参与决策的能力，使他们承担起对解决方案的责任，从而提高团队的生产效率，获得更有效和高效的成果。</p></li></ul><p>有一种关于团队发展的模型叫塔克曼阶梯理论，其中包括团队建设通常要经过的五个阶段。尽管这些阶段通常按顺序进行，然而，团队停滞在某个阶段或退回到较早阶段的情况也并非罕见；而如果团队成员曾经共事过，项目团队建设也可跳过某个阶段。</p><ul><li><p>形成阶段。在本阶段，团队成员相互认识，并了解项目情况及他们在项目中的正式角色与职责。在这一阶段，团队成员倾向于相互独立，不一定开诚布公。</p></li><li><p>震荡阶段。在本阶段，团队开始从事项目工作、制定技术决策和讨论项目管理方法。如果团队成员不能用合作和开放的态度对待不同观点和意见，团队环境可能变得事与愿违。</p></li><li><p>规范阶段。在规范阶段，团队成员开始协同工作，并调整各自的工作习惯和行为来支持团队，团队成员会学习相互信任。</p></li><li><p>成熟阶段。进入这一阶段后，团队就像一个组织有序的单位那样工作，团队成员之间相互依靠，平稳高效地解决问题。</p></li><li><p>解散阶段。在解散阶段，团队完成所有工作，团队成员离开项目。通常在项目可交付成果完成之后，或者，在结束项目或阶段过程中，释放人员，解散团队。</p></li></ul><p>某个阶段持续时间的长短，取决于团队活力、团队规模和团队领导力。项目经理应该对团队活力有较好的理解，以便有效地带领团队经历所有阶段。</p><h4 id="4-1-建设团队：输入"><a href="#4-1-建设团队：输入" class="headerlink" title="4.1 建设团队：输入"></a>4.1 建设团队：输入</h4><h5 id="4-1-1-项目管理计划"><a href="#4-1-1-项目管理计划" class="headerlink" title="4.1.1 项目管理计划"></a>4.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）资源管理计划。资源管理计划为如何通过团队绩效评价和其他形式的团队管理活动，为项目团队成员提供奖励、提出反馈、增加培训或采取惩罚措施提供了指南。资源管理计划可能包括团队绩效评价标准。</p><h5 id="4-1-2-项目文件"><a href="#4-1-2-项目文件" class="headerlink" title="4.1.2 项目文件"></a>4.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。项目早期与团队建设有关的经验教训可以运用到项目后期阶段，以提高团队绩效。</p></li><li><p>项目进度计划。项目进度计划定义了如何以及何时为项目团队提供培训，以培养不同阶段所需的能力，并根据项目执行期间的任何差异（如有）识别需要的团队建设策略。</p></li><li><p>项目团队派工单。项目团队派工单识别了团队成员的角色与职责。</p></li><li><p>资源日历。资源日历定义了项目团队成员何时能参与团队建设活动，有助于说明团队在整个项目期间的可用性。</p></li><li><p>团队章程。团队章程包含团队工作指南。团队价值观和工作指南为描述团队的合作方式提供了架构。</p></li></ul><h5 id="4-1-3-事业环境因素"><a href="#4-1-3-事业环境因素" class="headerlink" title="4.1.3 事业环境因素"></a>4.1.3 事业环境因素</h5><p>能够影响建设团队过程的事业环境因素包括（但不限于）：</p><ul><li><p>有关雇佣和解雇的人力资源管理政策、员工绩效审查、员工发展和培训记录，以及认可与奖励；</p></li><li><p>团队成员的技能、能力和特定知识；</p></li><li><p>团队成员的地理分布。</p></li></ul><h5 id="4-1-4-组织过程资产"><a href="#4-1-4-组织过程资产" class="headerlink" title="4.1.4 组织过程资产"></a>4.1.4 组织过程资产</h5><p>能够影响建设团队过程的组织过程资产包括（但不限于）历史信息和经验教训知识库。</p><h4 id="4-2-建设团队：工具与技术"><a href="#4-2-建设团队：工具与技术" class="headerlink" title="4.2 建设团队：工具与技术"></a>4.2 建设团队：工具与技术</h4><h5 id="4-2-1-集中办公"><a href="#4-2-1-集中办公" class="headerlink" title="4.2.1 集中办公"></a>4.2.1 集中办公</h5><p>集中办公是指把许多或全部最活跃的项目团队成员安排在同一个物理地点工作，以增强团队工作能力。集中办公既可以是临时的（如仅在项目特别重要的时期），也可以贯穿整个项目。实施集中办公策略，可借助团队会议室、张贴进度计划的场所，以及其他能够增进沟通和集体感的设施。</p><h5 id="4-2-2-虚拟团队"><a href="#4-2-2-虚拟团队" class="headerlink" title="4.2.2 虚拟团队"></a>4.2.2 虚拟团队</h5><p>虚拟团队的使用能带来很多好处，例如，使用更多技术熟练的资源、降低成本、减少出差及搬迁费用，以及拉近团队成员与供应商、客户或其他重要相关方的距离。虚拟团队可以利用技术来营造在线团队环境，以供团队存储文件、使用在线对话来讨论问题，以及保存团队日历。</p><h5 id="4-2-3-沟通技术"><a href="#4-2-3-沟通技术" class="headerlink" title="4.2.3 沟通技术"></a>4.2.3 沟通技术</h5><p>在解决集中办公或虚拟团队的团队建设问题方面，沟通技术至关重要。它有助于为集中办公团队营造一个融洽的环境，促进虚拟团队（尤其是团队成员分散在不同时区的团队）更好地相互理解。可采用的沟通技术包括：</p><ul><li><p>共享门户。共享信息库（例如网站、协作软件或内部网）对虚拟项目团队很有帮助。</p></li><li><p>视频会议。视频会议是一种可有效地与虚拟团队沟通重要技术。</p></li><li><p>音频会议。音频会议有助于与虚拟团队建立融洽的相互信任的关系。</p></li><li><p>电子邮件/聊天软件。使用电子邮件和聊天软件定期沟通也是一种有效的方式。</p></li></ul><h5 id="4-2-4-人际关系与团队技能"><a href="#4-2-4-人际关系与团队技能" class="headerlink" title="4.2.4 人际关系与团队技能"></a>4.2.4 人际关系与团队技能</h5><p>适用于本过程的人际关系与团队技能包括（但不限于）：</p><ul><li><p>冲突管理。项目经理应及时地以建设性方式解决冲突，从而创建高绩效团队。</p></li><li><p>影响力。本过程的影响力技能收集相关的关键信息，在维护相互信任的关系时，来解决重要问题并达成一致意见。</p></li><li><p>激励。激励为某人采取行动提供了理由。提高团队参与决策的能力并鼓励他们独立工作。</p></li><li><p>谈判。团队成员之间的谈判旨在就项目需求达成共识。谈判有助于在团队成员之间建立融洽的相互信任的关系。</p></li><li><p>团队建设。团队建设是通过举办各种活动，强化团队的社交关系，打造积极合作的工作环境。团队建设活动既可以是状态审查会上的五分钟议程，也可以是为改善人际关系而设计的、在非工作场所专门举办的专业提升活动。团队建设活动旨在帮助各团队成员更加有效地协同工作。如果团队成员的工作地点相隔甚远，无法进行面对面接触，就特别需要有效的团队建设策略。非正式的沟通和活动有助于建立信任和良好的工作关系。团队建设在项目前期必不可少，但它更是个持续的过程。项目环境的变化不可避免，要有效应对这些变化，就需要持续不断地开展团队建设。项目经理应该持续地监督团队机能和绩效，确定是否需要采取措施来预防或纠正各种团队问题。</p></li></ul><h5 id="4-2-5-认可与奖励"><a href="#4-2-5-认可与奖励" class="headerlink" title="4.2.5 认可与奖励"></a>4.2.5 认可与奖励</h5><p>在建设项目团队过程中，需要对成员的优良行为给予认可与奖励。最初的奖励计划是在规划资源管理过程中编制的，只有能满足被奖励者的某个重要需求的奖励，才是有效的奖励。在管理项目团队过程中，可以正式或非正式的方式做出奖励决定，但在决定认可与奖励时，应考虑文化差异。</p><p>当人们感受到自己在组织中的价值，并且可以通过获得奖励来体现这种价值，他们就会受到激励。通常，金钱是奖励制度中的有形奖励，然而也存在各种同样有效、甚至更加有效地无形奖励。大多数项目团队成员会因得到成长机会、获得成就感、得到赞赏以及用专业技能迎接新挑战，而受到激励。项目经理应该在整个项目周期中尽可能地给予表彰，而不是等到项目完成时。</p><h5 id="4-2-6-培训"><a href="#4-2-6-培训" class="headerlink" title="4.2.6 培训"></a>4.2.6 培训</h5><p>培训包括旨在提高项目团队成员能力的全部活动，可以是正式或非正式的，方式包括课堂培训、在线培训、计算机辅助培训、在岗培训（由其他项目团队成员提供）、辅导及训练。如果项目团队成员缺乏必要的管理或技术技能，可以把对这种技能的培养作为项目工作的一部分。项目经理应该按资源管理计划中的安排来实施预定的培训，也应该根据管理项目团队过程中的观察、交谈和项目绩效评估的结果，来开展必要的计划外培训，培训成本通常应该包括在项目预算中，或者如果增加的技能有利于未来的项目，则由执行组织承担。培训可以由内部或外部培训师来执行。</p><h5 id="4-2-7-个人和团队评估"><a href="#4-2-7-个人和团队评估" class="headerlink" title="4.2.7 个人和团队评估"></a>4.2.7 个人和团队评估</h5><p>个人和团队评估工具能让项目经理和项目团队洞察成员的优势和劣势。这些工具可帮助项目经理评估团队成员的偏好和愿望、团队成员如何处理和整理信息、如何制定决策，以及团队成员如何与他人打交道。有各种可用的工具，如态度调查、专项评估、结构化访谈、能力测试及焦点小组。这些工具有利于增进团队成员间的理解、信任、承诺和沟通，在整个项目期间不断提高团队成效。</p><h5 id="4-2-8-会议"><a href="#4-2-8-会议" class="headerlink" title="4.2.8 会议"></a>4.2.8 会议</h5><p>可以用会议来讨论和解决有关团队建设的问题，参会者包括项目经理和项目团队。会议类型包括（但不限于）：项目说明会、团队建设会议，以及团队发展会议。</p><h4 id="4-3-建设团队：输出"><a href="#4-3-建设团队：输出" class="headerlink" title="4.3 建设团队：输出"></a>4.3 建设团队：输出</h4><h5 id="4-3-1-团队绩效评价"><a href="#4-3-1-团队绩效评价" class="headerlink" title="4.3.1 团队绩效评价"></a>4.3.1 团队绩效评价</h5><p>随着项目团队建设工作（如培训、团队建设和集中办公等）的开展，项目管理团队应该对项目团队的有效性进行正式或非正式的评估。有效的团队建设策略和活动可以提高团队绩效，从而提高实现项目目标的可能性。</p><p>评价团队有效性的指标可包括：</p><ul><li><p>个人技能的改进，从而使成员更有效地完成工作任务；</p></li><li><p>团队能力的改进，从而使团队成员更好地开展工作；</p></li><li><p>团队成员离职率的降低；</p></li><li><p>团队凝聚力的加强，从而使团队成员公开分享信息和经验，并互相帮助来提高项目绩效。</p></li></ul><p>通过对团队整体绩效的评价，项目管理团队能够识别出所需的特殊培训、教练、辅导、协助或改变，以提高团队绩效。项目管理团队也应该识别出合适或所需的资源，以执行和实现在绩效评价过程中提出的改进建议。</p><h5 id="4-3-2-变更请求"><a href="#4-3-2-变更请求" class="headerlink" title="4.3.2 变更请求"></a>4.3.2 变更请求</h5><p>如果建设团队过程中出现变更请求，或者推荐的纠正措施或预防措施影响了项目管理计划的任何组成部分或项目文件，项目经理应提交变更请求并遵循实施整体变更控制过程。</p><h5 id="4-3-3-项目管理计划更新"><a href="#4-3-3-项目管理计划更新" class="headerlink" title="4.3.3 项目管理计划更新"></a>4.3.3 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更的项目管理计划组成部分包括（但不限于）资源管理计划。</p><h5 id="4-3-4-项目文件更新"><a href="#4-3-4-项目文件更新" class="headerlink" title="4.3.4 项目文件更新"></a>4.3.4 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。项目中遇到的条件、本可以规避这些挑战的方法，以及良好的团队建设方式更新在经验教训登记册中。</p></li><li><p>项目进度计划。项目团队建设活动可能会导致项目进度的变更。</p></li><li><p>项目团队派工单。如果团队建设导致已商定的派工单出现变更，应对项目团队派工单做出相应的的更新。</p></li><li><p>资源日历。更新资源日历，以反映项目资源的可用性。</p></li><li><p>团队章程。更新团队章程，以反映因团队建设对团队工作指南做出的变更。</p></li></ul><h5 id="4-3-5-事业环境因素更新"><a href="#4-3-5-事业环境因素更新" class="headerlink" title="4.3.5 事业环境因素更新"></a>4.3.5 事业环境因素更新</h5><p>作为建设项目团队过程的结果，需要更新的事业环境因素包括（但不限于）：</p><ul><li><p>员工发展计划的记录；</p></li><li><p>技能评估。</p></li></ul><h5 id="4-3-6-组织过程资产更新"><a href="#4-3-6-组织过程资产更新" class="headerlink" title="4.3.6 组织过程资产更新"></a>4.3.6 组织过程资产更新</h5><p>作为建设团队过程的结果，需要更新的组织过程资产包括（但不限于）：</p><ul><li><p>培训需求；</p></li><li><p>人事评测。</p></li></ul><hr><h3 id="五、管理团队"><a href="#五、管理团队" class="headerlink" title="五、管理团队"></a>五、管理团队</h3><p>管理团队是跟踪团队成员工作表现，提供反馈，解决问题并管理团队变更，以优化项目绩效的过程。本过程的主要作用是，影响团队行为、管理冲突以及解决问题。本过程需要在整个项目期间开展。</p><p>图9-12描述本过程的输入、工具与技术和输出。图9-13是本过程的数据流向图。</p><p><img src="/images/pmp-9/9-12.png" alt="管理团队：输入、工具与技术和输出"></p><p><img src="/images/pmp-9/9-13.png" alt="管理团队：数据流向图"></p><p>管理项目团队需要借助多方面的管理和领导力技能，来促进团队协作，整合团队成员的工作，从而创建高效团队。进行团队管理，需要综合运用各种技能，特别是沟通、冲突管理、谈判和领导技能。项目经理应该向团队成员分配富有挑战性的任务，并对优秀绩效进行表彰。</p><p>项目经理应留意团队成员是否有意愿和能力完成工作，然后相应地调整管理和领导力方式。想对那些已展现出能力和有经验的团队成员，技术能力较低的团队成员更需要强化监督。</p><h4 id="5-1-管理团队：输入"><a href="#5-1-管理团队：输入" class="headerlink" title="5.1 管理团队：输入"></a>5.1 管理团队：输入</h4><h5 id="5-1-1-项目管理计划"><a href="#5-1-1-项目管理计划" class="headerlink" title="5.1.1 项目管理计划"></a>5.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）资源管理计划。资源管理计划为如何管理和最终遣散项目团队资源提供指南。</p><h5 id="5-1-2-项目文件"><a href="#5-1-2-项目文件" class="headerlink" title="5.1.2 项目文件"></a>5.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>问题日志。在管理项目团队过程中，总会出现各种问题。此时，可用问题日志记录由谁负责在目标日期内解决特定问题，并监督解决情况。</p></li><li><p>经验教训登记册。项目早期的经验教训可以运用到项目后期阶段，以提高团队管理的效率与效果。</p></li><li><p>项目团队派工单。项目团队派工单识别了团队成员的角色与职责。</p></li><li><p>团队章程。团队章程为团队应如何决策、举行会议和解决冲突提供指南。</p></li></ul><h5 id="5-1-3-工作绩效报告"><a href="#5-1-3-工作绩效报告" class="headerlink" title="5.1.3 工作绩效报告"></a>5.1.3 工作绩效报告</h5><p>工作绩效报告是为制定决策、采取行动或引起关注所形成的实物或电子工作绩效信息，它包括从进度控制、成本控制、质量控制和范围确认中得到的结果，有助于项目团队管理。绩效报告和相关预测报告中的信息，有助于确定未来的团队资源需求，认可与奖励，以及更新资源管理计划。</p><h5 id="5-1-4-团队绩效评价"><a href="#5-1-4-团队绩效评价" class="headerlink" title="5.1.4 团队绩效评价"></a>5.1.4 团队绩效评价</h5><p>项目管理团队应该持续地对项目团队绩效进行正式或非正式的评价。不断地评价项目团队绩效，有助于采取措施解决问题、调整沟通方式、解决冲突和改进团队互动。</p><h5 id="5-1-5-事业环境因素"><a href="#5-1-5-事业环境因素" class="headerlink" title="5.1.5 事业环境因素"></a>5.1.5 事业环境因素</h5><p>能够影响管理团队过程的事业环境因素包括（但不限于）人力资源管理政策。</p><h5 id="5-1-6-组织过程资产"><a href="#5-1-6-组织过程资产" class="headerlink" title="5.1.6 组织过程资产"></a>5.1.6 组织过程资产</h5><p>能够影响管理团队过程的组织过程资产包括（但不限于）：</p><ul><li><p>嘉奖证书；</p></li><li><p>公司制服；</p></li><li><p>组织中其他的额外待遇。</p></li></ul><h4 id="5-2-管理团队：工具与技术"><a href="#5-2-管理团队：工具与技术" class="headerlink" title="5.2 管理团队：工具与技术"></a>5.2 管理团队：工具与技术</h4><h5 id="5-2-1-人际关系与团队技能"><a href="#5-2-1-人际关系与团队技能" class="headerlink" title="5.2.1 人际关系与团队技能"></a>5.2.1 人际关系与团队技能</h5><p>适用于本过程的人际关系与团队技能包括（但不限于）：</p><ul><li><p>冲突管理。在项目环境中，冲突不可避免。冲突的来源包括资源稀缺、进度优先级排序和个人工作风格差异等。采用团队基本规则、团队规范及成熟的项目管理实践（如沟通规划和角色定义），可以减少冲突的数量。</p><p>  成功的冲突管理可提高生产力，改进工作关系。同时，如果管理得当，意见分歧有利于提高创造力和改进决策。加入意见分歧成为负面因素，应该首先由项目团队成员负责解决；如果冲突升级，项目经理应提供协助，促成满意的解决方案，采用直接和合作的方式，尽早并且通常在私下处理冲突。如果破坏性冲突继续存在，则可使用正式程序，包括采取惩戒措施。</p><p>  项目经理解决冲突的能力往往决定其管理项目团队的成败。不同的项目经理可能采取不同的解决冲突方法。影响冲突解决方法的因素包括：</p><ul><li><p>冲突的重要性和激烈程度；</p></li><li><p>解决冲突的紧迫性；</p></li><li><p>涉及冲突的人员的相对权力；</p></li><li><p>维持良好关系的重要性；</p></li><li><p>永久或暂时解决冲突的动机。</p><p>有五种常用的冲突解决方法，每种技巧都有各自的作用和用途。</p></li><li><p>撤退/回避。从实际或潜在冲突中退出，将问题推迟到准备充分的时候，或者将问题推给其他人员解决。</p></li><li><p>缓和/包容。强调一致而非差异；为维持和谐与关系而退让一步，考虑其他方的需要。</p></li><li><p>妥协/调解。为了暂时或部分解决冲突，寻找能让各方都在一定程度上满意的方案，但这种方法有时会导致“双输”局面。</p></li><li><p>强迫/命令。以牺牲其他方为代价，推行某一方的观点；只提供赢-输方案，通常是利用权力来强行解决紧急问题，这种方法通常会导致“赢输”局面。</p></li><li><p>合作/解决问题。综合考虑不同的观点和意见，采用合作的态度和开放式对话引导各方达成共识和承诺，这种方法可以带来双赢局面。</p></li></ul></li><li><p>制定决策。这种情况下，决策包括谈判能力以及影响组织与项目管理团队的能力，而不是决策工具集所描述的一系列工具。进行有效决策需要：</p><ul><li><p>着眼于所要达到的目标；</p></li><li><p>遵循决策流程；</p></li><li><p>研究环境因素；</p></li><li><p>分析可用信息；</p></li><li><p>激发团队创造力；</p></li><li><p>理解风险。</p></li></ul></li><li><p>情商。情商指识别、评估和管理个人情绪、他人情绪及团体情绪的能力。项目管理团队能用情商来了解、评估及控制项目团队成员的情绪，预测团队成员的行为，确认团队成员的关注点及跟踪团队成员的问题，来达到减轻压力、加强合作的目的。</p></li><li><p>影响力。在矩阵环境中，项目经理对团队成员通常没有或仅有很小的命令职权，所以他们适时影响相关方的能力，对保证项目成功非常关键。影响力主要体现在如下各方面：</p><ul><li><p>说服他人；</p></li><li><p>清晰表达观点和立场；</p></li><li><p>积极且有效的倾听；</p></li><li><p>了解并综合考虑各种观点；</p></li><li><p>收集相关信息，在维护相互信任的关系下，解决问题并达成一致意见。</p></li></ul></li><li><p>领导力。成功的项目需要强有力的领导技能，领导力是领导团队、激励团队做好本职工作的能力。它包括各种不同的技巧、能力和行动。且领导力在项目生命周期中的所有阶段都很重要。有多重领导力理论，定义了适用于不同情形或团队的领导风格。领导力对沟通愿景及鼓舞项目团队高效工作十分重要。</p></li></ul><h5 id="5-2-2-项目管理信息系统（PMIS）"><a href="#5-2-2-项目管理信息系统（PMIS）" class="headerlink" title="5.2.2 项目管理信息系统（PMIS）"></a>5.2.2 项目管理信息系统（PMIS）</h5><p>项目管理信息系统可包括资源管理或进度计划软件，可用于在各个项目活动中管理和协调团队成员。</p><h4 id="5-3-管理团队：输出"><a href="#5-3-管理团队：输出" class="headerlink" title="5.3 管理团队：输出"></a>5.3 管理团队：输出</h4><h5 id="5-3-1-变更请求"><a href="#5-3-1-变更请求" class="headerlink" title="5.3.1 变更请求"></a>5.3.1 变更请求</h5><p>如果管理团队过程中出现变更请求，或者推荐措施、纠正措施或预防措施影响了项目管理计划的任何组成部分或项目文件，项目经理应提交变更请求。并通过实施整体变更控制过程对变更请求进行审查和处理。</p><p>例如，人员配备变更，无论是自主选择还是由不可控事件造成，都会干扰项目团队，这种干扰可能导致进度落后或预算超支。人员配置变更包括转派人员、外包部分工作，或替换离职人员。</p><h5 id="5-3-2-项目管理计划更新"><a href="#5-3-2-项目管理计划更新" class="headerlink" title="5.3.2 项目管理计划更新"></a>5.3.2 项目管理计划更新</h5><p>项目管理计划的任何变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更的项目管理计划组成部分包括（但不限于）：</p><ul><li><p>资源管理计划。资源管理计划根据实际的项目团队管理经验更新。</p></li><li><p>进度基准。可能需要更改项目进度，以反映团队的执行方式。</p></li><li><p>成本基准。可能需要更改项目成本基准，以反映团队的执行方式。</p></li></ul><h5 id="5-3-3-项目文件更新"><a href="#5-3-3-项目文件更新" class="headerlink" title="5.3.3 项目文件更新"></a>5.3.3 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>问题日志。在本过程中提出的新问题可以记录到问题日志中。</p></li><li><p>经验教训登记册。更新经验教训登记册，记录在项目中遇到的挑战、本应可以规避这些挑战的方法，以及良好的团队管理方式。</p></li><li><p>项目团队派工单。如果需要对团队做出变更，则在项目团队派工单中记录这些变更。</p></li></ul><h5 id="5-3-4-事业环境因素更新"><a href="#5-3-4-事业环境因素更新" class="headerlink" title="5.3.4 事业环境因素更新"></a>5.3.4 事业环境因素更新</h5><p>作为管理团队过程的结果，需要更新的事业环境因素包括（但不限于）：</p><ul><li><p>对组织绩效评价的输入；</p></li><li><p>个人技能。</p></li></ul><hr><h3 id="六、控制资源"><a href="#六、控制资源" class="headerlink" title="六、控制资源"></a>六、控制资源</h3><p>控制资源是确保按计划为项目分配实物资源，以及根据资源使用计划监督资源实际使用情况，并采取必要纠正措施的过程。本过程的主要作用是，确保所分配的资源适时适当地可用于项目，且在不再需要时被释放。本过程需要在整个项目期间开展。图9-14描述了本过程的输入、工具与技术和输出。图9-15是本过程的数据流向图。</p><p><img src="/images/pmp-9/9-14.png" alt="控制资源：输入、工具与技术和输出"></p><p><img src="/images/pmp-9/9-15.png" alt="控制资源：数据流向图"></p><p>应在所有项目阶段和整个项目生命周期期间持续开展控制资源过程，且适时、适地和适量地分配和释放资源，使项目能够持续进行。控制资源过程关注实物资源，例如设备、材料、设施和基础设施。管理团队过程关注团队成员。</p><p>本届讨论的控制资源技术是项目中最常用的，而在特定项目获应用领域中，还可采用许多其他控制资源技术。</p><p>更新资源分配时，需要了解已使用的资源和还需要获取的资源。为此，应审查至今为止的资源使用情况。控制资源过程关注：</p><ul><li><p>监督资源支出；</p></li><li><p>及时识别和处理资源缺乏/剩余情况；</p></li><li><p>确保根据计划和项目需求使用和释放资源；</p></li><li><p>在出现资源相关问题时通知相应的相关方；</p></li><li><p>影响可以导致资源使用变更的因素；</p></li><li><p>在变更实际发生时对其进行管理。</p></li></ul><p>进度基准或成本基准的任何变更，都必须经过实施整体变更控制过程的审批。</p><h4 id="6-1-控制资源：输入"><a href="#6-1-控制资源：输入" class="headerlink" title="6.1 控制资源：输入"></a>6.1 控制资源：输入</h4><h5 id="6-1-1-项目管理计划"><a href="#6-1-1-项目管理计划" class="headerlink" title="6.1.1 项目管理计划"></a>6.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）资源管理计划。资源管理计划为如何使用、控制和最终释放实物资源提供指南。</p><h5 id="6-1-2-项目文件"><a href="#6-1-2-项目文件" class="headerlink" title="6.1.2 项目文件"></a>6.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>问题日志。问题日志用于识别有关缺乏资源、原材料供应延迟，或低等级原材料等问题。</p></li><li><p>经验教训登记册。在项目早期获得的经验教训可以运用到后期阶段，以改进实物资源控制。</p></li><li><p>实物资源分配。实物资源分配描述了资源的预期使用情况以及资源的详细信息，例如类型、数量、地点以及属于组织内部资源还是外购资源。</p></li><li><p>项目进度计划。项目进度计划展示了项目在何时何地需要哪些资源。</p></li></ul><h5 id="6-1-3-工作绩效数据"><a href="#6-1-3-工作绩效数据" class="headerlink" title="6.1.3 工作绩效数据"></a>6.1.3 工作绩效数据</h5><p>工作绩效数据包含有关项目状态的数据，例如已使用的资源的数量和类型。</p><h5 id="6-1-4-协议"><a href="#6-1-4-协议" class="headerlink" title="6.1.4 协议"></a>6.1.4 协议</h5><p>在项目中签署的协议是获取组织外部资源的依据，应在需要新的和未规划的资源时，或在当前资源出现问题时，在协议里定义相关程序。</p><h5 id="6-1-5-组织过程资产"><a href="#6-1-5-组织过程资产" class="headerlink" title="6.1.5 组织过程资产"></a>6.1.5 组织过程资产</h5><p>能够影响控制资源过程的组织过程资产包括（但不限于）：</p><ul><li><p>有关资源控制和分配的政策；</p></li><li><p>执行组织内用于解决问题的升级程序；</p></li><li><p>经验教训知识库，其中包含以往类似项目的信息。</p></li></ul><h4 id="6-2-控制资源：工具与技术"><a href="#6-2-控制资源：工具与技术" class="headerlink" title="6.2 控制资源：工具与技术"></a>6.2 控制资源：工具与技术</h4><h5 id="6-2-1-数据分析"><a href="#6-2-1-数据分析" class="headerlink" title="6.2.1 数据分析"></a>6.2.1 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）：</p><ul><li><p>备选方案分析。备选方案分析有助于选择最佳解决方案以纠正资源使用偏差，可以将加班和增加团队资源等备选方案与延期交付或阶段性交付相比较，以权衡利弊。</p></li><li><p>成本效益分析。成本效益分析有助于在项目成本出现差异时确定最佳的纠正措施。</p></li><li><p>绩效审查。绩效审查是测量、比较和分析计划的资源使用和实际资源使用的不同。分析成本和进度工作绩效信息有助于指出可能影响资源使用的问题。</p></li><li><p>趋势分析。在项目进展过程中，项目团队可能会使用趋势分析，基于当前绩效信息来确定未来项目阶段所需的资源。趋势分析检查项目绩效随时间的变化情况，可用于确定绩效是在改善还是在恶化。</p></li></ul><h5 id="6-2-2-问题解决"><a href="#6-2-2-问题解决" class="headerlink" title="6.2.2 问题解决"></a>6.2.2 问题解决</h5><p>问题解决可能会用到一系列工具，有助于项目经理解决控制资源过程中出现的问题。问题可能来自组织内部（组织中另一部门使用的机器或基础设施未及时释放，因储存条件不当造成材料受损等）或来自组织外部（主要供应商破产或恶劣天气使资源受损）。项目经理应采取有条不紊的步骤来解决问题，包括：</p><ul><li><p>识别问题。明确问题。</p></li><li><p>定义问题。将问题分解为可管理的小问题。</p></li><li><p>调查。收集数据。</p></li><li><p>分析。找出问题的根本原因。</p></li><li><p>解决。从众多解决方案中选择最合适的一个。</p></li><li><p>检查解决方案。确认是否已解决问题。</p></li></ul><h5 id="6-2-3-人际关系与团队技能"><a href="#6-2-3-人际关系与团队技能" class="headerlink" title="6.2.3 人际关系与团队技能"></a>6.2.3 人际关系与团队技能</h5><p>人际关系与团队技能有时被称为“软技能”，输入个人能力。本过程使用的人际关系与团队技能包括：</p><ul><li><p>谈判。项目经理可能需要就增加实物资源、变更实物资源或资源相关成本进行谈判。</p></li><li><p>影响力。影响力有助于项目经理及时解决问题并获得所需资源。</p></li></ul><h5 id="6-2-4-项目管理信息系统（PMIS）"><a href="#6-2-4-项目管理信息系统（PMIS）" class="headerlink" title="6.2.4 项目管理信息系统（PMIS）"></a>6.2.4 项目管理信息系统（PMIS）</h5><p>项目管理信息系统可包括资源管理或进度计划软件，可用于监督资源的使用情况，帮助确保合适的资源适时适地用于合适的活动。</p><h4 id="6-3-控制资源：输出"><a href="#6-3-控制资源：输出" class="headerlink" title="6.3 控制资源：输出"></a>6.3 控制资源：输出</h4><h5 id="6-3-1-工作绩效信息"><a href="#6-3-1-工作绩效信息" class="headerlink" title="6.3.1 工作绩效信息"></a>6.3.1 工作绩效信息</h5><p>工作绩效信息包括项目工作进展信息，这一信息将资源需求和资源分配与项目活动期间的资源使用相比较，从而发现需要处理的资源可用性方面的差异。</p><h5 id="6-3-2-变更请求"><a href="#6-3-2-变更请求" class="headerlink" title="6.3.2 变更请求"></a>6.3.2 变更请求</h5><p>如果控制资源过程出现变更请求，或者推荐的纠正措施或预防措施影响了项目管理计划的任何组成部分或项目文件，项目经理应提交变更请求。并通过实施整体变更控制过程对变更请求进行审查和处理。</p><h5 id="6-3-3-项目管理计划更新"><a href="#6-3-3-项目管理计划更新" class="headerlink" title="6.3.3 项目管理计划更新"></a>6.3.3 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更的项目管理计划组成部分包括（但不限于）：</p><ul><li><p>资源管理计划。资源管理计划根据实际的项目资源管理经验更新。</p></li><li><p>进度基准。可能需要更新项目进度，以反映管理项目资源的方式。</p></li><li><p>成本基准。可能需要更新项目成本基准，以反映管理项目资源的方式。</p></li></ul><h5 id="6-3-4-项目文件更新"><a href="#6-3-4-项目文件更新" class="headerlink" title="6.3.4 项目文件更新"></a>6.3.4 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>假设日志。把关于设备、材料、用品和其他实物资源的新假设条件更新在假设日志中。</p></li><li><p>问题日志。在本过程中出现的新问题可以记录到问题日志中。</p></li><li><p>经验教训登记册。在经验教训登记册中更新有效管理资源物流、废料、使用偏差，以及应对资源偏差的纠正措施的技术。</p></li><li><p>实物资源分配单。实物资源分配单是动态的，会因可用性、项目、组织、环境或其他因素而发生变更。</p></li><li><p>资源分解结构。可能需要更新资源分解结构，以反映使用项目资源的方式。</p></li><li><p>风险登记册。关于资源可用性、利用或其他实物资源的风险更新在风险登记册中。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《PMBOK第六版》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目资源管理包括识别、获取和管理所需资源以成功完成项目的各个过程，这些过程有助于确保项目经理和项目团队在正确的时间和地点使用正确的资源。&lt;/p&gt;
    
    </summary>
    
      <category term="PMP抄书系列" scheme="http://www.xiaoleon.cn/categories/PMP%E6%8A%84%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="pmp" scheme="http://www.xiaoleon.cn/tags/pmp/"/>
    
  </entry>
  
  <entry>
    <title>PMP(8) 项目质量管理</title>
    <link href="http://www.xiaoleon.cn/2019/02/22/pmp-8/"/>
    <id>http://www.xiaoleon.cn/2019/02/22/pmp-8/</id>
    <published>2019-02-22T12:50:13.000Z</published>
    <updated>2019-05-13T09:48:09.847Z</updated>
    
    <content type="html"><![CDATA[<p>项目质量管理包括把组织的质量政策应用于规划、管理、控制项目和产品质量要求，以满足相关方目标的各个过程。此外，项目质量管理以执行组织的名义支持过程的持续改进活动。</p><a id="more"></a><p>项目质量管理过程包括：</p><ul><li><p><strong>规划质量管理</strong> —— 识别项目及其可交付成果的质量要求和（或）标准，并书面描述项目将如何证明符合质量要求和（或）标准的过程。</p></li><li><p><strong>管理质量</strong> —— 管理质量是把组织的质量政策用于项目，并将质量管理计划转化为可执行的质量活动的过程。</p></li><li><p><strong>控制质量</strong> —— 为了评估绩效，确保项目输出完整、正确，并满足客户期望，而监督和记录质量管理活动执行结果的过程。</p></li></ul><p>图8-1概述了项目质量管理的各个过程。虽然各项目质量管理过程通常以界限分明、相互独立的形式出现，但在实践中它们会以《PMBOK》无法全面叙述的方式相互交叠、相互作用。此外，不同行业和公司的质量过程各不相同。</p><p><img src="/images/pmp-8/8-1.png" alt="项目质量管理概述"></p><p>图8-2概述了项目质量管理过程的主要输入和输出以及这些过程在项目质量管理知识领域中的相互关系。规划质量管理过程关注工作需要达到的质量，管理质量则关注管理整个项目期间的质量过程。在管理质量过程期间，在规划质量管理过程中识别的质量要求成为测试与评估工具，将用于控制质量过程，以确认项目是否达到这些质量要求。控制质量关注工作成果与质量要求的比较，确保结果可接受。项目质量管理知识领域有两个用于其他知识领域的特定输出，即核实的可交付成果和质量报告。</p><p><img src="/images/pmp-8/8-2.png" alt="主要项目质量管理过程的相互关系"></p><p><strong>项目质量管理的核心概念</strong></p><p>项目质量管理需要兼顾项目管理与项目可交付成果两个方面，它适用于所有项目，无论项目的可交付成果具有何种特性。质量的测量方法和技术则需专门针对项目所产生的可交付成果类型而定，例如，对于软件与核电站建设的可交付成果，项目质量管理需要采用不同的方法和措施。无论什么项目，若未达到质量要求，都会给某个或全部项目相关方带来严重的负面后果，例如：</p><ul><li><p>为满足客户要求而让项目团队超负荷工作，就可能导致利润下降、整体项目风险增加，以及员工疲劳、出错或返工。</p></li><li><p>为满足项目进度目标而仓促完成预定的质量检查，就可能造成检验疏漏、利润下降，以及后续风险增加。</p></li></ul><p>“质量”与“等级”不是相同的概念。质量作为实现的性能或成果，是“一系列内在特性满足要求的程度”。等级作为设计意图，是对用途相同但技术特性不同的可交付成果的级别分类。项目经理及项目管理团队负责权衡，以便同时达到所要求的质量与等级水平。质量水平未达到质量要求肯定是个问题，而低等级产品不一定是个问题。例如：</p><ul><li><p>一个低等级（功能有限）产品具备高质量（无明显缺陷），也许不是问题。该产品适合一般使用。</p></li><li><p>一个高等级（功能繁多）产品质量低（有许多缺陷），也许是个问题。该产品的功能会因质量低劣而无效和（或）低效。</p></li></ul><p>预防胜于检查。最好将质量设计到可交付成果中，而不是在检查时发现质量问题。预防错误的成本通常远低于在检查或使用中发现并纠正错误的成本。</p><p>根据不同的项目和行业领域，项目团队可能需要具备统计控制过程方面的实用知识，以便评估控制质量的输出中所包含的数据。项目管理团队应了解以下术语之间的差别：</p><ul><li><p>“预防”（保证过程中不出现错误）与“检查”（保证错误不落到客户手中）；</p></li><li><p>“属性抽样”（结果为合格或不合格）与“变量抽样”（在连续的量表上表明结果所处的位置，表明合格的程度）；</p></li><li><p>“公差”（结果的可接受范围）与“控制界限”（在统计意义上稳定的过程或过程绩效的普遍偏差的边界）。</p></li></ul><p>质量成本（COQ）包括在产品生命周期中为预防不符合要求、为评价产品或服务是否符合要求，以及因未达到要求（返工）而发生的所有成本。失败成本通常分为内部（项目团队发现的）和外部（客户发现的）两类。失败成本也称为劣质成本。组织选择投资缺陷预防，因为它对产品生命周期有利。由于项目的临时性，针对产品生命周期的COQ决策，通常是项目集管理、项目组合管理、PMO或运营的关注点。</p><p>按有效性递增排列的五种质量管理水平如下：</p><ul><li><p>通常，代价最大的方法是让客户发现缺陷。这种方法可能会导致担保问题、召回、商誉受损和返工成本。</p></li><li><p>控制质量过程包括先检测和纠正缺陷，再将可交付成果发送给客户。该过程会带来相关成本，主要是评估成本和内部失败成本。</p></li><li><p>通过质量保证检查并纠正过程本身，而不仅仅是特殊缺陷。</p></li><li><p>将质量融入项目和产品的规划和设计中。</p></li><li><p>在整个组织内创建一种关注并致力于实现过程和产品质量的文化。</p></li></ul><p><strong>项目质量管理的趋势和新兴实践</strong></p><p>现代质量管理方法力求缩小差异，交付满足既定相关方要求的成果。项目质量管理的趋势可能包括（但不限于）：</p><ul><li><p>客户满意。了解、评估、定义和管理要求，以便满足客户的期望。这就需要把“符合要求”（确保项目产出预定的成果）和“适合使用”（产品或服务必须满足实际需求）结合起来。在敏捷环境中，相关方与项目管理团队合作可确保在整个项目期间始终做到客户满意。</p></li><li><p>持续改进。由休哈特提出并经戴明完善的“计划-实施-检查-行动”（PDCA）循环是质量改进的基础。另外，诸如全面质量管理（TQM）、六西格玛和精益六西格玛等质量改进举措也可以提高项目管理的质量以及最终产品、服务或成果的质量。</p></li><li><p>管理层的责任。项目的成功需要项目团队全体成员的参与。管理层在其质量职责内，肩负着为项目提供具有足够能力的资源的相应责任。</p></li><li><p>与供应商的互利合作关系。组织与其供应商相互依赖。相对传统的供应商管理而言，与供应商建立合作伙伴关系对组织和供应商都更加有益。组织应着眼于长期关系而不是短期利益。互利合作关系增强了组织和供应商互相为对方创造价值的能力，推动他们共同实现客户的需求和期望，并优化成本和资源。</p></li></ul><p><strong>裁剪考虑因素</strong></p><p>每个项目都是独特的，因此项目经理需要裁剪项目质量管理过程。裁剪时应考虑的因素包括（但不限于）：</p><ul><li><p>政策合规与审计。组织有哪些质量政策和程序？组织使用哪些质量工具、技术和模板？</p></li><li><p>标准与法规合规性。是否存在必须遵守的行业质量标准？需要考虑哪些政府、法律或法规方面的制约因素？</p></li><li><p>持续改进。如何管理项目中的质量改进？是在组织层面还是在单个项目层面进行管理？</p></li><li><p>相关方参与。项目环境是否有利于与相关方及供应商合作？</p></li></ul><p><strong>关于敏捷/适应型环境的考虑因素</strong></p><p>为引导变更，敏捷方法要求多个质量与审核步骤贯穿整个项目，而不是在面临项目结束时才执行。</p><p>循环回顾，定期检查质量过程的效果；寻找问题的根本原因，然后建议实施新的质量改进方法；后续回顾会议评估试验过程，确定是否可行、是否应继续、或做出调整，或者直接弃用。</p><p>为促进频繁地增量交付，敏捷方法关注于小批量工作，纳入尽可能多的项目可交付成果的要素。小批量系统的目的是在项目生命周期早期（整体变更成本较低）发现不一致和质量问题。</p><h3 id="一、规划质量管理"><a href="#一、规划质量管理" class="headerlink" title="一、规划质量管理"></a>一、规划质量管理</h3><p>规划质量管理是识别项目及其可交付成果的质量要求和（或）标准，并书面描述项目将如何证明符合质量要求和（或）标准的过程。本过程的主要作用是，为在整个项目期间如何管理和核实质量提供指南和方向。本过程仅开展一次或仅在项目的预定义点开展。图8-3描述了本过程的输入和输出。图8-4是本过程的数据流向图。</p><p><img src="/images/pmp-8/8-3.png" alt="规划质量管理：输入、工具与技术和输出"></p><p><img src="/images/pmp-8/8-4.png" alt="规划质量管理：数据流向图"></p><p>质量规划应与其他规划过程并行开展。例如，为满足既定的质量标准而对可交付成果提出变更，可能需要调整成本或进度计划，并就该变更对相关计划的影响进行详细风险分析。</p><p>本节讨论项目中最常用的质量规划技术，但在特定项目获应用领域中，还可采用许多其他质量规划技术。</p><h4 id="1-1-规划质量管理：输入"><a href="#1-1-规划质量管理：输入" class="headerlink" title="1.1 规划质量管理：输入"></a>1.1 规划质量管理：输入</h4><h5 id="1-1-1-项目章程"><a href="#1-1-1-项目章程" class="headerlink" title="1.1.1 项目章程"></a>1.1.1 项目章程</h5><p>项目章程包含对项目和产品特征的高层级描述，还包括可以影响项目质量管理的项目审批要求、可测量的项目目标和相关的成功标准。</p><h5 id="1-1-2-项目管理计划"><a href="#1-1-2-项目管理计划" class="headerlink" title="1.1.2 项目管理计划"></a>1.1.2 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>需求管理计划。需求管理计划提供了识别、分析和管理需求的方法，以供质量管理计划和质量测量指标借鉴。</p></li><li><p>风险管理计划。风险管理计划提供了识别、分析和监督风险的方法。将风险管理计划和质量管理计划的信息相结合，有助于成功交付产品和项目。</p></li><li><p>相关方参与计划。相关方参与计划提供了记录相关方需求和期望的方法，为质量管理奠定了基础。</p></li><li><p>范围基准。在确定适用于项目的质量标准和目标时，以及在确定要求质量审查的项目可交付成果和过程时，需要考虑WBS和项目范围说明书中记录的可交付成果。范围说明书包含可交付成果的验收标准。该标准的界定可能导致质量成本并进而导致项目成本的显著升高或降低。满足所有的验收标准意味着满足相关方的需求。</p></li></ul><h5 id="1-1-3-项目文件"><a href="#1-1-3-项目文件" class="headerlink" title="1.1.3 项目文件"></a>1.1.3 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>假设日志。假设日志记录与质量要求和标准合规性有关的所有假设条件和制约因素。</p></li><li><p>需求文件。需求文件记录项目和产品为满足相关方的期望应达到的要求，它包括（但不限于）针对项目和产品的质量要求。这些需求有助于项目团队规划将如何实施项目质量控制。</p></li><li><p>需求跟踪矩阵。需求跟踪矩阵将产品需求连接到可交付成果，有助于确保需求文件中的各项需求都得到测试。矩阵提供了合适需求时所需测试的概述。</p></li><li><p>风险登记册。风险登记册包含可能影响质量要求的各种威胁和机会的信息。</p></li><li><p>相关方登记册。相关方登记册有助于识别对质量有特别兴趣或影响的相关方，尤其注重客户和项目发起人的需求和期望。</p></li></ul><h5 id="1-1-4-事业环境因素"><a href="#1-1-4-事业环境因素" class="headerlink" title="1.1.4 事业环境因素"></a>1.1.4 事业环境因素</h5><p>能够影响规划质量管理过程的事业环境因素包括（但不限于）：</p><ul><li><p>政府法规；</p></li><li><p>特定应用领域的相关规划、标准和指南；</p></li><li><p>地理分布；</p></li><li><p>组织结构；</p></li><li><p>市场条件；</p></li><li><p>项目或可交付成果的工作条件或运行条件；</p></li><li><p>文化观念。</p></li></ul><h5 id="1-1-5-组织过程资产"><a href="#1-1-5-组织过程资产" class="headerlink" title="1.1.5 组织过程资产"></a>1.1.5 组织过程资产</h5><p>能够影响规划质量管理过程的组织过程资产包括（但不限于）：</p><ul><li><p>组织的质量管理体系，包括政策、程序及指南。</p></li><li><p>质量模板，例如核查表、跟踪矩阵及其它；</p></li><li><p>历史数据库和经验教训知识库。</p></li></ul><h4 id="1-2-规划质量管理：工具与技术"><a href="#1-2-规划质量管理：工具与技术" class="headerlink" title="1.2 规划质量管理：工具与技术"></a>1.2 规划质量管理：工具与技术</h4><h5 id="1-2-1-专家判断"><a href="#1-2-1-专家判断" class="headerlink" title="1.2.1 专家判断"></a>1.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>质量保证；</p></li><li><p>质量控制；</p></li><li><p>质量测量结果；</p></li><li><p>质量改进；</p></li><li><p>质量体系。</p></li></ul><h5 id="1-2-2-数据收集"><a href="#1-2-2-数据收集" class="headerlink" title="1.2.2 数据收集"></a>1.2.2 数据收集</h5><p>适用于本过程的数据收集技术包括（但不限于）：</p><ul><li><p>标杆对照。标杆对照是将实际或计划的项目实践或项目的质量标准与可比项目的实践进行比较，以便识别最佳实践，形成改进意见，并为绩效考核提供依据。作为标杆的项目可以来自执行组织内部或外部，或者来自统一应用领域或其他应用领域。标杆对照也允许用不同应用领域或行业的项目做类比。</p></li><li><p>头脑风暴。通过头脑风暴可以向团队成员或主题专家收集数据，以制定最适合新项目的质量管理计划。</p></li><li><p>访谈。访谈有经验的项目参与者、相关方和主题专家有助于了解他们对项目和产品质量的隐性和显性、正式和非正式的需求和期望。应在信任和保密的环境下开展访谈，以获得真实可信、不带偏见的反馈。</p></li></ul><h5 id="1-2-3-数据分析"><a href="#1-2-3-数据分析" class="headerlink" title="1.2.3 数据分析"></a>1.2.3 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）：</p><ul><li><p>成本效益分析。成本效益分析是用来估算备选方案优势和劣势的财务分析工具，以确定可以创造最佳效益的备选方案。成本效益分析可帮助项目经理确定规划的质量活动是否有效利用了成本。达到质量要求的主要效益包括减少返工、提高生产率、降低成本、提升相关方满意度及提升盈利能力。对每个质量活动进行成本效益分析，就是要比较其可能成本与预期效益。</p></li><li><p>质量成本。与项目有关的质量成本（COQ）包含以下一种或多种成本：</p><ul><li><p>预防成本。预防特定项目的产品、可交付成果或服务质量低劣所带来的相关成本。</p></li><li><p>评估成本。评估、测量、审计和测试特定项目的产品、可交付成果或服务所带来的的相关成本。</p></li><li><p>失败成本（内部/外部）。因产品、可交付成果或服务与相关方需求或期望不一致而导致的相关成本。</p><p>最优COQ能够在预防成本和评估成本之间找到恰当的投资平衡点，以规避失败成本。有关模型表明，最有项目质量成本，指在投资额外的预防/评估成本时，既无益处又不具备成本效益。</p></li></ul></li></ul><p><img src="/images/pmp-8/8-5.png" alt="质量成本"></p><h5 id="1-2-4-决策"><a href="#1-2-4-决策" class="headerlink" title="1.2.4 决策"></a>1.2.4 决策</h5><p>适用于本过程的决策技术包括（但不限于）多标准决策分析。多标准决策分析工具（如优先矩阵）可用于识别关键事项和合适的备选方案，并通过一系列决策排列出备选方案的优先顺序。先对标准排序和加权，再应用于所有备选方案，计算出各个备选方案的数学得分，然后根据得分对备选方案排序。在本过程中，它有助于排定质量测量指标的优先顺序。</p><h5 id="1-2-5-数据表现"><a href="#1-2-5-数据表现" class="headerlink" title="1.2.5 数据表现"></a>1.2.5 数据表现</h5><p>适用于本过程的数据表现技术包括（但不限于）：</p><ul><li><p>流程图。流程图，也称过程图，用来显示在一个或多个输入转化成一个或多个输出的过程中，所需要的步骤顺序和可能分支。它通过映射水平价值链的过程细节来显示活动、决策点、分支循环、并行路径及整体处理顺序。图8-6展示了其中一个版本的价值链，即SIPOC（供应商、输入、过程、输出和客户）模型。流程图可能有助于了解和估算一个过程的质量成本。通过工作流的逻辑分支及其相对频率来估算质量成本。这些逻辑分支细分为完成符合要求的输出而需要开展的一致性工作和非一致性工作。用于展示过程步骤时，流程图有时又被称为“过程流程图”或“过程流向图”，可帮助改进过程并识别可能出现质量缺陷或可以纳入质量检查的地方。</p></li><li><p>逻辑数据模型。逻辑数据模型把组织数据可视化，以商业语言加以描述，不依赖任何特定技术。逻辑数据模型可用于识别会出现数据完整性或其它质量问题的地方。</p></li><li><p>矩阵图。矩阵图在行列交叉的位置展示因素、原因和目标之间的关系强弱。根据可用来比较因素的数量，项目经理可使用不同形状的矩阵图，如L型、T型、Y型、X型、C型和屋顶型矩阵。在本过程中，它们有助于识别对项目成功至关重要的质量测量指标。</p></li><li><p>思维导图。思维导图是一种用于可视化组织信息的绘图法。质量思维导图通常是基于单个质量概念创建的，是绘制在空白的页面中央的图像，之后再增加以图像、词汇或词条形式表现的想法。思维导图技术可以有助于快速收集项目质量要求、制约因素、依赖关系和联系。</p></li></ul><p><img src="/images/pmp-8/8-6.png" alt="SIPOC模型"></p><h5 id="1-2-6-测试与检查的规划"><a href="#1-2-6-测试与检查的规划" class="headerlink" title="1.2.6 测试与检查的规划"></a>1.2.6 测试与检查的规划</h5><p>在规划阶段，项目经理和项目团队决定如何测试或检查产品、可交付成果或服务，以满足相关方的需求和期望，以及如何满足产品的绩效和可靠性目标。不同行业有不同的测试和检查，可能包括软件项目的α测试和β测试、建筑项目的强度测试、制造和实地测试的检查，以及工程的无损伤测试。</p><h5 id="1-2-7-会议"><a href="#1-2-7-会议" class="headerlink" title="1.2.7 会议"></a>1.2.7 会议</h5><p>项目团队可以召开规划会议来制定质量管理计划。参会者可能包括项目经理、项目发起人、选定的项目团队成员、选定的相关方、项目质量管理活动的负责人，以及其他必要人员。</p><h4 id="1-3-规划质量管理：输出"><a href="#1-3-规划质量管理：输出" class="headerlink" title="1.3 规划质量管理：输出"></a>1.3 规划质量管理：输出</h4><h5 id="1-3-1-质量管理计划"><a href="#1-3-1-质量管理计划" class="headerlink" title="1.3.1 质量管理计划"></a>1.3.1 质量管理计划</h5><p>质量管理计划是项目管理计划的组成部分，描述如何实施适用的政策、程序和指南以实现质量目标。它描述了项目管理团队为实现一系列项目质量目标所需的活动和资源。质量管理计划可以是正式或非正式的，非常详细或高度概括的，其风格与详细程度取决于项目的具体需要。应该在项目早期就对质量管理计划进行评审，以确保决策是基于准确信息的。这样做的好处是，更加关注项目的价值定位，降低因返工而造成的成本超支金额和进度延误次数。</p><p>质量管理计划包括（但不限于）以下组成部分：</p><ul><li><p>项目采用的质量标准；</p></li><li><p>项目的质量目标；</p></li><li><p>质量角色与职责；</p></li><li><p>需要质量审查的项目可交付成果和过程；</p></li><li><p>为项目规划的质量控制和质量管理活动；</p></li><li><p>项目使用的质量工具；</p></li><li><p>与项目有关的主要程序，例如处理不符合要求的情况、纠正措施程序，以及持续改进程序。</p></li></ul><h5 id="1-3-2-质量测量指标"><a href="#1-3-2-质量测量指标" class="headerlink" title="1.3.2 质量测量指标"></a>1.3.2 质量测量指标</h5><p>质量测量指标专用于描述项目或产品属性，以及控制质量过程将如何验证符合程度。质量测量指标的例子包括按时完成的任务的百分比、以CPI测量的成本绩效、故障率、识别的日缺陷数量、每月总停机时间、每个代码行的错误、客户满意度分数，以及测试计划所涵盖的需求的百分比（即测试覆盖度）。</p><h5 id="1-3-3-项目管理计划更新"><a href="#1-3-3-项目管理计划更新" class="headerlink" title="1.3.3 项目管理计划更新"></a>1.3.3 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更请求的项目管理计划组成部分包括（但不限于）：</p><ul><li><p>风险管理计划。在确定质量管理方法时可能需要更改已商定的项目风险管理方法，这些变更会记录在风险管理计划中。</p></li><li><p>范围基准。如果需要增加特定的质量管理活动，范围基准可能因本过程而变更。WBS词典记录的质量要求可能需要更新。</p></li></ul><h5 id="1-3-4-项目文件更新"><a href="#1-3-4-项目文件更新" class="headerlink" title="1.3.4 项目文件更新"></a>1.3.4 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。在质量规划过程中遇到的挑战需要更新在经验教训登记册中。</p></li><li><p>需求跟踪矩阵。本过程指定的质量要求，记录在需求跟踪矩阵中。</p></li><li><p>风险登记册。在本过程中识别的新风险记录在风险登记册中，并通过风险管理过程进行管理。</p></li><li><p>相关方登记册。如果在本过程中收集到有关现有或新相关方的其他信息，则记录到相关方登记册中。</p></li></ul><hr><h3 id="二、管理质量"><a href="#二、管理质量" class="headerlink" title="二、管理质量"></a>二、管理质量</h3><p>管理质量是把组织的质量政策用于项目，并将质量管理计划转化为可执行的质量活动的过程。本过程的主要作用是，提高实现质量目标的可能性，以及识别无效过程和导致质量低劣的原因。管理质量使用控制质量过程的数据和结果向相关方展示项目的总体质量状态。本过程需要在整个项目期间开展。</p><p>图8-7描述本过程的输入、工具与技术和输出。图8-8是本过程的数据流向图。</p><p><img src="/images/pmp-8/8-7.png" alt="管理质量：输入、工具与技术和输出"></p><p><img src="/images/pmp-8/8-8.png" alt="管理质量：数据流向图"></p><p>管理质量有时被称为“质量保证”，但“管理质量”的定义比“质量保证”更广，因其可用于非项目工作。在项目管理中，质量管理着眼于项目使用的过程，旨在高效地执行项目过程，包括遵守和满足标准，向相关方保证最终产品可以满足他们的需求、期望和要求。管理质量包括所有质量保证活动，还与产品设计和过程改进有关。管理质量的工作属于质量成本框架中的一致性工作。</p><p>管理质量过程执行在项目质量管理计划中所定义的一系列有计划、有系统的行动和过程，有助于：</p><ul><li><p>通过执行有关产品特定方面的设计准则，设计出最优的成熟产品；</p></li><li><p>建立信心，相信通过质量保证工具和技术（如质量审计和故障分析）可以使未来输出在完工时满足特定的需求和期望；</p></li><li><p>确保使用质量过程并确保其使用能够满足项目的质量目标；</p></li><li><p>提高过程和活动的效率与效果，以获得更好的成果和绩效并提高相关方的满意程度。</p></li></ul><p>项目经理和项目团队可以通过组织的质量保证部门或其他组织智能执行某些管理质量活动，例如故障分析、实验设计和质量改进。质量保证部门在质量工具和技术的使用方面通常用有跨组织经验，是良好的项目资源。</p><p>管理质量被认为是所有人的共同职责，包括项目经理、项目团队、项目发起人、执行组织的管理层，甚至是客户。所有人在管理项目质量方面都扮演一定的角色，尽管这些角色的人数和工作量不同。参与质量管理工作的程度取决于所在行业和项目管理风格。在敏捷项目中，整个项目期间的质量管理由所有团队成员执行；但在传统项目中，质量管理通常是特定团队成员的职责。</p><h4 id="2-1-管理质量：输入"><a href="#2-1-管理质量：输入" class="headerlink" title="2.1 管理质量：输入"></a>2.1 管理质量：输入</h4><h5 id="2-1-1-项目管理计划"><a href="#2-1-1-项目管理计划" class="headerlink" title="2.1.1 项目管理计划"></a>2.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）质量管理计划。质量管理计划定义了项目和产品质量的可接受水平，并描述了如何确保可交付成果和过程达到这一质量水平。质量管理计划还描述了不合格产品的处理方式以及需要采取的纠正措施。</p><h5 id="2-1-2-项目文件"><a href="#2-1-2-项目文件" class="headerlink" title="2.1.2 项目文件"></a>2.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。项目早期与质量管理有关的经验教训，可以运用到项目后期阶段，以提高质量管理的效率与效果。</p></li><li><p>质量控制测量结果。质量控制测量结果用于分析和评估项目过程和可交付成果的质量是否符合执行组织的标准或特定要求。质量控制测量结果也有助于分析这些测量结果的产生过程，以确定实际测量结果的正确程度。</p></li><li><p>质量测量指标。核实质量测量指标是控制质量过程的一个环节。管理质量过程依据这些质量测量指标设定项目的测试场景和可交付成果，用作改进举措的依据。</p></li><li><p>风险报告。管理质量过程使用风险报告识别整体项目风险的来源以及整体风险敞口的最重要的驱动因素，这些因素能够影响项目的质量目标。</p></li></ul><h5 id="2-1-3-组织过程资产"><a href="#2-1-3-组织过程资产" class="headerlink" title="2.1.3 组织过程资产"></a>2.1.3 组织过程资产</h5><p>能够影响管理质量过程的组织过程资产包括（但不限于）：</p><ul><li><p>包括政策、程序及指南的组织质量管理体系；</p></li><li><p>质量模板，例如核查表、跟踪矩阵、测试计划、测试文件及其他模板；</p></li><li><p>以往审计的结果；</p></li><li><p>包含类似项目信息的经验教训知识库。</p></li></ul><h4 id="2-2-管理质量：工具与技术"><a href="#2-2-管理质量：工具与技术" class="headerlink" title="2.2 管理质量：工具与技术"></a>2.2 管理质量：工具与技术</h4><h5 id="2-2-1-数据收集"><a href="#2-2-1-数据收集" class="headerlink" title="2.2.1 数据收集"></a>2.2.1 数据收集</h5><p>适用于本过程的数据收集技术包括（但不限于）核对单。核对单是一种结构化工具，通常列出特定组成部分，用来核实所要求的一系列步骤是否已得到执行或检查需求列表是否已得到满足。基于项目需求和实践，核对单可简可繁。许多组织都有标准化的核对单，用来规范地执行经常性任务。在某些应用领域，核对单也可从专业协会或商业性服务机构获取。质量核对单应该涵盖在范围基准中定义的验收标准。</p><h5 id="2-2-2-数据分析"><a href="#2-2-2-数据分析" class="headerlink" title="2.2.2 数据分析"></a>2.2.2 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）：</p><ul><li><p>备选方案分析。该技术用于评估已识别的可选方案，以选择那些最合适的质量方案或方法。</p></li><li><p>文件分析。分析项目控制过程所输出的不同文件，如质量报告、测试报告、绩效报告和偏差分析，可以重点指出可能超出控制范围之外并阻碍项目团队满足特定要求或相关方期望的过程。</p></li><li><p>过程分析。过程分析可以识别过程改进机会，同时检查在过程期间遇到的问题、制约因素、以及非增值活动。</p></li><li><p>根本原因分析（RCA）。根本原因分析是确定引起偏差、缺陷或风险的根本原因的一种分析技术。一项根本原因可能引起多项偏差、缺陷或风险。根本原因分析还可以作为一项技术，用于识别问题的根本原因并解决问题。消除所有根本原因可以杜绝问题再次发生。</p></li></ul><h5 id="2-2-3-决策"><a href="#2-2-3-决策" class="headerlink" title="2.2.3 决策"></a>2.2.3 决策</h5><p>适用于本过程的决策技术包括（但不限于）多标准决策分析。在讨论影响项目或产品质量的备选方案时，可以使用多标准决策评估多个标准。“项目”决策可以包括在不同执行情景或供应商中加以选择，“产品”决策可以包括评估生命周期成本、进度、相关方的满意程度，以及与解决产品缺陷有关的风险。</p><h5 id="2-2-4-数据表现"><a href="#2-2-4-数据表现" class="headerlink" title="2.2.4 数据表现"></a>2.2.4 数据表现</h5><p>适用于本过程的数据表现技术包括（但不限于）：</p><ul><li><p>亲和图。亲和图可以对潜在缺陷成因进行分类，展示最应关注的领域。</p></li><li><p>因果图。因果图，又称“鱼骨图”、“why-why分析图”和“石川图”，将问题陈述的原因分解为离散的分支，有助于识别问题的主要原因或根本原因。图8-9是因果图的一个例子。</p></li><li><p>流程图。流程图展示了引发缺陷的一系列步骤。</p></li><li><p>直方图。直方图是一种展示数字数据的条形图，可以展示每个可交付成果的缺陷数量、缺陷成因的排列、各个过程的不合规次数，或项目或产品缺陷的其他表现形式。</p></li><li><p>矩阵图。矩阵图在行列交叉的位置展示因素、原因和目标之间的关系强弱。</p></li><li><p>散点图。散点图是一种展示两个变量之间的关系的图形，它能够展示两支轴的关系，一支轴表示过程、环境或活动的任何要素，另一支轴表示质量缺陷。</p></li></ul><p><img src="/images/pmp-8/8-9.png" alt="因果图"></p><h5 id="2-2-5-审计"><a href="#2-2-5-审计" class="headerlink" title="2.2.5 审计"></a>2.2.5 审计</h5><p>审计是用于确定项目活动是否遵循了组织和项目的政策、过程与程序的一种结构化且独立的过程。质量审计通常由项目外部的团队开展，如组织内部审计部门、项目管理办公室（PMO）或组织外部的审计师。质量审计目标可能包括（但不限于）：</p><ul><li><p>识别全部正在实施的良好及最佳实践；</p></li><li><p>识别所有违规做法、差距及不足；</p></li><li><p>分享所在组织和（或）行业中类似项目的良好实践；</p></li><li><p>积极、主动地提供协助，以改进过程的执行，从而帮助团队提高生产效率；</p></li><li><p>强调每次审计都应对组织经验教训知识库的积累做出贡献。</p></li></ul><p>采取后续措施纠正问题，可以降低质量成本，并提高发起人或客户对项目产品的接受度。质量审计可事先安排，也可随机进行；可由内部或外部审计师进行。</p><p>质量审计还可确认已批准的变更请求（包括更新、纠正措施、缺陷补救和预防措施）的实施情况。</p><h5 id="2-2-6-面向X的设计"><a href="#2-2-6-面向X的设计" class="headerlink" title="2.2.6 面向X的设计"></a>2.2.6 面向X的设计</h5><p>面向X的设计（DfX）是产品设计期间可采用的一系列技术指南，旨在优化设计的特定方面，可以控制或提高产品最终特性。DfX中的“X”可以是产品开发的不同方面，例如可靠性、调配、装配、制造、成本、服务、可用性、安全性和质量。使用DfX可以降低成本、改进质量、提高绩效和客户满意度。</p><h5 id="2-2-7-问题解决"><a href="#2-2-7-问题解决" class="headerlink" title="2.2.7 问题解决"></a>2.2.7 问题解决</h5><p>问题解决发现解决问题或应对挑战的解决方案。它包括收集其他信息、具有批判性思维的、创造性的、量化的和（或）逻辑性的解决方法。有效和系统化地解决问题是质量保证和质量改进的基本要素。问题可能在控制质量过程或质量审计中发现，也可能与过程或可交付成果有关。使用结构化的问题解决方法有助于消除问题和制定长久有效的解决方案。问题解决方法通常包括以下要素：</p><ul><li><p>定义问题；</p></li><li><p>识别根本原因；</p></li><li><p>生成可能的解决方案；</p></li><li><p>选择最佳解决方案；</p></li><li><p>执行解决方案；</p></li><li><p>验证解决方案的有效性。</p></li></ul><h5 id="2-2-8-质量改进方法"><a href="#2-2-8-质量改进方法" class="headerlink" title="2.2.8 质量改进方法"></a>2.2.8 质量改进方法</h5><p>质量改进的开展，可基于质量控制过程的发现和建议、质量审计的发现，或管理质量过程的问题解决。计划——实施——检查——行动和六西格玛是最常用于分析和评估改进机会的两种质量改进工具。</p><h4 id="2-3-管理质量：输出"><a href="#2-3-管理质量：输出" class="headerlink" title="2.3 管理质量：输出"></a>2.3 管理质量：输出</h4><h5 id="2-3-1-质量报告"><a href="#2-3-1-质量报告" class="headerlink" title="2.3.1 质量报告"></a>2.3.1 质量报告</h5><p>质量报告可能是图形、数据或定性文件，其中包含的信息可帮助其他过程和部门采取纠正措施，以实现项目质量期望。质量报告的信息可以包含团队上报的质量管理问题，针对过程、项目和产品的改善建议，纠正措施建议（包括返工、缺陷/漏洞补救、100%检查等），以及在控制质量过程中发现的情况的概述。</p><h5 id="2-3-2-测试与评估文件"><a href="#2-3-2-测试与评估文件" class="headerlink" title="2.3.2 测试与评估文件"></a>2.3.2 测试与评估文件</h5><p>可基于行业需求和组织模板创建测试与评估文件。它们是控制质量过程的输入，用于评估质量目标的实现情况。这些文件可能包括专门的核对单和详尽的需求跟踪矩阵。</p><h5 id="2-3-3-变更请求"><a href="#2-3-3-变更请求" class="headerlink" title="2.3.3 变更请求"></a>2.3.3 变更请求</h5><p>如果管理质量过程期间出现了可能影响项目管理计划任何组成部分、项目文件或项目/产品管理过程的变更，项目经理应提交变更请求并遵循实施整体变更控制过程。</p><h5 id="2-3-4-项目管理计划更新"><a href="#2-3-4-项目管理计划更新" class="headerlink" title="2.3.4 项目管理计划更新"></a>2.3.4 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更请求的项目管理计划组成部分包括（但不限于）：</p><ul><li><p>质量管理计划。可能需要根据实际结果修改已商定的质量管理方法。</p></li><li><p>范围基准。范围基准可能因特定的质量管理活动而变更。</p></li><li><p>进度基准。进度基准可能因特定的质量管理活动而变更。</p></li><li><p>成本基准。成本基准可能因特定的质量管理活动而变更。</p></li></ul><h5 id="2-3-5-项目文件更新"><a href="#2-3-5-项目文件更新" class="headerlink" title="2.3.5 项目文件更新"></a>2.3.5 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>问题日志。在本过程中提出的新问题记录到问题日志中。</p></li><li><p>经验教训登记册。项目中遇到的挑战、本应可以规避这些挑战的方法，以及良好的质量管理方式，需要记录在经验教训登记册中。</p></li><li><p>风险登记册。在本过程中识别的新风险记录在风险登记册中，并通过风险管理过程进行管理。</p></li></ul><hr><h3 id="三、控制质量"><a href="#三、控制质量" class="headerlink" title="三、控制质量"></a>三、控制质量</h3><p>控制质量是为了评估绩效，确保项目输出完整、正确且满足客户期望，而监督和记录质量管理活动执行结果的过程。本过程的主要作用是，核实项目可交付成果和工作已经达到主要相关方的质量要求，可供最终验收。控制质量过程确定项目输出是否达到预期目的，这些输出需要满足所有适用标准、要求、法规和规范。本过程需要在整个项目期间开展。</p><p>图8-10描述本过程的输入、工具与技术和输出。图8-11是本过程的数据流向图。</p><p><img src="/images/pmp-8/8-10.png" alt="控制质量：输入、工具与技术和输出"></p><p><img src="/images/pmp-8/8-11.png" alt="控制质量：数据流向图"></p><p>控制质量过程的目的是在用户验收和最终交付之前测试产品或服务的完整性、合规性和适用性。本过程通过测量所有步骤、属性和变量，来核实与规划阶段所描述规范的一致性和合规性。</p><p>在整个项目期间应执行质量控制，用可靠的数据来证明项目已经达到发起人和（或）客户的验收标准。</p><p>控制质量的努力程度和执行程度可能会因所在行业和项目管理风格而不同。例如，相比其他行业，制药、医疗、运输和核能产业可能拥有更加严格的质量控制程序，为满足标准付出的工作也会更广；在敏捷项目中，控制质量活动可能由所有团队成员在整个项目生命周期中执行，而在瀑布式项目中，控制质量活动由特定团队成员在特定时间点或者项目或阶段快结束时执行。</p><h4 id="3-1-控制质量：输入"><a href="#3-1-控制质量：输入" class="headerlink" title="3.1 控制质量：输入"></a>3.1 控制质量：输入</h4><h5 id="3-1-1-项目管理计划"><a href="#3-1-1-项目管理计划" class="headerlink" title="3.1.1 项目管理计划"></a>3.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）质量管理计划。质量管理计划定义了如何在项目中开展质量控制。</p><h5 id="3-1-2-项目文件"><a href="#3-1-2-项目文件" class="headerlink" title="3.1.2 项目文件"></a>3.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。在项目早期获得的经验教训可以运用到后期阶段，以改进质量控制。</p></li><li><p>质量测量指标。质量测量指标专用于描述项目或产品属性，以及控制质量过程将如何验证符合程度。</p></li><li><p>测试与评估文件。测试与评估文件用于评估质量目标的实现程度。</p></li></ul><h5 id="3-1-3-批准的变更请求"><a href="#3-1-3-批准的变更请求" class="headerlink" title="3.1.3 批准的变更请求"></a>3.1.3 批准的变更请求</h5><p>在实施整体变更控制过程中，通过更新变更日志，显示哪些变更已经得到批准，哪些变更没有得到批准。批准的变更请求可包括各种修正，如缺陷补救、修订的工作方法和修订的进度计划。完成局部变更时，如果步骤不完整活不正确，可能会导致不一致和延迟。批准的变更请求的实施需要核实，并需要确认完整性、正确性，以及是否重新测试。</p><h5 id="3-1-4-可交付成果"><a href="#3-1-4-可交付成果" class="headerlink" title="3.1.4 可交付成果"></a>3.1.4 可交付成果</h5><p>可交付成果指的是在某一过程、阶段或项目完成时，必须产出的任何独特并可核实的产品、成果或服务能力。作为指导与管理项目工作过程的输出的可交付成果将得到检查，并与项目范围说明书定义的验收标准作比较。</p><h5 id="3-1-5-工作绩效数据"><a href="#3-1-5-工作绩效数据" class="headerlink" title="3.1.5 工作绩效数据"></a>3.1.5 工作绩效数据</h5><p>工作绩效数据包括产品状态数据，例如观察结果、质量测量指标、技术绩效测量数据，以及关于进度绩效和成本绩效的项目质量信息。</p><h5 id="3-1-6-事业环境因素"><a href="#3-1-6-事业环境因素" class="headerlink" title="3.1.6 事业环境因素"></a>3.1.6 事业环境因素</h5><p>能够影响控制质量过程的事业环境因素包括（但不限于）：</p><ul><li><p>项目管理信息系统；质量管理软件可用于跟进过程或可交付成果中的错误和差异；</p></li><li><p>政府法规；</p></li><li><p>特定应用领域的相关规则、标准和指南。</p></li></ul><h5 id="3-1-7-组织过程资产"><a href="#3-1-7-组织过程资产" class="headerlink" title="3.1.7 组织过程资产"></a>3.1.7 组织过程资产</h5><p>能够影响质量过程的组织过程资产包括（但不限于）：</p><ul><li><p>质量标准和政策；</p></li><li><p>质量模板，例如核查表、核对单等；</p></li><li><p>问题与缺陷报告程序及沟通政策。</p></li></ul><h4 id="3-2-控制质量：工具与技术"><a href="#3-2-控制质量：工具与技术" class="headerlink" title="3.2 控制质量：工具与技术"></a>3.2 控制质量：工具与技术</h4><h5 id="3-2-1-数据收集"><a href="#3-2-1-数据收集" class="headerlink" title="3.2.1 数据收集"></a>3.2.1 数据收集</h5><p>适用于本过程的数据收集技术包括（但不限于）：</p><ul><li><p>核对单。核对单有助于以结构化方式管理控制质量活动。</p></li><li><p>核查表。核查表，又称计数表，用于合理排列各种事项，以便有效地收集关于潜在质量问题的有用数据。在开展检查以识别缺陷时，用核查表收集属性数据就特别方便，例如关于缺陷数量或后果的数据。见图8-12。</p></li></ul><p><img src="/images/pmp-8/8-12.png" alt="核查表"></p><ul><li><p>统计抽样。统计抽样是指从目标总体中选取部分样本用于检查（如从75张工程图纸中随机抽取10张）。样本用于测量控制和确认质量。抽样的频率和规模应在规划质量管理过程中确定。</p></li><li><p>问卷调查。问卷调查可用于在部署产品或服务之后收集关于客户满意度的数据。在问卷调查中识别的缺陷相关成本可被视为COQ模型中的外部失败成本，给组织带来的影响会超出成本本身。</p></li></ul><h5 id="3-2-2-数据分析"><a href="#3-2-2-数据分析" class="headerlink" title="3.2.2 数据分析"></a>3.2.2 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）：</p><ul><li><p>绩效审查。绩效审查针对实际结果，测量、比较和分析规划质量管理过程中定义的质量测量指标。</p></li><li><p>根本原因分析（RCA）。根本原因分析用于识别缺陷成因。</p></li></ul><h5 id="3-2-3-检查"><a href="#3-2-3-检查" class="headerlink" title="3.2.3 检查"></a>3.2.3 检查</h5><p>检查是指检验工作产品，以确定是否符合书面标准。检查的结果通常包括相关的测量数据，可在任何层面上进行。可以检查单个活动的成果，也可以检查项目的最终产品。检查也可称为审查、同行审查、审计或巡检等，而在某些应用领域，这些术语的含义比较狭窄和具体。检查也可用于确认缺陷补救。</p><h5 id="3-2-4-测试-产品评估"><a href="#3-2-4-测试-产品评估" class="headerlink" title="3.2.4 测试/产品评估"></a>3.2.4 测试/产品评估</h5><p>测试是一种有组织的、结构化的调查，旨在根据项目需求提供有关被测产品或服务质量的客观信息。测试的目的是找出产品或服务中存在的错误、缺陷、漏洞或其他不合规问题。用于评估各项需求的测试的类型、数量和程度是项目质量计划的一部分，具体取决于项目的性质、时间、预算或其他制约因素。测试可以贯穿于整个项目，可以随着项目的不同组成部分变得可用时进行，也可以在项目结束（即交付最终可交付成果）时进行。早期测试有助于识别不合规问题，帮助减少修补不合规组件的成本。</p><p>不同应用领域需要不同测试。例如，软件测试可能包括单元测试、集成测试、黑盒测试、白盒测试、接口测试、回归测试、α测试等；在建筑项目中，测试可能包括水泥强度测试、混凝土和易性测试、在建筑工地进行的旨在测试硬化混凝土结构和质量的无损伤测试，以及土壤试验；在硬件开发中，测试可能包括环境应力筛选、老化测试、系统测试等。</p><h5 id="3-2-5-数据表现"><a href="#3-2-5-数据表现" class="headerlink" title="3.2.5 数据表现"></a>3.2.5 数据表现</h5><p>适用于本过程的数据表现技术包括（但不限于）：</p><ul><li><p>因果图。因果图用于识别质量缺陷和错误可能造成的结果。</p></li><li><p>控制图。控制图用于确定一个过程是否稳定，或者是否具有可预测的绩效。规格上限和下限是根据要求制定的，反映了可允许的最大值和最小值。上下控制界限不同于规格界限。控制界限根据标准的统计原则，通过标准的统计计算确定，代表一个稳定过程的自然波动范围。项目经理和相关方可基于计算出的控制界限，识别须采取纠正措施的检查点，以预防不在控制界限内的绩效。控制图可用于监测各种类型的输出变量。虽然控制图最常用来跟踪批量生产中的重复性活动，但也可用来检测成本与进度偏差、产量、范围变更频率或其他管理工作成果，以便帮助确定项目管理过程是否受控。</p></li><li><p>直方图。直方图可按来源或组成部分展示缺陷数量。</p></li><li><p>散点图。散点图可在一直轴上展示计划的绩效，在另一支轴上展示实际绩效。</p></li></ul><h5 id="3-2-6-会议"><a href="#3-2-6-会议" class="headerlink" title="3.2.6 会议"></a>3.2.6 会议</h5><p>以下会议可作为控制质量过程的一部分：</p><ul><li><p>审查已批准的变更请求。对所有已批准的变更请求进行审查，以核实它们是否已按批准的方式实施，确认是否已完成拒不变更，以及是否已执行、测试、完成和证实所有部分。</p></li><li><p>回顾/经验教训。项目团队举行的会议，旨在讨论：</p><ul><li><p>项目/阶段的成功要素；</p></li><li><p>待改进之处；</p></li><li><p>当前项目和未来项目可增加的内容；</p></li><li><p>可增加到组织过程资产中的内容。</p></li></ul></li></ul><h4 id="3-3-控制质量：输出"><a href="#3-3-控制质量：输出" class="headerlink" title="3.3 控制质量：输出"></a>3.3 控制质量：输出</h4><h5 id="3-3-1-质量控制测量结果"><a href="#3-3-1-质量控制测量结果" class="headerlink" title="3.3.1 质量控制测量结果"></a>3.3.1 质量控制测量结果</h5><p>控制质量的测量结果是对质量控制活动的结果的书面记录，应以质量管理计划所确定的格式加以记录。</p><h5 id="3-3-2-核实的可交付成果"><a href="#3-3-2-核实的可交付成果" class="headerlink" title="3.3.2 核实的可交付成果"></a>3.3.2 核实的可交付成果</h5><p>控制质量过程的一个目的就是确定可交付成果的正确性。开展控制质量过程的结果是核实的可交付成果，后者又是确认范围过程的一项输入，以便正式验收。如果存在任何与可交付成果有关的变更请求或改进事项，可能会执行变更、开展检查并重新核实。</p><h5 id="3-3-3-工作绩效信息"><a href="#3-3-3-工作绩效信息" class="headerlink" title="3.3.3 工作绩效信息"></a>3.3.3 工作绩效信息</h5><p>工作绩效信息包含有关项目需求实现情况的信息、拒绝的原因、要求的返工、纠正措施建议、核实的可交付成果列表、质量测量指标的状态，以及过程调整需求。</p><h5 id="3-3-4-变更请求"><a href="#3-3-4-变更请求" class="headerlink" title="3.3.4 变更请求"></a>3.3.4 变更请求</h5><p>如果控制质量过程期间出现了可能影响项目管理计划任何组成部分或项目文件的变更，项目经理应提交变更请求，且应该通过实施整体变更控制过程对变更请求进行审查和处理。</p><h5 id="3-3-5-项目管理计划更新"><a href="#3-3-5-项目管理计划更新" class="headerlink" title="3.3.5 项目管理计划更新"></a>3.3.5 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更请求的项目管理计划组成部分包括（但不限于）质量管理计划。</p><h5 id="3-3-6-项目文件更新"><a href="#3-3-6-项目文件更新" class="headerlink" title="3.3.6 项目文件更新"></a>3.3.6 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>问题日志。多次不符合质量要求的可交付成果通常被记录为问题。</p></li><li><p>经验教训登记册。质量缺陷的来源、本应可以规避它们的方法，以及有效的处理方式，都应该记录到经验教训登记册中。</p></li><li><p>风险登记册。在本过程中识别的新风险记录在风险登记册中，并通过风险管理过程进行管理。</p></li><li><p>测试与评估文件。本过程可能导致测试与评估文件修改，使未来的测试更加有效。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《PMBOK第六版》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目质量管理包括把组织的质量政策应用于规划、管理、控制项目和产品质量要求，以满足相关方目标的各个过程。此外，项目质量管理以执行组织的名义支持过程的持续改进活动。&lt;/p&gt;
    
    </summary>
    
      <category term="PMP抄书系列" scheme="http://www.xiaoleon.cn/categories/PMP%E6%8A%84%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="pmp" scheme="http://www.xiaoleon.cn/tags/pmp/"/>
    
  </entry>
  
  <entry>
    <title>PMP(7) 项目成本管理</title>
    <link href="http://www.xiaoleon.cn/2019/02/14/pmp-7/"/>
    <id>http://www.xiaoleon.cn/2019/02/14/pmp-7/</id>
    <published>2019-02-14T13:25:24.000Z</published>
    <updated>2019-05-13T09:48:01.429Z</updated>
    
    <content type="html"><![CDATA[<p>项目成本管理包括为使项目在批准的预算内完成而对成本进行规划、估算、预算、融资、筹资、管理和控制的各个过程，从而确保项目在批准的预算内完工。</p><a id="more"></a><p>项目成本管理过程包括：</p><ul><li><p><strong>规划成本管理</strong> —— 确定如何估算、预算、管理、监督和控制项目成本的过程。</p></li><li><p><strong>估算成本</strong> —— 对完成项目活动所需货币资源进行近似估算的过程。</p></li><li><p><strong>制定预算</strong> —— 汇总所有单个活动或工作包的估算成本，建立一个经批准的成本基准的过程。</p></li><li><p><strong>控制成本</strong> —— 监督项目状态，以更新项目成本和管理成本基准变更的过程。</p></li></ul><p>图7-1概括了项目成本管理的各个过程。虽然在本《PMBOK指南》中，各项目成本管理过程以界限分明和相互独立的形式出现，但在实践中它们会以本指南无法全面详述的方式相互交叠和相互作用。这些过程不仅彼此相互作用，而且还与其他知识领域中的过程相互作用。</p><p>在某些过程，特别是范围较小的项目中，成本估算和成本预算之间的联系非常紧密，以至于可视为一个过程，由一个人在较短时间内完成。但本章仍然把这两个过程分开来介绍，因为它们所用的工具和技术各不相同。对成本的影响力在项目早期最大，因此尽早定义范围就至关重要。</p><p><img src="/images/pmp-7/7-1.png" alt="项目成本管理概述"></p><p><strong>项目成本管理的核心概念</strong></p><p>项目成本管理重点关注完成项目活动所需资源的成本，但同时也应考虑项目决策对项目产品、服务或成果的使用成本、维护成本和支持成本的影响。例如，限制设计审查的次数可降低项目成本，但可能增加由此带来的产品运营成本。</p><p>成本管理的另一方面是认识到不同的相关方会在不同的时间，用不同的方法测算项目成本。例如，对于某采购品，可在做出采购决策、下达订单、实际交货、实际成本发生或进行项目会计记账时，测算其成本。在很多组织中，预测和分析项目产品的财务效益是在项目之外进行的，但对于有些项目，如固定资产投资项目，可在项目成本管理中进行这项预测和分析工作。在这种情况下，项目成本管理还需使用其他过程和许多通用财务管理技术，如投资回报率分析、现金流贴现分析和投资回收期分析等。</p><p><strong>项目成本管理的趋势和新兴实践</strong></p><p>在项目成本管理的实践中，通过对挣值管理（EVM）的扩展，引入挣得进度（ES）这一概念。</p><p>ES是EVM理论和实践的延伸。挣得进度理论用ES和实际时间（AT）替代了传统的EVM所使用的进度偏差测量指标（挣值-计划价值），使用这种替代方法计算进度偏差ES-AT，如果挣得进度大于0，则表示项目进度提前了；换句话说，在某个给定的时间点，项目的挣值大于计划价值。使用挣得进度测量指标的进度绩效指数SPI为ES与AT之比，表示完成项目的工作效率。此外，挣得进度理论通过挣得进度、实际时间和估算持续时间，提供了预测项目完成日期的计算公式。</p><p><strong>裁剪考虑因素</strong></p><p>由于每个项目都是独特的，项目经理因此可能需要裁剪项目成本管理过程。裁剪时应考虑的因素包括（但不限于）：</p><ul><li><p>知识管理。组织是否拥有易于使用的、正式的知识管理体系和财务数据库，并要求项目经理使用？</p></li><li><p>估算和预算。组织是否拥有正式或非正式的，与成本估算和预算相关的政策、程序和指南？</p></li><li><p>挣值管理。组织是否采用挣值管理来管理项目？</p></li><li><p>敏捷方法的使用。组织是否采用敏捷方法管理项目？这对成本估算有什么影响？</p></li><li><p>治理。组织是否拥有正式或非正式的审计和治理政策、程序和指南？</p></li></ul><p><strong>关于敏捷/适应型环境的考虑因素</strong></p><p>对易变性高、范围并未完全明确、经常发生变更的项目，详细的成本计算可能没有多大帮助。在这种情况下，可以采用轻量级估算方法快速生成对项目人力成本的高层级预测，在出现变更时容易调整预测；而详细的估算适用于采用准时制的短期规划。</p><p>如果易变的项目也遵循严格的预算，通常需要更频繁的更改范围和进度计划，以始终保持在成本制约因素之内。</p><h3 id="一、规划成本管理"><a href="#一、规划成本管理" class="headerlink" title="一、规划成本管理"></a>一、规划成本管理</h3><p>规划成本管理是确定如何估算、预算、管理、监督和控制项目成本的过程。本过程的主要作用是，在整个项目期间为如何管理项目成本提供指南和方向。本过程仅开展一次或仅在项目的预定义点开展。图7-2描述本过程的输入、工具与技术和输出，图7-3是本过程的数据流向图。</p><p><img src="/images/pmp-7/7-2.png" alt="规划成本管理：输入、工具与技术和输出"></p><p><img src="/images/pmp-7/7-3.png" alt="规划成本管理：数据流向图"></p><p>应该在项目规划阶段的早期就对成本管理工作进行规划，建立个成本管理过程的基本框架，以确保各过程的有效性及各过程之间的协调性。成本管理计划是项目管理计划的组成部分，其过程及工具与技术应记录在成本管理计划中。</p><h5 id="1-1-规划成本管理：输入"><a href="#1-1-规划成本管理：输入" class="headerlink" title="1.1 规划成本管理：输入"></a>1.1 规划成本管理：输入</h5><h5 id="1-1-1-项目章程"><a href="#1-1-1-项目章程" class="headerlink" title="1.1.1 项目章程"></a>1.1.1 项目章程</h5><p>项目章程规定了预先批准的财务资源，可据此确定详细的项目成本。项目章程所规定的项目审批要求，也对项目成本管理有影响。</p><h5 id="1-1-2-项目管理计划"><a href="#1-1-2-项目管理计划" class="headerlink" title="1.1.2 项目管理计划"></a>1.1.2 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>进度管理计划。进度管理计划确定了编制、监督和控制项目进度的准则和活动，同时也提供了影响成本估算和管理的过程及控制方法。</p></li><li><p>风险管理计划。风险管理计划提供了识别、分析和监督风险的方法，同时也提供了影响成本估算和管理的过程及控制方法。</p></li></ul><h5 id="1-1-3-事业环境因素"><a href="#1-1-3-事业环境因素" class="headerlink" title="1.1.3 事业环境因素"></a>1.1.3 事业环境因素</h5><p>能够影响成本管理过程的事业环境因素包括（但不限于）：</p><ul><li><p>能够影响成本管理的组织文化和组织结构；</p></li><li><p>市场条件，决定着在当地及全球市场上可获取哪些产品、服务和成果；</p></li><li><p>货币汇率，用于换算发生在多个国家的项目成本；</p></li><li><p>发布的商业信息，经常可以从商业数据库中获取资源成本费率及相关信息，而这些数据库动态跟踪具有相应技能的人力资源的成本数据，也提供材料与设备的标准成本数据；还可以从卖方公布的价格清单中获取相关信息；</p></li><li><p>项目管理信息系统，可为管理成本提供多种方案；</p></li><li><p>不同地区的生产率差异，可能会对项目成本造成巨大影响。</p></li></ul><h5 id="1-1-4-组织过程资产"><a href="#1-1-4-组织过程资产" class="headerlink" title="1.1.4 组织过程资产"></a>1.1.4 组织过程资产</h5><p>能够影响规划成本管理过程的组织过程资产包括（但不限于）：</p><ul><li><p>财务控制程序（如定期报告、必须的费用与支付审查、会计编码及标准合同条款等）；</p></li><li><p>历史信息和经验教训知识库；</p></li><li><p>财务数据库；</p></li><li><p>现有的正式和非正式的与成本估算和预算有关的政策、程序和指南。</p></li></ul><h4 id="1-2-规划成本管理：工具与技术"><a href="#1-2-规划成本管理：工具与技术" class="headerlink" title="1.2 规划成本管理：工具与技术"></a>1.2 规划成本管理：工具与技术</h4><h5 id="1-2-1-专家判断"><a href="#1-2-1-专家判断" class="headerlink" title="1.2.1 专家判断"></a>1.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>以往类似项目；</p></li><li><p>来自行业、学科和应用领域的信息；</p></li><li><p>成本估算和预算；</p></li><li><p>挣值管理。</p></li></ul><h5 id="1-2-2-数据分析"><a href="#1-2-2-数据分析" class="headerlink" title="1.2.2 数据分析"></a>1.2.2 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）备选方案分析。备选方案分析可包括审查筹资的战略方法，如自筹资金、股权投资、借贷投资等，还可以包括对筹集项目资源的方法（如自制、采购、租用或租赁）的考量。</p><h5 id="1-2-3-会议"><a href="#1-2-3-会议" class="headerlink" title="1.2.3 会议"></a>1.2.3 会议</h5><p>项目团队可能举行规划会议来制定成本管理计划。参会者可能包括项目经理、项目发起人、选定的项目团队成员、选定的相关方、项目成本负责人，以及其他必要人员。</p><h4 id="1-3-规划成本管理：输出"><a href="#1-3-规划成本管理：输出" class="headerlink" title="1.3 规划成本管理：输出"></a>1.3 规划成本管理：输出</h4><h5 id="1-3-1-成本管理计划"><a href="#1-3-1-成本管理计划" class="headerlink" title="1.3.1 成本管理计划"></a>1.3.1 成本管理计划</h5><p>成本管理计划是项目管理计划的组成部分，描述将如何规划、安排和控制项目成本。成本管理过程及其工具与技术应记录在成本管理计划中。</p><p>例如，在成本管理计划中规定：</p><ul><li><p>计量单位。需要规定每种资源的计量单位，例如用于测量时间的人时数、人天数或周数，用于计量数量的米、升、吨、千米或立方码，或者用货币表示的总价。</p></li><li><p>精确度。根据活动范围和项目规模，设定成本估算向上或向下取整的程度（例如995.59美元取整为1000美元）。</p></li><li><p>准确度。为活动成本估算规定一个可接受的区间（如±10%），其中可能包括一定数量的应急储备。</p></li><li><p>组织程序链接。工作分解结构为成本管理计划提供了框架，以便据此规范地开展成本估算、预算和控制。在项目成本核算中使用的WBS组成部分，称为控制账户（CA），每个控制账户都有唯一的编码或账号，直接与执行组织的会计制度相联系。</p></li><li><p>控制临界值。可能需要规定偏差临界值，用于监督成本绩效。它是在需要采取某种措施前，允许出现的最大差异，通常用偏离基准计划的百分数来表示。</p></li><li><p>绩效测量规则。需要规定用于绩效测量的挣值管理（EVM）规则。例如，成本管理计划应该：</p><ul><li><p>定义WBS中用于绩效测量的控制账户；</p></li><li><p>确定拟用的EVM技术（如加权里程碑法、固定公式法、完成百分比法等）；</p></li><li><p>规定跟踪方法，以及用于计算项目完工估算（EAC）的EVM公式，该公式计算出的结果可用于验证通过自下而上方法得出的完工估算。</p></li></ul></li><li><p>报告格式。需要规定各种成本报告的格式和编制频率。</p></li><li><p>其他细节。关于成本管理活动的其他细节包括（但不限于）：</p><ul><li><p>对战略筹资方案的说明；</p></li><li><p>处理汇率波动的程序；</p></li><li><p>记录项目成本的程序。</p></li></ul></li></ul><p>关于整治管理的更多信息，参见《挣值管理实践标准》。</p><hr><h3 id="二、估算成本"><a href="#二、估算成本" class="headerlink" title="二、估算成本"></a>二、估算成本</h3><p>估算成本是对完成项目工作所需资源成本进行近似估算的过程。本过程的主要作用是，确定项目所需的资金。本过程应根据需要在整个项目期间定期开展。图7-4描述本过程的输入、工具与技术和输出，图7-5是本过程的数据流向图。</p><p><img src="/images/pmp-7/7-4.png" alt="估算成本：输入、工具与技术和输出"></p><p><img src="/images/pmp-7/7-5.png" alt="估算成本：数据流向图"></p><p>成本估算是对完成活动所需资源的可能成本的量化评估，是在某特定时点，根据已知信息所做出的成本预测。在估算成本时，需要识别和分析可用于启动与完成项目的备选成本方案；需要权衡备选成本方案并考虑风险，如比较自制成本与外购成本、购买成本与租赁成本及多种资源共享方案，以优化项目成本。</p><p>通常用某种货币单元（如美元、欧元、日元等）进行成本估算，但有时也可采用其他计量单位，如人时数或人天数，以消除通货膨胀的影响，便于成本比较。</p><p>在项目过程中，应该随着更详细信息的呈现和假设条件的验证，对成本估算进行审查和优化。在项目生命周期中，项目估算的准确性亦将随着项目的进展而逐步提高。例如，在启动阶段可得出项目的粗略量级估算（Rough Order of Magnitude，ROM），其区间为-25%到+75%；之后，随着信息越来越详细，确定性估算的区间可缩小至-5%到+10%。某些组织已经制定出相应的指南，规定何时进行优化，以及每次优化所要达到的置信度或准确度。</p><p>进行成本估算，应该考虑将向项目收费的全部资源，包括（但不限于）人工、材料、设备、服务、设施，以及一些特殊的成本种类，如通货膨胀补贴、融资成本或应急成本。成本估算可在活动层级呈现，也可以汇总形式呈现。</p><h4 id="2-1-估算成本：输入"><a href="#2-1-估算成本：输入" class="headerlink" title="2.1 估算成本：输入"></a>2.1 估算成本：输入</h4><h5 id="2-1-1-项目管理计划"><a href="#2-1-1-项目管理计划" class="headerlink" title="2.1.1 项目管理计划"></a>2.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>成本管理计划。成本管理计划描述了可使用的估算方法以及成本估算需要达到的准确度和精确度。</p></li><li><p>质量管理计划。质量管理计划描述了项目管理团队为实现一系列项目质量目标所需的活动和资源。</p></li><li><p>范围基准。范围基准包括项目范围说明书、WBS和WBS词典：</p><ul><li><p>项目范围说明书。范围说明书反映了因项目资金支出的周期而产生的资金制约因素，或其他财务假设条件和制约因素。</p></li><li><p>工作分解结构。WBS指明了项目全部可交付成果及其各组成部分之间的相互关系。</p></li><li><p>WBS词典。在WBS词典和相关的详细工作说明书中，列明了可交付成果，并描述了为产出可交付成果，WBS各组成部分所需进行的工作。</p></li></ul></li></ul><h5 id="2-1-2-项目文件"><a href="#2-1-2-项目文件" class="headerlink" title="2.1.2 项目文件"></a>2.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。项目早期与制定成本估算有关的经验教训可以运用到项目后期阶段，以提高成本估算的准确度和精确度。</p></li><li><p>项目进度计划。进度计划包括项目可用的团队和实物资源的类型、数量和可用时间长短。如果资源成本取决于使用时间的长短，并且成本出现季节波动，则持续时间估算会对成本估算产生影响。进度计划还为包含融资成本（包括利息）的项目提供有用信息。</p></li><li><p>资源需求。资源需求明确了每个工作包或活动所需的资源类型和数量。</p></li><li><p>风险登记册。风险登记册包含了已识别并按优先顺序排列的单个项目风险的详细信息，及针对这些风险采取的应对措施。风险登记册还提供了可用于估算成本的详细信息。</p></li></ul><h5 id="2-1-3-事业环境因素"><a href="#2-1-3-事业环境因素" class="headerlink" title="2.1.3 事业环境因素"></a>2.1.3 事业环境因素</h5><p>会影响估算成本过程的事业环境因素包括（但不限于）：</p><ul><li><p>市场条件。可以从市场上获得什么产品、服务和成果，可以从谁那里、以什么条件获得。地区和（或）全球性的供求情况会显著影响资源成本。</p></li><li><p>发布的商业信息。经常可以从商业数据库中获取资源成本费率及相关信息，而这些数据库动态跟踪具有相应技能的人力资源的成本数据，也提供材料与设备的标准成本数据；还可以从卖方公布的价格清单中获取相关信息。</p></li><li><p>汇率和通货膨胀率。对于持续多年、涉及多种货币的大规模项目，需要了解汇率波动和通货膨胀，并将其纳入估算成本过程。</p></li></ul><h5 id="2-1-4-组织过程资产"><a href="#2-1-4-组织过程资产" class="headerlink" title="2.1.4 组织过程资产"></a>2.1.4 组织过程资产</h5><p>会影响估算成本过程的组织过程资产包括（但不限于）：</p><ul><li><p>成本估算政策；</p></li><li><p>成本估算模版；</p></li><li><p>历史信息和经验教训知识库。</p></li></ul><h4 id="2-2-估算成本：工具与技术"><a href="#2-2-估算成本：工具与技术" class="headerlink" title="2.2 估算成本：工具与技术"></a>2.2 估算成本：工具与技术</h4><h5 id="2-2-1-专家判断"><a href="#2-2-1-专家判断" class="headerlink" title="2.2.1 专家判断"></a>2.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>以往类似项目；</p></li><li><p>来自行业、学科和应用领域的信息；</p></li><li><p>成本估算方法。</p></li></ul><h5 id="2-2-2-类比估算"><a href="#2-2-2-类比估算" class="headerlink" title="2.2.2 类比估算"></a>2.2.2 类比估算</h5><p>成本类比估算使用以往类似项目的参数值或属性来估算。项目的参数值和属性包括（但不限于）范围、成本、预算、持续时间和规模指标（如尺寸、重量），类比估算以这些项目参数值或属性为基础来估算当前项目的同类参数或指标。</p><h5 id="2-2-3-参数估算"><a href="#2-2-3-参数估算" class="headerlink" title="2.2.3 参数估算"></a>2.2.3 参数估算</h5><p>参数估算是指利用历史数据之间的统计关系和其他变量（如建筑施工中的平方英尺），来进行项目工作的成本估算，参数估算的准确性取决于参数模型的成熟度和基础数据的可靠性。参数估算可以针对整个项目或项目中的某个部分，并可与其他估算方法联合使用。</p><h5 id="2-2-4-自下而上估算"><a href="#2-2-4-自下而上估算" class="headerlink" title="2.2.4 自下而上估算"></a>2.2.4 自下而上估算</h5><p>自下而上估算是对工作组成部分进行估算的一种方法。首先对单个工作包或活动的成本进行最具体、细致的估算，然后把这些细节性成本向上汇总或“滚动”到更高层次，用于后续报告和跟踪。自下而上估算的准确性及其本身所需的成本，通常取决于单个活动或工作包的规模或其他属性。</p><h5 id="2-2-5-三点估算"><a href="#2-2-5-三点估算" class="headerlink" title="2.2.5 三点估算"></a>2.2.5 三点估算</h5><p>通过考虑估算中的不确定性和风险，使用三种估算值来界定活动成本的近似区间，可以提高单点成本估算的准确性：</p><ul><li><p>最可能成本（<code>cM</code>）。对所需进行的工作和相关费用进行比较现实的估算，所得到的活动成本。</p></li><li><p>最乐观成本（<code>cO</code>）。基于活动的最好情况所得到的成本。</p></li><li><p>最悲观成本（<code>cP</code>）。基于活动的最差情况所得到的成本。</p></li></ul><p>基于活动成本在三种估算值区间内的假定分布情况，使用公式来计算预期成本（<code>cE</code>）。两种常用的公式是三角分布和贝塔分布，其计算公式分别为：</p><ul><li><p>三角分布。<code>cE = (cO + cM + cP) / 3</code></p></li><li><p>贝塔分布。<code>cE = (cO + 4cM + cP) / 6</code></p></li></ul><p>基于三点的假定分布计算出期望成本，并说明期望成本的不确定区间。</p><h5 id="2-2-6-数据分析"><a href="#2-2-6-数据分析" class="headerlink" title="2.2.6 数据分析"></a>2.2.6 数据分析</h5><p>适用于估算成本过程的数据分析技术包括（但不限于）：</p><ul><li><p>备选方案分析。备选方案分析是一种对已识别的可选方案进行评估的技术，用来决定选择哪种方案或使用何种方法来执行项目工作。例如评估购买和制造可交付成果分别对成本、进度、资源和质量的影响。</p></li><li><p>储备分析。为应对成本的不确定性，成本估算中可以包括应急储备（有时称为“应急费用”）。应急储备是包含在成本基准内的一部分预算，用来应对已识别的风险；应急储备还通常是预算的一部分，用来应对那些会影响项目的“已知——未知”风险。例如，可以预知有些项目可交付成果需要返工，却不知道返工的工作量是多少。可以预留应急储备来应对这些未知数量的返工工作。小至某个具体活动，大到整个项目，任何层级都可能有其应急储备。应急储备可取成本估算值的某一百分比、某个固定值，或者通过定量分析来确定。而随着项目信息越来越明确，可以动用、减少或取消应急储备。应该在成本文件中清楚地列出应急储备。应急储备是成本基准的一部分，也是项目整体资金需求的一部分。</p></li><li><p>质量成本。在估算时，可能要用刀关于质量成本的各种假设，这包括对以下情况进行评估：是为达到要求而增加投入，还是承担不符合要求而造成的成本；是寻求短期成本降低，还是承担产品生命周期后期频繁出现问题的后果。</p></li></ul><h5 id="2-2-7-项目管理信息系统（PMIS）"><a href="#2-2-7-项目管理信息系统（PMIS）" class="headerlink" title="2.2.7 项目管理信息系统（PMIS）"></a>2.2.7 项目管理信息系统（PMIS）</h5><p>项目管理信息系统可包括电子表单、模拟软件以及统计分析工具，可用来辅助成本估算。这些工具能简化某些成本估算技术的使用，使人们能够快速考虑多种成本估算方案。</p><h5 id="2-2-8-决策"><a href="#2-2-8-决策" class="headerlink" title="2.2.8 决策"></a>2.2.8 决策</h5><p>适用于估算成本过程的决策技术包括（但不限于）投票。投票是为达成某种期望结果，而对多个未来行动方案进行评估的过程。这些技术可以调动团队成员的参与，提高估算的准确性，并提高对估算结果的责任感。</p><h4 id="2-3-估算成本：输出"><a href="#2-3-估算成本：输出" class="headerlink" title="2.3 估算成本：输出"></a>2.3 估算成本：输出</h4><h5 id="2-3-1-成本估算"><a href="#2-3-1-成本估算" class="headerlink" title="2.3.1 成本估算"></a>2.3.1 成本估算</h5><p>成本估算包括对完成项目工作可能需要的成本、应对已识别风险的应急储备，以及应对计划外工作的管理储备的量化估算。成本估算可以是汇总的或详细分列的。成本估算应覆盖项目所使用的全部资源，包括（但不限于）直接人工、材料、设备、服务、设施、信息技术，以及一些特殊的成本种类，如融资成本（包括利息）、通货膨胀补贴、汇率或成本应急储备。如果间接成本也包含在项目估算中，则可在活动层次或更高层次上计列间接成本。</p><h5 id="2-3-2-估算依据"><a href="#2-3-2-估算依据" class="headerlink" title="2.3.2 估算依据"></a>2.3.2 估算依据</h5><p>成本估算所需的支持信息的数量和种类，因应用领域而异，不论其详细程度如何，支持性文件都应该清晰、完整地说明成本估算是如何得出的。</p><p>成本估算的支持信息可包括：</p><ul><li><p>关于估算依据的文件（如估算是如何编制的）；</p></li><li><p>关于全部假设条件的文件；</p></li><li><p>关于各种已知制约因素的文件；</p></li><li><p>有关已识别的、在估算成本时应考虑的风险的文件；</p></li><li><p>对估算区间的说明（如“10000美元±10%”就说明了预期成本的所在区间）；</p></li><li><p>对最终估算的置信水平的说明。</p></li></ul><h5 id="2-3-3-项目文件更新"><a href="#2-3-3-项目文件更新" class="headerlink" title="2.3.3 项目文件更新"></a>2.3.3 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>假设日志。在成本估算过程中可能会做出新的假设、识别新的制约因素，或者重新审查和修改已有的假设条件或制约因素。假设日志应根据这些新信息做出相应更新。</p></li><li><p>经验教训登记册。有效和高效地估算成本的技术，需要更新在经验教训登记册中。</p></li><li><p>风险登记册。在估算成本过程中选择和商定风险应对措施时，可能需要更新风险登记册。</p></li></ul><hr><h3 id="三、制定预算"><a href="#三、制定预算" class="headerlink" title="三、制定预算"></a>三、制定预算</h3><p>制定预算是汇总所有单个活动或工作包的估算成本，建立一个经批准的成本基准的过程。本过程的主要作用是，确定可据以监督和控制项目绩效的成本基准。本过程仅开展一次或仅在项目的预定义点开展。图7-6描述本过程的输入、工具与技术和输出，图7-7是本过程的数据流向图。</p><p><img src="/images/pmp-7/7-6.png" alt="制定预算：输入、工具与技术和输出"></p><p><img src="/images/pmp-7/7-7.png" alt="制定预算：数据流向图"></p><h4 id="3-1-制定预算：输入"><a href="#3-1-制定预算：输入" class="headerlink" title="3.1 制定预算：输入"></a>3.1 制定预算：输入</h4><h5 id="3-1-1-项目管理计划"><a href="#3-1-1-项目管理计划" class="headerlink" title="3.1.1 项目管理计划"></a>3.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>成本管理计划。成本管理计划描述了如何将成本纳入项目预算中。</p></li><li><p>资源管理计划。资源管理计划提供了有关（人力和其他资源的）费率、差旅成本估算，和其他可预见成本的信息，这些信息是估算整个项目预算时必须考虑的因素。</p></li><li><p>范围基准。范围基准包括项目范围说明书、WBS和WBS词典的详细信息，可用于成本估算和管理。</p></li></ul><h5 id="3-1-2-项目文件"><a href="#3-1-2-项目文件" class="headerlink" title="3.1.2 项目文件"></a>3.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>估算依据。在估算依据中包括基本的假设条件，例如，项目预算中是否应该包含间接成本或其他成本。</p></li><li><p>成本估算。个工作包内每个活动的成本估算汇总后，即得到各工作包的成本估算。</p></li><li><p>项目进度计划。项目进度计划包括项目活动、里程碑、工作包和控制账户的计划开始和完成日期。可根据这些信息，把计划成本和实际成本汇总到相应的日历时段中。</p></li><li><p>风险登记册。应该审查风险登记册，以确定如何汇总风险应对成本。风险登记册的更新包含在项目文件更新中。</p></li></ul><h5 id="3-1-3-商业文件"><a href="#3-1-3-商业文件" class="headerlink" title="3.1.3 商业文件"></a>3.1.3 商业文件</h5><p>可作为本过程输入的商业文件包括（但不限于）：</p><ul><li><p>商业论证。商业论证识别了项目成功的关键因素，包括财务成功因素。</p></li><li><p>效益管理计划。效益管理计划包括目标效益，例如净现值的计算、实现效益的时限，以及与效益有关的测量指标。</p></li></ul><h5 id="3-1-4-协议"><a href="#3-1-4-协议" class="headerlink" title="3.1.4 协议"></a>3.1.4 协议</h5><p>在制定预算时，需要考虑将要或已经采购的产品、服务或成本的成果，以及适用的协议信息。</p><h5 id="3-1-5-事业环境因素"><a href="#3-1-5-事业环境因素" class="headerlink" title="3.1.5 事业环境因素"></a>3.1.5 事业环境因素</h5><p>会影响估算成本过程的事业环境因素包括（但不限于）汇率。对于持续多年、涉及多种货币的大规模项目，需要了解汇率波动并将其纳入制定预算过程。</p><h5 id="3-1-6-组织过程资产"><a href="#3-1-6-组织过程资产" class="headerlink" title="3.1.6 组织过程资产"></a>3.1.6 组织过程资产</h5><p>会影响制定预算过程的组织过程资产包括（但不限于）：</p><ul><li><p>现有的正式和非正式的与成本预算有关的政策、程序和指南；</p></li><li><p>历史信息和经验教训知识库；</p></li><li><p>成本预算工具；</p></li><li><p>报告方法。</p></li></ul><h4 id="3-2-制定预算：工具与技术"><a href="#3-2-制定预算：工具与技术" class="headerlink" title="3.2 制定预算：工具与技术"></a>3.2 制定预算：工具与技术</h4><h5 id="3-2-1-专家判断"><a href="#3-2-1-专家判断" class="headerlink" title="3.2.1 专家判断"></a>3.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>以往类似项目；</p></li><li><p>来自行业、学科和应用领域的信息；</p></li><li><p>财务原则；</p></li><li><p>资金需求和来源。</p></li></ul><h5 id="3-2-2-成本汇总"><a href="#3-2-2-成本汇总" class="headerlink" title="3.2.2 成本汇总"></a>3.2.2 成本汇总</h5><p>先把成本估算汇总到WBS中的工作包中，再有工作包汇总至WBS的更高层次（如控制账户），最终得出整个项目的总成本。</p><h5 id="3-2-3-数据分析"><a href="#3-2-3-数据分析" class="headerlink" title="3.2.3 数据分析"></a>3.2.3 数据分析</h5><p>可用于制定预算过程的数据分析技术包括（但不限于）可以建立项目管理储备的储备分析。管理储备是为了管理控制的目的而特别留出的项目预算，用来应对项目范围中不可预见的工作，目的是用来应对会影响项目的“未知-未知”风险。管理储备不包括在成本基准中，但属于项目总预算和资金需求的一部分。当动用管理储备资助不可预见的工作时，就要把动用的管理储备增加到成本基准中，从而导致成本基准变更。</p><h5 id="3-2-4-历史信息审核"><a href="#3-2-4-历史信息审核" class="headerlink" title="3.2.4 历史信息审核"></a>3.2.4 历史信息审核</h5><p>审核历史信息有助于进行参数估算或类比估算。历史信息可包括各种项目特征（参数），它们用于建立数学模型预测项目总成本。这些数学模型可以是简单的（例如，建造住房的总成本取决于单位面积建造成本），也可以使复杂的（例如，软件开发项目的成本模型中有多个变量，且每个变量又受许多因素的影响）。</p><p>类比和参数模型的成本及准确性可能差别很大。在以下情况下，它们将最为可靠：</p><ul><li><p>用来建立模型的历史信息准确；</p></li><li><p>模型中的参数易于量化；</p></li><li><p>模型可以调整，以便对大项目、小项目和各项目阶段都适用。</p></li></ul><h5 id="3-2-5-资金限制平衡"><a href="#3-2-5-资金限制平衡" class="headerlink" title="3.2.5 资金限制平衡"></a>3.2.5 资金限制平衡</h5><p>应该根据对项目资金的任何限制，来平衡资金支出。如果发现资金限制与计划支出之间的差异，则可能需要调整工作的进度计划，以平衡资金支出水平。这可以通过在项目进度计划中添加强制日期来实现。</p><h5 id="3-2-6-融资"><a href="#3-2-6-融资" class="headerlink" title="3.2.6 融资"></a>3.2.6 融资</h5><p>融资是指为项目获取资金。长期的基础建设、工业和公共服务项目通常会寻求外部融资。如果项目使用外部资金，出资实体可能会提出一些必须满足的要求。</p><h4 id="3-3-制定预算：输出"><a href="#3-3-制定预算：输出" class="headerlink" title="3.3 制定预算：输出"></a>3.3 制定预算：输出</h4><h5 id="3-3-1-成本基准"><a href="#3-3-1-成本基准" class="headerlink" title="3.3.1 成本基准"></a>3.3.1 成本基准</h5><p>成本基准是经过批准的、按时间段分配的项目预算，不包括任何管理储备，只有通过正式的变更控制程序才能变更，用作与实际结果进行比较的依据。成本基准是不同进度活动经批准的预算的总和。</p><p>项目预算和成本基准的各个组成部分，如图7-8所示。先汇总各项目活动的成本估算及其应急储备，得到相关工作包的成本；然后汇总各工作包的成本估算及其应急储备，得到控制账户的成本；接着再汇总各控制账户的成本，得到成本基准。由于成本基准中的成本估算与进度活动直接关联，因此就可按时间段分配成本基准，得到一条S曲线，如图7-9所示。对于使用挣值管理的项目，成本基准指的是绩效测量基准。</p><p>最后，在成本基准之上增加管理储备，得到项目预算。当出现有必要动用管理储备的变更时，则应该在获得变更控制过程的批准之后，把适量的管理储备移入成本基准中。</p><p><img src="/images/pmp-7/7-8.png" alt="项目预算的组成"></p><p><img src="/images/pmp-7/7-9.png" alt="成本基准、支出与资金需求"></p><h5 id="3-3-2-项目资金需求"><a href="#3-3-2-项目资金需求" class="headerlink" title="3.3.2 项目资金需求"></a>3.3.2 项目资金需求</h5><p>根据成本基准，确定总资金需求和阶段性（如季度或年度）资金需求。成本基准中既包括预计支出及预计债务。项目资金通常以增量的方式投入，并且可能是非均衡的，呈现出图7-9中所示的阶梯状。如果有管理储备，则总资金需求等于成本基准加管理储备。在资金需求文件中，也可说明资金来源。</p><h5 id="3-3-3-项目文件更新"><a href="#3-3-3-项目文件更新" class="headerlink" title="3.3.3 项目文件更新"></a>3.3.3 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>成本估算。更新成本估算，以记录任何额外信息。</p></li><li><p>项目进度计划。项目进度计划可能记录了各项活动的估算成本。</p></li><li><p>风险登记册。记录在本过程中识别的新风险于风险登记册中，并通过风险管理过程进行管理。</p></li></ul><hr><h3 id="四、控制成本"><a href="#四、控制成本" class="headerlink" title="四、控制成本"></a>四、控制成本</h3><p>控制成本是监督项目状态，以更新项目成本和管理成本基准变更的过程。本过程的主要作用是，在整个项目期间保持对成本基准的维护。本过程需要在整个项目期间开展。图7-10描述本过程的输入、工具与技术和输出，图7-11是本过程的数据流向图。</p><p><img src="/images/pmp-7/7-10.png" alt="控制成本：输入、工具与技术和输出"></p><p><img src="/images/pmp-7/7-11.png" alt="控制成本：数据流向图"></p><p>要更新预算，就需要了解截至目前的实际成本。只有经过实施整体变更控制过程的批准，才可以增加预算。只监督资金的支出，而不考虑由这些支出所完成的工作的价值，对项目没有什么意义，最多只能跟踪资金流。所以在成本控制中，应重点分析项目资金支出与相应完成的工作之间的关系。有效成本控制的关键在于管理经批准的成本基准。</p><p>项目成本控制包括：</p><ul><li><p>对造成成本基准变更的因素施加影响；</p></li><li><p>确保所有变更请求都得到及时处理；</p></li><li><p>当变更实际发生时，管理这些变更；</p></li><li><p>确保成本支出不超过批准的资金限额，既不超出按时段、按WBS组件、按活动分配的限额，也不超出项目总限额；</p></li><li><p>监督成本绩效，找出并分析与成本基准间的偏差；</p></li><li><p>对照资金支出，监督工作绩效；</p></li><li><p>防止在成本或资源使用报告中出现未经批准的变更；</p></li><li><p>向相关方报告所有经批准的变更及其相关成本；</p></li><li><p>设法把预期的成本超支控制在可接受的范围内。</p></li></ul><h4 id="4-1-控制成本：输入"><a href="#4-1-控制成本：输入" class="headerlink" title="4.1 控制成本：输入"></a>4.1 控制成本：输入</h4><h5 id="4-1-1-项目管理计划"><a href="#4-1-1-项目管理计划" class="headerlink" title="4.1.1 项目管理计划"></a>4.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>成本管理计划。成本管理计划描述将如何管理和控制项目成本。</p></li><li><p>成本基准。把成本基准与实际结果相比，以判断是否需要进行变更或采取纠正或预防措施。</p></li><li><p>绩效测量基准。使用挣值分析时，将绩效测量基准与实际结果比较，以决定是否有必要进行变更、采取纠正措施或预防措施。</p></li></ul><h5 id="4-1-2-项目文件"><a href="#4-1-2-项目文件" class="headerlink" title="4.1.2 项目文件"></a>4.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）经验教训登记册。在项目早期获得的经验教训可以运用到后期阶段，以改进成本控制。</p><h5 id="4-1-3-项目资金需求"><a href="#4-1-3-项目资金需求" class="headerlink" title="4.1.3 项目资金需求"></a>4.1.3 项目资金需求</h5><p>项目资金需求包括预计支出和预计债务</p><h5 id="4-1-4-工作绩效数据"><a href="#4-1-4-工作绩效数据" class="headerlink" title="4.1.4 工作绩效数据"></a>4.1.4 工作绩效数据</h5><p>工作绩效数据包含关于项目状态的数据，例如哪些成本已批准、发生、支付和开具发票。</p><h5 id="4-1-5-组织过程资产"><a href="#4-1-5-组织过程资产" class="headerlink" title="4.1.5 组织过程资产"></a>4.1.5 组织过程资产</h5><p>会影响控制成本过程的组织过程资产包括（但不限于）：</p><ul><li><p>现有的正式和非正式的与成本控制相关的政策、程序和指南；</p></li><li><p>成本控制工具；</p></li><li><p>可用的监督和报告方法。</p></li></ul><h4 id="4-2-控制成本：工具与技术"><a href="#4-2-控制成本：工具与技术" class="headerlink" title="4.2 控制成本：工具与技术"></a>4.2 控制成本：工具与技术</h4><h5 id="4-2-1-专家判断"><a href="#4-2-1-专家判断" class="headerlink" title="4.2.1 专家判断"></a>4.2.1 专家判断</h5><p>控制成本过程中的专家判断包括（但不限于）：</p><ul><li><p>偏差分析；</p></li><li><p>挣值分析；</p></li><li><p>预测；</p></li><li><p>财务分析。</p></li></ul><h5 id="4-2-2-数据分析"><a href="#4-2-2-数据分析" class="headerlink" title="4.2.2 数据分析"></a>4.2.2 数据分析</h5><p>适用于控制成本过程的数据分析技术包括（但不限于）：</p><ul><li><p>挣值分析（EVM）。挣值分析将实际进度和成本绩效与绩效测量基准进行比较。EVM把范围基准、成本基准和进度基准整合起来，形成绩效测量基准。它针对每个工作包和控制账户，计算并监测以下三个关键指标：</p><ul><li><p>计划价值。计划价值（PV）是为计划工作分配的经批准的预算，它是为完成某活动或工作分解结构（WBS）组成部分而准备的一份经批准的预算，不包括管理储备。应该把概预算分配至项目生命周期的各个阶段；在某个给定的时间点，计划价值代表着应该已经完成的工作。PV的总和有时被称为绩效测量基准（PMB），项目的总计划价值又被称为完工预算（BAC）。</p></li><li><p>挣值。挣值（EV）是对已完成工作的测量值，用该工作的批准预算来表示，是已完成工作的经批准的预算。EV的计算应给与PMB相对应，且所得的EV值不得大于相应组件的PV总预算。EV常用于计算项目的完成百分比，应该为每个WBS组件规定进展测量准则，用于考核正在实施的工作。项目经理既要监测EV的增量，以判断当前的状态，又要检测EV的累计值，以判断长期的绩效趋势。</p></li><li><p>实际成本。实际成本（AC）是在给定时段内，执行某活动而实际发生的成本，是为完成与EV相对应的工作而发生的总成本。AC的计算方法必须与PV和EV的计算方法保持一致（例如，都只计算直接小时数，都只计算直接成本，或都计算包含间接成本在内的全部成本）。AC没有上限，为实现EV所花费的任何成本都要计算进去。</p></li><li><p>偏差分析。在EVM中，偏差分析用以解释成本偏差（<code>CV = EV - AC</code>）、进度偏差（<code>SV = EV - PV</code>）和完工偏差（<code>VAC = BAC - EAC</code>）的原因、影响和纠正措施。成本和进度偏差是最需要分析的两种偏差。对于不使用正规挣值分析的项目，可开展类似的偏差分析，通过比较计划成本和实际成本，来识别成本基准与实际项目绩效之间的差异；然后可以实施进一步的分析，以判定偏离进度基准的原因和程度，并决定是否需要采取纠正或预防措施。可通过成本绩效测量来评估偏离原始成本基准的程度。项目成本控制的重要工作包括：判定偏离成本基准的原因和程度，并决定是否需要采取纠正或预防措施。随着项目工作的逐步完成，偏差的可接受范围（常用百分比表示）将逐步缩小。偏差分析包括（但不限于）：</p><ul><li><p>进度偏差。进度偏差（SV）是测量进度绩效的一种指标，表示为挣值与计划价值之差。它是指在某个给定的时点，项目提前或落后的进度，它是测量项目进度绩效的一种指标，等于挣值（EV）减去计划价值（PV）。EVA进度偏差是一种有用的指标，可表明项目进度是落后还是提前与进度基准。当项目完工时，全部的计划价值都将实现（即成为挣值），所以EVA进度偏差最终将等于零。最好把进度偏差与关键路径法（CPM）和风险管理一起使用。公式：<code>SV = EV - PV</code>。</p></li><li><p>成本偏差。成本偏差（CV）是在某个给定时点的预算亏空或盈余量，表示为挣值与实际成本之差。它是测量项目成本绩效的一种指标，等于挣值（EV）减去实际成本（AC）。项目结束时的成本偏差，就是完工预算（BAC）与实际成本之间的差值。由于成本偏差指明了实际绩效与成本支出之间的关系，所以非常重要。负的CV一般都是不可挽回的。公式：<code>CV = EV - AC</code>。</p></li><li><p>进度绩效指数。进度绩效指数（SPI）是测量进度效率的一种指标，表示为挣值与计划价值之比，反映了项目团队完成工作的效率。有时与成本绩效指数（CPI）一起使用，以预测项目的最终完工估算。当SPI小于1.0时，说明已完成的工作量未达到计划要求；当SPI大于1.0时，则说明已完成的工作量超过计划。由于SPI测量的使项目的总工作量，所以还需要对关键路径上的绩效进行单独分析，以确认项目是否将比计划完成日期提前或推迟完工。SPI等于EV与PV的比值。公式：<code>SPI = EV / PV</code>。</p></li><li><p>成本绩效指数。成本绩效指数（CPI）是测量预算资源的成本效率的一种指标，表示为挣值与实际成本之比。它是最关键的EVA指标，用来测量已完成工作的成本效率。当CPI小于1.0时，说明已完成工作的成本超支；当CPI大于1.0时，则说明到目前为止成本有结余。CPI等于EV与AC的比值。公式：<code>CPI = EV / AC</code>。</p></li></ul></li><li><p>趋势分析。趋势分析旨在审查项目绩效随时间的变化情况，以判断绩效是正在改善还是正在恶化。图形分析技术有助于了解截至目前的绩效情况，并发发展趋势与未来的绩效目标进行比较，如BAC与EAC、预测完工日期与计划完工日期的比较。趋势分析技术包括（但不限于）：</p><ul><li><p>图表。在挣值分析中，对计划价值、挣值和实际成本这三个参数，既可以分阶段（通常以周或月为单位）进行监督和报告，也可以针对累计值进行监督和报告。图7-12以S曲线展示了某个项目的EV数据，该项目预算超支且进度落后。</p><p><img src="/images/pmp-7/7-12.png" alt="挣值、计划价值和实际成本"></p></li><li><p>预测。随着项目进展，项目团队可根据项目绩效，对完工估算（EAC）进行预测，预测的结果可能与完工预算（BAC）存在差异。如果BAC已明显不再可行，则项目经理应考虑对EAC进行预测。预测EAC是根据当前掌握的绩效信息和其他知识，预计项目未来的情况和事件。预测要根据项目执行过程中所提供的工作绩效数据来产生、更新和重新发布。工作绩效信息包含项目过去的绩效，以及可能在未来对项目产生影响的任何信息。在计算EAC时，通常用已完成工作的实际成本，加上剩余工作的完工尚需估算（ETC）。项目团队要根据已有的经验，考虑实施ETC工作可能遇到的各种情况。把挣值分析与手工预测EAC方法联合起来使用，效果会更佳。由项目经理和项目团队手工进行的自下而上汇总方法，就是一种最普遍的EAC预测方法。项目经理所进行的自下而上的EAC估算，就是以已完成工作为基础，并根据已积累的经验来为剩余项目工作编制一个新估算。公式：<code>EAC = AC + 自下而上的ETC</code>。可以很方便地把项目经理手工估算的EAC与计算得出的EAC做比较，这些计算得出的EAC代表了不同的风险情景。在计算EAC值时，经常会使用累积CPI和累积SPI值。尽管可以用许多方法来计算基于EVM数据的EAC值，但下面只介绍最常用的三种方法：</p><ul><li><p>假设将按预算单价完成ETC工作。这种方法承认以实际成本表示的累积实际项目绩效（不论好坏），并预计未来的全部ETC工作都将按预算单价完成。如果目前的实际绩效不好，则只有在进行项目风险分析并取得有力证据后，才能做出“未来绩效将会改进”的假设。公式：<code>EAC = AC + (BAC - EV)</code>。</p></li><li><p>假设以当前CPI完成ETC工作。这种方法假设项目将按截至目前的情况继续进行，即ETC工作将按项目截至目前的累计成本绩效指数（CPI）实施。公式：<code>EAC = BAC / CPI</code>。</p></li><li><p>假设SPI与CPI将同时影响ETC工作。在这种预测中，需要计算一个由成本绩效指数与进度绩效指数总和决定的效率指标，并假设ETC工作将按该效率指标完成。如果项目进度对ETC有重要影响，这种方法最有效。使用这种方法时，还可以根据项目经理的判断，分别给CPI和SPI赋予不同的权重，如80/20、50/50或其他比率。公式：<code>EAC = AC + [(BAC - EV) / (CPI * SPI)]</code>。</p></li></ul></li></ul></li><li><p>储备分析。在控制成本过程中，可以采用储备分析来监督项目中应急储备和管理储备的使用情况，从而判断是否还需要这些储备，或者是否需要增加额外的储备。随着项目工作的进展，这些储备可能按计划用于支付风险或其他应急情况的成本；反之，如果抓住机会节约了成本，节约下来的资金可能会增加到应急储备中，或作为盈利/利润从项目中剥离。如果已识别的风险没有发生，就可能要从项目预算中扣除未使用的应急储备，为其他项目或运营腾出资源。同时，在项目中开展进一步风险分析，可能会发现需要为项目预算申请额外的储备。</p></li></ul></li></ul><h5 id="4-2-3-完工尚需绩效指数"><a href="#4-2-3-完工尚需绩效指数" class="headerlink" title="4.2.3 完工尚需绩效指数"></a>4.2.3 完工尚需绩效指数</h5><p>完工尚需绩效指数（TCPI）是一种为了实现特定的管理目标，剩余资源的使用必须达到的成本绩效指标，是完成剩余工作所需的成本与剩余预算值比。TCPI是指为了实现具体的管理目标（如BAC或EAC），剩余工作的实施必须达到的成本绩效指标。如果BAC已明显不再可行，则项目经理应考虑使用预测的EAC。经过批准后，就用EAC取代BAC。基于BAC的TCPI公式：<code>TCPI = (BAC - EV) / (BAC - AC)</code>。</p><p>TCPI的概念可用图7-13表示。其计算公式在图的左下角，用剩余工作（BAC减去EV）除以剩余资金（可以是BAC减去AC，或EAC减去AC）。</p><p>如果累计CPI低于基准，那么项目的全部剩余工作都应立即按TCPI（BAC）执行，才能确保实际总成本不超过批准的BAC。至于所要求的这种绩效水平是否可行，就需要综合考虑多种因素（包括风险、项目剩余时间和技术绩效）后才能判断；如果不可行，就需要把项目未来所需的绩效水平调整为如TCPI（EAC）线所示。基于EAC的TCPI公式：<code>TCPI = (BAC - EV) / (EAC - AC)</code>。表7-1列出了EVM的计算公式。</p><p><img src="/images/pmp-7/7-13.png" alt="完工尚需绩效指数"></p><p><img src="/images/pmp-7/表7-1.png" alt="挣值计算汇总表"></p><h5 id="4-2-4-项目管理信息系统（PMIS）"><a href="#4-2-4-项目管理信息系统（PMIS）" class="headerlink" title="4.2.4 项目管理信息系统（PMIS）"></a>4.2.4 项目管理信息系统（PMIS）</h5><p>项目管理信息系统常用语监测PV、EV和AC这三个EVM指标、绘制趋势图，并预测最终项目结果的可能区间。</p><h4 id="4-3-控制成本：输出"><a href="#4-3-控制成本：输出" class="headerlink" title="4.3 控制成本：输出"></a>4.3 控制成本：输出</h4><h5 id="4-3-1-工作绩效信息"><a href="#4-3-1-工作绩效信息" class="headerlink" title="4.3.1 工作绩效信息"></a>4.3.1 工作绩效信息</h5><p>工作绩效信息包括有关项目工作实施情况的信息（对照成本基准），可以在工作包层级和控制账户层级上评估已执行的工作和工作成本方面的偏差。对于使用挣值分析的项目，CV、CPI、EAC、VAC和TCPI将记录在工作绩效报告中。</p><h5 id="4-3-2-成本预测"><a href="#4-3-2-成本预测" class="headerlink" title="4.3.2 成本预测"></a>4.3.2 成本预测</h5><p>无论是计算得出的EAC值，还是自下而上估算的EAC值，都需要记录下来，并传达给相关方。</p><h5 id="4-3-3-变更请求"><a href="#4-3-3-变更请求" class="headerlink" title="4.3.3 变更请求"></a>4.3.3 变更请求</h5><p>分析项目绩效后，可能会就成本基准和进度基准，或项目管理计划的其他组成部分提出变更请求。应该通过实施整体变更控制过程对变更请求进行审查和处理。</p><h5 id="4-3-4-项目管理计划更新"><a href="#4-3-4-项目管理计划更新" class="headerlink" title="4.3.4 项目管理计划更新"></a>4.3.4 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更请求的项目管理计划组成部分包括（但不限于）：</p><ul><li><p>成本管理计划。成本管理计划中需要更新的内容包括：用于管理项目成本的控制临界值或所要求的准确度。要根据相关方的反馈意见，对它们进行更新。</p></li><li><p>成本基准。在针对范围、资源或成本估算的变更获得批准后，需要对成本基准做出相应的变更。在某些情况下，成本偏差可能太过严重，以至于需要修订成本基准，以便为绩效测量提供现实可行的依据。</p></li><li><p>绩效测量基准。在针对范围、进度绩效或成本估算的变更获得批准后，需要对绩效测量基准做出相应的变更。在某些情况下，绩效偏差可能太过严重，以至于需要提出变更请求来修订绩效测量基准，以便为绩效测量提供现实可行的依据。</p></li></ul><h5 id="4-3-5-项目文件更新"><a href="#4-3-5-项目文件更新" class="headerlink" title="4.3.5 项目文件更新"></a>4.3.5 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>假设日志。成本绩效可能表明需要重新修订有关资源生产率和其他影响成本绩效的因素的假设条件。</p></li><li><p>估算依据。成本绩效可能表明需要重新审查初始估算依据。</p></li><li><p>成本估算。可能需要更新成本估算，以反映项目的实际成本效率。</p></li><li><p>经验教训登记册。有效维护预算、偏差分析、挣值分析、预测，以及应对成本偏差的纠正措施的相关技术，应当更新在经验教训登记册中。</p></li><li><p>风险登记册。如果出现成本偏差，或者成本可能达到临界值，则应更新风险登记册。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《PMBOK第六版》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目成本管理包括为使项目在批准的预算内完成而对成本进行规划、估算、预算、融资、筹资、管理和控制的各个过程，从而确保项目在批准的预算内完工。&lt;/p&gt;
    
    </summary>
    
      <category term="PMP抄书系列" scheme="http://www.xiaoleon.cn/categories/PMP%E6%8A%84%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="pmp" scheme="http://www.xiaoleon.cn/tags/pmp/"/>
    
  </entry>
  
  <entry>
    <title>PMP(6) 项目进度管理</title>
    <link href="http://www.xiaoleon.cn/2019/02/10/pmp-6/"/>
    <id>http://www.xiaoleon.cn/2019/02/10/pmp-6/</id>
    <published>2019-02-10T11:17:20.000Z</published>
    <updated>2019-05-13T09:47:52.527Z</updated>
    
    <content type="html"><![CDATA[<p>项目进度管理包括为管理项目按时完成所需的各个过程</p><a id="more"></a><p>其过程包括：</p><ul><li><p><strong>规划进度管理</strong> —— 为规划、编制、管理、执行和控制项目进度而制定政策、程序和文档的过程。</p></li><li><p><strong>定义活动</strong> —— 识别和记录为完成项目可交付成果而需采取的具体行动的过程。</p></li><li><p><strong>排列活动顺序</strong> —— 识别和记录项目活动之间的关系的过程。</p></li><li><p><strong>估算活动持续时间</strong> —— 根据资源估算的结果，估算完成单项活动所需工作时段数的过程。</p></li><li><p><strong>制定进度计划</strong> —— 分析活动顺序、持续时间、资源需求和进度制约因素，创建项目进度模型，从而落实项目执行和监控的过程。</p></li><li><p><strong>控制进度</strong> —— 监督项目状态，以更新项目进度和管理进度基准变更的过程</p></li></ul><p>图6-1概括了项目进度管理的各个过程。虽然在本《PMBOK指南》中，各项目进度管理过程以界限分明和相互独立的形式出现，但在实践中它们会以本指南无法全面详述的方式相互交叠和相互作用。</p><p><img src="/images/pmp-6/6-1.png" alt="项目进度管理概述"></p><p><strong>项目进度管理的核心概念</strong></p><p>项目进度计划提供详尽的计划，说明项目如何以及何时交付项目范围中定义的产品、服务和成果，是一种用于沟通和管理相关方期望的工具，为绩效报告提供了依据。</p><p>项目管理团队选择进度计划方法，例如关键路径法或敏捷方法。之后，项目管理团队将项目特定数据，如活动、计划日期、持续时间、资源、依赖关系和制约因素等输入进度计划编制工具，以创建项目进度模型。这件工作的成果就是项目进度计划。图6-2是进度计划工作的概览，展示如何结合进度计划编制方法、编制工具及项目进度管理各过程的输出创建进度模型。</p><p>在小型项目中，定义活动、排列活动顺序、估算活动持续时间及制定进度模型等过程之间的联系非常密切，以至于可视为一个过程，能够由一个人在较短时间内完成。但本章仍然把这些过程分开介绍，因为每个过程所用的工具和技术各不相同。有关某些过程的更详细的描述，请参见《进度计划实践标准》。</p><p>在可能的情况下，应在整个项目期间保持项目详细进度计划的灵活性，使其可以随着知识的获得、对风险理解的加深，以及增值活动的设计而调整。</p><p><img src="/images/pmp-6/6-2.png" alt="进度规划工作概述"></p><p><strong>项目进度管理的发展趋势和新兴实践</strong></p><p>全球市场瞬息万变，竞争激烈，具有很高的不确定性和不可预测性，很难定义长期范围，因此，为应对环境变化，根据具体情景有效采用和裁剪开发实践就日益重要。适应型规划虽然制定了计划，但也意识到工作开始之后，优先级可能发生改变，需要修改计划以反映新的优先级。</p><p>有关项目进度计划方法的新兴实践包括（但不限于）：</p><ul><li><p>具有未完项的迭代型进度计划。这是一种基于适应型生命周期的滚动式规划，例如敏捷的产品开发方法。这种方法将需求记录在用户故事中，然后在建造之前按优先级排序并优化用户故事，最后在规定的时间盒内开发产品功能。这一方法通常用于向客户交付增量价值，或多个团队并行开发大量内部关联较小的功能。适应型生命周期在产品开发中的应用越来越普遍，很多项目都采用这种进度计划方法。这种方法的好处在于，它允许在整个开发生命周期期间进行变更。</p></li><li><p>按需进度计划。这种方法通常用于看板体系，基于制约理论和来自精益生产的拉动式进度计划概念，根据团队的交付能力来限制团队正在开展的工作。按需进度计划方法不依赖于以前为产品开发或产品增量制定的进度计划，而是在资源可用时立即从未完项和工作序列中提取出来开展。按需进度计划方法经常用于此类项目：在运营或持续环境中以增量方式研发产品，其任务可以被设计成相对类似的规模和范围，或者可以按规模和范围进行组合的工作。按需进度计划方法通常于产品在运营和维护环境下以增量方式演进，且任务的规模或范围相对类似，或者，可以按照规模或范围对任务进行组合的项目。</p></li></ul><p><strong>裁剪考虑因素</strong></p><p>由于每个项目都是独特的，因此项目经理可能需要裁剪项目进度管理过程。裁剪时应考虑的因素包括（但不限于）：</p><ul><li><p>生命周期方法。哪种生命周期方法最适合制定详细的进度计划？</p></li><li><p>资源可用性。影响资源可持续时间的因素是什么（如可用资源与其生产效率之间的相关性）？</p></li><li><p>项目维度。项目复杂性、技术不确定性、产品新颖度、速度或进度跟踪（如挣值、完成百分比、“红黄绿”停止信号灯指示）如何影响预期的控制水平？</p></li><li><p>技术支持。是否采用技术来制定、记录、传递、接收和存储项目进度模型的信息以及是否易于获取？</p></li></ul><p>有关进度计划的更多信息，参阅《进度计划实践标准》。</p><p><strong>关于敏捷/适应型环境的考虑因素</strong></p><p>适应型方法采用短周期来开展工作、审查结果，并在必要时做出调整。这些周期可针对方法和可交付成果的适用性提供快速反馈，通常表现为迭代型进度计划和拉动式按需进度计划，具体参见“项目进度管理的发展趋势和新兴实践”一节。</p><p>在大型组织中，可能同时存在小规模项目和大规模举措，需要制定长期路线图，通过规模参数（如团队规模、地理分布、法规合规性、组织复杂性和技术复杂性）来管理这些项目集。为管理大规模的、全企业系统的、完整的交付生命周期，可能需要采用一系列技术，包括预测型方法、适应型方法或两种方法的混合。组织还可能需要结合几种核心方法，或采用已实践过的方法，并采纳来自传统技术的一些原则和实践。</p><p>无论是采用预测型开发生命周期来管理项目，还是在适应型环境下管理项目，项目经理的角色都不变。但是，要成功实施适应型方法，项目经理需要了解如何高效使用相关的工具和技术。</p><h3 id="一、规划进度管理"><a href="#一、规划进度管理" class="headerlink" title="一、规划进度管理"></a>一、规划进度管理</h3><p>规划进度管理是为规划、编制、管理、执行和控制项目进度而制定政策、程序和文档的过程。本过程的主要作用是，为如何在整个项目期间管理项目进度提供指南和方向。本过程仅开展一次或仅在项目的预定义点开展。图6-3描述本过程的输入、工具与技术和输出。图6-4是本过程的数据流向图。</p><p><img src="/images/pmp-6/6-3.png" alt="规划进度管理：输入、工具与技术和输出"></p><p><img src="/images/pmp-6/6-4.png" alt="规划进度管理：数据流向图"></p><h4 id="1-1-规划进度管理：输入"><a href="#1-1-规划进度管理：输入" class="headerlink" title="1.1 规划进度管理：输入"></a>1.1 规划进度管理：输入</h4><h5 id="1-1-1-项目章程"><a href="#1-1-1-项目章程" class="headerlink" title="1.1.1 项目章程"></a>1.1.1 项目章程</h5><p>项目章程中规定的总体里程碑进度计划会影响项目的进度管理。</p><h5 id="1-1-2-项目管理计划"><a href="#1-1-2-项目管理计划" class="headerlink" title="1.1.2 项目管理计划"></a>1.1.2 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>范围管理计划。范围管理计划描述如何定义和制定范围，并提供有关如何制定进度计划的信息。</p></li><li><p>开发方法。产品开发方法有助于定义进度计划方法、估算技术、进度计划编制工具以及用来控制进度的技术。</p></li></ul><h5 id="1-1-3-事业环境因素"><a href="#1-1-3-事业环境因素" class="headerlink" title="1.1.3 事业环境因素"></a>1.1.3 事业环境因素</h5><p>能够影响规划进度管理过程的事业环境因素包括（但不限于）：</p><ul><li><p>组织文化和结构；</p></li><li><p>团队资源可用性、技能以及物质资源可用性；</p></li><li><p>进度计划软件；</p></li><li><p>指南和标准，用于裁剪组织标准过程和程序以满足项目的特定要求；</p></li><li><p>商业数据库，如标准化的估算数据。</p></li></ul><h5 id="1-1-4-组织过程资产"><a href="#1-1-4-组织过程资产" class="headerlink" title="1.1.4 组织过程资产"></a>1.1.4 组织过程资产</h5><p>能够影响规划进度管理过程的组织过程资产包括（但不限于）：</p><ul><li><p>历史信息和经验教训知识库；</p></li><li><p>现有与制定进度计划以及管理和控制进度相关的正式和非正式的政策、程序和指南；</p></li><li><p>模板和表格；</p></li><li><p>监督和报告工具。</p></li></ul><h4 id="1-2-规划进度管理：工具与技术"><a href="#1-2-规划进度管理：工具与技术" class="headerlink" title="1.2 规划进度管理：工具与技术"></a>1.2 规划进度管理：工具与技术</h4><h5 id="1-2-1-专家判断"><a href="#1-2-1-专家判断" class="headerlink" title="1.2.1 专家判断"></a>1.2.1 专家判断</h5><p>应征求具备专业知识或在以往类似项目中接受过相关培训的个人或小组的意见：</p><ul><li><p>进度计划的编制、管理和控制；</p></li><li><p>进度计划方法（如预测型或适应型生命周期）；</p></li><li><p>进度计划软件；</p></li><li><p>项目所在的特定行业。</p></li></ul><h5 id="1-2-2-数据分析"><a href="#1-2-2-数据分析" class="headerlink" title="1.2.2 数据分析"></a>1.2.2 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）备选方案分析。备选方案分析可包括确定采用哪些进度计划方法，以及如何将不同方法整合到项目中；此外，它还可以包括确定进度计划的详细程度、滚动式规划的持续时间，以及审查和更新频率。管理进度所需的计划详细程度与更新计划所需的时间量之间的平衡，应针对各个项目具体而言。</p><h5 id="1-2-3-会议"><a href="#1-2-3-会议" class="headerlink" title="1.2.3 会议"></a>1.2.3 会议</h5><p>项目团队可能举行规划会议来制定进度管理计划。参会人员可能包括项目经理、项目发起人、选定的项目团队成员、选定的相关方、进度计划或执行负责人，以及其他必要人员。</p><h4 id="1-3-规划进度管理：输出"><a href="#1-3-规划进度管理：输出" class="headerlink" title="1.3 规划进度管理：输出"></a>1.3 规划进度管理：输出</h4><h5 id="1-3-1-进度管理计划"><a href="#1-3-1-进度管理计划" class="headerlink" title="1.3.1 进度管理计划"></a>1.3.1 进度管理计划</h5><p>进度管理计划是项目管理计划的组成部分，为编制、监督和控制项目进度建立准则和明确活动。根据项目需要，进度管理计划可以是正式或非正式的，非常详细或高度概括的，其中应包括合适的控制临界值。</p><p>进度管理计划会规定：</p><ul><li><p>项目进度模型制定。需要规定用于制定项目进度模型的进度规划方法论和工具。</p></li><li><p>进度计划的发布和迭代长度。使用适应型生命周期时，应指定固定时间的发布时段、阶段和迭代。固定时间段指项目团队稳定地朝着目标前进的持续时间，它可以推动团队先处理基本功能，然后在时间允许的情况下再处理其他功能，从而尽可能减少范围蔓延。</p></li><li><p>准确度。准确度定义了需要规定活动持续时间估算的可接受区间，以及允许的应急储备数量。</p></li><li><p>计量单位。需要规定每种资源的计量单位，例如，用于测量时间的人时数、人天数或周数，用于计量数量的米、升、吨、千米或立方码。</p></li><li><p>组织程序链接。工作分解结构（WBS）为进度管理计划提供了框架，保证了与估算及相应进度计划的协调性。</p></li><li><p>项目进度模型维护。需要规定在项目执行期间，将如何在进度模型中更新项目状态，记录项目进展。</p></li><li><p>控制临界值。可能需要规定偏差临界值，用于监督进度绩效。它是在需要采取某种措施前，允许出现的最大差异。临界值通常用偏离基准计划中的参数的某个百分数来表示。</p></li><li><p>绩效测量规则。需要规定用于绩效测量的挣值管理（EVM）规则或其他测量规则。例如，进度管理计划可能规定：</p><ul><li><p>确定完成百分比的规则；</p></li><li><p>EVM技术，如基准法、固定公式法、完成百分比法等。更多信息，参阅《挣值管理实践标准》；</p></li><li><p>进度绩效测量指标，如进度偏差（SV）和进度绩效指数（SPI），用来评价偏离原始进度基准的程度。</p></li></ul></li><li><p>报告格式。需要规定各种进度报告的格式和编制频率。</p></li></ul><hr><h3 id="二、定义活动"><a href="#二、定义活动" class="headerlink" title="二、定义活动"></a>二、定义活动</h3><p>定义活动是识别和记录为完成项目可交付成果而须采取的具体行动的过程。本过程的主要作用是，将工作包分解为进度活动，作为对项目工作进行进度估算、规划、执行、监督和控制的基础。本过程需要在整个项目期间开展。图6-5描述本过程的输入、工具与技术和输出。图6-6是本过程的数据流向图。</p><p><img src="/images/pmp-6/6-5.png" alt="定义活动：输入、工具与技术和输出"></p><p><img src="/images/pmp-6/6-6.png" alt="定义活动：数据流向图"></p><h4 id="2-1-定义活动：输入"><a href="#2-1-定义活动：输入" class="headerlink" title="2.1 定义活动：输入"></a>2.1 定义活动：输入</h4><h5 id="2-1-1-项目管理计划"><a href="#2-1-1-项目管理计划" class="headerlink" title="2.1.1 项目管理计划"></a>2.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>进度管理计划。进度管理计划定义进度计划方法、滚动式规划的持续时间，以及管理工作所需的详细程度。</p></li><li><p>范围基准。在定义活动时，需明确考虑范围基准中的项目WBS、可交付成果、制约因素和假设条件。</p></li></ul><h5 id="2-1-2-事业环境因素"><a href="#2-1-2-事业环境因素" class="headerlink" title="2.1.2 事业环境因素"></a>2.1.2 事业环境因素</h5><p>影响定义活动过程的事业环境因素包括（但不限于）：</p><ul><li><p>组织文化和结构；</p></li><li><p>商业数据库中发布的商业信息；</p></li><li><p>项目管理信息系统（PMIS）。</p></li></ul><h5 id="2-1-3-组织过程资产"><a href="#2-1-3-组织过程资产" class="headerlink" title="2.1.3 组织过程资产"></a>2.1.3 组织过程资产</h5><p>能够影响定义活动过程的组织过程资产包括（但不限于）：</p><ul><li><p>经验教训知识库，其中包含以往类似项目的活动清单等历史信息；</p></li><li><p>标准化的流程；</p></li><li><p>以往项目中包含标准活动清单或部分活动清单的模板；</p></li><li><p>现有与活动规划相关的正式和非正式的政策、程序和指南，如进度规划方法论，在编制活动定义时应考虑这些因素。</p></li></ul><h4 id="2-2-定义活动：工具与技术"><a href="#2-2-定义活动：工具与技术" class="headerlink" title="2.2 定义活动：工具与技术"></a>2.2 定义活动：工具与技术</h4><h5 id="2-2-1-专家判断"><a href="#2-2-1-专家判断" class="headerlink" title="2.2.1 专家判断"></a>2.2.1 专家判断</h5><p>应征求了解以往类似项目和当前项目的个人或小组的专业意见。</p><h5 id="2-2-2-分解"><a href="#2-2-2-分解" class="headerlink" title="2.2.2 分解"></a>2.2.2 分解</h5><p>分解是一种把项目范围和项目可交付成果逐步划分为更小、更便于管理的组成部分的技术。活动表示完成工作包所需的投入。定义活动过程的最终输出是活动而不是可交付成果，可交付成果是创建WBS过程的输出。</p><p>WBS、WBS词典和活动清单可依次或同时编制，其中WBS和WBS词典是制定最终活动清单的基础。WBS中的每个工作包都需分解成活动，以便通过这些活动来完成相应的可交付成果。让团队成员参与分解过程，有助于得到更好、更准确的结果。</p><h5 id="2-2-3-滚动式规则"><a href="#2-2-3-滚动式规则" class="headerlink" title="2.2.3 滚动式规则"></a>2.2.3 滚动式规则</h5><p>滚动式规则是一种迭代式的规划技术，即详细规划近期要完成的工作，同时在较高层级上粗略规划远期工作。它是一种渐进明细的规划方式，适用于工作包、规划报以及采用敏捷或瀑布式方法的发布规划。因此，在项目生命周期的不同阶段，工作的详细程度会有所不同。在早期的战略规划阶段，信息上不够明确，工作包只能分解到已知的详细水平；而后，随着了解到更多的信息，近期即将实施的工作包就可以分解到具体的活动。</p><h5 id="2-2-4-会议"><a href="#2-2-4-会议" class="headerlink" title="2.2.4 会议"></a>2.2.4 会议</h5><p>会议可以是面对面或虚拟会议，正式或非正式会议。参会者可以是团队成员或主题专家，目的是定义完成工作所需的活动。</p><h4 id="2-3-定义活动：输出"><a href="#2-3-定义活动：输出" class="headerlink" title="2.3 定义活动：输出"></a>2.3 定义活动：输出</h4><h5 id="2-3-1-活动清单"><a href="#2-3-1-活动清单" class="headerlink" title="2.3.1 活动清单"></a>2.3.1 活动清单</h5><p>活动清单包含项目所需的进度活动。对于使用滚动式规划或敏捷技术的项目，活动清单会在项目进展过程中得到定期更新。活动清单包括每个活动的标识及工作范围详述，使项目团队成员知道需要完成什么工作。</p><h5 id="2-3-2-活动属性"><a href="#2-3-2-活动属性" class="headerlink" title="2.3.2 活动属性"></a>2.3.2 活动属性</h5><p>活动属性是指每项活动所具有的多重属性，用来扩充对活动的描述，活动属性随时间演进。在项目初始阶段，活动属性包括唯一活动标识（ID）、WBS标识和活动标签或名称；在活动属性编制完成时，活动属性可能包括活动描述、紧前活动、紧后活动、逻辑关系、提前量和滞后量、资源需求、强制日期、制约因素和假设条件。活动属性可用于识别开展工作的地点、编制开展活动的项目日历，以及相关的活动类型。活动属性还可用于编制进度计划。根据活动属性，可在报告中以各种方式对计划进度活动进行选择、排序和分类。</p><h5 id="2-3-3-里程碑清单"><a href="#2-3-3-里程碑清单" class="headerlink" title="2.3.3 里程碑清单"></a>2.3.3 里程碑清单</h5><p>里程碑是项目中的重要时点或事件，里程碑清单列出了所有项目里程碑，并指明每个里程碑是强制性的（如合同要求的）还是选择性的（如根据历史信息确定的）。里程碑的持续时间为零，因为它们代表的是一个重要时间点或事件。</p><h5 id="2-3-4-变更请求"><a href="#2-3-4-变更请求" class="headerlink" title="2.3.4 变更请求"></a>2.3.4 变更请求</h5><p>一旦定义项目的基准后，在将可交付成果渐进明细为活动的过程中，可能会发现原本不属于项目基准的工作，这样就会提出变更请求。在这情况下，应该通过实施整体变更控制过程对变更请求进行审查和处理。</p><h5 id="2-3-5-项目管理计划更新"><a href="#2-3-5-项目管理计划更新" class="headerlink" title="2.3.5 项目管理计划更新"></a>2.3.5 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更请求的项目管理计划组成部分包括（但不限于）：</p><ul><li><p>进度基准。在整个项目期间，工作包逐渐细化为活动。在这个过程中可能会发现原本不属于项目基准的工作，从而需要修改作为进度基准一部分的交付日期或其他重要的进度里程碑。</p></li><li><p>成本基准。在针对进度活动的变更获得批准后，需要对成本基准做出相应的变更。</p></li></ul><hr><h3 id="三、排序活动顺序"><a href="#三、排序活动顺序" class="headerlink" title="三、排序活动顺序"></a>三、排序活动顺序</h3><p>排列活动顺序是识别和记录项目活动之间的关系的过程，本过程的主要作用是定义工作之间的逻辑顺序，以便在既定的所有项目制约因素下获得最高的效率。本过程需要在整个项目期间开展。图6-7描述本过程的输入、工具与技术和输出，图6-8是本过程的数据流向图。</p><p><img src="/images/pmp-6/6-7.png" alt="排列活动顺序：输入、工具与技术和输出"></p><p><img src="/images/pmp-6/6-8.png" alt="排列活动顺序：数据流向图"></p><p>除了首尾两项，每项活动都至少有一项紧前活动和一项紧后活动，并且逻辑关系适当。通过设计逻辑关系来创建一个切实的项目进度计划，可能有必要在活动之间使用提前量或滞后量，是项目进度计划更为切实可行；可以使用项目管理软件、手动技术或自动技术，来排列活动顺序。排列活动顺序过程旨在将项目活动列表转化为图表，作为发布进度基准的第一步。</p><h4 id="3-1-排列活动顺序：输入"><a href="#3-1-排列活动顺序：输入" class="headerlink" title="3.1 排列活动顺序：输入"></a>3.1 排列活动顺序：输入</h4><h5 id="3-1-1-项目管理计划"><a href="#3-1-1-项目管理计划" class="headerlink" title="3.1.1 项目管理计划"></a>3.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>进度管理计划。进度管理计划规定了排列活动顺序的方法和准确度，以及所需的其他标准。</p></li><li><p>范围基准。在排列活动顺序时，需明确考察范围基准中的项目WBS、可交付成果、制约因素和假设条件。</p></li></ul><h5 id="3-1-2-项目文件"><a href="#3-1-2-项目文件" class="headerlink" title="3.1.2 项目文件"></a>3.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>活动属性。活动属性中可能描述了事件之间的必然顺序或确定的紧前或紧后关系，以及定义的提前量与滞后量，和活动之间的逻辑关系。</p></li><li><p>活动清单。活动清单列出了项目所需的、待排序的全部进度活动，这些活动的依赖关系和其他制约因素会对活动排序产生影响。</p></li><li><p>假设日志。假设日志所记录的假设条件和制约因素可能影响活动排序的方式、活动之间的关系，以及对提前量和滞后量的需求，并且有可能生成一个会影响项目进度的风险。</p></li><li><p>里程碑清单。里程碑清单中可能已经列出特定里程碑的实现日期，这可能影响活动排序的方式。</p></li></ul><h5 id="3-1-3-事业环境因素"><a href="#3-1-3-事业环境因素" class="headerlink" title="3.1.3 事业环境因素"></a>3.1.3 事业环境因素</h5><p>能够影响排列活动顺序过程的事业环境因素包括（但不限于）：</p><ul><li><p>政府或行业标准；</p></li><li><p>项目管理信息系统（PMIS）；</p></li><li><p>进度规划工具；</p></li><li><p>组织的工作授权系统。</p></li></ul><h5 id="3-1-4-组织过程资产"><a href="#3-1-4-组织过程资产" class="headerlink" title="3.1.4 组织过程资产"></a>3.1.4 组织过程资产</h5><p>能够影响排列活动顺序过程的组织过程资产包括（但不限于）：</p><ul><li><p>项目组合与项目集规划，以及项目之间的依赖关系与关联；</p></li><li><p>现有与活动规划相关的正式和非正式的政策、程序和指南，如进度计划方法论，在确定逻辑关系时应考虑这些因素；</p></li><li><p>有助于加快项目活动网络图编制的各种模板；模板中也会包括有助于排列活动顺序的，与活动属性有关的信息；</p></li><li><p>经验教训知识库，其中包含有助于优化排序过程的历史信息。</p></li></ul><h4 id="3-2-排列活动顺序：工具与技术"><a href="#3-2-排列活动顺序：工具与技术" class="headerlink" title="3.2 排列活动顺序：工具与技术"></a>3.2 排列活动顺序：工具与技术</h4><h5 id="3-2-1-紧前关系绘图法"><a href="#3-2-1-紧前关系绘图法" class="headerlink" title="3.2.1 紧前关系绘图法"></a>3.2.1 紧前关系绘图法</h5><p>紧前关系绘图法（PDM）是创建进度模型的一种技术，用节点表示活动，用一种或多种逻辑关系连接活动，以显示活动的实施顺序。</p><p>PDM包括四种依赖关系或逻辑关系。紧前活动是在进度计划的逻辑路径中，排在非开始活动前面的活动。紧后活动是在进度计划的逻辑路径中，排在某个活动后面的活动。这些关系的定义如下，并如图6-9所示：</p><ul><li><p>完成到开始（FS）。只有紧前活动完成，紧后活动才能开始的逻辑关系。例如，只有完成装配PC硬件（紧前活动），才能开始在PC上安装操作系统（紧后活动）。</p></li><li><p>完成到完成（FF）。只有紧前活动完成，紧后活动才能完成的逻辑关系。例如，只有完成文件的编写（紧前活动），才能完成文件的编辑（紧后活动）。</p></li><li><p>开始到开始（SS）。只有紧前活动开始，紧后活动才能开始的逻辑关系。例如，开始地基浇灌（紧前活动）之后，才能开始混凝土的找平（紧后活动）。</p></li><li><p>开始到完成（SF）。只有紧前活动开始，紧后活动才能完成的逻辑关系。例如，只有启动新的应付账款系统（紧前活动），才能关闭就得应付账款系统（紧后活动）。</p></li></ul><p>在PDM图中，FS是最常用的逻辑关系类型；SF关系则很少使用，为了保持PDM四种逻辑关系类型的完整性，这里也将SF列出。</p><p>虽然两个活动之间可能同时存在两种逻辑关系（例如SS和FF），但不建议相同的活动之间存在多种关系。因此必须做出选出影响最大关系的决定。此外也不建议采用闭环的逻辑关系。</p><p><img src="/images/pmp-6/6-9.png" alt="紧前关系绘图法（PDM）的活动关系类型"></p><h5 id="3-2-2-确定和整合依赖关系"><a href="#3-2-2-确定和整合依赖关系" class="headerlink" title="3.2.2 确定和整合依赖关系"></a>3.2.2 确定和整合依赖关系</h5><p>如下所述，依赖关系可能是强制或选择的，内部或外部的。这四种依赖关系可以组合成强制性外部依赖关系、强制性内部依赖关系、选择性外部依赖关系或选择性内部依赖关系。</p><ul><li><p>强制性依赖关系。强制性依赖关系是法律或合同要求的或工作的内在性质决定的依赖关系，强制性依赖关系往往与客观限制有关。例如，在建筑项目中，只有在地基建成后，才能建立地面结构；在电子项目中，必须先把原型制造出来，然后才能对其进行测试。强制性依赖关系又称硬逻辑关系或硬依赖关系，技术依赖关系可能不是强制性的。在活动排序过程中，项目团队应明确哪些关系是强制性依赖关系，不应把强制性依赖关系和进度计划编制工具中的进度制约因素相混淆。</p></li><li><p>选择性依赖关系。选择性依赖关系有时又称首选逻辑关系、优先逻辑关系或软逻辑关系。即便还有其他依赖关系可用，选择性依赖关系应基于具体应用领域的最佳实践或项目的某些特殊性质对活动顺序的要求来创建。例如，根据普遍公认的最佳实践，在建造期间，应先完成卫生管道工程，才能开始电气工程。这个顺序并不是强制性要求，两个工程可以同时（并行）开展工作，但如按先后顺序进行可以降低整体项目风险。应该对选择性依赖关系进行全面记录，因为它们会影响总浮动时间，并限制后续的进度安排。如果打算进行快速跟进，则应当审查相应的选择性依赖关系，并考虑是否需要调整或去除。在排列活动顺序过程中，项目团队应明确哪些依赖关系属于选择性依赖关系。</p></li><li><p>外部依赖关系。外部依赖关系是项目活动与非项目活动之间的依赖关系，这些依赖关系往往不在项目团队的控制范围内。例如，软件项目的测试活动取决于外部硬件的到货；建筑项目的现场准备，可能要在政府的环境听证会之后才能开始。在排列活动顺序过程中，项目管理团队应明确哪些依赖关系属于外部依赖关系。</p></li><li><p>内部依赖关系。内部依赖关系是项目活动之间的紧前关系，通常在项目团队的控制之中。例如，只有机器组装完毕，团队才能对其测试，这是一个内部的强制性依赖关系。在排列活动顺序过程中，项目管理团队应明确哪些依赖关系属于内部依赖关系。</p></li></ul><h5 id="3-2-3-提前量和滞后量"><a href="#3-2-3-提前量和滞后量" class="headerlink" title="3.2.3 提前量和滞后量"></a>3.2.3 提前量和滞后量</h5><p>提前量是相对于紧前活动，紧后活动可以提前的时间量。例如，在新办公大楼建设项目中，绿化施工可以在尾工清单编制完成前2周开始，这就是带2周提前量的完成到开始的过程，如图6-10所示。在进度计划软件中，提前量往往表示为负滞后量。</p><p><img src="/images/pmp-6/6-10.png" alt="提前量和滞后量示例"></p><p>滞后量是相对于紧前活动，紧后活动需要推迟的时间量。例如，对于一个大型技术文档，编写小组可以在编写工作开始后15天，开始编辑文档草案，这就是带15天滞后量的开始到开始关系，如图6-10所示。在图6-11的项目进度网络图中，活动H到活动I之间就有滞后量，表示为SS+10（带10天滞后量的开始到开始关系），虽然图中并没有用精确的时间刻度来表示之后的量值。</p><p>项目管理团队应该明确哪些依赖关系中需要加入提前量或滞后量，以便准确地表示活动之间的逻辑关系。提前量和滞后量的使用不能替代进度逻辑关系，而且持续时间估算中不包括任何提前量或滞后量，同时还应该记录各种活动及与之相关的假设条件。</p><p><img src="/images/pmp-6/6-11.png" alt="项目进度网络图"></p><h5 id="3-2-4-项目管理信息系统（PMIS）"><a href="#3-2-4-项目管理信息系统（PMIS）" class="headerlink" title="3.2.4 项目管理信息系统（PMIS）"></a>3.2.4 项目管理信息系统（PMIS）</h5><p>项目管理信息系统包括进度计划软件；这些软件有助于规划、组织和调整活动顺序，插入逻辑关系、提前和滞后值，以及区分不同类型的依赖关系。</p><h4 id="3-3-排列活动顺序：输出"><a href="#3-3-排列活动顺序：输出" class="headerlink" title="3.3 排列活动顺序：输出"></a>3.3 排列活动顺序：输出</h4><h5 id="3-3-1-项目进度网络图"><a href="#3-3-1-项目进度网络图" class="headerlink" title="3.3.1 项目进度网络图"></a>3.3.1 项目进度网络图</h5><p>项目进度网络图是表示项目进度活动之间的逻辑关系（也叫依赖关系）的图形。图6-11是项目进度网络图的一个示例。项目进度网络图可手工或借助项目管理软件来绘制，可包括项目的全部细节，也可只列出一项或多项概括性活动。项目进度网络图应附有简要文字描述，说明活动排序所使用的的基本方法。在文字描述中，还应该对任何异常的活动序列做详细说明。</p><p>带有多个紧前活动的活动代表路径汇聚，而带有多个紧后活动的活动则代表路径分支。带汇聚和分支的活动受到多个活动的影响或能够影响多个活动，因此存在更大的风险。I活动被称为“路径汇聚”，因为它拥有多个紧前活动，而K活动被称为“路径分支”，因为它拥有多个紧后活动。</p><h5 id="3-3-2-项目文件更新"><a href="#3-3-2-项目文件更新" class="headerlink" title="3.3.2 项目文件更新"></a>3.3.2 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>活动属性。活动属性中可能描述了事件之间的必然顺序或确定的紧前或紧后关系，以及定义的提前量与滞后量，和活动之间的逻辑关系。</p></li><li><p>活动清单。在排列活动顺序时，活动清单可能会受到项目活动关系变更的影响。</p></li><li><p>假设日志。根据活动的排序、关系确定以及提前量和滞后量，可能需要更新假设日志中的假设条件和制约因素，并且有可能生成一个会影响项目进度的风险。</p></li><li><p>里程碑清单。在排列活动顺序时，特定里程碑的计划实现日期可能会受到项目活动关系变更的影响。</p></li></ul><hr><h3 id="四、估算活动持续时间"><a href="#四、估算活动持续时间" class="headerlink" title="四、估算活动持续时间"></a>四、估算活动持续时间</h3><p>估算活动持续时间是根据资源估算的结果，估算完成单项活动所需工作时段数的过程。本过程的主要作用是，确定完成每个活动所需花费的时间量。本过程需要在整个项目期间开展。图6-12描述本过程的输入、工具与技术和输出。图6-13是本过程的数据流向图。</p><p><img src="/images/pmp-6/6-12.png" alt="估算活动持续时间：输入、工具与技术和输出"></p><p><img src="/images/pmp-6/6-13.png" alt="估算活动持续时间：数据流向图"></p><p>估算活动持续时间依据的信息包括：工作范围、所需资源类型与技能水平、估算的资源数量和资源日历，而可能影响持续时间估算的其他因素包括对持续时间受到的约束、相关人力投入、资源类型（如固定持续时间、固定人力投入或工作、固定资源数量）以及所采用的进度网络分析技术。应该由项目团队中最熟悉具体活动的个人或小组提供持续时间估算所需的各种输入，对持续时间的估算也应该渐进明细，取决于输入数据的数量和质量。例如，在工程与设计项目中，随着数据越来越详细，越来越准确，持续时间估算的准确性和质量也会越来越高。</p><p>在本过程中，应该首先估算出完成活动所需的工作量和计划投入该活动的资源数量，然后结合项目日历和资源日历，据此估算出完成活动所需的工作时段数（活动持续时间）。在许多情况下，预计可用的资源数量以及这些资源的技能熟练程度可能会决定活动的持续时间，更改分配到活动的主导性资源通常会影响持续时间，但这不是简单的“直线”或线性关系。有时候，因为工作的特性（即受到持续时间的约束、相关人力投入或资源数量），无论资源分配如何（如24小时应力测试），都需要花预定的时间才能完成工作。估算持续时间时需要考虑的其他因素包括：</p><ul><li><p>收益递减规律。在保持其他因素不变的情况下，增加一个用于确定单位产出所需投入的因素（如资源）会最终达到一个临界点，在该点之后的产出或输出会随着增加这个因素而递减。</p></li><li><p>资源数量。增加资源数量，使其达到初始数量的两倍不一定能缩短一半的时间，因为这样做可能会因风险而造成持续时间增加；在某些情况下，如果增加太多活动资源，可能会因知识传递、学习曲线、额外合作等其他相关因素而造成持续时间增加。</p></li><li><p>技术进步。在确定持续时间估算时，这个因素也可能发挥重要作用。例如，通过采购最近技术，制造工厂可以提高产量，而这可能会影响持续时间和资源需求。</p></li><li><p>员工激励。项目经理还需要了解“学生综合征”（即拖延症）和帕金森定律，前者指出，人们只有在最后一刻，即快到期限时才会全力以赴；后者指出，只要还有时间，工作就会不断扩展，直到用完所有的时间。</p></li></ul><p>应该把活动持续时间估算所依据的全部数据与假设都记录在案。</p><h4 id="4-1-估算活动持续时间：输入"><a href="#4-1-估算活动持续时间：输入" class="headerlink" title="4.1 估算活动持续时间：输入"></a>4.1 估算活动持续时间：输入</h4><h5 id="4-1-1-项目管理计划"><a href="#4-1-1-项目管理计划" class="headerlink" title="4.1.1 项目管理计划"></a>4.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>进度管理计划。进度管理计划规定了用于估算活动持续时间的方法和准确度，以及所需的其他标准。</p></li><li><p>范围基准。范围基准包含WBS词典，后者包括可能影响人力投入和持续时间估算的技术细节。</p></li></ul><h5 id="4-1-2-项目文件"><a href="#4-1-2-项目文件" class="headerlink" title="4.1.2 项目文件"></a>4.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>活动属性。活动属性可能描述了确定的紧前或紧后关系、定义的提前量与滞后量以及可能影响持续时间估算的活动之间的逻辑关系。</p></li><li><p>活动清单。活动清单列出了项目所需的、待估算的全部进度活动，这些活动的依赖关系和其他制约因素会对持续时间估算产生影响。</p></li><li><p>假设日志。假设日志所记录的假设条件和制约因素有可能生成一个会影响项目进度的风险。</p></li><li><p>经验教训登记册。与人力投入和持续时间估算有关的经验教训登记册可以运用到项目后续阶段，以提高人力投入和持续时间估算的准确性。</p></li><li><p>里程碑清单。里程碑清单中可能已经列出特定里程碑的计划实现日期，这可能影响持续时间估算。</p></li><li><p>项目团队派工单。将合适的人员分派到团队，为项目配备人员。</p></li><li><p>资源分解结构。资源分解结构按照资源类别和资源类型，提供了已识别资源的层级结构。</p></li><li><p>资源日历。资源日历中的资源可用性、资源类型和资源性质，都会影响进度活动的持续时间。资源日历规定了在项目期间特定的项目资源何时可用及可用多久。</p></li><li><p>资源需求。估算的活动资源需求会对活动持续时间产生影响。对于大多数活动来说，所分配的资源能否达到要求，将对其持续时间有显著影响。例如，向某个活动新增资源或分配低技能资源，就需要增加沟通、培训和协调工作，从而可能导致活动效率或生产率下降，由此需要估算更长的持续时间。</p></li><li><p>风险登记册。单个项目风险可能影响资源的选择和可用性。风险登记册的更新包括在项目文件更新中，见“规划风险应对”一节。</p></li></ul><h5 id="4-1-3-事业环境因素"><a href="#4-1-3-事业环境因素" class="headerlink" title="4.1.3 事业环境因素"></a>4.1.3 事业环境因素</h5><p>能够影响估算活动持续时间过程的事业环境因素包括（但不限于）：</p><ul><li><p>持续时间估算数据库和其他参考数据；</p></li><li><p>生产率测量指标；</p></li><li><p>发布的商业信息；</p></li><li><p>团队成员的所在地。</p></li></ul><h5 id="4-1-4-组织过程资产"><a href="#4-1-4-组织过程资产" class="headerlink" title="4.1.4 组织过程资产"></a>4.1.4 组织过程资产</h5><p>能够影响估算活动持续时间过程的组织过程资产包括（但不限于）：</p><ul><li><p>关于持续时间的历史信息；</p></li><li><p>项目日历；</p></li><li><p>估算政策；</p></li><li><p>进度规划方法论；</p></li><li><p>经验教训知识库。</p></li></ul><h4 id="4-2-估算活动持续时间：工具与技术"><a href="#4-2-估算活动持续时间：工具与技术" class="headerlink" title="4.2 估算活动持续时间：工具与技术"></a>4.2 估算活动持续时间：工具与技术</h4><h5 id="4-2-1-专家判断"><a href="#4-2-1-专家判断" class="headerlink" title="4.2.1 专家判断"></a>4.2.1 专家判断</h5><p>应征求具备以下专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>进度计划的编制、管理和控制；</p></li><li><p>有关估算的专业知识；</p></li><li><p>学科或应用知识。</p></li></ul><h5 id="4-2-2-类比估算"><a href="#4-2-2-类比估算" class="headerlink" title="4.2.2 类比估算"></a>4.2.2 类比估算</h5><p>类比估算是一种使用相似活动项目的历史数据，来估算当前活动或项目的持续时间或成本的技术。类比估算以过去类似项目的参数值（如持续时间、预算、规模、重量和复杂性等）为基础，来估算未来项目的同类参数或指标。在估算持续时间时，类比估算技术以过去类似项目的实际持续时间为依据，来估算当前项目的持续时间。这是一种粗略的估算方法，有时需要根据项目复杂性方面的已知差异进行调整，在项目详细信息不足时，就经常使用类比估算来估算项目持续时间。</p><p>相对于其他估算技术，类比估算通常成本较低、耗时较少，但准确性也较低。类比估算可以针对整个项目或项目中的某个部分进行，或可以与其他估算方法联合使用。如果以往活动是本质上而不是表面上类似，并且从事估算的项目团队成员具备必要的专业知识，那么类比估算就最为可靠。</p><h5 id="4-2-3-参数估算"><a href="#4-2-3-参数估算" class="headerlink" title="4.2.3 参数估算"></a>4.2.3 参数估算</h5><p>参数估算是一种基于历史数据和项目参数，使用某种算法来计算成本或持续时间的估算技术。它是指利用历史数据之间的统计关系和其他变量（如建筑施工中的平方英尺），来估算诸如成本、预算和持续时间等活动参数。</p><p>把需要实施的工作量乘以完成单位工作量所需的工时，即可计算出持续时间。例如，对于设计项目，将图纸的张数乘以每张图纸所需的工时；或者对于电缆铺设项目，将电缆的长度乘以铺设每米电缆所需的工时。如果所用的资源每小时能够铺设25米电缆，那么铺设1000米电缆的持续时间是40小时（1000米除以24米/小时）。</p><p>参数估算的准确性取决于参数模型和成熟度和基础数据的可靠性。且参数进度估算可以针对整个项目或项目中的某个部分，并可以与其他估算方法联合使用。</p><h5 id="4-2-4-三点估算"><a href="#4-2-4-三点估算" class="headerlink" title="4.2.4 三点估算"></a>4.2.4 三点估算</h5><p>通过考虑估算中的不确定性和风险，可以提高持续时间估算的准确性。使用三点估算有助于界定活动持续时间的近似区间：</p><ul><li><p>最可能时间（<code>tM</code>）。基于最可能获得的资源、最可能取得的资源生产率、对资源可用时间的实现预计、资源对其他参与者的可能依赖关系及可能发生的各种干扰等，所估算的活动持续时间。</p></li><li><p>最乐观时间（<code>tO</code>）。基于活动的最好情况所估算的活动持续时间。</p></li><li><p>最悲观时间（<code>tP</code>）。寄语活动的最差情况所估算的活动持续时间。</p></li></ul><p>基于持续时间的三种估算值区间内的假定分布情况，可计算期望持续时间<code>tE</code>。一个常用公式为三角分布：</p><p><code>tE = (tO + tM + tP) / 3</code></p><p>历史数据不充分或使用判断数据时，使用三角分布，基于三点的假定分布估算出期望持续时间，并说明期望持续时间的不确定区间。</p><h5 id="4-2-5-自下而上估算"><a href="#4-2-5-自下而上估算" class="headerlink" title="4.2.5 自下而上估算"></a>4.2.5 自下而上估算</h5><p>自下而上估算是一种估算项目持续时间或成本的方法，通过从下到上逐层汇总WBS组成部分的估算而得到项目估算。如果无法以合理的可信度对活动持续时间进行估算，则应将活动中的工具进一步细化，然后估算具体的持续时，接着再汇总这些资源需求估算，得到每个活动的持续时间。活动之间可能存在或不存在会影响资源利用的依赖关系；如果存在，就应该对相应的资源使用方式加以说明，并记录在活动资源需求中。</p><h5 id="4-2-6-数据分析"><a href="#4-2-6-数据分析" class="headerlink" title="4.2.6 数据分析"></a>4.2.6 数据分析</h5><p>可用作本过程的数据分析技术包括（但不限于）：</p><ul><li><p>备选方案分析。备选方案分析用于比较不同的资源能力或技术水平、进度压缩技术、不同工具（手动和自动），以及关于资源的创建、租赁和购买决策。这有助于团队权衡资源、成本和持续时间变量，以确定完成项目工作的最佳方式。</p></li><li><p>储备分析。储备分析用于确定项目所需的应急储备量和管理储备。在进行持续时间估算时，需考虑应急储备（有时称为“进度储备”），以应对进度方面的不确定性。应急储备是包含在进度基准中的一段持续时间，用来应对已经接受的已识别风险。应急储备与“已知——未知”风险相关，需要加以合理估算，用于完成未知的工作量。应急储备可取活动持续时间估算值的某一百分比或某一固定的时间段，亦可把应急储备从各个活动中剥离出来并汇总。随着项目信息越来越明确，可以动用、减少或取消应急储备，应该在项目进度文件中清楚地列出应急储备。也可以估算项目进度管理所需要的管理储备量。管理储备是为管理控制的目的而特别留出的项目预算，用来应对项目范围中不可预见的工作。管理储备用来应对会影响项目的“未知——未知”风险，它不包括在进度基准中，但属于项目总持续时间的一部分。依据合同条款，使用管理储备可能需要变更进度基准。</p></li></ul><h5 id="4-2-7-决策"><a href="#4-2-7-决策" class="headerlink" title="4.2.7 决策"></a>4.2.7 决策</h5><p>适用于本过程的决策技术包括（但不限于）投票。举手表决是从投票方法衍生出来的一种形式，经常用于敏捷项目中。采用这种技术时，项目经理会让团队成员针对某个决定示意支持程度，举拳头表示不支持，伸五个手指表示完全支持，深处三个以下手指的团队成员有机会与团队讨论其反对意见。项目经理会不断进行举手表决，直到整个团队达成共识（所有人都伸出三个以上手指）或同意进入下一个决定。</p><h5 id="4-2-8-会议"><a href="#4-2-8-会议" class="headerlink" title="4.2.8 会议"></a>4.2.8 会议</h5><p>项目团队可能会召开会议来估算活动持续时间。如果采用敏捷方法，则有必要举行冲刺或迭代计划会议，以讨论按优先级排序的产品未完项（用户故事），并决定团队在下一个迭代中会致力于解决哪个未完项。然后团队将用户故事分解为按小时估算的底层级任务，然后根据团队在持续时间（迭代）方面的能力确认估算可行。该会议通常在迭代的第一天举行，参会者包括产品负责人、开发团队和项目经理，会议结果包括迭代未完项、假设条件、关注事项、风险、依赖关系、决定和行动。</p><h4 id="4-3-估算活动持续时间：输出"><a href="#4-3-估算活动持续时间：输出" class="headerlink" title="4.3 估算活动持续时间：输出"></a>4.3 估算活动持续时间：输出</h4><h5 id="4-3-1-持续时间估算"><a href="#4-3-1-持续时间估算" class="headerlink" title="4.3.1 持续时间估算"></a>4.3.1 持续时间估算</h5><p>持续时间估算是对完成某项活动、阶段或项目所需的工作时段数的定量评估，其中并不包括任何滞后量，但可指出一定的变动区间。例如：</p><ul><li><p>2周±2天，表明活动至少需要8天，最多不超过12天（假定每周工作5天）；</p></li><li><p>超过3周的概率为15%，表明该活动将在3周内（含3周）完工的概率为85%。</p></li></ul><h5 id="4-3-2-估算依据"><a href="#4-3-2-估算依据" class="headerlink" title="4.3.2 估算依据"></a>4.3.2 估算依据</h5><p>持续时间估算所需的支持信息的数量和种类，因应用领域而异。不论其详细程度如何，支持性文件都应该清晰、完整地说明持续时间估算是如何得出的。</p><p>持续时间估算的支持信息可包括：</p><ul><li><p>关于估算依据的文件（如估算是如何编制的）；</p></li><li><p>关于全部假设条件的文件；</p></li><li><p>关于各种已知制约因素的文件；</p></li><li><p>对估算区间的说明（如“±10%”），以指出预期持续时间的所在区间；</p></li><li><p>对最终估算的置信水平的说明；</p></li><li><p>有关影响估算的单个项目风险的文件。</p></li></ul><h5 id="4-3-3-项目文件更新"><a href="#4-3-3-项目文件更新" class="headerlink" title="4.3.3 项目文件更新"></a>4.3.3 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>活动属性。本过程输出的活动持续时间估算将记录在活动属性中。</p></li><li><p>假设日志。这包括为估算持续时间而制定的假设条件，如资源的技能水平、可用性，以及估算依据，此外还记录了进度计划方法轮和进度计划编制工具所带来的的制约因素。</p></li><li><p>经验教训登记册。在更新经验教训登记册时，可以增加能够有效和高效地估算人力投入和持续时间的技术。</p></li></ul><hr><h3 id="五、制定进度计划"><a href="#五、制定进度计划" class="headerlink" title="五、制定进度计划"></a>五、制定进度计划</h3><p>制定进度计划是分析活动顺序、持续时间、资源需求和进度制约因素，创建进度模型，从而落实项目执行和监控的过程。本过程的主要作用是，未完成项目活动而制定具有计划日期的进度模型。本过程需要在整个项目期间开展。图6-14描述本过程的输入、工具与技术和输出，图6-15是本过程的数据流向图。</p><p><img src="/images/pmp-6/6-14.png" alt="制定进度计划：输入、工具与技术和输出"></p><p><img src="/images/pmp-6/6-15.png" alt="制定进度计划：数据流向图"></p><p>制定可行的项目进度计划是一个反复进行的过程。基于获取的最佳信息，使用进度模型来确定各项目活动和里程碑的计划开始日期和计划完成日期。编制进度计划时，需要审查和修正持续时间估算、资源估算和进度储备，以制定项目进度计划，并在经批准后作为基准用于跟踪项目进度。关键步骤包括定义项目里程碑、识别活动并排列活动顺序，以及估算持续时间。一旦活动的开始和完成日期得到确定，通常就需要由分配至各个活动的项目人员审查其被分配的活动。之后，项目人员确定开始和完成日期与资源日历没有冲突，也与其他项目或任务没有冲突，从而确认计划日期的有效性。最后分析进度计划，确定是否存在逻辑关系冲突，以及在批准进度计划并将其作为基准之前是否需要资源平衡。同时，需要修订和维护项目进度模型，确保进度计划在整个项目期间一直切实可行。</p><p>有关进度规划的更多信息，参阅《进度计划实践标准》。</p><h4 id="5-1-制定进度计划：输入"><a href="#5-1-制定进度计划：输入" class="headerlink" title="5.1 制定进度计划：输入"></a>5.1 制定进度计划：输入</h4><h5 id="5-1-1-项目管理计划"><a href="#5-1-1-项目管理计划" class="headerlink" title="5.1.1 项目管理计划"></a>5.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>进度管理计划。进度管理计划规定了用于制定进度计划的进度计划编制工具和工具，以及推算进度计划的方法。</p></li><li><p>范围基准。范围说明书、WBS和WBS词典包含了项目可交付成果的详细信息，供创建进度模型时借鉴。</p></li></ul><h5 id="5-1-2-项目文件"><a href="#5-1-2-项目文件" class="headerlink" title="5.1.2 项目文件"></a>5.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>活动属性。活动属性提供了创建进度模型所需的细节信息。</p></li><li><p>活动清单。活动清单明确了需要在进度模型中包含的活动。</p></li><li><p>假设日志。假设日志所记录的假设条件和制约因素可能造成影响项目进度的单个项目风险。</p></li><li><p>估算依据。持续时间估算所需的支持信息的数量和种类，因应用领域而异。不论其详细程度如何，支持性文件都应该清晰、完整地说明持续时间估算是如何得出的。</p></li><li><p>持续时间估算。持续时间估算包括对完成某项活动所需的工作时段数的定量评估，用于进度计划的推算。</p></li><li><p>经验教训。与创建进度模型有关的经验教训登记册可以运用到项目后期阶段，以提高进度模型的有效性。</p></li><li><p>里程碑清单。里程碑清单列出特定里程碑的实现日期。</p></li><li><p>项目进度网络图。项目进度网络图中包含用于推算进度计划的紧前和紧后活动的逻辑关系。</p></li><li><p>项目团队派工单。项目团队派工单明确了分配到每个活动的资源。</p></li><li><p>资源日历。资源日历规定了在项目期间的资源可用性。</p></li><li><p>资源需求。活动资源需求明确了每个活动所需的资源类型和数量，用于创建进度模型。</p></li><li><p>风险登记册。风险登记册中的所有已识别的会影响进度模型的风险的详细信息及特征。进度储备则通过预期或平均风险影响程度，反映了与进度有关的风险信息。</p></li></ul><h5 id="5-1-3-协议"><a href="#5-1-3-协议" class="headerlink" title="5.1.3 协议"></a>5.1.3 协议</h5><p>在制定如何执行项目工作以履行合同承诺的详细信息时，供应商为项目进度提供了输入。</p><h5 id="5-1-4-事业环境因素"><a href="#5-1-4-事业环境因素" class="headerlink" title="5.1.4 事业环境因素"></a>5.1.4 事业环境因素</h5><p>能够影响制定进度计划过程的事业环境因素包括（但不限于）：</p><ul><li><p>政府或行业标准；</p></li><li><p>沟通渠道。</p></li></ul><h5 id="5-1-5-组织过程资产"><a href="#5-1-5-组织过程资产" class="headerlink" title="5.1.5 组织过程资产"></a>5.1.5 组织过程资产</h5><p>能够影响制定进度计划过程的组织过程资产包括（但不限于）：</p><ul><li><p>进度计划方法论，其中包括制定和维护进度模型时应遵循的政策；</p></li><li><p>项目日历。</p></li></ul><h4 id="5-2-制定进度计划：工具与技术"><a href="#5-2-制定进度计划：工具与技术" class="headerlink" title="5.2 制定进度计划：工具与技术"></a>5.2 制定进度计划：工具与技术</h4><h5 id="5-2-1-进度网络分析"><a href="#5-2-1-进度网络分析" class="headerlink" title="5.2.1 进度网络分析"></a>5.2.1 进度网络分析</h5><p>进度网络分析是创建项目进度模型的一种综合技术，它采用了其他几种技术，例如关键路径法、资源优化技术和建模技术。其他分析包括（但不限于）：</p><ul><li><p>当多个路径在同一时间点汇聚或分叉时，评估汇总进度储备的必要性，以减少出现进度落后的可能性。</p></li><li><p>审查网络，看看关键路径是否存在高风险活动或具有较多提前量的活动，是否需要使用进度储备或执行风险应对计划来降低关键路径的风险。</p></li></ul><p>进度网络分析是一个反复进行的过程，一直持续到创建出可行的进度模型。</p><h5 id="5-2-2-关键路径法"><a href="#5-2-2-关键路径法" class="headerlink" title="5.2.2 关键路径法"></a>5.2.2 关键路径法</h5><p>关键路径法用于在进度模型中估算项目最短工期，确定逻辑网络路径的进度灵活性大小。这种进度网络分析技术在不考虑任何资源限制的情况下，沿进度网络路径使用顺推与逆推法，计算出所有活动的最早开始、最早结束、最晚开始和最晚完成日期，如图6-16所示。在这个例子中，最长路径包括活动A、C和D，因此，活动序列A-C-D就是关键路径。关键路径是项目中时间最长的活动顺序，决定着可能的项目最短工期。最长路径的总浮动时间最少，通常为零。由此得到的最早和最晚的开始和结束日期并不一定就是项目进度计划，而只是把既定的参数（活动持续时间、逻辑关系、提前量、滞后量和其他已知的制约因素）输入进度模型后所得到的一种结果，表明活动可以在该时段内实施。关键路径法用来计算进度模型中的关键路径、总浮动时间和自由浮动时间，或逻辑网络路径的进度灵活性大小。</p><p>在任一网络路径上，进度活动可以从最早开始日期推迟或拖延的时间，而不至于延误项目完成日期或违反进度制约因素，就是总浮动时间或进度灵活性。正常情况下，关键路径的总浮动时间为零。在进行紧前关系绘图法排序的过程中，取决于所有的制约因素，关键路径的总浮动时间可能是正值、零或负值。总浮动时间为正值，是由于逆推计算所使用的进度制约因素要晚于顺推计算所得出的最早完成日期；总浮动时间为负值，是由于持续时间和逻辑关系违反了对最晚日期的制约因素。负值浮动时间分析是一种有助于找到推动延迟的进度回到正轨的方法的技术。进度网络图可能有多条次关键路径。许多软件允许用户自行定义用于确定关键路径的参数。为了使网络路径的总浮动时间为零或正值，可能需要调整活动持续时间（可增加资源或缩减范围时）、逻辑关系（针对选择性依赖关系时）、提前量和滞后量，或其他进度制约因素。一旦计算出总浮动时间和自由浮动时间，自由浮动时间就是指在不延误任何紧后活动最早开始日期或不违反进度制约因素的前提下，某进度活动可以推迟的时间量。例如，图6-16中，活动B的自由浮动时间是5天。</p><p><img src="/images/pmp-6/6-16.png" alt="关键路径法示例"></p><h5 id="5-2-3-资源优化"><a href="#5-2-3-资源优化" class="headerlink" title="5.2.3 资源优化"></a>5.2.3 资源优化</h5><p>资源优化用于调整活动的开始和完成日期，以调整计划使用的资源，使其等于或少于可用的资源。资源优化技术是根据资源供需情况，来调整进度模型的技术，包括（但不限于）：</p><ul><li><p>资源平衡。为了在资源需求与资源供给之间取得平衡，根据资源制约因素对开始日期和完成日期进行调整的一种技术。如果共享资源或关键资源只在特定时间可用，数量有限，或被过度分配，如一个资源在同一时段内被分配至两个或多个活动（见图6-17），就需要进行资源平衡。也可以为保持资源使用量处于均衡水平而进行资源平衡。资源平衡往往导致关键路径改变。而可以用浮动时间平衡资源。因此，在项目进度计划期间，关键路径可能发生变化。</p></li><li><p>资源平滑。对进度模型中的活动进行调整，从而使项目资源不超过预定的资源限制的一种技术。相对于资源平衡而言，资源平滑不会改变项目关键路径，完工日期也不会延迟。也就是说，活动只在其自由和总浮动时间内延迟，但资源平滑技术可能无法实现所有资源的优化。</p></li></ul><p><img src="/images/pmp-6/6-17.png" alt="资源平衡"></p><h5 id="5-2-4-数据分析"><a href="#5-2-4-数据分析" class="headerlink" title="5.2.4 数据分析"></a>5.2.4 数据分析</h5><p>可用作本过程的数据分析技术包括（但不限于）：</p><ul><li><p>假设情景分析。假设情景分析是对各种情景进行评估，预测它们对项目目标的影响（积极或消极的）。假设情景分析就是对“如果情境X出现，情况会怎样？”这样的问题进行分析，即基于已有的进度计划，考虑各种各样的情景。例如，推迟某主要部件的交货日期，延长某设计工作的时间，或加入外部因素（如罢工或许可证申请流程变化等）。可以根据假设情景分析的结果，评估项目进度计划在不同条件下的可行性，以及为应对意外情况的影响而编制进度储备和应对计划。</p></li><li><p>模拟。模拟是把单个项目风险和不确定性的其它来源模型化的方法，以评估它们对项目目标的潜在影响。最常见的模拟技术是蒙特卡洛分析，它利用风险和其他不确定资源计算整个项目可能的进度结果。模拟包括基于多种不同的活动假设、制约因素、风险、问题或情景，使用概率分布和不确定性的其他表现形式，来计算出多种可能的工作包持续时间。图6-18显示了一个项目的概率分布，表明实现特定目标日期（即项目完成日期）的可能性。在这个例子中，项目按时或在目标日期，即5月13日之前完成的概率是10%，而在5月28日之前完成的概率是90%。</p></li></ul><p><img src="/images/pmp-6/6-18.png" alt="目标里程碑的概率分布示例"></p><p>有关蒙特卡洛模拟如何用于进度模型的更多信息，请参见《进度计划实践标准》。</p><h5 id="5-2-5-提前量和滞后量"><a href="#5-2-5-提前量和滞后量" class="headerlink" title="5.2.5 提前量和滞后量"></a>5.2.5 提前量和滞后量</h5><p>提前量和滞后量是网络分析中使用的一种调整方法，通过调整紧后活动的开始时间来编制一份切实可行的进度计划。提前量用于在条件许可的情况下提早开始紧后活动；而滞后量是在某些限制条件下，在紧前和紧后活动之间增加一段不需工作或资源的自然时间。</p><h5 id="5-2-6-进度压缩"><a href="#5-2-6-进度压缩" class="headerlink" title="5.2.6 进度压缩"></a>5.2.6 进度压缩</h5><p>进度压缩技术是指在不缩减项目范围的前提下，缩短或加快进度工期，以满足进度制约因素、强制日期或其他进度目标。负值浮动时间分析是一种有用的技术。关键路径是浮动时间最少的方法。在违反制约因素或强制日期时，总浮动时间可能变成负值。图6-19比较了多个进度压缩技术。包括：</p><ul><li><p>赶工。通过增加资源，以最小的成本代价来压缩进度工期的一种技术。赶工的例子包括：批准加班、增加额外资源或支付加急费用，来加快关键路径上的活动。赶工只适用于那些通过增加资源就能缩短持续时间的，且位于关键路径上的活动。但赶工并非总是切实可行的，因它可能导致风险和（或）成本的增加。</p></li><li><p>快速跟进。一种进度压缩技术，将正常情况下按顺序进行的活动或阶段改为至少是部分并行开展。例如，在大楼的建筑图纸尚未全部完成前就开始建地基。快速跟进可能造成返工和风险增加，所以它只适用于能够通过并行活动来缩短关键路径上的项目工期的情况。以防进度加快而使用提前量通常增加相关活动之间的协调工作，并增加质量风险。快速跟进还有可能增加项目成本。</p></li></ul><p><img src="/images/pmp-6/6-19.png" alt="进度压缩技术的比较"></p><h5 id="5-2-7-项目管理信息系统（PMIS）"><a href="#5-2-7-项目管理信息系统（PMIS）" class="headerlink" title="5.2.7 项目管理信息系统（PMIS）"></a>5.2.7 项目管理信息系统（PMIS）</h5><p>项目管理信息系统包括进度计划软件，这些软件用活动、网络图、资源需求和活动持续时间等作为输入，自动生成开始和完成日期，从而可加快进度计划的编制过程。</p><h5 id="5-2-8-敏捷发布规划"><a href="#5-2-8-敏捷发布规划" class="headerlink" title="5.2.8 敏捷发布规划"></a>5.2.8 敏捷发布规划</h5><p>敏捷发布规划基于项目路线图和产品发展愿景，提供了高度概括的发布进度时间轴（通常是3到6个月）。同时，敏捷发布规划还确定了发布的迭代或冲刺次数，使产品负责人和团队能够决定需要开发的内容，并基于业务目标、依赖关系和障碍因素确定达到产品放行所需的时间。</p><p>对客户而言，产品功能就是价值，因此，该时间轴定义了每次迭代结束时交付的功能，提供了更易于理解的项目进度计划，而这些就是客户真正需要的信息。</p><p>图6-20展示了产品愿景、产品路线图、发布规划和迭代计划之间的关系。</p><p><img src="/images/pmp-6/6-20.png" alt="产品愿景、发布规划和迭代计划之间的关系"></p><h4 id="5-3-制定进度计划：输出"><a href="#5-3-制定进度计划：输出" class="headerlink" title="5.3 制定进度计划：输出"></a>5.3 制定进度计划：输出</h4><h5 id="5-3-1-进度基准"><a href="#5-3-1-进度基准" class="headerlink" title="5.3.1 进度基准"></a>5.3.1 进度基准</h5><p>进度基准是经过批准的进度模型，只有通过正式的变更控制程序才能进行变更，用作与实际结果进行比较的依据。经相关方接受和批准，进度基准包含基准开始日期和基准结束日期。在监控过程中，将用实际开始和完成日期与批准的基准日期进行比较，以确定是否存在偏差。进度基准是项目管理计划的组成部分。</p><h5 id="5-3-2-项目进度计划"><a href="#5-3-2-项目进度计划" class="headerlink" title="5.3.2 项目进度计划"></a>5.3.2 项目进度计划</h5><p>项目进度计划是进度模型的输出，为各个相互关联的活动标注了计划日期、持续时间、里程碑和所需资源等星系。项目进度计划中至少要包括每个活动的计划开始日期与计划完成日期。即使在早期阶段就进行了资源规划，但在未确认资源分配和计划开始与完成日期之前，项目进度计划都只是初步的。一般要在项目管理计划编制完成之前进行这些确认。还可以编制一份目标项目进度模型，规定每个活动的目标开始日期与目标完成日期。项目进度计划可以是概括（有时称为朱进度计划或里程碑进度计划）或详细的。虽然项目进度计划可用列表形式，但图形方式更常见。可以采用以下一种或多种图形来呈现：</p><ul><li><p>横道图。横道图也称为“甘特图”，是展示进度信息的一种图表方式。在横道图中，纵向列示活动，横向列示日期，用横条表示活动自开始日期至完成日期的持续时间。横道图相对易读，比较常用。它可能会包括浮动时间，也可能不包括，具体取决于受众。为了便于控制，以及与管理层进行沟通，可在里程碑或横跨多个相关联的工作包之间，列出内容更广、更综合的概括性活动，并在横道图报告中显示。见图6-21中的“概括性进度计划”部分，它按WBS的结构罗列相关活动。</p></li><li><p>里程碑图。与横道图类似，但仅标示出主要可交付成果和关键外部接口的计划开始或完成日期，见图6-21的“里程碑进度计划”部分。</p></li><li><p>项目进度网络图。这些图形通常用活动节点法绘制，没有时间刻度，纯粹显示活动及其相互关系，有时也称为“纯逻辑图”，如图6-11所示。项目进度网络图也可以是包含时间刻度的进度网络图，有时称为“逻辑横道图”，如图6-21中的详细进度计划所示。这些图形中有活动日期，通常会同时展示项目网络逻辑和项目关键路径活动等信息。本例子也显示了如何通过一系列相关活动来对每个工作包进行规划。项目进度网络图的另一种呈现形式是“时标逻辑图”，其中包含时间刻度和表示活动持续时间的横条，以及活动之间的逻辑关系。它们用于优化展现活动之间的关系，许多活动都可以按顺序出现在图的同一行中。</p></li></ul><p>图6-21是一个正在执行的示例项目的进度计划，工作进展是通过截止日期或状态日期表示的。针对一个简单的项目，图6-21给出了进度计划的三种形式：（1）里程碑进度计划，也叫里程碑图；（2）概括性进度计划，也叫横道图；（3）详细进度计划，也叫项目进度关联横道图。图6-21还直观地显示出项目进度计划不同详细程度的关系。</p><p><img src="/images/pmp-6/6-21.png" alt="项目进度计划示例"></p><h5 id="5-3-3-进度数据"><a href="#5-3-3-进度数据" class="headerlink" title="5.3.3 进度数据"></a>5.3.3 进度数据</h5><p>项目进度模型中的进度数据是用以描述和控制进度计划的信息集合。进度数据至少包括进度里程碑、进度活动、活动属性，以及已知的全部假设条件与制约因素，而所需的其他数据因应用领域而异。经常可用作支持细节的信息包括（但不限于）：</p><ul><li><p>按时段计列的资源需求，往往以资源直方图表示；</p></li><li><p>备选的进度计划，如最好情况或最坏情况下的进度计划、经资源平衡或未经资源平衡的进度计划、有强制日期或无强制日期的进度计划；</p></li><li><p>使用的进度储备。</p></li></ul><p>进度数据还可包括资源直方图、现金流预测，以及订购与交付进度安排等其他相关信息。</p><h5 id="5-3-4-项目日历"><a href="#5-3-4-项目日历" class="headerlink" title="5.3.4 项目日历"></a>5.3.4 项目日历</h5><p>在项目日历中规定可以开展进度活动的可用工作日和工作班次，它把可用于开展进度活动的时间段（按天或更小的时间单位）与不可用的时间段区分开来。在一个进度模型中，可能需要采用不止一个项目日历来编制项目进度计划，因为有些活动需要不同的工作时段。因此，可能需要对项目日历进行更新。</p><h5 id="5-3-5-变更请求"><a href="#5-3-5-变更请求" class="headerlink" title="5.3.5 变更请求"></a>5.3.5 变更请求</h5><p>修改项目范围或项目进度计划之后，可能会对范围基准和（或）项目管理计划的其他组成部分提出变更请求，应该同构实施整体变更控制过程对变更请求进行审查和处理。预防措施可包括推荐的变更，以消除或降低不利进度偏差的发生概率。</p><h5 id="5-3-6-项目管理计划更新"><a href="#5-3-6-项目管理计划更新" class="headerlink" title="5.3.6 项目管理计划更新"></a>5.3.6 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更请求的项目管理计划组成部分包括（但不限于）：</p><ul><li><p>进度管理计划。可能需要更新进度管理计划，以反映制定和管理进度计划的方式的变更。</p></li><li><p>成本基准。在针对范围、资源或成本估算的变更获得批准后，需要对成本基准做出相应的变更。有时成本偏差太过严重，以至于需要修订成本基准，以便为绩效测量提供现实可行的依据。</p></li></ul><h5 id="5-3-7-项目文件更新"><a href="#5-3-7-项目文件更新" class="headerlink" title="5.3.7 项目文件更新"></a>5.3.7 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>活动属性。更新活动属性以反映在制定进度计划过程中所产生的对资源需求和其他相关内容的修改。</p></li><li><p>假设日志。可能需要更新假设日志，以反映创建进度模型时发现的有关持续时间、资源使用、排序或其他信息的假设条件的变更。</p></li><li><p>持续时间估算。资源的数量和可用性以及活动依赖关系可能会引起持续时间估算的变更。如果资源平衡分析改变了资源需求，就可能需要对持续时间估算做出相应的更新。</p></li><li><p>经验教训登记册。在更新经验教训登记册时，可以增加能够有效和高效制定进度模型的技术。</p></li><li><p>资源需求。资源平衡可能对所需资源类型与数量的初步估算产生显著影响。如果资源平衡分析改变了资源需求，就需要对资源需求做出相应的更新。</p></li><li><p>风险登记册。可能需要更新风险登记册，以反映进度假设条件所隐含的机会或威胁。</p></li></ul><hr><h3 id="六、控制进度"><a href="#六、控制进度" class="headerlink" title="六、控制进度"></a>六、控制进度</h3><p>控制进度是监督项目状态，以更新项目进度和管理进度基准变更的过程。本过程的主要作用是在整个项目期间保持对进度基准的维护，且需要在整个项目期间开展。图6-22描述本过程的输入、工具与技术和输出。图6-23是本过程的数据流向图。</p><p><img src="/images/pmp-6/6-22.png" alt="控制进度：输入、工具与技术和输出"></p><p><img src="/images/pmp-6/6-23.png" alt="控制进度：数据流向图"></p><p>要更新进度模型，就需要了解迄今为止的实际绩效。进度基准的任何变更都必须经过实施整体变更控制过程的审批。控制进度作为实施整体变更控制过程的一部分，关注如下内容：</p><ul><li><p>判断项目进度的当前状态；</p></li><li><p>对因其进度变更的因素施加影响；</p></li><li><p>重新考虑必要的进度储备；</p></li><li><p>判断项目进度是否已经发生变更；</p></li><li><p>在变更实际发生时对其进行管理。</p></li></ul><p>如果采用敏捷方法，控制进度要关注如下内容：</p><ul><li><p>通过比较上一个时间周期中已交付并验收的工作总量与已完成的工作估算值，来判断项目进度的当前状态；</p></li><li><p>实施回顾性审查（定期审查，记录经验教训），以便纠正与改进过程（如果需要的话）；</p></li><li><p>对剩余工作计划（未完项）重新进行优先级排序；</p></li><li><p>确定每次迭代时间（约定的工作周期持续时间，通常是两周或一个月）内可交付成果的生成、核实和验收的速度；</p></li><li><p>确定项目进度已经发生变更；</p></li><li><p>在变更实际发生时对其进行管理。</p></li></ul><p>将工作外包时，定期向承包商和供应商了解里程碑的状态更新是确保工作按商定进度进行的一种途径，有助于确保进度受控。同时，应执行进度状态评审和巡查，确保承包商报告准确且完整。</p><h4 id="6-1-控制进度：输入"><a href="#6-1-控制进度：输入" class="headerlink" title="6.1 控制进度：输入"></a>6.1 控制进度：输入</h4><h5 id="6-1-1-项目管理计划"><a href="#6-1-1-项目管理计划" class="headerlink" title="6.1.1 项目管理计划"></a>6.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>进度管理计划。进度管理计划描述了进度的更新频率、进度储备的使用方式，<br>以及进度的控制方式。</p></li><li><p>进度基准。把进度基准与实际结果相比，以判断是否需要进行变更或采取纠正或预防措施。</p></li><li><p>范围基准。在监控进度基准时，需明确考虑范围基准中的项目WBS、可交付成果、制约因素和假设条件。</p></li><li><p>绩效测量基准。使用挣值分析时，将绩效测量基准与实际结果比较，以决定是否有必要进行变更、采取纠正措施或预防措施。</p></li></ul><h5 id="6-1-2-项目文件"><a href="#6-1-2-项目文件" class="headerlink" title="6.1.2 项目文件"></a>6.1.2 项目文件</h5><p>作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。在项目早期获得的经验教训可以运用到后期阶段，以改进进度控制。</p></li><li><p>项目日历。在一个进度模型中，可能需要不止一个项目日历来预测项目进度，因为有些活动需要不同的工作时段。</p></li><li><p>项目进度计划。项目进度计划是最新版本的项目进度计划，其中图示了截至指定日期的更新情况、已完活动和已开始活动。</p></li><li><p>资源日历。资源日历显示了团队和物质资源的可用性。</p></li><li><p>进度数据。在控制进度过程中需要对进度数据进行审查和更新。</p></li></ul><h5 id="6-1-3-工作绩效数据"><a href="#6-1-3-工作绩效数据" class="headerlink" title="6.1.3 工作绩效数据"></a>6.1.3 工作绩效数据</h5><p>工作绩效数据包含关于项目状态的数据，例如哪些活动已经开始，它们的进展如何（如实际持续时间、剩余持续时间和实际完成百分比），哪些活动已经完成。</p><h5 id="6-1-4-组织过程资产"><a href="#6-1-4-组织过程资产" class="headerlink" title="6.1.4 组织过程资产"></a>6.1.4 组织过程资产</h5><p>能够影响控制进度过程的组织过程资产包括（但不限于）：</p><ul><li><p>现有与进度控制相关的正式和非正式的政策、程序和指南；</p></li><li><p>进度控制工具；</p></li><li><p>可用的监督和报告方法。</p></li></ul><h4 id="6-2-控制进度：工具与技术"><a href="#6-2-控制进度：工具与技术" class="headerlink" title="6.2 控制进度：工具与技术"></a>6.2 控制进度：工具与技术</h4><h5 id="6-2-1-数据分析"><a href="#6-2-1-数据分析" class="headerlink" title="6.2.1 数据分析"></a>6.2.1 数据分析</h5><p>可用作本过程的数据分析技术包括（但不限于）：</p><ul><li><p>挣值分析。进度绩效测量指标（如进度偏差（SV）和进度绩效指数（SPI））用于评价偏离初始进度基准的程度。</p></li><li><p>迭代燃尽图。这类图用于追踪迭代未完项中尚待完成的工作。它基于迭代规划中确定的工作，分析与理想燃尽图的偏差。可使用预测趋势线来预测迭代结束时可能出现的偏差，以及在迭代期间应该采取的合理行动。在燃尽图中，先用对角线表示理想的燃尽情况，再每天画出实际剩余工作，最后基于剩余工作计算出趋势线以预测完成情况。图6-24是迭代燃尽图的一个例子。</p></li></ul><p><img src="/images/pmp-6/6-24.png" alt="迭代燃尽图"></p><ul><li><p>绩效审查。绩效审查是指根据进度基准，测量、对比和分析进度绩效，如实际开始和完成日期、已完成百分比，以及当前工作的剩余持续时间。</p></li><li><p>趋势分析。趋势分析检查项目绩效随时间的变化情况，以确定绩效是在改善还是在恶化。图形分析技术有助于理解截至目前的绩效，并与未来的绩效目标（表示为完工日期）进行对比。</p></li><li><p>偏差分析。偏差分析关注世纪开始和完成日期与计划的偏离，实际持续时间与计划的差异，以及浮动时间的偏差。它包括确定偏离进度基准的原因与程度，评估这些偏差对未来工作的影响，以及确定是否需要采取纠正或预防措施。例如，非关键路径上的某个活动发生较长时间的延误，可能不会对整体项目进度产生影响；而某个关键或次关键活动的稍许延误，却可能需要立即采取行动。</p></li><li><p>假设情景分析。假设情景分析基于项目风险管理过程的输出，对各种不同的情景进行评估，促使进度模型符合项目管理计划和批准的基准。</p></li></ul><h5 id="6-2-2-关键路径法"><a href="#6-2-2-关键路径法" class="headerlink" title="6.2.2 关键路径法"></a>6.2.2 关键路径法</h5><p>检查关键路径的进展情况有助于确定项目进度状态。关键路径上的偏差对项目的结束日期产生直接影响。评估关键路径上的活动的进展情况，有助于识别进度风险。</p><h5 id="6-2-3-项目管理信息系统（PMIS）"><a href="#6-2-3-项目管理信息系统（PMIS）" class="headerlink" title="6.2.3 项目管理信息系统（PMIS）"></a>6.2.3 项目管理信息系统（PMIS）</h5><p>项目管理信息系统包括进度计划软件。用这种软件对照计划日期跟踪实际日期，对照进度基准报告偏差和进展，以及预测项目进度模型变更的影响。</p><h5 id="6-2-4-资源优化"><a href="#6-2-4-资源优化" class="headerlink" title="6.2.4 资源优化"></a>6.2.4 资源优化</h5><p>资源优化技术是在同时考虑资源可用性和项目时间的情况下，对活动和活动所需资源进行的进度规划。</p><h5 id="6-2-5-提前量和滞后量"><a href="#6-2-5-提前量和滞后量" class="headerlink" title="6.2.5 提前量和滞后量"></a>6.2.5 提前量和滞后量</h5><p>在网络分析中调整提前量和滞后量，设法使进度滞后的项目活动赶上计划。例如，在新办公大楼建设项目中，通过增加活动之间的提前量，把绿化施工调整到大楼外墙装饰完工之前开始；或者，在大型技术文件编写项目中，通过消除或减少滞后量，把草稿编辑工作调整到草稿编写完成之后立即开始。</p><h5 id="6-2-6-进度压缩"><a href="#6-2-6-进度压缩" class="headerlink" title="6.2.6 进度压缩"></a>6.2.6 进度压缩</h5><p>采用进度压缩技术使进度落后的项目活动赶上计划，可以对剩余工作使用快速跟进或赶工方法。</p><h4 id="6-3-控制进度：输出"><a href="#6-3-控制进度：输出" class="headerlink" title="6.3 控制进度：输出"></a>6.3 控制进度：输出</h4><h5 id="6-3-1-工作绩效信息"><a href="#6-3-1-工作绩效信息" class="headerlink" title="6.3.1 工作绩效信息"></a>6.3.1 工作绩效信息</h5><p>工作绩效信息包括与进度基准相比较的项目工作执行情况。可以在工作包层级和控制账户层级，计算开始和完成日期的偏差以及持续时间的偏差。对于使用挣值分析的项目，进度偏差（SV）和进度绩效指数（SPI）将记录在工作绩效报告中。</p><h5 id="6-3-2-进度预测"><a href="#6-3-2-进度预测" class="headerlink" title="6.3.2 进度预测"></a>6.3.2 进度预测</h5><p>进度更新即进度预测，指根据已有的信息和知识，对项目未来的情况和事件进行的估算或预计。随着项目执行，应该基于工作绩效信息，更新和重新发布预测。这些信息基于项目的过去绩效，并取决于纠正或预防措施所期望的未来绩效，可能包括挣值绩效指数，以及可能在未来对项目造成影响的进度储备信息。</p><h5 id="6-3-3-变更请求"><a href="#6-3-3-变更请求" class="headerlink" title="6.3.3 变更请求"></a>6.3.3 变更请求</h5><p>通过分析进度偏差，审查进展报告、绩效测量结果和项目范围或进度调整情况，可能会对进度基准、范围基准和（或）项目管理计划的其他组成部分提出变更请求。应该通过实施整体变更控制过程对变更请求进行审查和处理。预防措施可包括推荐的变更，以消除或降低不利进度偏差的发生概率。</p><h5 id="6-3-4-项目管理计划更新"><a href="#6-3-4-项目管理计划更新" class="headerlink" title="6.3.4 项目管理计划更新"></a>6.3.4 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更请求的项目管理计划组成部分包括（但不限于）：</p><ul><li><p>进度管理计划。可能需要更新进度管理计划，以反映进度管理方法的变更。</p></li><li><p>进度基准。在项目范围、活动资源或活动持续时间估算等方面的变更获得批准后，可能需要对进度基准做相应变更。另外，因进度压缩技术或绩效问题造成变更时，也可能需要更新进度基准。</p></li><li><p>成本基准。在针对范围、资源或成本估算的变更获得批准后，需要对成本基准做出相应的变更。</p></li><li><p>绩效测量基准。在范围、进度绩效或成本估算的变更获得批准后，需要对绩效测量基准做出相应的变更。有时绩效偏差太过严重，需要提出变更请求来修订绩效测量基准，以便为绩效测量提供可行的依据。</p></li></ul><h5 id="6-3-5-项目文件更新"><a href="#6-3-5-项目文件更新" class="headerlink" title="6.3.5 项目文件更新"></a>6.3.5 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>假设日志。进度绩效可能表明需要修改关于活动排序、持续时间和生产效率的假设条件。</p></li><li><p>估算依据。进度绩效可能表明需要修改持续时间的估算方式。</p></li><li><p>经验教训登记册。更新经验教训登记册，以记录维护进度的有效技术，以及造成偏差的原因和用于应对进度偏差的纠正措施。</p></li><li><p>项目进度计划。把更新后的进度数据代入进度模型，生成更新后的项目进度计划，以反映进度变更并有效管理项目。</p></li><li><p>资源日历。更新资源日历，以反映因资源优化、进度压缩，以及纠正或预防措施而导致的资源日历变更。</p></li><li><p>风险登记册。采用进度压缩技术可能导致风险，也就可能需要更新风险登记册及其中的风险应对计划。</p></li><li><p>进度数据。可能需要重新绘制进度网络图，以反映经批准的剩余持续时间和经批准的进度计划修改。有时，项目进度延误非常严重，以至于必须重新预测开始与完成日期，编制新的目标进度计划，才能为指导工作、测量绩效和度量进展提供现实的数据。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《PMBOK第六版》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目进度管理包括为管理项目按时完成所需的各个过程&lt;/p&gt;
    
    </summary>
    
      <category term="PMP抄书系列" scheme="http://www.xiaoleon.cn/categories/PMP%E6%8A%84%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="pmp" scheme="http://www.xiaoleon.cn/tags/pmp/"/>
    
  </entry>
  
  <entry>
    <title>PMP(5) 项目范围管理</title>
    <link href="http://www.xiaoleon.cn/2019/02/09/pmp-5/"/>
    <id>http://www.xiaoleon.cn/2019/02/09/pmp-5/</id>
    <published>2019-02-09T10:25:39.000Z</published>
    <updated>2019-05-13T09:47:26.097Z</updated>
    
    <content type="html"><![CDATA[<p>项目范围管理包括确保项目做且只做所需的全部工作，以成功完成项目的各个过程。管理项目范围主要在于定义和控制哪些工作应该包括在项目内，哪些不应该包括在项目内。</p><a id="more"></a><p>项目范围管理过程包括：</p><ul><li><p><strong>规划范围管理</strong> —— 为记录如何定义、确认和控制项目范围及产品范围，而创建范围管理计划的过程。</p></li><li><p><strong>收集需求</strong> —— 为实现项目目标而确定、记录并管理相关方的需要和需求的过程。</p></li><li><p><strong>定义范围</strong> —— 制定项目和产品详细描述的过程。</p></li><li><p><strong>创建WBS</strong> —— 将项目可交付成果和项目工作分解为较小的、更易于管理的组件的过程。</p></li><li><p><strong>确认范围</strong> —— 正式验收已完成的项目可交付成果的过程。</p></li><li><p><strong>控制范围</strong> —— 监督项目和产品的范围状态，管理范围基准变更的过程。</p></li></ul><p>图5-1概括了项目范围管理的各个过程。虽然各项目范围管理过程以界限分明、相互独立的形式出现，但在实践中它们会以《PMBOK指南》无法全面叙述的方式相互交叠、相互作用。</p><p><strong>项目范围管理的核心概念</strong></p><p>在项目环境中，“范围”这一术语有两种含义：</p><ul><li><p>产品范围。某项产品、服务或成果所具有的特征和功能。</p></li><li><p>项目范围。为交付具有规定特性与功能的产品、服务或成果而必须完成的工作。项目范围有时也包括产品范围。</p></li></ul><p>从预测型方法到适应型方法或敏捷型方法，项目生命周期可以处于这个连续区间内的任何位置。在预测型生命周期中，在项目开始时就对项目可交付成果进行定义，对任何范围变化都要进行渐进管理。而在适应型或敏捷型生命周期中，通过多次迭代来开发可交付成果，并在每次迭代开始时定义和批准详细的范围。</p><p>采用适应型生命周期，旨在应对大量变更，需要相关方持续参与项目；因此，应将适应型项目的整体范围分解为一系列拟实现的需求和拟执行的工作（有时称为产品未完项）。在一个迭代开始时，团队将努力确定产品未完项中，哪些最优先项应在下一次迭代中交付。在每次迭代中，都会重复开展三个过程：收集需求、定义范围和创建WBS。相反，在预测型项目中，这些过程在项目开始时开展，并在必要时通过实施整体变更控制过程进行更新。</p><p>在适应型或敏捷型生命周期中，发起人和客户代表应该持续参与项目，随同可交付成果的创建提供反馈意见，并确保产品未完项反映他们的当前需求。在每次迭代中，都会重复开展两个过程：确认范围和控制范围。相反，在预测型项目中，确认范围在每个可交付成果生成时或者在阶段审查点开展，而控制范围则是一个持续性的过程。</p><p>在预测型项目中，经过批准的项目范围说明书、工作分解结构（WBS）和相应的WBS词典构成项目范围基准。只有通过正式变更控制程序，才能进行基准变更。在开展确认范围、控制范围及其他控制过程时，基准被用作比较的基础。而采用适应型生命周期的项目，则使用未完项（包括产品需求和用户故事）反映当前需求。</p><p>项目范围的完成情况是根据项目管理计划来衡量的，而产品范围的完成情况是根据产品需求来衡量的。在这里，“需求”是指根据特定协议或其他强制性规范，产品、服务或成果必须具备的条件或能力。</p><p>确认范围是正式验收已完成的项目可交付成果的过程。从控制质量过程输出的核实的可交付成果是确认范围过程的输入，而验收的可交付成果是确认范围过程的输出之一，由获得授权的相关方正式签字批准。因此，相关方需要在规划阶段早期介入（有时需要在启动阶段就介入），对可交付成果的质量提出意见，以便控制质量过程能够据此评估绩效并提出必要的变更建议。</p><p><strong>项目范围管理的发展趋势和新兴实践</strong></p><p>需求一直是项目管理中的重点，并且还将继续得到项目管理从业者的更多关注。随着全球环境变得日益复杂，组织开始认识到如何运用商业分析，通过定义、管理和控制需求活动来提高竞争优势。商业分析活动可在项目启动和项目经理任命之前就开始。根据《需求管理：实践指南》，需求管理过程始于需要评估，而需要评估又可能始于项目组和规划、项目集规划或单个项目。</p><p>在项目范围管理过程中，收集、记录和管理相关方需求。项目范围管理的范围趋势和新兴实践包括（但不限于）注重与商业分析专业人士的合作，以便：</p><ul><li><p>确定问题并识别商业需要；</p></li><li><p>识别并推荐能够满足这些需要的可行解决方案；</p></li><li><p>收集、记录并管理相关方需求，以满足商业和项目目标；</p></li><li><p>推动项目集或项目的产品、服务或最终成果的成功应用。</p></li></ul><p>需求管理过程结束于需求关闭，即把产品、服务或成果移交给接收方，以便长期测量、监控、实现和维持效益。</p><p>应该将商业分析的角色连同职责分配给具有足够商业分析技能和专业知识的人员。如果项目已配备商业分析师，那么，与需求管理相关的活动便是该角色的职责。而项目经理则负责确保这些活动在项目管理计划有所安排，并且在预算内按时完成，同时能够创造价值。</p><p>项目经理与商业分析师之间应该是伙伴式合作关系。如果项目经理和商业分析师能够理解彼此在促进项目目标实现过程中的角色和职责，项目成功的可能性就更大。</p><p><strong>裁剪时需要考虑的因素</strong></p><p>因为每个项目都是独特的，所以项目经理需要裁剪项目范围管理过程。裁剪时应考虑的因素包括（但不限于）：</p><ul><li><p>知识和需求管理。组织是否拥有正式或非正式的知识和需求管理体系？为了在未来项目中重复使用需求，项目经理应建立哪些指南？</p></li><li><p>确认和控制。组织是否拥有正式或非正式的与确认和控制相关的政策、程序和指南？</p></li><li><p>开发方法。组织是否采用敏捷方法管理项目？开发方法属于迭代型还是增量型？是否采用预测型方法？混合型方法是否有效？</p></li><li><p>需求的稳定性。项目中是否存在需求不稳定的领域？是否有必要采用精益、敏捷或其他适应型技术来处理不稳定的需求，直至需求稳定且定义明确？</p></li><li><p>治理。组织是否拥有正式或非正式的审计和治理政策、程序和指南？</p></li></ul><p><strong>在敏捷或适应型环境中需要考虑的因素</strong></p><p>对于需求不断变化、风险大或不确定性高的项目，在项目开始时通常无法明确项目的范围，而需要在项目期间逐渐明确。敏捷方法特意在项目早期缩短定义和协商范围的时间，并为持续探索和明确范围而延长创建相应过程的时间。在许多情况下，不断涌现的需求往往导致真实的业务需求与最初所述的业务需求之间存在差异。因此，敏捷方法有目的地构建和审查原型，并通过多次发布版本来明确需求。这样一来，范围会在整个项目期间被定义和再定义。在敏捷方法中，把需求列入未完项。</p><h3 id="一、规划范围管理"><a href="#一、规划范围管理" class="headerlink" title="一、规划范围管理"></a>一、规划范围管理</h3><p>规划范围管理是为记录如何定义、确认和控制项目范围及产品范围，而创建范围管理计划的过程。本过程的主要作用是，在整个项目期间对如何管理范围提供指南和方向。本过程仅开展一次或仅在项目的预定义点开展。图5-2描述本过程的输入、工具与技术和输出。图5-3是本过程的数据流向图。</p><p><img src="/images/pmp-5/5-2.png" alt="规划范围管理：输入、工具与技术和输出"></p><p><img src="/images/pmp-5/5-3.png" alt="规划范围管理：数据流向图"></p><p>范围管理计划是项目或项目集管理计划的组成部分，描述将如何定义、制定、监督、控制和确认项目范围。制定范围管理计划和细化项目范围始于对下列信息的分析：项目章程中的信息、项目管理计划中已批准的子计划、组织过程资产中的历史信息和相关事业环境因素。</p><h4 id="1-1-规划范围管理：输入"><a href="#1-1-规划范围管理：输入" class="headerlink" title="1.1 规划范围管理：输入"></a>1.1 规划范围管理：输入</h4><h5 id="1-1-1-项目章程"><a href="#1-1-1-项目章程" class="headerlink" title="1.1.1 项目章程"></a>1.1.1 项目章程</h5><p>项目章程记录项目目的、项目概述、假设条件、制约因素，以及项目意图实现的高层级需求。</p><h5 id="1-1-2-项目管理计划"><a href="#1-1-2-项目管理计划" class="headerlink" title="1.1.2 项目管理计划"></a>1.1.2 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>质量管理计划。在项目中实施组织的质量政策、方法和标准的方式会影响管理项目和产品范围的方式。</p></li><li><p>项目生命周期描述。项目生命周期定义了项目从开始到完成所经历的一系列阶段。</p></li><li><p>开发方法。开发方法定义了项目是采用瀑布式、迭代型、适应型、敏捷型还是混合型开发方法。</p></li></ul><h5 id="1-1-3-事业环境因素"><a href="#1-1-3-事业环境因素" class="headerlink" title="1.1.3 事业环境因素"></a>1.1.3 事业环境因素</h5><p>能够影响规划范围管理过程的事业环境因素包括（但不限于）：</p><ul><li><p>组织文化；</p></li><li><p>基础设施；</p></li><li><p>人事管理制度；</p></li><li><p>市场条件。</p></li></ul><h5 id="1-1-4-组织过程资产"><a href="#1-1-4-组织过程资产" class="headerlink" title="1.1.4 组织过程资产"></a>1.1.4 组织过程资产</h5><p>能够影响规划范围管理过程的组织过程资产包括（但不限于）：</p><ul><li><p>政策和程序；</p></li><li><p>历史信息和经验教训知识库。</p></li></ul><h4 id="1-2-规划范围管理：工具与技术"><a href="#1-2-规划范围管理：工具与技术" class="headerlink" title="1.2 规划范围管理：工具与技术"></a>1.2 规划范围管理：工具与技术</h4><h5 id="1-2-1-专家判断"><a href="#1-2-1-专家判断" class="headerlink" title="1.2.1 专家判断"></a>1.2.1 专家判断</h5><p>应该就以下主题，考虑具备相关专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>以往类似项目；</p></li><li><p>特定行业、学科和应用领域的信息。</p></li></ul><h5 id="1-2-2-数据分析"><a href="#1-2-2-数据分析" class="headerlink" title="1.2.2 数据分析"></a>1.2.2 数据分析</h5><p>适用于本过程的数据分析技术包括（但不限于）备选方案分析。本技术用于评估收集需求、详述项目和产品范围、创造产品、确认范围和控制范围的各种方法。</p><h5 id="1-2-3-会议"><a href="#1-2-3-会议" class="headerlink" title="1.2.3 会议"></a>1.2.3 会议</h5><p>项目团队可以参加项目会议来制定范围管理计划。参会者可能包括项目经理、项目发起人、选定的项目团队成员、选定的相关方、范围管理各过程的负责人，以及其他必要人员。</p><h4 id="1-3-规划范围管理：输出"><a href="#1-3-规划范围管理：输出" class="headerlink" title="1.3 规划范围管理：输出"></a>1.3 规划范围管理：输出</h4><h5 id="1-3-1-范围管理计划"><a href="#1-3-1-范围管理计划" class="headerlink" title="1.3.1 范围管理计划"></a>1.3.1 范围管理计划</h5><p>范围管理计划是项目管理计划的组成部分，描述将如何定义、制定、监督、控制和确认项目范围。范围管理计划要对将用于下列工作的管理过程做出规定：</p><ul><li><p>制定项目范围说明书；</p></li><li><p>根据详细项目范围说明书创建WBS；</p></li><li><p>确定如何审批和维护范围基准；</p></li><li><p>正式验收已完成的项目可交付成果。</p></li></ul><p>根据项目需要，范围管理计划可以是正式或非正式的，非常详细或高度概括的。</p><h5 id="1-3-2-需求管理计划"><a href="#1-3-2-需求管理计划" class="headerlink" title="1.3.2 需求管理计划"></a>1.3.2 需求管理计划</h5><p>需求管理计划是项目管理计划的组成部分，描述将如何分析、记录和管理项目和产品需求。根据《从业者商业分析：实践指南》，有些组织称之为“商业分析计划”。需求管理计划的主要内容包括（但不限于）：</p><ul><li><p>如何规划、跟踪和报告各种需求活动；</p></li><li><p>配置管理活动，例如：如何启动变更，如何分析其影响，如何进行追溯、跟踪和报告，以及变更审批权限；</p></li><li><p>需求优先级排序过程；</p></li><li><p>测量指标及使用这些指标的理由；</p></li><li><p>反映哪些需求属性将被列入跟踪矩阵的跟踪结构。</p></li></ul><hr><h3 id="二、收集需求"><a href="#二、收集需求" class="headerlink" title="二、收集需求"></a>二、收集需求</h3><p>收集需求是为实现目标而确定、记录并管理相关方的需要和需求的过程。本过程的主要作用是，为定义产品范围和项目范围奠定基础，且仅开展一次或仅在项目的预定义点开展。图5-4描述本过程的输入、工具与技术和输出。图5-5是本过程的数据流向图。</p><p><img src="/images/pmp-5/5-4.png" alt="收集需求：输入、工具与技术和输出"></p><p><img src="/images/pmp-5/5-4.png" alt="收集需求：数据流向图"></p><p>《PMBOK指南》并没有专门讨论产品需求，因为产品需求因行业而异。《从业者商业分析：实践指南》提供了有关产品需求的更深入信息。让相关方积极参与需求的探索和分解工作（分解成项目和产品需求），并仔细确定、记录和管理对产品、服务或成果的需求，能直接促进项目成功。需求是指根据特定协议或其他强制性规范，产品、服务或成果必须具备的条件或能力。它包括发起人、客户和其他相关方的已量化且书面记录的需要和期望。应该足够详细地探明、分析和记录这些需求，将其包含在范围基准中，并在项目执行开始后对其进行测量。需求将成为工作分解结构（WBS）的基础，也将成为成本、进度、质量和采购规划的基础。</p><h4 id="2-1-收集需求：输入"><a href="#2-1-收集需求：输入" class="headerlink" title="2.1 收集需求：输入"></a>2.1 收集需求：输入</h4><h5 id="2-1-1-项目章程"><a href="#2-1-1-项目章程" class="headerlink" title="2.1.1 项目章程"></a>2.1.1 项目章程</h5><p>项目章程记录了项目概述以及将用于指定详细需求的高层级需求。</p><h5 id="2-1-2-项目管理计划"><a href="#2-1-2-项目管理计划" class="headerlink" title="2.1.2 项目管理计划"></a>2.1.2 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>范围管理计划。范围管理计划包含如何定义和制定项目范围的信息。</p></li><li><p>需求管理计划。需求管理计划包含如何收集、分析和记录项目需求的信息。</p></li><li><p>相关方参与计划。从相关方参与计划中了解相关方的沟通需求和参与程度，以便评估并适应相关方对需求活动的参与程度。</p></li></ul><h5 id="2-1-3-项目文件"><a href="#2-1-3-项目文件" class="headerlink" title="2.1.3 项目文件"></a>2.1.3 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>假设日志。假设日志识别了有关产品、项目、环境、相关方以及会影响需求的其他因素的假设条件。</p></li><li><p>经验教训登记册。经验教训登记册提供了有效的需求收集技术，尤其针对使用迭代型或适应型产品开发方法的项目。</p></li><li><p>相关方登记册。相关方登记册用于了解哪些相关方能够提供需求方面的信息，及记录相关方对项目的需求和期望。</p></li></ul><h5 id="2-1-4-商业文件"><a href="#2-1-4-商业文件" class="headerlink" title="2.1.4 商业文件"></a>2.1.4 商业文件</h5><p>会影响收集需求过程的商业文件是商业论证，它描述了为满足业务需要而应达到的必要、期望及可选标准。</p><h5 id="2-1-5-协议"><a href="#2-1-5-协议" class="headerlink" title="2.1.5 协议"></a>2.1.5 协议</h5><p>协议会包含项目和产品需求。</p><h5 id="2-1-6-事业环境因素"><a href="#2-1-6-事业环境因素" class="headerlink" title="2.1.6 事业环境因素"></a>2.1.6 事业环境因素</h5><p>会影响收集需求过程的事业环境因素包括（但不限于）：</p><ul><li><p>组织文化；</p></li><li><p>基础设施；</p></li><li><p>人事管理制度；</p></li><li><p>市场条件。</p></li></ul><h5 id="2-1-7-组织过程资产"><a href="#2-1-7-组织过程资产" class="headerlink" title="2.1.7 组织过程资产"></a>2.1.7 组织过程资产</h5><p>会影响收集需求过程的组织过程资产包括（但不限于）：</p><ul><li><p>政策和程序；</p></li><li><p>包含以往项目信息的历史信息和经验教训知识库。</p></li></ul><h4 id="2-2-收集需求：工具与技术"><a href="#2-2-收集需求：工具与技术" class="headerlink" title="2.2 收集需求：工具与技术"></a>2.2 收集需求：工具与技术</h4><h5 id="2-2-1-专家判断"><a href="#2-2-1-专家判断" class="headerlink" title="2.2.1 专家判断"></a>2.2.1 专家判断</h5><p>应该就以下主题，考虑具备相关专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>商业分析；</p></li><li><p>需求获取；</p></li><li><p>需求分析；</p></li><li><p>需求文件；</p></li><li><p>以往类似项目的项目需求；</p></li><li><p>图解技术；</p></li><li><p>引导；</p></li><li><p>冲突管理。</p></li></ul><h5 id="2-2-2-数据收集"><a href="#2-2-2-数据收集" class="headerlink" title="2.2.2 数据收集"></a>2.2.2 数据收集</h5><p>可用于本过程的数据收集技术包括（但不限于）：</p><ul><li><p>头脑风暴。头脑风暴是一种用来产生和收集对项目需求与产品需求的多种创意的技术。</p></li><li><p>访谈。访谈是通过与相关方直接交谈，来获取信息的正式或非正式的方法。访谈的典型做法是向被访者提出预设和即兴的问题，并记录他们的回答。访谈经常是一个访谈者和一个被访谈者之间的“一对一”谈话，但也可以包括多个访谈者和（或）多个被访者。访谈有经验的项目参与者、发起人和其他高管，以及主题专家，有助于识别和定义所需产品可交付成果的特征和功能。访谈也可用于获取机密信息。</p></li><li><p>焦点小组。焦点小组是召集预定的相关方和主题专家，了解他们对所讨论的产品、服务或成果的期望和态度。由一位受过训练的主持人引导大家进行互动式讨论。焦点小组往往比“一对一”的访谈更热烈。</p></li><li><p>问卷调查。问卷调查是指设计一系列书面问题，向众多受访者快速收集信息。问卷调查方法非常适用于以下情况：受众多样化，需要快速完成调查，受访者地理位置分散，并且适合开展统计分析。</p></li><li><p>标杆对照见。标杆对照将实际或计划的产品、过程和实践，与其他可比组织的实践进行比较，以便识别最佳实践，形成改进意见，并为绩效考核提供依据。标杆对照所采用的可比组织可以是内部的，也可以是外部的。</p></li></ul><h5 id="2-2-3-数据分析"><a href="#2-2-3-数据分析" class="headerlink" title="2.2.3 数据分析"></a>2.2.3 数据分析</h5><p>可用于本过程的数据分析技术包括（但不限于）文件分析。文件分析包括审核和评估任何相关的文件信息。在此过程中，文件分析用于通过分析现有文件，识别与需求相关的信息来获取需求。有助于获取相关需求的文件很多。可供分析的文件包括（但不限于）：</p><ul><li><p>协议；</p></li><li><p>商业计划；</p></li><li><p>业务流程或接口文档；</p></li><li><p>业务规则库；</p></li><li><p>现行流程；</p></li><li><p>市场文献；</p></li><li><p>问题日志；</p></li><li><p>政策和程序；</p></li><li><p>法规文件，如法律、准则、法令等；</p></li><li><p>建议邀请书；</p></li><li><p>用例。</p></li></ul><h5 id="2-2-4-决策"><a href="#2-2-4-决策" class="headerlink" title="2.2.4 决策"></a>2.2.4 决策</h5><p>适用于收集需求过程的决策技术包括（但不限于）：</p><ul><li><p>投票。投票是一种为达成某种期望结果，而对多个未来行动方案进行评估的集体决策技术和过程。本技术用于生成、归类和排序产品需求。投票技术示例包括：</p><ul><li><p>一致同意。每个人都同意某个行动方案。</p></li><li><p>大多数同意。获得群体中超过50%人员的支持，就能做出决策。把参与决策的小组人数定位奇数，可防止因平局而无法达成决策。</p></li><li><p>相对多数同意。根据群体中相对多数人的意见做出决策，即便未能获得大多数人的支持。通常在候选项超过两个时使用。</p></li></ul></li><li><p>独裁型决策制定。采用这种方法，将由一个人负责为整个集体制定决策。</p></li><li><p>多标准决策分析。该技术借助决策矩阵，用系统分析方法建立诸如风险水平、不确定性和价值收益等多种标准，以对众多创意进行评估和排序。</p></li></ul><h5 id="2-2-5-数据表现"><a href="#2-2-5-数据表现" class="headerlink" title="2.2.5 数据表现"></a>2.2.5 数据表现</h5><p>可用于本过程的数据表现技术包括（但不限于）：</p><ul><li><p>亲和图。用来对大量创意进行分组的技术，以便进一步审查和分析。</p></li><li><p>思维导图。把从头脑风暴中获得的创意整合成一张图，用以反映创意之间的共性与差异，激发新创意。</p></li></ul><h5 id="2-2-6-人际关系和团队技能"><a href="#2-2-6-人际关系和团队技能" class="headerlink" title="2.2.6 人际关系和团队技能"></a>2.2.6 人际关系和团队技能</h5><p>可用于本过程的人际关系与团队技能包括（但不限于）：</p><ul><li><p>名义小组技术。名义小组技术是用于促进头脑风暴的一种技术，通过投票排列最有用的创意，以便进一步开展头脑风暴或优先排序。名义小组技术是一种结构化的头脑风暴形式，由四个步骤组成：</p><ul><li><p>向集体提出一个问题或难题。每个人在沉思后写出自己的想法。</p></li><li><p>主持人在活动挂图上记录所有人的想法。</p></li><li><p>集体讨论各个想法，直到全体成员达成一个明确的共识。</p></li><li><p>个人私下投票决出各种想法的优先顺序，通常采用5分制，1分最低，5分最高。为减少想法数量、集中关注想法，可进行数论投票。每轮投票后，都将清点选票，得分最高者被选出。</p></li></ul></li><li><p>观察和交谈。观察和交谈是指直接查看个人在各自的环境中如何执行工作（或任务）和实施流程。当产品使用者难以或不愿清晰说明他们的需求时，就特别需要通过观察来了解他们的工作细节。观察，也称为“工作跟随”，通常由旁边观察者观察业务专家如何执行工作，但也可以由“参与观察者”来观察，通过实际执行一个流程或程序，来体验该流程或程序是如何实施的，以便挖掘隐藏的需求。</p></li><li><p>引导。引导与主题研讨会结合使用，把主要相关方召集在一起定义产品需求。研讨会可用于快速定义跨职能需求并协调相关方的需求差异。因为具有群体互动的特点，有效引导的研讨会有助于参与者之间建立信任、改进关系、改善沟通，从而有利于相关方达成一致意见。此外，与分别召开会议相比，研讨会能够更早发现并解决问题。适合采用引导技能的情境包括（但不限于）：</p><ul><li><p>联合应用设计或开发（JAD）。JAD会议适用于软件开发行业。这种研讨会注重把业务主题专家和开发团队集中在一起，以收集需求和改进软件开发过程。</p></li><li><p>质量功能展开（QFD）。制造行业则采用QFD这种引导技能来帮助确定新产品的关键特征。QFD从收集客户需要（又称“客户声音”）开始，然后客观地对这些需要进行分类和排序，并为实现这些需要而设定目标。</p></li><li><p>用户故事。用户故事是对所需功能的简短文字描述，经常产生于需求研讨会。用户故事描述哪个相关方将从功能中收益（角色），他需要实现什么（目标），以及他期望获得什么利益（动机）。</p></li></ul></li></ul><h5 id="2-2-7-系统交互图"><a href="#2-2-7-系统交互图" class="headerlink" title="2.2.7 系统交互图"></a>2.2.7 系统交互图</h5><p>系统交互图是范围模型的一个例子，它是对产品范围的可视化描述，显示业务系统（过程、设备、计算机系统等）及其与人和其他系统（行动者）之间的交互方式。系统交互图显示了业务系统的输入、输入提供者、业务系统的输出和输出接收者。</p><p><img src="/images/pmp-5/5-6.png" alt="系统交互图"></p><h5 id="2-2-8-原型法"><a href="#2-2-8-原型法" class="headerlink" title="2.2.8 原型法"></a>2.2.8 原型法</h5><p>原型法是指在实际制造预期产品之前，先造出该产品的模型，并据此征求对需求的早期反馈。原型包括微缩产品、计算机生成的二维和三维模型、实体模型或模拟。因为原型是有形的实物，它使得相关方可以体验最终产品的模型，而不是仅限于讨论抽象的需求描述。原型法支持渐进明细的理念，需要经历从模型创建、用户体验、反馈收集到原型修改的反复循环过程。在经过足够的反馈循环之后，就可以通过原型获得足够的需求信息，从而进入设计或制造阶段。</p><p>故事板是一种原型技术，通过一系列的图像或图示来展开顺序或导航路径。故事板用于各种行业的各种项目中，如电影、广告、教学设计，以及敏捷和其他软件开发项目。在软件开发中，故事板使用实体模型来展示网页、屏幕或其他用户界面的导航路径。</p><h4 id="2-3-收集需求：输出"><a href="#2-3-收集需求：输出" class="headerlink" title="2.3 收集需求：输出"></a>2.3 收集需求：输出</h4><h5 id="2-3-1-需求文件"><a href="#2-3-1-需求文件" class="headerlink" title="2.3.1 需求文件"></a>2.3.1 需求文件</h5><p>需求文件描述各种单一需求将如何满足与项目相关的业务需求。一开始可能只有高层级的需求，然后随着有关需求信息的增加而逐步细化。只有明确的（可测量和可测试的）、可跟踪的、完整的、相互协调的，且主要相关方愿意认可的需求，才能作为基准。需求文件的格式多种多样，既可以是一份按相关方和优先级分类列出全部需求的简单文件，也可以使一份包括内容提要、细节描述和附件等的详细文件。</p><p>许多组织把需求分为不同的种类，如业务解决方案和技术解决方案。前者是相关方的需要，后者是指如何实现这些需要。把需求分成不同的类别，有利于对需求进行进一步完善和细化。需求的类别包括：</p><ul><li><p>业务需求。整个组织的高层级需要。例如，解决业务问题或抓住业务机会，以及实施项目的原因。</p></li><li><p>相关方需求。相关方或相关方群体的需要。</p></li><li><p>解决方案需求。为满足业务需求和相关方需求，产品、服务或成果必须具备的特性、功能和特征。解决方案需求又进一步分为功能需求和非功能需求：</p><ul><li><p>功能需求。功能需求描述产品应具备的功能，例如，产品应该执行的行动、流程、数据和交互。</p></li><li><p>非功能需求。非功能需求是对功能需求的补充，是产品正常运行所需的环境条件或质量要求，例如，可靠性、保密性、性能、安全性、服务水平、可支持性、保留或清除等。</p></li></ul></li><li><p>过渡和就绪需求。这些需求描述了从“当前状态”过渡到“将来状态”所需的临时能力，如数据转换和培训需求。</p></li><li><p>项目需求。项目需要满足的行动、过程或其他条件，例如里程碑日期、合同责任、制约因素等。</p></li><li><p>质量需求。用于确认项目可交付成果的成功完成或其他项目需求的实现的任何条件或标准，例如测试、认证、确认等。</p></li></ul><h5 id="2-3-2-需求跟踪矩阵"><a href="#2-3-2-需求跟踪矩阵" class="headerlink" title="2.3.2 需求跟踪矩阵"></a>2.3.2 需求跟踪矩阵</h5><p>需求跟踪矩阵是把产品需求从其来源连接到能满足需求的可交付成果的一种表格。使用需求跟踪矩阵，把每个需求与业务目标或项目目标联系起来，有助于确保每个需求都具有商业价值。需求跟踪矩阵提供了在整个项目生命周期中跟踪需求的一种方法，有助于确保需求文件中被批准的每项需求在项目结束的时候都能交付。最后，需求跟踪矩阵还为管理产品范围变更提供了框架。</p><p>跟踪需求包括（但不限于）：</p><ul><li><p>业务需要、机会、目的和目标；</p></li><li><p>项目目标；</p></li><li><p>产品范围和WBS可交付成果；</p></li><li><p>产品设计；</p></li><li><p>产品开发；</p></li><li><p>测试策略和测试场景；</p></li><li><p>高层级需求到详细需求。</p></li></ul><p>应在需求跟踪矩阵中记录每个需求的相关属性，这些属性有助于明确每个需求的关键信息。需求跟踪矩阵中记录的典型属性包括唯一标识、需求的文字描述、收录该需求的理由、所有者、来源、优先级别、版本、当前状态（如进行中、已取消、已推迟、新增加、已批准、被分配和已完成）和状态日期。为确保相关方满意，可能需要增加一些补充属性，如稳定性、复杂性和验收标准。图5-7是需求跟踪矩阵示例，其中列有相关的需求属性。</p><p><img src="/images/pmp-5/5-7.png" alt="需求跟踪矩阵示例"></p><hr><h3 id="三、定义范围"><a href="#三、定义范围" class="headerlink" title="三、定义范围"></a>三、定义范围</h3><p>定义范围是制定项目和产品详细描述的过程。本过程的主要作用是，描述产品、服务或成果的边界和验收标准。图5-8描述本过程的输入、工具与技术和输出。图5-9是本过程的数据流向图。</p><p><img src="/images/pmp-5/5-8.png" alt="定义范围：输入、工具与技术和输出"></p><p><img src="/images/pmp-5/5-9.png" alt="定义范围：数据流向图"></p><p>由于在收集需求过程中识别出的所有需求未必都包含在项目中，所以定义范围过程就要从需求文件（收集需求过程的输出）中选取最终的项目需求，然后制定出关于项目及其产品、服务或成果的详细描述。准备好详细的项目范围说明书，对项目成功至关重要。</p><p>应根据项目启动过程中记载的主要可交付成果、假设条件和制约因素来编制详细的项目范围说明书。在项目规划过程中，随着对项目信息的更多了解，应该更加详细具体地定义和描述项目范围。此外，还需要分析现有风险、假设条件和制约因素的完整性，并做必要的增补或更新。需要多次反复开展定义范围过程：在迭代型生命周期的项目中，先为整个项目确定一个高层级的愿景，再一次针对一个迭代期明确详细范围。通常，随着当前迭代期的项目范围和可交付成果的进展，而详细规划下一个迭代期的工作。</p><h4 id="3-1-定义范围：输入"><a href="#3-1-定义范围：输入" class="headerlink" title="3.1 定义范围：输入"></a>3.1 定义范围：输入</h4><h5 id="3-1-1-项目章程"><a href="#3-1-1-项目章程" class="headerlink" title="3.1.1 项目章程"></a>3.1.1 项目章程</h5><p>项目章程中包含对项目的高层级描述、产品特征和审批要求。</p><h5 id="3-1-2-项目管理计划"><a href="#3-1-2-项目管理计划" class="headerlink" title="3.1.2 项目管理计划"></a>3.1.2 项目管理计划</h5><p>项目管理计划组件包括（但不限于）范围管理计划，其中记录了如何定义、确认和控制项目范围。</p><h5 id="3-1-3-项目文件"><a href="#3-1-3-项目文件" class="headerlink" title="3.1.3 项目文件"></a>3.1.3 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>假设日志。假设日志识别了有关产品、项目、环境、相关方以及会影响项目和产品范围的假设条件和制约因素。</p></li><li><p>需求文件。需求文件识别了应纳入范围的需求。</p></li><li><p>风险登记册。风险登记册包含了可能影响项目范围的应对策略，例如缩小或改变项目和产品范围，以规避或缓解风险。</p></li></ul><h5 id="3-1-4-事业环境因素"><a href="#3-1-4-事业环境因素" class="headerlink" title="3.1.4 事业环境因素"></a>3.1.4 事业环境因素</h5><p>会影响定义范围过程的事业环境因素包括（但不限于）：</p><ul><li><p>组织文化；</p></li><li><p>基础设施；</p></li><li><p>人事管理制度；</p></li><li><p>市场条件。</p></li></ul><h5 id="3-1-5-组织过程资产"><a href="#3-1-5-组织过程资产" class="headerlink" title="3.1.5 组织过程资产"></a>3.1.5 组织过程资产</h5><p>能够影响定义范围过程的组织过程资产包括（但不限于）：</p><ul><li><p>用于制定项目范围说明书的政策、程序和模板；</p></li><li><p>以往项目的项目档案；</p></li><li><p>以往阶段或项目的经验教训。</p></li></ul><h4 id="3-2-定义范围：工具与技术"><a href="#3-2-定义范围：工具与技术" class="headerlink" title="3.2 定义范围：工具与技术"></a>3.2 定义范围：工具与技术</h4><h5 id="3-2-1-专家判断"><a href="#3-2-1-专家判断" class="headerlink" title="3.2.1 专家判断"></a>3.2.1 专家判断</h5><p>应征求具备类似项目的知识或经验的个人或小组的意见。</p><h5 id="3-2-2-数据分析"><a href="#3-2-2-数据分析" class="headerlink" title="3.2.2 数据分析"></a>3.2.2 数据分析</h5><p>可用于本过程的数据分析技术包括（但不限于）备选方案分析。备选方案分析可用于评估实现项目章程中所述的需求和目标的各种方法。</p><h5 id="3-2-3-决策"><a href="#3-2-3-决策" class="headerlink" title="3.2.3 决策"></a>3.2.3 决策</h5><p>可用于本过程的决策技术包括（但不限于）多标准决策分析。多标准决策分析是一种借助决策矩阵来使用系统分析方法的技术，目的是建立诸如需求、进度、预算和资源等多种标准来完善项目和产品范围。</p><h5 id="3-2-4-人际关系与团队技能"><a href="#3-2-4-人际关系与团队技能" class="headerlink" title="3.2.4 人际关系与团队技能"></a>3.2.4 人际关系与团队技能</h5><p>人际关系与团队技能的一个示例是引导。在研讨会和座谈会中使用引导技能来协调具有不同期望或不同专业知识的关键相关方，使他们就项目可交付成果以及项目和产品边界达成跨职能的共识。</p><h5 id="3-2-5-产品分析"><a href="#3-2-5-产品分析" class="headerlink" title="3.2.5 产品分析"></a>3.2.5 产品分析</h5><p>产品分析可用于定义产品和服务，包括针对产品或服务提问并回答，以描述要交付的产品的用途、特征及其他方面。</p><p>每个应用领域都有一种或几种普遍公认的方法，用以把高层及的产品或服务描述转变为有意义的可交付成果。首先获取高层级的需求，然后将其细化到最终产品设计所需的详细程度。产品分析技术包括（但不限于）：</p><ul><li><p>产品分解；</p></li><li><p>需求分析；</p></li><li><p>系统分析；</p></li><li><p>系统工程；</p></li><li><p>价值分析；</p></li><li><p>价值工程。</p></li></ul><h4 id="3-3-定义范围：输出"><a href="#3-3-定义范围：输出" class="headerlink" title="3.3 定义范围：输出"></a>3.3 定义范围：输出</h4><h5 id="3-3-1-项目范围说明书"><a href="#3-3-1-项目范围说明书" class="headerlink" title="3.3.1 项目范围说明书"></a>3.3.1 项目范围说明书</h5><p>项目范围说明书是对项目范围、主要可交付成果、假设条件和制约因素的描述。它记录了整个范围，包括项目和产品范围；详细描述了项目的可交付成果；还代表项目相关方之间就项目范围所达成的共识。为便于管理相关方的期望，项目范围说明书可明确指出哪些工作不属于本项目范围。项目范围说明书使项目团队能进行更详细的规划，在执行过程中指导项目团队的工作，并为评价变更请求或额外工作是否超过项目边界提供基准。</p><p>项目范围说明书描述要做和不要做的工作的详细程度，决定着项目管理团队控制整个项目范围的有效程度。详细的项目范围说明书包括以下内容（可能直接列出或参引其他文件）：</p><ul><li><p>产品范围描述。逐步细化在项目章程和需求文件中所述的产品、服务或成果的特征；</p></li><li><p>可交付成果。为完成某一过程、阶段或项目而必须产出的任何独特并可核实的产品、成果或服务能力，可交付成果也包括各种辅助成果，如项目管理报告和文件。对可交付成果的描述可略可详。</p></li><li><p>验收标准。可交付成果通过验收前必须满足的一系列条件。</p></li><li><p>项目的除外责任。识别排除在项目之外的内容。明确说明哪些内容不属于项目范围，有助于管理相关方的期望及减少范围蔓延。</p></li></ul><p>虽然项目章程和项目范围说明书的内容存在一定程度的重叠，但它们的详细程度完全不同。项目章程包含高层级的信息，而项目范围说明书则是对范围组成部分的详细描述，这些组成部分需要在项目过程中渐进明细。表5-1显示了这两个文件的一些关键内容。</p><p><img src="/images/pmp-5/表5-1.png" alt="项目章程与项目范围说明书的内容"></p><h5 id="3-3-2-项目文件更新"><a href="#3-3-2-项目文件更新" class="headerlink" title="3.3.2 项目文件更新"></a>3.3.2 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>假设日志。随同本过程识别出更多的假设条件或制约因素而更新假设日志。</p></li><li><p>需求文件。可以通过增加或修改需求而更新需求文件。</p></li><li><p>需求跟踪矩阵。应该随同需求文件的更新而更新需求跟踪矩阵。</p></li><li><p>相关方登记册。如果在本过程中收集到了现有或新相关方的更多信息，则记录到相关方登记册中。</p></li></ul><hr><h3 id="四、创建WBS"><a href="#四、创建WBS" class="headerlink" title="四、创建WBS"></a>四、创建WBS</h3><p>创建工作分解结构（WBS）是把项目可交付成果和项目工作分解成较小、更易于管理的组件的过程。本过程的主要作用是，为所要交付的内容提供架构，它仅开展一次或仅在项目的预定义点开展。图5-10描述本过程的输入、工具与技术和输出。图5-11是本过程的数据流向图。</p><p><img src="/images/pmp-5/5-10.png" alt="创建WBS：输入、工具与技术和输出"></p><p><img src="/images/pmp-5/5-10.png" alt="创建WBS：数据流向图"></p><p>WBS是对项目团队为实现项目目标、创建所需可交付成果而需要实施的全部工作范围的层级分解。WBS组织并定义了项目的总范围，代表着经批准的当前项目范围说明书中所规定的工作。</p><p>WBS最低层的组成部分称为工作包，其中包括计划的工作。工作包对相关活动进行归类，以便对工作安排进度、进行估算、开展监督与控制。在“工作分解结构”这个词语中，“工作”是指作为活动结果的工作产品或可交付成果，而不是活动本身。</p><h4 id="4-1-创建WBS：输入"><a href="#4-1-创建WBS：输入" class="headerlink" title="4.1 创建WBS：输入"></a>4.1 创建WBS：输入</h4><h5 id="4-1-1-项目管理计划"><a href="#4-1-1-项目管理计划" class="headerlink" title="4.1.1 项目管理计划"></a>4.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）范围管理计划。范围管理计划定义了如何根据项目范围说明书创建WBS。</p><h5 id="4-1-2-项目文件"><a href="#4-1-2-项目文件" class="headerlink" title="4.1.2 项目文件"></a>4.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>项目范围说明书。项目范围说明书描述了需要实施的工作及不包含在项目中的工作。</p></li><li><p>需求文件。需求文件详细描述了各种单一需求如何满足项目的业务需要。</p></li></ul><h5 id="4-1-3-事业环境因素"><a href="#4-1-3-事业环境因素" class="headerlink" title="4.1.3 事业环境因素"></a>4.1.3 事业环境因素</h5><p>会影响创建WBS过程的事业环境因素包括（但不限于）项目所在行业的WBS标准，这些标准可以作为创建WBS的外部参考资料。</p><h5 id="4-1-4-组织过程资产"><a href="#4-1-4-组织过程资产" class="headerlink" title="4.1.4 组织过程资产"></a>4.1.4 组织过程资产</h5><p>能够影响创建WBS过程的组织过程资产包括（但不限于）：</p><ul><li><p>用于创建WBS的政策、程序和模板；</p></li><li><p>以往项目的项目档案；</p></li><li><p>以往项目的经验教训。</p></li></ul><h4 id="4-2-创建WBS：工具与技术"><a href="#4-2-创建WBS：工具与技术" class="headerlink" title="4.2 创建WBS：工具与技术"></a>4.2 创建WBS：工具与技术</h4><h5 id="4-2-1-专家判断"><a href="#4-2-1-专家判断" class="headerlink" title="4.2.1 专家判断"></a>4.2.1 专家判断</h5><p>应征求具备类似项目知识或经验的个人或小组的意见。</p><h5 id="4-2-2-分解"><a href="#4-2-2-分解" class="headerlink" title="4.2.2 分解"></a>4.2.2 分解</h5><p>分解是一种把项目范围和项目可交付成果逐步划分为更小、更便于管理的组成部分的技术；工作包是WBS最低层的工作，可对其成本和持续时间进行估算和管理。分解的程度取决于所需的控制程度，以实现对项目的高效管理；工作包的详细程度则因项目规模和复杂程度而异。要把整个项目工作分解为工作包，通常需要开展以下活动：</p><ul><li><p>识别和分析可交付成果及相关工作；</p></li><li><p>确定WBS的解构和编排方法；</p></li><li><p>自上而下逐层细化分解；</p></li><li><p>为WBS组成部分制定和分配标识编码；</p></li><li><p>核实可交付成果分解的程度是否恰当。</p></li></ul><p>图5-12显示了某工作分解结构的一部分，其中若干分支已经向下分解到工作包层次。</p><p><img src="/images/pmp-5/5-12.png" alt="分解到工作包的WBS示例"></p><p>创建WBS的方法多种多样，常用的方法包括自上而下的方法、使用组织特定的指南和使用WBS模板。自上而下的方法可用于归并较低层级组件。WBS的解构可以采用多种形式，例如：</p><ul><li><p>以项目生命周期的各阶段作为分解的第二层，把产品和项目可交付成果放在第三层，如图5-13所示；</p></li><li><p>以主要可交付成果作为分解的第二层，如图5-14所示；</p></li><li><p>纳入由项目团队以外的组织开发的各种较低层次组件（如外包工作）。随后，作为外包工作的一部分，卖方须制定相应的合同WBS。</p></li></ul><p><img src="/images/pmp-5/5-13.png" alt="WBS示例：以阶段作为第二层"></p><p><img src="/images/pmp-5/5-14.png" alt="WBS示例：以主要可交付成果作为第二层"></p><p>对WBS较高层组件进行分解，就是要把每个可交付成果或组件分解为最基本的组成部分，即可核实的产品、服务或成果。如果采用敏捷方法，可以将长篇故事分解成用户故事。WBS可以采用提纲式、组织结构图或能说明层级结构的其他形式。通过确认WBS较低层组件是完成上层相应可交付成果的必要且充分的工作，来核实分解的正确性。不同的可交付成果可以分解到不同的层次。某些可交付成果只须分解到下一层，即可达到工作包的层次，而另一些则须分解更多层。工作分解得越细致，对工作的规划、管理和控制就越有利。但是，过细的分解会造成管理努力的无效耗费、资源使用效率低下、工作实施效率降低，同时造成WBS各层级的数据汇总困难。</p><p>要在未来远期才完成的可交付成果或组件，当前可能无法分解。项目管理团队因而通常需要等待对该可交付成果或组成部分达成一致意见，才能够制定出WBS中的相应细节。这种技术有时称作滚动式规划。</p><p>WBS包含了全部的产品和项目工作，包括项目管理工作。通过把WBS底层的所有工作逐层向上汇总，来确保既没有遗漏的工作，也没有多余的工作。这又是被称为100%规则。</p><p>关于WBS的详细信息，可参考《工作分解结构实践标准》。该标准列举了一些具体行业的WBS模板，可以在裁剪后应用于特定领域的具体项目。</p><h4 id="4-3-创建WBS：输出"><a href="#4-3-创建WBS：输出" class="headerlink" title="4.3 创建WBS：输出"></a>4.3 创建WBS：输出</h4><h5 id="4-3-1-范围基准"><a href="#4-3-1-范围基准" class="headerlink" title="4.3.1 范围基准"></a>4.3.1 范围基准</h5><p>范围基准是经过批准的范围说明书、WBS和相应的WBS词典，只有通过正式的变更控制程序才能进行变更，它被用作比较的基础。范围基准是项目管理计划的组成部分，包括：</p><ul><li><p>项目范围说明书。项目范围说明书包括对项目范围、主要可交付成果、假设条件和制约因素的描述。</p></li><li><p>WBS。WBS是对项目团队为实现项目目标、创建所需可交付成果而需要实施的全部工作范围的层级分解。工作分解结构每向下分解一层，代表对项目工作更详细的定义。</p></li><li><p>工作包。WBS的最低层级是带有独特标识号的工作包。这些标识号为进行成本、进度和资源信息的逐层汇总提供了层级结构，构成账户编码。每个工作包都是控制账户的一部分，而控制账户则是一个管理控制点。在该控制点上，把范围、预算和进度加以整合，并与挣值相比较，以测量绩效。控制账户拥有两个或更多工作包，但每个工作包只与一个控制账户关联。</p></li><li><p>规划包。一个控制账户可以包含一个或多个规划包，其是一种低于控制账户而高于工作包的工作分解结构组件，工作内容已知，但详细的进度活动未知。</p></li><li><p>WBS词典。WBS词典是针对WBS中的每个组件，详细描述可交付成果、活动和进度信息的文件。WBS词典对WBS提供支持，其中大部分信息由其他过程创建，然后在后期添加到词典中。WBS词典中的内容可能包括（但不限于）：</p><ul><li><p>账户编码标识；</p></li><li><p>工作描述；</p></li><li><p>假设条件和制约因素；</p></li><li><p>负责的组织；</p></li><li><p>进度里程碑；</p></li><li><p>相关的进度活动；</p></li><li><p>所需资源；</p></li><li><p>成本估算；</p></li><li><p>质量要求；</p></li><li><p>验收标准；</p></li><li><p>技术参考文献；</p></li><li><p>协议信息。</p></li></ul></li></ul><h5 id="4-3-2-项目文件更新"><a href="#4-3-2-项目文件更新" class="headerlink" title="4.3.2 项目文件更新"></a>4.3.2 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>假设日志。随同本过程识别出更多的假设条件或制约因素而更新假设日志。</p></li><li><p>需求文件。可以更新需求文件，以反映在本过程提出并已被批准的变更。</p></li></ul><hr><h3 id="五、确认范围"><a href="#五、确认范围" class="headerlink" title="五、确认范围"></a>五、确认范围</h3><p>确认范围是正式验收已完成的项目可交付成果的过程。本过程的主要作用是，使验收过程具有客观性；同时通过确认每个可交付成果，来提高最终产品、服务或成果获得验收的可能性。本过程应根据需要在整个项目期间定期开展。图5-15描述本过程的输入、工具与技术和输出。图5-16是本过程的数据流向图。</p><p><img src="/images/pmp-5/5-15.png" alt="确认范围：输入、工具与技术和输出"></p><p><img src="/images/pmp-5/5-16.png" alt="确认范围：数据流向图"></p><p>由客户或发起人审查从控制质量过程输出的核实的可交付成果，确认这些可交付成果已经圆满完成并通过正式验收。本过程对可交付成果的确认和最终验收，需要依据：从项目范围管理知识领域的各规划过程获得的输出（如需求文件或范围基准），以及从其他知识领域的各执行过程获得的工作绩效数据。</p><p>确认范围过程与控制质量过程的不同之处在于，前者关注可交付成果的验收，而后者关注可交付成果的正确性及是否满足质量要求。控制质量过程通常优先于确认范围过程，但二者也可同时进行。</p><h4 id="5-1-确认范围：输入"><a href="#5-1-确认范围：输入" class="headerlink" title="5.1 确认范围：输入"></a>5.1 确认范围：输入</h4><h5 id="5-1-1-项目管理计划"><a href="#5-1-1-项目管理计划" class="headerlink" title="5.1.1 项目管理计划"></a>5.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>范围管理计划。项目管理计划定义了如何正式验收已经完成的可交付成果。</p></li><li><p>需求管理计划。需求管理计划描述了如何确认项目需求。</p></li><li><p>范围基准。用范围基准与实际结果比较，以决定是否有必要进行变更、采取纠正措施或预防措施。</p></li></ul><h5 id="5-1-2-项目文件"><a href="#5-1-2-项目文件" class="headerlink" title="5.1.2 项目文件"></a>5.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。在项目早期获得的经验教训可以运用到后期阶段，以提高验收可交付成果的效率与效果。</p></li><li><p>质量报告。质量报告的内容可包括由团队管理或需上报的全部质量保证事项、改进建议，以及在控制质量过程中发现的情况的概述。在验收产品之前，需要查看所有这些内容。</p></li><li><p>需求文件。将需求与实际结果比较，以决定是否有必要进行变更、采取纠正措施或预防措施。</p></li><li><p>需求跟踪矩阵。需求跟踪矩阵含有与需求相关的信息，包括如何确认需求。</p></li></ul><h5 id="5-1-3-核实的可交付成果"><a href="#5-1-3-核实的可交付成果" class="headerlink" title="5.1.3 核实的可交付成果"></a>5.1.3 核实的可交付成果</h5><p>核实的可交付成果是指已经完成，并被控制质量过程检查为正确的可交付成果。</p><h5 id="5-1-4-工作绩效数据"><a href="#5-1-4-工作绩效数据" class="headerlink" title="5.1.4 工作绩效数据"></a>5.1.4 工作绩效数据</h5><p>工作绩效数据可能包括符合需求的程度、不一致的数量、不一致的严重性或在某时间段内开展确认的次数。</p><h4 id="5-2-确认范围：工具与技术"><a href="#5-2-确认范围：工具与技术" class="headerlink" title="5.2 确认范围：工具与技术"></a>5.2 确认范围：工具与技术</h4><h5 id="5-2-1-检查"><a href="#5-2-1-检查" class="headerlink" title="5.2.1 检查"></a>5.2.1 检查</h5><p>检查是指开展测量、审查与确认等活动，来判断工作和可交付成果是否符合需求和产品验收标准。检查有时也被称为审查、产品审查和巡检等。在某些应用领域，这些术语具有独特和具体的含义。</p><h5 id="5-2-2-决策"><a href="#5-2-2-决策" class="headerlink" title="5.2.2 决策"></a>5.2.2 决策</h5><p>可用于本过程的决策技术包括（但不限于）投票。当由项目团队和其他相关方进行验收时，使用投票来形成结论。</p><h4 id="5-3-确认范围：输出"><a href="#5-3-确认范围：输出" class="headerlink" title="5.3 确认范围：输出"></a>5.3 确认范围：输出</h4><h5 id="5-3-1-验收的可交付成果"><a href="#5-3-1-验收的可交付成果" class="headerlink" title="5.3.1 验收的可交付成果"></a>5.3.1 验收的可交付成果</h5><p>符合验收标准的可交付成果应该由客户或发起人正式签字批准。应该从客户或发起人那里获得正式文件，证明相关方对项目可交付成果的正式验收。这些文件将提交给结束项目或阶段过程。</p><h5 id="5-3-2-工作绩效信息"><a href="#5-3-2-工作绩效信息" class="headerlink" title="5.3.2 工作绩效信息"></a>5.3.2 工作绩效信息</h5><p>工作绩效信息包括项目进展信息，例如，哪些可交付成果已经被验收，哪些未通过验收以及原因。这些信息应该被记录下来并传递给相关方。</p><h5 id="5-3-3-变更请求"><a href="#5-3-3-变更请求" class="headerlink" title="5.3.3 变更请求"></a>5.3.3 变更请求</h5><p>对已经完成但未通过正式验收的可交付成果及其未通过验收的原因，应该记录在案。可能需要针对这些可交付成果提出变更请求，开展缺陷补救。变更请求应该由实施整体变更控制过程进行审查与处理。</p><h5 id="5-3-4-项目文件更新"><a href="#5-3-4-项目文件更新" class="headerlink" title="5.3.4 项目文件更新"></a>5.3.4 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。更新经验教训登记册，以记录所遇到的挑战、本应如何避免该挑战，以及良好的可交付成果验收方法。</p></li><li><p>需求文件。记录实际的验收结果，更新需求文件。需要特别注意实际结果比原定需求更好的情况，或者原定需求已经被放弃的情况。</p></li><li><p>需求跟踪矩阵。根据验收结果更新需求跟踪矩阵，包括所采用的验收方法及其使用结果。</p></li></ul><hr><h3 id="六、控制范围"><a href="#六、控制范围" class="headerlink" title="六、控制范围"></a>六、控制范围</h3><p>控制范围是监督项目和产品的范围状态，管理范围基准变更的过程。本过程的主要作用是，在整个项目期间保持对范围基准的维护，且需要在整个项目期间开展。图5-17描述本过程的输入、工具与技术和输出。图5-18是本过程的数据流向图。</p><p><img src="/images/pmp-5/5-17.png" alt="控制范围：输入、工具与技术和输出"></p><p><img src="/images/pmp-5/5-18.png" alt="控制范围：数据流向图"></p><p>控制项目范围确保所有变更请求、推荐的纠正措施或预防措施都通过实施整体变更控制过程进行处理。在变更实际发生时，也要采用控制范围过程来管理这些变更。控制范围过程应该与其他控制过程协调开展。未经控制的产品或项目范围的扩大（未对时间、成本和资源做相应调整）被称为范围蔓延。变更不可避免，因此在每个项目上，都必须强制实施某种形式的变更控制。</p><h4 id="6-1-控制范围：输入"><a href="#6-1-控制范围：输入" class="headerlink" title="6.1 控制范围：输入"></a>6.1 控制范围：输入</h4><h5 id="6-1-1-项目管理计划"><a href="#6-1-1-项目管理计划" class="headerlink" title="6.1.1 项目管理计划"></a>6.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>范围管理计划。范围管理计划记录了如何控制项目和产品范围。</p></li><li><p>需求管理计划。需求管理计划记录了如何管理项目需求。</p></li><li><p>变更管理计划。变更管理计划定义了管理项目变更的过程。</p></li><li><p>配置管理计划。配置管理计划定义了哪些是配置项，哪些配置项需要正式变更控制，以及针对这些配置项的变更控制过程。</p></li><li><p>范围基准。用范围基准与实际结果比较，以决定是否有必要进行变更、采取纠正措施或预防措施。</p></li><li><p>绩效测量基准。使用挣值分析时，将绩效测量基准与实际结果比较，以决定是否有必要进行变更、采取纠正措施或预防措施。</p></li></ul><h5 id="6-1-2-项目文件"><a href="#6-1-2-项目文件" class="headerlink" title="6.1.2 项目文件"></a>6.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。在项目早期获得的经验教训可以运用到后期阶段，以改进范围控制。</p></li><li><p>需求文件。需求文件用于发现任何对商定的项目或产品范围的偏离。</p></li><li><p>需求跟踪矩阵。需求跟踪矩阵有助于探查任何变更或对范围基准的任何偏离对项目目标的影响，它还可以提供受控需求的状态。</p></li></ul><h5 id="6-1-3-工作绩效数据"><a href="#6-1-3-工作绩效数据" class="headerlink" title="6.1.3 工作绩效数据"></a>6.1.3 工作绩效数据</h5><p>工作绩效数据可能包括收到的变更请求的数量、接受的变更请求的数量，或者核实、确认和完成的可交付成果的数量。</p><h5 id="6-1-4-组织过程资产"><a href="#6-1-4-组织过程资产" class="headerlink" title="6.1.4 组织过程资产"></a>6.1.4 组织过程资产</h5><p>能够影响控制范围过程的组织过程资产包括（但不限于）：</p><ul><li><p>现有的、正式和非正式的，与范围控制相关的政策、程序和指南；</p></li><li><p>可用的监督和报告的方法与模板。</p></li></ul><h4 id="6-2-控制范围：工具与技术"><a href="#6-2-控制范围：工具与技术" class="headerlink" title="6.2 控制范围：工具与技术"></a>6.2 控制范围：工具与技术</h4><h5 id="6-2-1-数据分析"><a href="#6-2-1-数据分析" class="headerlink" title="6.2.1 数据分析"></a>6.2.1 数据分析</h5><p>可用于控制范围过程的数据分析技术包括（但不限于）：</p><ul><li><p>偏差分析。偏差分析用于将基准与实际结果进行比较，以确定偏差是否处于临界值区间内或是否有必要采取纠正或预防措施。</p></li><li><p>趋势分析。趋势分析旨在审查项目绩效随时间的变化情况，以判断绩效是正在改善还是正在恶化。</p></li></ul><p>确定偏离范围基准的原因和程度，并决定是否需要采取纠正或预防措施，是项目范围控制的重要工作。</p><h4 id="6-3-控制范围：输出"><a href="#6-3-控制范围：输出" class="headerlink" title="6.3 控制范围：输出"></a>6.3 控制范围：输出</h4><h5 id="6-3-1-工作绩效信息"><a href="#6-3-1-工作绩效信息" class="headerlink" title="6.3.1 工作绩效信息"></a>6.3.1 工作绩效信息</h5><p>本过程产生的工作绩效信息是有关项目和产品范围实施情况（对照范围基准）的、相互关联且与各种背景相结合的信息，包括收到的变更的分类、识别的范围偏差和原因、偏差对进度和成本的影响，以及对将来范围绩效的预测。</p><h5 id="6-3-2-变更请求"><a href="#6-3-2-变更请求" class="headerlink" title="6.3.2 变更请求"></a>6.3.2 变更请求</h5><p>分析项目绩效后，可能会就范围基准和进度基准，或项目管理计划的其他组成部分提出变更请求。变更请求需要经过实施整体变更控制的审查和处理。</p><h5 id="6-3-3-项目管理计划更新"><a href="#6-3-3-项目管理计划更新" class="headerlink" title="6.3.3 项目管理计划更新"></a>6.3.3 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。可能需要变更请求的项目管理计划组成部分包括（但不限于）：</p><ul><li><p>范围管理计划。可以更新范围管理计划，以反映范围管理方式的变更。</p></li><li><p>范围基准。在针对范围、范围说明书、WBS或WBS词典的变更获得批准后，需要对范围基准做出相应的变更。有时范围偏差太过严重，以至于需要修订范围基准，以便为绩效测量提供现实可行的依据。</p></li><li><p>进度基准。在针对范围、资源或进度估算的变更获得批准后，需要对进度基准做出相应的变更。有时进度偏差太过严重，以至于需要修订进度基准，以便为绩效测量提供现实可行的依据。</p></li><li><p>成本基准。在针对范围、资源或成本估算的变更获得批准后，需要对成本基准做出相应的变更。有时成本偏差太过严重，以至于需要修订成本基准，以便为绩效测量提供现实可行的依据。</p></li><li><p>绩效测量基准。在针对范围、进度绩效或成本估算的变更获得批准后，需要对绩效测量基准做出相应的变更。有时绩效偏差太过严重，需要提出变更请求来修订绩效测量基准，以便为绩效测量提供现实可行的依据。</p></li></ul><h5 id="6-3-4-项目文件更新"><a href="#6-3-4-项目文件更新" class="headerlink" title="6.3.4 项目文件更新"></a>6.3.4 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。更新经验教训登记册，以记录控制范围的有效技术，以及造成偏差的原因和选择的纠正措施。</p></li><li><p>需求文件。可以通过增加或修改需求而更新需求文件。</p></li><li><p>需求跟踪矩阵。应该随同需求文件的更新而更新需求跟踪矩阵。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《PMBOK第六版》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目范围管理包括确保项目做且只做所需的全部工作，以成功完成项目的各个过程。管理项目范围主要在于定义和控制哪些工作应该包括在项目内，哪些不应该包括在项目内。&lt;/p&gt;
    
    </summary>
    
      <category term="PMP抄书系列" scheme="http://www.xiaoleon.cn/categories/PMP%E6%8A%84%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="pmp" scheme="http://www.xiaoleon.cn/tags/pmp/"/>
    
  </entry>
  
  <entry>
    <title>PMP(4) 项目整合管理</title>
    <link href="http://www.xiaoleon.cn/2019/02/06/pmp-4/"/>
    <id>http://www.xiaoleon.cn/2019/02/06/pmp-4/</id>
    <published>2019-02-06T10:00:21.000Z</published>
    <updated>2019-05-13T09:47:38.748Z</updated>
    
    <content type="html"><![CDATA[<p>项目整合管理包括对隶属于项目管理过程组的各种过程和项目管理活动进行识别、定义、组合、统一和协调的各个过程。在项目管理中，整合兼具统一、合并、沟通和建立联系的性质，这些行动应该贯穿项目始终。</p><a id="more"></a><p>项目整合管理包括进行以下选择：</p><ul><li><p>资源分配；</p></li><li><p>平衡竞争型需求；</p></li><li><p>研究各种备选方法；</p></li><li><p>为实现项目目标而裁剪过程；</p></li><li><p>管理各个项目管理知识领域之间的依赖关系。</p></li></ul><p>项目整合管理过程包括：</p><ul><li><p><strong>制定项目章程</strong> —— 编写一份正式批准项目并授权项目经理在项目活动中使用组织资源的文件的过程。</p></li><li><p><strong>制定项目管理计划</strong> —— 定义、准备和协调项目计划的所有组成部分，并把它们整合为一份综合项目管理计划的过程。</p></li><li><p><strong>指导与管理项目工作</strong> —— 为实现项目目标而领导和执行项目管理计划中所确定的工作，并实施已批准变更的过程。</p></li><li><p><strong>管理项目知识</strong> —— 使用现有知识并生成新知识，以实现项目目标，并且帮助组织学习的过程。</p></li><li><p><strong>监控项目工作</strong> —— 跟踪、审查和报告整体项目进展，以实现项目管理计划中确定的绩效目标的过程。</p></li><li><p><strong>实施整体变更控制</strong> —— 审查所有变更请求，批准变更，管理对可交付成果、组织过程资产、项目文件和项目管理计划的变更，并对变更处理结果进行沟通的过程。</p></li><li><p><strong>结束项目或阶段</strong> —— 终结项目、阶段或合同的所有活动的过程。</p></li></ul><p>图4-1概述了项目整合管理的各个过程。虽然在本《PMBOK指南》中，各项目整合管理过程以界限分明和相互独立的形式出现，但在实践中它们会以本指南无法全面详述的方式相互交叠和相互作用。</p><p><img src="/images/pmp-4/4-1.png" alt="项目整合管理概述"></p><p><strong>项目整合管理的核心概念</strong></p><p>项目整合管理由项目经理负责。虽然其他知识领域可以由相关专家（如成本分析专家、进度规划专家、风险管理专家）管理，但是项目整合管理的责任不能被授权或转移。只能由项目经理负责整合所有其他知识领域的成果，并掌握项目总体情况。项目经理必须对整个项目承担最终责任。</p><p>项目于项目管理本质上具有整合性质，例如，为应急计划制定成本估算时，就需要整合项目成本管理、项目进度管理和项目风险管理知识领域中的相关过程。在识别出各种人员配备方案有关的额外风险时，可能需要再次进行上述某个或某几个过程。</p><p>项目管理过程组的各个过程之间经常反复发生联系。例如，在项目早期，规划过程组为执行过程组提供书面的项目管理计划；然后，随着项目的进展，规划过程组还将根据变更情况，更新项目管理计划。</p><p>项目整合管理指的是：</p><ul><li><p>确保产品、服务或成果的交付日期，项目生命周期以及效益管理计划这些方面保持一致；</p></li><li><p>编制项目管理计划以实现项目目标；</p></li><li><p>确保创造合适的知识并运用到项目中，并从项目中获取必要的知识；</p></li><li><p>管理项目管理计划中活动的绩效和变更；</p></li><li><p>做出针对影响项目的关键变更的综合决策；</p></li><li><p>测量和监督项目进展，并采取适当措施以实现项目目标；</p></li><li><p>收集关于已达成结果的数据，分析数据以获取信息，并与相关方分享信息；</p></li><li><p>完成全部项目工作，正式关闭各个阶段、合同以及整个项目；</p></li><li><p>管理可能需要的阶段过渡。</p></li></ul><p>项目越复杂，相关方的期望越多样化，就需要越全面的整合方法。</p><p><strong>项目整合管理的发展趋势和新兴实践</strong></p><p>项目整合管理知识领域要求整合所有其他知识领域的成果。与整合管理过程相关的发展趋势包括（但不限于）：</p><ul><li><p>使用自动化工具。项目经理需要整合大量的数据和信息，因此有必要使用项目管理信息系统（PMIS）和自动化工具来收集、分析和使用信息，以实现项目目标和项目收益。</p></li><li><p>使用可视化管理工具。有些项目团队使用可视化管理工具，而不是书面计划和其他文档，来获取和监督关键的项目要素。这样，就便于整个团队直观地看到项目的实时状态，促进知识转移，并提高团队成员和其他相关方识别和解决问题的能力。</p></li><li><p>项目知识管理。项目人员的流动性和不稳定性越来越高，就要求采用更严格的过程，在整个项目生命周期中积累知识并传达给目标受众，以防止知识流失。</p></li><li><p>增加项目经理的职责。项目经理被要求介入启动和结束项目，例如开展项目商业论证和效益管理。按照以往的惯例，这些事务均有管理层和项目管理办公室负责。现在，项目经理需要频繁地与他们合作处理这些事务，以便更好地实现项目目标以及交付项目效益。项目经理也需要更全面地识别相关方，并引导他们参与项目，包括管理项目经理与各职能部门、运营部门和高级管理人员之间的接口。</p></li><li><p>混合型方法。经实践检验的新做法会不断地融入项目管理方法，例如，采用敏捷或其他迭代做法，为开展需求管理而采用商业分析技术，为分析项目复杂性而采取相关工具，以及为在组织中应用项目成果而采用组织变革管理方法。</p></li></ul><p><strong>裁剪时需要考虑的因素</strong></p><p>因为每个项目都是独特的，所以项目经理可能需要裁剪项目整合管理过程。裁剪时应考虑的因素包括（但不限于）：</p><ul><li><p>项目生命周期。什么是合适的项目生命周期？项目生命周期应包括哪些阶段？</p></li><li><p>开发生命周期。对特定产品、服务或成果而言，什么是合适的开发生命周期和开发方法？预测型或适应型方法是否适当？如果是适应型，开发产品是该采用增量还是迭代的方式？混合型方法是否为最佳选择？</p></li><li><p>管理方法。考虑到组织文化和项目的复杂性，哪种管理过程最有效？</p></li><li><p>知识管理。在项目中如何管理知识以营造合作的工作氛围？</p></li><li><p>变更。在项目中如何管理变更？</p></li><li><p>治理。有哪些监控机构、委员会和其他相关方该参与项目治理？对项目状态报告的要求是什么？</p></li><li><p>经验教训。在项目期间及项目结束时，应收集哪些信息？历史信息和经验教训是否适用于未来的项目？</p></li><li><p>效益。应该在何时以何方式报告效益：在项目结束时还是在每次迭代或阶段结束时？</p></li></ul><p><strong>在敏捷或适应型环境中需要考虑的因素</strong></p><p>迭代和敏捷方法能够促进团队成员以相关领域专家的身份参与整合管理。团队成员自行决定计划及其组件的整合方式。</p><p>在适应型环境下，《整合管理的核心概念》中所述的对项目经理的期望保持不变，但把对具体产品的规划和交付授权给团队来控制。项目经理的关注点在于营造一盒合作型的决策氛围，并确保团队有能力应对变更。如果团队成员具备广泛的技能而不局限于某个狭窄的专利领域，那么这种合作型方法就会更加有效。</p><h3 id="一、制定项目章程"><a href="#一、制定项目章程" class="headerlink" title="一、制定项目章程"></a>一、制定项目章程</h3><p>制定项目章程是编写一份正式批准项目并授权项目经理在项目活动中使用组织资源的文件的过程。本过程的主要作用是，明确项目与组织战略目标之间的直接联系，确立项目的正式地位，并展示组织对项目的承诺。本过程仅开展一次或仅在项目的预定义点开展。图4-2描述本过程的输入、工具与技术和输出。图4-3是本过程的数据流向图。</p><p><img src="/images/pmp-4/4-2.png" alt="制定项目章程：输入、工具与技术和输出"></p><p><img src="/images/pmp-4/4-3.png" alt="制定项目章程：数据流向图"></p><p>项目章程在项目执行组织与需求组织之间建立起伙伴关系。在执行外部项目时，通常需要用正式的合同来达成合作协议。这种情况下，可能仍要用项目章程来建立组织内部的合作关系，以确保正确交付合同内容。项目章程一旦被批准，就标志着项目的正式启动。在项目中，应尽早确认并任命项目经理，最好在制定项目章程时就任命，且总应在规划开始之前任命。项目章程可由发起人编制，或者由项目经理与发起机构合作编制。通过这种合作，项目经理可以更好地了解项目目的、目标和预期效益，以便更有效地向项目活动分配资源。项目章程授权项目经理规划、执行和控制项目。</p><p>项目由项目以外的机构来启动，如发起人、项目集或项目管理办公室（PMO）、项目组合治理委员会主席或其授权代表。项目启动者或发起人应该具有一定的职权，能为项目获取资金并提供资源。项目可能因内部经营需要或外部影响而启动，故通常需要编制需求分析、可行性研究、商业论证或有待项目处理的情况的描述。通过编制项目章程，来确认项目符合组织战略和日常运营的需要。不要把项目章程看做合同，因为其中未承诺报酬或金钱用于交换的对价。</p><h4 id="1-1-制定项目章程：输入"><a href="#1-1-制定项目章程：输入" class="headerlink" title="1.1 制定项目章程：输入"></a>1.1 制定项目章程：输入</h4><h5 id="1-1-1-商业文件"><a href="#1-1-1-商业文件" class="headerlink" title="1.1.1 商业文件"></a>1.1.1 商业文件</h5><p>在商业论证和效益管理计划中，可以找到关于项目目标以及项目对业务目标的贡献的相关信息。虽然商业文件是在项目之前制定的，但需要定期审核。</p><ul><li><p>商业论证。经批准的商业论证或类似文件是最常用于制定项目章程的商业文件。商业论证从商业视角描述必要的信息，并且据此决定项目的期望结果是否值得所需投资。高于项目级别的经理和高管们通常使用该文件作为决策的依据。一般情况下，商业论证会包含商业需求和成本效益分析，以论证项目的合理性并确定项目边界。商业论证的编制可由一下一个或多个因素引发：</p><ul><li><p>市场需求（例如，为应对汽油紧缺，某汽车制造商批准一个低油耗车型的研发项目）；</p></li><li><p>组织需要（例如，因为管理费用太高，公司决定合并一些职能并优化流程以降低成本）；</p></li><li><p>客户要求（例如，为了给新工业园区供电，某电力公司批准一个新变电站建设项目）；</p></li><li><p>技术进步（例如，基于技术进步，某航空公司批准了一个新项目，来开发电子机票以取代纸质机票）；</p></li><li><p>法律要求（例如，某油漆制品厂批准一个项目，来编写有毒物质处理指南）；</p></li><li><p>生态影响（例如，某公司批准一个项目，来降低对环境的影响）；</p></li><li><p>社会需要（例如，为应对霍乱频发，某发展中国家的非政府组织批准一个项目，为社区建设饮用水系统和公共厕所，并开展卫生教育）。</p></li></ul></li></ul><p>项目章程包含来源于商业文件中的相关项目信息。既然商业文件不是项目文件，项目经理就不可以对它们进行更新或修改，只可以提出相关建议。</p><h5 id="1-1-2-协议"><a href="#1-1-2-协议" class="headerlink" title="1.1.2 协议"></a>1.1.2 协议</h5><p>协议用于定义启动项目的初衷。协议有多种形式，包括合同、谅解备忘录（MOUs）、服务水平协议（SLA）、协议书、意向书、口头协议、电子邮件或其他书面协议。为外部客户做项目时，通常就以合同的形式出现。</p><h5 id="1-1-3-事业环境因素"><a href="#1-1-3-事业环境因素" class="headerlink" title="1.1.3 事业环境因素"></a>1.1.3 事业环境因素</h5><p>能够影响制定项目章程过程的事业环境因素包括（但不限于）：</p><ul><li><p>政府或行业标准（如产品标准、质量标准、安全标准和工艺标准）；</p></li><li><p>法律法规要求和（或）制约因素；</p></li><li><p>市场条件；</p></li><li><p>组织文化和政治氛围；</p></li><li><p>组织治理框架（通过安排人员、制定政策和确定过程，以结构化的方法实施控制、指导和协调，以实现组织的战略和运营目标）；</p></li><li><p>相关方的期望和风险临界值。</p></li></ul><h5 id="1-1-4-组织过程资产"><a href="#1-1-4-组织过程资产" class="headerlink" title="1.1.4 组织过程资产"></a>1.1.4 组织过程资产</h5><p>能够影响制定项目章程过程的组织过程资产包括（但不限于）：</p><ul><li><p>组织的标准政策、流程和程序；</p></li><li><p>项目组合、项目集和项目的治理框架（用于提供指导和制定决策的治理职能和过程）；</p></li><li><p>监督和报告方法；</p></li><li><p>模板（如项目章程模板）；</p></li><li><p>历史信息与经验教训知识库（如项目记录与文件、关于以往项目选择决策的结果及以往项目绩效的信息）。</p></li></ul><h4 id="1-2-制定项目章程：工具与技术"><a href="#1-2-制定项目章程：工具与技术" class="headerlink" title="1.2 制定项目章程：工具与技术"></a>1.2 制定项目章程：工具与技术</h4><h5 id="1-2-1-专家判断"><a href="#1-2-1-专家判断" class="headerlink" title="1.2.1 专家判断"></a>1.2.1 专家判断</h5><p>专家判断是指基于某应用领域、知识领域、学科和行业等的专业知识而做出的，关于当前活动的合理判断，这些专业知识可来自具有专业学历、知识、技能、经验或培训经历的任何小组或个人。</p><p>本过程应该就以下主题，考虑具备相关专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>组织战略；</p></li><li><p>效益管理；</p></li><li><p>关于项目所在的行业以及项目关注的领域的技术知识；</p></li><li><p>持续时间和预算的估算；</p></li><li><p>风险识别。</p></li></ul><h5 id="1-2-2-数据收集"><a href="#1-2-2-数据收集" class="headerlink" title="1.2.2 数据收集"></a>1.2.2 数据收集</h5><p>可用于本过程的数据收集技术包括（但不限于）：</p><ul><li><p>头脑风暴。本技术用于在短时间内获得大量创意，适用于团队环境，需要引导者进行引导。头脑风暴由两个部分构成：创意产生和创意分析。制定项目章程时可通过头脑风暴向相关方、主题专家和团队成员收集数据、解决方案或创意。</p></li><li><p>焦点小组。焦点小组召集相关方和主题专家讨论项目风险、成功标准和其他议题，比一对一访谈更有利于互动交流。</p></li><li><p>访谈。访谈是指通过与相关方直接交谈来了解高层级需求、假设条件、制约因素、审批标准以及其他信息。</p></li></ul><h5 id="1-2-3-人际关系与团队技能"><a href="#1-2-3-人际关系与团队技能" class="headerlink" title="1.2.3 人际关系与团队技能"></a>1.2.3 人际关系与团队技能</h5><p>可用于本过程的人际关系与团队技能包括（但不限于）：</p><ul><li><p>冲突管理。冲突管理有助于相关方就目标、成功标准、高层级需求、项目描述、总体里程碑和其他内容达成一致意见。</p></li><li><p>引导。引导是指有效引导团队活动成功以达成决定、解决方案或结论的能力。引导者确保参与者有效参与，互相理解，考虑所有意见，按既定决策流程全力支持得到的结论或结果，以及所达成的行动计划和协议在之后得到合理执行。</p></li><li><p>会议管理。会议管理包括准备议程、确保邀请每个关键相关方群体的代表，以及准备和发送后续的会议纪要和行动计划。</p></li></ul><h5 id="1-2-4-会议"><a href="#1-2-4-会议" class="headerlink" title="1.2.4 会议"></a>1.2.4 会议</h5><p>在本过程中，与关键相关方举行会议的目的是识别项目目标、成功标准、主要可交付成果、高层级需求、总体里程碑和其他概述信息。</p><h4 id="1-3-制定项目章程：输出"><a href="#1-3-制定项目章程：输出" class="headerlink" title="1.3 制定项目章程：输出"></a>1.3 制定项目章程：输出</h4><h5 id="1-3-1-项目章程"><a href="#1-3-1-项目章程" class="headerlink" title="1.3.1 项目章程"></a>1.3.1 项目章程</h5><p>项目章程是由项目启动者或发起人发布的，正式批准项目成立，并授权项目经理使用组织资源开展项目活动的文件。它记录了关于项目和项目预期交付的产品、服务或成果的高层级信息，例如：</p><ul><li><p>项目目的；</p></li><li><p>可测量的项目目标和相关的成功标准；</p></li><li><p>高层级需求；</p></li><li><p>高层级项目描述、边界定义以及主要可交付成果；</p></li><li><p>整体项目风险；</p></li><li><p>总体里程碑进度计划；</p></li><li><p>预先批准的财务资源；</p></li><li><p>关键相关方名单；</p></li><li><p>项目审批要求（例如，用什么标准评价项目成功，由谁对项目成功下结论，由谁来签署项目结束）；</p></li><li><p>项目退出标准（例如，在何种条件下才能关闭或取消项目或阶段）；</p></li><li><p>委派的项目经理及其职责和职权；</p></li><li><p>发起人或其他批准项目章程的人员的的姓名和职权。</p></li></ul><p>项目章程确保相关方在总体上就主要可交付成果、里程碑以及每个项目参与者的角色和职责达成共识。</p><h5 id="1-3-2-假设日志"><a href="#1-3-2-假设日志" class="headerlink" title="1.3.2 假设日志"></a>1.3.2 假设日志</h5><p>通常，在项目启动之前编制商业论证时，识别高层级的战略和运营假设条件与制约因素。这些假设条件与制约因素应纳入项目章程。较低层级的活动和任务假设条件在项目期间随着诸如定义技术规范、估算、进度和风险等活动的开展而生成。假设日志用于记录整个项目生命周期中的所有假设条件和制约因素。</p><hr><h3 id="二、制定项目管理计划"><a href="#二、制定项目管理计划" class="headerlink" title="二、制定项目管理计划"></a>二、制定项目管理计划</h3><p>制定项目管理计划是定义、准备和协调项目计划的所有组成部分，并把它们整合为一份综合项目管理计划的过程。本过程的主要作用是，生成一份综合文件，用于确定所有项目工作的基础及其执行方式，它仅开展一次或仅在项目的预定义点开展。图4-4描述本过程的输入、工具与技术和输出。图4-5是本过程的数据流向图。</p><p><img src="/images/pmp-4/4-4.png" alt="制定项目管理计划：输入、工具与技术和输出"></p><p><img src="/images/pmp-4/4-5.png" alt="制定项目管理计划：数据流向图"></p><p>项目管理计划确定项目的执行、监控和收尾方式，其内容会因项目所在的应用领域和复杂程度而异。</p><p>项目管理计划可以是概括或详细的，而每个组成部分的详细程度取决于具体项目的要求。项目管理计划应足够强大，可以应对不断变化的项目环境。这种敏捷性有利于随项目进展产出更准确的信息。</p><p>项目管理计划应基准化，即，至少应规定项目的范围、时间和成本方面的基准，以便据此考核项目执行情况和管理项目绩效。在确定基准之前，可能要对项目管理计划进行多次更新，且这些更新无需遵循正式流程。但是，一旦确定了基准，就只能通过实施整体变更控制过程进行更新。在这种情况下，如果需要进行变更，应提出变更请求以待决定。这一过程将形成一份项目管理计划。在项目收尾之前，该计划需要通过不断更新来渐进明细，并且这些更新需要得到控制和批准。</p><p>对隶属于项目集或项目组合的项目，则应该制定与项目集或项目组合管理计划相一致的项目管理计划。例如，项目集管理计划中要求超过某一特定成本的所有变更都需要上报变更控制委员会（CCB）审查，在项目管理计划中就应该对审查流程和成本临界值做出相应规定。</p><h4 id="2-1-制定项目管理计划：输入"><a href="#2-1-制定项目管理计划：输入" class="headerlink" title="2.1 制定项目管理计划：输入"></a>2.1 制定项目管理计划：输入</h4><h5 id="2-1-1-项目章程"><a href="#2-1-1-项目章程" class="headerlink" title="2.1.1 项目章程"></a>2.1.1 项目章程</h5><p>项目团队把项目章程作为初始项目规划的起始点。项目章程所包含的信息种类数量因项目的复杂程度和已知的信息而异。在项目章程中至少应该定义项目的高层级信息，供将来在项目管理计划的各个组成部分中进一步细化。</p><h5 id="2-1-2-其他过程的输出"><a href="#2-1-2-其他过程的输出" class="headerlink" title="2.1.2 其他过程的输出"></a>2.1.2 其他过程的输出</h5><p>创建项目管理计划需要整合诸多过程的输出。其他规划过程所输出的子计划和基准都是本过程的输入。此外，对这些子计划和基准的变更都可能导致对项目管理计划的相应更新。</p><h5 id="2-1-3-事业环境因素"><a href="#2-1-3-事业环境因素" class="headerlink" title="2.1.3 事业环境因素"></a>2.1.3 事业环境因素</h5><p>能够影响制定项目管理计划过程的事业环境因素包括（但不限于）：</p><ul><li><p>政府或行业标准（如产品标准、质量标准、安全标准和工艺标准）；</p></li><li><p>法律法规要求和（或）制约因素；</p></li><li><p>垂直市场（如建筑）和（或）专门领域（如环境、安全、风险或敏捷软件开发）的项目管理知识体系；</p></li><li><p>组织的结构、文化、管理实践和可持续性；</p></li><li><p>组织治理框架（通过安排人员、制定政策和确定过程，以结构化的方式实施控制、指导和协调，以实现组织的战略和运营目标）；</p></li><li><p>基础设施（如现有的设施和固定资产）。</p></li></ul><h5 id="2-1-4-组织过程资产"><a href="#2-1-4-组织过程资产" class="headerlink" title="2.1.4 组织过程资产"></a>2.1.4 组织过程资产</h5><p>能够影响制定项目管理计划的组织过程资产包括（但不限于）：</p><ul><li><p>组织的标准政策、流程和程序；</p></li><li><p>项目管理计划模板，包括：</p><ul><li><p>根据项目的特定要求而裁剪组织的标准流程的指南和标准；</p></li><li><p>项目收尾指南或要求，如产品确认及验收标准；</p></li></ul></li><li><p>变更控制程序，包括修改正式的组织标准、政策、计划、程序或项目文件，以及批准和确认变更所须遵循的步骤；</p></li><li><p>监督和报告方法、风险控制程序、以及沟通要求；</p></li><li><p>以往类似项目的相关信息（如范围、成本、进度与绩效测量基准、项目日历、项目进度网络图和风险登记册）；</p></li><li><p>历史信息和经验教训知识库。</p></li></ul><h4 id="2-2-制定项目管理计划：工具与技术"><a href="#2-2-制定项目管理计划：工具与技术" class="headerlink" title="2.2 制定项目管理计划：工具与技术"></a>2.2 制定项目管理计划：工具与技术</h4><h5 id="2-2-1-专家判断"><a href="#2-2-1-专家判断" class="headerlink" title="2.2.1 专家判断"></a>2.2.1 专家判断</h5><p>应该就以下主题，考虑具备相关专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>根据项目需要裁剪项目管理过程，包括这些过程间的依赖关系和相互影响，以及这些过程的主要输入和输出；</p></li><li><p>根据需要制定项目管理计划的附加组成部分；</p></li><li><p>确定这些过程所需的工具和技术；</p></li><li><p>编制应包括在项目管理计划中的技术与管理细节；</p></li><li><p>确定项目所需的资源与技能水平；</p></li><li><p>定义项目的配置管理级别；</p></li><li><p>确定哪些项目文件受制于正式的变更控制过程；</p></li><li><p>确定项目工作的优先级，确保把项目资源在合适的时间分配到合适的工作。</p></li></ul><h5 id="2-2-2-数据收集"><a href="#2-2-2-数据收集" class="headerlink" title="2.2.2 数据收集"></a>2.2.2 数据收集</h5><p>可用于本过程的数据收集技术包括（但不限于）：</p><ul><li><p>头脑风暴。制定项目管理计划时，经常以头脑风暴的形式来收集关于项目方法的创意和解决方案。参会者包括项目团队成员，其他主题专家（SME）或相关方也可以参与。</p></li><li><p>核对单。很多组织基于自身经验制定了标准化的核对单，或者采用所在行业的核对单。核对单可以指导项目经理制定计划或帮助检查项目管理计划是否包含所需全部信息。</p></li><li><p>焦点小组。焦点小组召集相关方讨论项目管理方法以及项目管理计划各个组成部分的整合方式。</p></li><li><p>访谈。访谈用于从相关方获取特定信息，用以制定项目管理计划、任何子计划或项目文件。</p></li></ul><h5 id="2-2-3-人际关系和团队技能"><a href="#2-2-3-人际关系和团队技能" class="headerlink" title="2.2.3 人际关系和团队技能"></a>2.2.3 人际关系和团队技能</h5><p>制定项目管理计划时需要的人际关系和团队技能包括：</p><ul><li><p>冲突管理。必要时可以通过冲突管理让具有差异性的相关方就项目管理计划的所有方面达成共识。</p></li><li><p>引导。引导者确保参与者有效参与，互相理解，考虑所有意见，按既定决策流程全力支持得到的结论或结果。</p></li><li><p>会议管理。有必要采用会议管理来确保有效召开多次会议，以便制定、统一和商定项目管理计划。</p></li></ul><h5 id="2-2-4-会议"><a href="#2-2-4-会议" class="headerlink" title="2.2.4 会议"></a>2.2.4 会议</h5><p>在本过程中，可以通过会议讨论项目方法，确定为达成项目目标而采用的工作执行方式，以及制定项目监控方式。</p><p>项目开工会议通常意味着规划阶段结束和执行阶段开始，旨在传达项目目标、获得团队对项目的承诺，以及阐明每个相关方的角色和职责。开工会议可能在不同时间点举行，具体取决于项目的特征：</p><ul><li><p>对于小型项目，通常由一个团队展开项目规划和执行。这种情况下，项目在启动之后很快就会开工（规划过程组），因为执行团队参与了规划。</p></li><li><p>对于大型项目，通常由项目管理团队开展大部分规划工作。在初始规划工作完成、开发（执行）阶段开始时，项目团队其他成员才参与进来。这种情况下，将随同执行过程组的相关过程召开开工会议。</p></li></ul><p>对于多阶段项目，通常在每个阶段开始时都要举行一次开工会议。</p><h4 id="2-3-制定项目管理计划：输出"><a href="#2-3-制定项目管理计划：输出" class="headerlink" title="2.3 制定项目管理计划：输出"></a>2.3 制定项目管理计划：输出</h4><h5 id="2-3-1-项目管理计划"><a href="#2-3-1-项目管理计划" class="headerlink" title="2.3.1 项目管理计划"></a>2.3.1 项目管理计划</h5><p>项目管理计划是说明项目执行、监控和收尾方式的一份文件，它整合并综合了所有子管理计划和基准，以及管理项目所需的其他信息。究竟需要哪些项目管理计划组件，取决于具体项目的需求。</p><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>子管理计划：</p><ul><li><p>范围管理计划。确立如何定义、制定、监督、控制和确认项目范围。</p></li><li><p>需求管理计划。确定如何分析、记录和管理需求。</p></li><li><p>进度管理计划。为编制、监督和控制项目进度建立准则并确定活动。</p></li><li><p>成本管理计划。确定如何规划、安排和控制成本。</p></li><li><p>质量管理计划。确定在项目中如何实施组织的质量政策、方法和标准。</p></li><li><p>资源管理计划。指导如何对项目资源进行分类、分配、管理和释放。</p></li><li><p>沟通管理计划。确定项目信息将如何、何时、由谁来进行管理和传播。</p></li><li><p>风险管理计划。确定如何安排和实施风险管理活动。</p></li><li><p>采购管理计划。确定项目团队将如何从执行组织外部获取货物和服务。</p></li><li><p>相关方参与计划。确定如何根据相关方的需求、利益和影响让他们参与项目决策和执行。</p></li></ul></li><li><p>基准：</p><ul><li><p>范围基准。经过批准的范围说明书、工作分解结构（WBS）和相应的WBS词典，用作比较依据。</p></li><li><p>进度基准。经过批准的进度模型，用作与实际结果进行比较的依据。</p></li><li><p>成本基准。经过批准的、按时间段分配的项目预算，用作实际结果进行比较的依据。</p></li></ul></li><li><p>其他组件。大多数项目管理计划组件都来自于其他过程，虽然有些组件是在本过程生成的。虽然在本过程生成的组件会因项目而异，但是通常包括（但不限于）：</p><ul><li><p>变更管理计划。描述在整个项目期间如何正式审批和采纳变更请求。</p></li><li><p>配置管理计划。描述如何记录和更新项目的特定信息，以及该记录和更新哪些信息，以保持产品、服务或成果的一致性和（或）有效性。</p></li><li><p>绩效测量基准。经过整合的项目范围、进度和成本计划，用作项目执行的比较依据，以测量和管理项目绩效。</p></li><li><p>项目生命周期。描述项目从开始到结束所经历的一系列阶段。</p></li><li><p>开发方法。描述产品、服务或成果的开发方法，例如预测、迭代、敏捷或混合型模式。</p></li><li><p>管理审查。确定项目经理和有关相关方审查项目进展的时间点，以考核绩效是否符合预期，或者确定是否有必要采取预防或纠正措施。</p></li></ul></li></ul><p>项目管理计划是用于管理项目的主要文件之一。管理项目时还会使用其他项目文件。这些其他文件不属于项目管理计划，但它们也是实现高效管理所必须的文件。表4-1列出了主要的项目管理计划组件和项目文件。</p><p><img src="/images/pmp-4/表4-1.png" alt="项目管理计划和项目文件"></p><hr><h3 id="三、指导与管理项目工作"><a href="#三、指导与管理项目工作" class="headerlink" title="三、指导与管理项目工作"></a>三、指导与管理项目工作</h3><p>指导与管理项目工作是为实现项目目标而领导和执行项目管理计划中所确定的工作，并实施已批准变更的过程。本过程的主要作用是，对项目工作和可交付成果开展综合管理，以提高项目成功的可能性。本过程需要在整个项目期间开展。图4-6描述本过程的输入、工具与技术和输出。图4-7是本过程的数据流向图。</p><p><img src="/images/pmp-4/4-6.png" alt="指导与管理项目工作：输入、工具与技术和输出"></p><p><img src="/images/pmp-4/4-7.png" alt="指导与管理项目工作：数据流向图"></p><p>指导与管理项目工作包含执行计划的项目活动，以完成项目可交付成果并达成既定目标。本过程需要分配可用资源并管理其有效使用，也需要执行因分析工作绩效数据和信息而提出的项目计划变更。指导与管理项目工作过程会受项目所在应用领域的直接影响，按项目管理计划中的规定，开展相关过程，完成项目共工作，并产出可交付成果。</p><p>项目经理与项目管理团队一起指导实施已计划好的项目活动，并管理项目内的各种技术接口和组织接口。指导与管理项目工作还要求回顾所有项目变更的影响，并实施已批准的变更，包括纠正措施、预防措施和（或）缺陷补救。</p><p>在项目执行过程中，收集工作绩效数据并传达给合适的控制过程做进一步分析。通过分析工作绩效数据，得到关于可交付成果的完成情况以及与项目绩效相关的其他细节，工作绩效数据也用作监控过程组的输入，并可作为反馈输入到经验教训库，以改善未来工作包的绩效。</p><h4 id="3-1-指导与管理项目工作：输入"><a href="#3-1-指导与管理项目工作：输入" class="headerlink" title="3.1 指导与管理项目工作：输入"></a>3.1 指导与管理项目工作：输入</h4><h5 id="3-1-1-项目管理计划"><a href="#3-1-1-项目管理计划" class="headerlink" title="3.1.1 项目管理计划"></a>3.1.1 项目管理计划</h5><p>项目管理计划的任何组件都可用作本过程的输入。</p><h5 id="3-1-2-项目文件"><a href="#3-1-2-项目文件" class="headerlink" title="3.1.2 项目文件"></a>3.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>变更日志。变更日志记录所有变更请求的状态。</p></li><li><p>经验教训登记册。经验教训用于改进项目绩效，以免重犯错误。登记册有助于确定针对哪些方面设定规则或指南，以使团队行动保持一致。</p></li><li><p>里程碑清单。里程碑清单列出特定里程碑的计划实现日期。</p></li><li><p>项目沟通记录。项目沟通记录包含绩效报告、可交付成果的状态，以及项目生成的其他信息。</p></li><li><p>项目进度计划。进度计划至少包含工作活动清单、持续时间、资源，以及计划的开始与完成日期。</p></li><li><p>需求跟踪矩阵。需求跟踪矩阵把产品需求连接到相应的可交付成果，有助于把关注点放在最终结果上。</p></li><li><p>风险登记册。风险登记册提供可能影响项目执行的各种威胁和机会的信息。</p></li><li><p>风险报告。风险报告提供关于整体项目风险来源的信息，以及关于已识别单个项目风险的概括信息。</p></li></ul><h5 id="3-1-3-批准的变更请求"><a href="#3-1-3-批准的变更请求" class="headerlink" title="3.1.3 批准的变更请求"></a>3.1.3 批准的变更请求</h5><p>批准的变更请求是实施整体变更控制过程的输出，包括经项目经理审查和批准的变更请求，必要时可经变更控制委员会（CCB）审查和批准。批准的变更请求可能是纠正措施、预防措施或缺陷补救，并由项目团队纳入项目进度计划付诸实施，可能对项目或项目管理计划的任一领域产生影响，还可能导致修改正式受控的项目管理计划组件或项目文件。</p><h5 id="3-1-4-事业环境因素"><a href="#3-1-4-事业环境因素" class="headerlink" title="3.1.4 事业环境因素"></a>3.1.4 事业环境因素</h5><p>能够影响指导与管理项目工作过程的事业环境因素包括（但不限于）：</p><ul><li><p>组织的结构、文化、管理实践和可持续性；</p></li><li><p>基础设施（如现有的设施和固定资产）；</p></li><li><p>相关方的风险临界值（如允许的成本超支百分比）。</p></li></ul><h5 id="3-1-5-组织过程资产"><a href="#3-1-5-组织过程资产" class="headerlink" title="3.1.5 组织过程资产"></a>3.1.5 组织过程资产</h5><p>能够影响指导与管理项目工作过程的组织过程资产包括（但不限于）：</p><ul><li><p>组织的标准政策、流程和程序；</p></li><li><p>问题与缺陷管理程序，用于定义问题与缺陷控制、问题与缺陷识别及其解决，以及行动事项跟踪；</p></li><li><p>问题与缺陷管理数据库，包括历史问题与缺陷状态、问题和缺陷解决情况，以及行动事项的结果；</p></li><li><p>绩效测量数据库，用来收集与提供过程和产品的测量数据；</p></li><li><p>变更控制和风险控制程序；</p></li><li><p>以往项目的项目信息（如范围、成本、进度和绩效测量基准，项目日历，项目进度网络图，风险登记册，风险报告以及经验教训知识库）。</p></li></ul><h4 id="3-2-指导与管理项目工作：工具与技术"><a href="#3-2-指导与管理项目工作：工具与技术" class="headerlink" title="3.2 指导与管理项目工作：工具与技术"></a>3.2 指导与管理项目工作：工具与技术</h4><h5 id="3-2-1-专家判断"><a href="#3-2-1-专家判断" class="headerlink" title="3.2.1 专家判断"></a>3.2.1 专家判断</h5><p>应该就以下主题，考虑具备相关专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>关于项目所在的行业以及项目关注的领域的技术知识；</p></li><li><p>成本和预算管理；</p></li><li><p>法律与采购；</p></li><li><p>法律法规；</p></li><li><p>组织治理。</p></li></ul><h5 id="3-2-2-项目管理信息系统（PMIS）"><a href="#3-2-2-项目管理信息系统（PMIS）" class="headerlink" title="3.2.2 项目管理信息系统（PMIS）"></a>3.2.2 项目管理信息系统（PMIS）</h5><p>PMIS提供信息技术（IT）软件工具，例如进度计划软件工具、工作授权系统、配置管理系统、信息收集与发布系统，以及进入其他在线自动化系统（如公司知识库）的界面。自动收集和报告关键绩效指标（KPI）可以是本系统的一项功能。</p><h5 id="3-2-3-会议"><a href="#3-2-3-会议" class="headerlink" title="3.2.3 会议"></a>3.2.3 会议</h5><p>在指导与管理项目工作时，可以通过会议来讨论和解决项目的相关事项。参会者可包括项目经理、项目团队成员，以及所讨论事项相关或会受该事项影响的相关方。应该明确每个参会者的角色，确保有效参会。会议类型包括（但不限于）：开工会议、技术会议、敏捷或迭代规划会议、每日站会、指导小组会议、问题解决会议、进展跟进会议以及回顾会议。</p><h4 id="3-3-指导与管理项目工作：输出"><a href="#3-3-指导与管理项目工作：输出" class="headerlink" title="3.3 指导与管理项目工作：输出"></a>3.3 指导与管理项目工作：输出</h4><h5 id="3-3-1-可交付成果"><a href="#3-3-1-可交付成果" class="headerlink" title="3.3.1 可交付成果"></a>3.3.1 可交付成果</h5><p>可交付成果是在某一过程、阶段或项目完成时，必须产出的任何独特并可核实的产品、成果或服务能力。它通常是项目结果，并可包括项目管理计划的组成部分。</p><p>一旦完成了可交付成果的第一个版本，就应该执行变更控制。用配置管理工具和程序来支持对可交付成果（如文件、软件和构件）的多个版本的控制。</p><h5 id="3-3-2-工具绩效数据"><a href="#3-3-2-工具绩效数据" class="headerlink" title="3.3.2 工具绩效数据"></a>3.3.2 工具绩效数据</h5><p>工作绩效数据是在执行项目工作的过程中，从每个正在执行的活动中收集到的原始观察结果和测量值。数据通常是最低层次的细节，将交由其他过程从中提炼出信息。在工作执行过程中收集数据，再交由控制过程做进一步分析。</p><p>例如，工作绩效数据包括已完成的工作、关键绩效指标（KPI）、技术绩效测量结果、进度活动的实际开始日期和完成日期、已完成的故事点、可交付成果状态、进度进展情况、变更请求的数量、缺陷的数量、实际发生的成本、实际持续时间等。</p><h5 id="3-3-3-问题日志"><a href="#3-3-3-问题日志" class="headerlink" title="3.3.3 问题日志"></a>3.3.3 问题日志</h5><p>在整个项目生命周期中，项目经理通常会遇到问题、差距、不一致或意外冲突。项目经理需要采取某些行动加以处理，以免影响项目绩效。问题日志是一种记录和跟进所有问题的项目文件，所需记录和跟进的内容可能包括：</p><ul><li><p>问题类型；</p></li><li><p>问题提出者和提出时间；</p></li><li><p>问题描述；</p></li><li><p>问题优先级；</p></li><li><p>由谁负责解决问题；</p></li><li><p>目标解决日期；</p></li><li><p>问题状态；</p></li><li><p>最终解决情况。</p></li></ul><p>问题日志可以帮助项目经理有效跟进和管理问题，确保它们得到调查和解决。作为本过程的输出，问题日志被首次创建，尽管在项目期间任何时候都可能发生问题。在整个项目生命周期应该随同监控活动更新问题日志。</p><h5 id="3-3-4-变更请求"><a href="#3-3-4-变更请求" class="headerlink" title="3.3.4 变更请求"></a>3.3.4 变更请求</h5><p>变更请求是关于修改任何文件、可交付成果或基准的正式提议。如果在开展项目工作时发现问题，就可提出变更请求，对项目政策或程序、项目或产品范围、项目成本或预算、项目进度计划、项目或产品结果的质量进行修改。其他变更请求包括必要的预防措施或纠正措施，用来防止以后的不利后果。任何项目相关方都可以提出变更请求，应该通过实施整体变更控制过程对变更请求进行审查和处理。变更请求源自项目内部或外部，是可选或由法律（合同）强制的。变更请求可能包括：</p><ul><li><p>纠正措施。为使项目工作绩效重新与项目管理计划一致，而进行的有目的的活动；</p></li><li><p>预防措施。为确保项目工作的未来绩效符合项目管理计划，而进行的有目的的活动；</p></li><li><p>缺陷补救。为了修正不一致产品或产品组件的有目的的活动；</p></li><li><p>更新。对正式受控的项目文件或计划等进行的变更，以反映修改或增加的意见或内容。</p></li></ul><h5 id="3-3-5-项目管理计划更新"><a href="#3-3-5-项目管理计划更新" class="headerlink" title="3.3.5 项目管理计划更新"></a>3.3.5 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。项目管理计划的任一组成部分都可在本过程中通过变更请求加以更新。</p><h5 id="3-3-6-项目文件更新"><a href="#3-3-6-项目文件更新" class="headerlink" title="3.3.6 项目文件更新"></a>3.3.6 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>活动清单。为完成项目工作，可以通过增加或修改活动来更新活动清单。</p></li><li><p>假设日志。可以增加新的假设条件和制约因素，也可以更新或关闭已有的假设条件和制约因素。</p></li><li><p>经验教训登记册。任何有助于提高当前或未来项目绩效的经验教训都应得到及时记录。</p></li><li><p>需求文件。在本过程中可以识别新的需求，也可以适时更新需求的实现情况。</p></li><li><p>风险登记册。在本过程中可以识别新的风险，也可以更新现有风险。风险登记册用于在风险管理过程中记录风险。</p></li><li><p>相关方登记册。如果在本过程中收集到了现有或新相关方的更多信息，则记录到相关方登记册中。</p></li></ul><h5 id="3-3-7-组织过程资产更新"><a href="#3-3-7-组织过程资产更新" class="headerlink" title="3.3.7 组织过程资产更新"></a>3.3.7 组织过程资产更新</h5><p>可在本过程更新任何组织过程资产。</p><hr><h3 id="四、管理项目知识"><a href="#四、管理项目知识" class="headerlink" title="四、管理项目知识"></a>四、管理项目知识</h3><p>管理项目知识是使用现有知识并生成新知识，以实现项目目标，并且帮助组织学习的过程。本过程的主要作用是，利用已有的组织知识来创造或改进项目成果，并且使当前项目创造的知识可用于支持组织运营和未来的项目或阶段。本过程需要在整个项目期间开展。图4-8描述本过程的输入、工具以及技术的输出。图4-9是本过程的数据流向图。</p><p><img src="/images/pmp-4/4-8.png" alt="管理项目知识：输入、工具与技术的输出"></p><p><img src="/images/pmp-4/4-9.png" alt="管理项目知识：数据流向图"></p><p>知识通常分为“显性知识”（易使用文字、图片和数字进行编撰的知识）和“隐性知识”（个体知识以及难以明确表达的知识，如信念、洞察力、经验和“诀窍”）两种。知识管理指管理显性和隐性知识，旨在重复使用现有知识并生成新知识。有助于达成这两个目的的关键活动是知识分享和知识集成（不同领域的知识、情境知识和项目管理知识）。</p><p>一个常见误解是，知识管理只是将知识记录下来用于分享；另一种常见误解是，知识管理只是在项目结束时总结经验教训，以供未来项目使用。这样的话，只有经编撰的显性知识可以得到分享。因为显性知识缺乏情境，可作不同解读，所以，虽易分享，但无法确保正确理解或应用。隐性知识虽蕴含情境，却很难编撰。它存在于专家各人的思想中，或者存在于社会团体和情境中，通常经由人际交流和互动来分享。</p><p>从组织的角度来看，知识管理指的是确保项目团队和其他相关方的技能、经验和专业知识在项目开始之前、开展期间和结束之后得到运用。因为知识存在于人们的思想中，且无法强迫人们分享自己的知识或关注他人的知识，所以，知识管理最重要的环节就是营造一种相互信任的氛围，激励人们分享知识或关注他人的知识。如果不激励人们分享知识或关注他人的知识，即便最好的知识管理工具和技术也无法发挥作用。在实践中，联合使用知识管理工具和技术（用于人际互动）以及信息管理工具和技术（用于编撰显性知识）来分享知识。</p><h4 id="4-1-管理项目知识：输入"><a href="#4-1-管理项目知识：输入" class="headerlink" title="4.1 管理项目知识：输入"></a>4.1 管理项目知识：输入</h4><h5 id="4-1-1-项目管理计划"><a href="#4-1-1-项目管理计划" class="headerlink" title="4.1.1 项目管理计划"></a>4.1.1 项目管理计划</h5><p>项目管理计划的所有组成部分均为本过程的输入。</p><h5 id="4-1-2-项目文件"><a href="#4-1-2-项目文件" class="headerlink" title="4.1.2 项目文件"></a>4.1.2 项目文件</h5><p>可作为本过程输入的项目文件包括（但不限于）：</p><ul><li><p>经验教训登记册。经验教训登记册提供了有效的知识管理实践。</p></li><li><p>项目团队派工单。项目团队派工单说明了项目已具有的能力和经验以及可能缺乏的知识。</p></li><li><p>资源分解结构。资源分解结构包含有关团队组成的信息，有助于了解团队拥有和缺乏的知识。</p></li><li><p>相关方登记册。相关方登记册包含已识别的相关方的详细情况，有助于了解他们可能拥有的知识。</p></li></ul><h5 id="4-1-3-可交付成果"><a href="#4-1-3-可交付成果" class="headerlink" title="4.1.3 可交付成果"></a>4.1.3 可交付成果</h5><p>可交付成果是在某一过程、阶段或项目完成时，必须产出的任何独特并可核实的产品、成果或服务能力。它通常是为实现项目目标而完成的有形的组成部分，并可包括项目管理计划的组成部分。</p><h5 id="4-1-4-事业环境因素"><a href="#4-1-4-事业环境因素" class="headerlink" title="4.1.4 事业环境因素"></a>4.1.4 事业环境因素</h5><p>能够影响管理项目知识过程的事业环境因素包括（但不限于）：</p><ul><li><p>组织文化、相关方文化和客户文化。相互信任的工作关系和互不指责的文化对知识管理尤其重要。其他因素则包括赋予学习的价值和社会行为规范。</p></li><li><p>设施和资源的地理分布。团队成员所在的位置有助于确定收集和分享知识的方法。</p></li><li><p>组织中的知识专家。有些组织拥有专门从事知识管理的团队或员工。</p></li><li><p>法律法规要求和（或）制约因素。包括对项目信息的保密性要求。</p></li></ul><h5 id="4-1-5-组织过程资产"><a href="#4-1-5-组织过程资产" class="headerlink" title="4.1.5 组织过程资产"></a>4.1.5 组织过程资产</h5><p>在项目管理过程和例行工作中，经常必然要使用项目管理知识，能够影响管理项目知识过程的组织过程资产包括（但不限于）：</p><ul><li><p>组织的标准政策、流程和程序。可能包括：信息的保密性和获取渠道、安全与数据保护、记录保留政策、版权信息的使用、机密信息的销毁、文件格式和最大篇幅、注册数据和元数据、授权使用的技术和社交媒体等。</p></li><li><p>人事管理制度。包括员工发展与培训记录以及关于知识分享行为的能力框架。</p></li><li><p>组织对沟通的要求。正式且严格的沟通要求有利于信息分享。对于生成新知识和整合不同相关方群体的知识，非正式沟通更加有效。</p></li><li><p>正式的知识分享和信息分享程序。包括项目和项目阶段开始之前、开展期间和结束之后的学习回顾，例如识别、吸取和分享从当前项目和其他项目获得的经验教训。</p></li></ul><h4 id="4-2-管理项目知识：工具与技术"><a href="#4-2-管理项目知识：工具与技术" class="headerlink" title="4.2 管理项目知识：工具与技术"></a>4.2 管理项目知识：工具与技术</h4><h5 id="4-2-1-专家判断"><a href="#4-2-1-专家判断" class="headerlink" title="4.2.1 专家判断"></a>4.2.1 专家判断</h5><p>应该就以下主题，考虑具备相关专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>知识管理；</p></li><li><p>信息管理；</p></li><li><p>组织学习；</p></li><li><p>知识和信息管理工具；</p></li><li><p>来自其他项目的相关信息。</p></li></ul><h5 id="4-2-2-知识管理"><a href="#4-2-2-知识管理" class="headerlink" title="4.2.2 知识管理"></a>4.2.2 知识管理</h5><p>知识管理工具和技术将员工联系起来，使他们能够合作生成新知识、分享隐性知识，以及集成不同团队成员所拥有的知识。适用于项目的工具和技术取决于项目的性质，尤其是创新程度、项目复杂性，以及团队的多元化（包括学科背景多元化）程度。</p><p>工具和技术包括（但不限于）：</p><ul><li><p>人际交往，包括非正式的社交和在线社交。可以进行开放式提问（如“谁知道……？”）的在线论坛有助于与专家进行知识分享对话；</p></li><li><p>实践社区（有时称为“兴趣社区”或“社区”）和特别兴趣小组；</p></li><li><p>会议，包括使用通信技术进行互动的虚拟会议；</p></li><li><p>工作跟随和跟随指导；</p></li><li><p>讨论论坛，如焦点小组；</p></li><li><p>知识分享活动，如专题讲座和会议；</p></li><li><p>研讨会，包括问题解决会议和经验教训总结会议；</p></li><li><p>讲故事；</p></li><li><p>创造力和创意管理技术；</p></li><li><p>知识展会和茶座；</p></li><li><p>交互式培训。</p></li></ul><p>可以通过面对面和（或）虚拟方式来应用所有这些工具和技术。通常，面对面互动最有利于建立知识管理所需的信任关系。一旦信任关系建立，可以用虚拟互动来维护这种信任关系。</p><h5 id="4-2-3-信息管理"><a href="#4-2-3-信息管理" class="headerlink" title="4.2.3 信息管理"></a>4.2.3 信息管理</h5><p>信息管理工具和技术用于创建人们和知识之间的联系，可以有效促进简单、明确的显性知识的分享，包括（但不限于）：</p><ul><li><p>编撰显性知识的方法，例如，如何确定经验教训登记册的条目；</p></li><li><p>经验教训登记册；</p></li><li><p>图书馆服务；</p></li><li><p>信息收集，例如搜索网络和阅读已发表的文章；</p></li><li><p>项目管理信息系统（PMIS）。项目管理信息系统通常包括文档管理系统。</p></li></ul><p>通过增加互动要素，如“与我联系”的功能，使用户能够与经验教训发帖者联系，并向其寻求与特定项目和情境有关的建议。这样一来，就能够强化信息管理工具和技术的使用。</p><p>互动和支持也有助于人们找到相关信息。相比搜索关键词，直接询问通常是一种更轻松快捷的方式。搜索关键词经常难以使用，因为人们可能不知道选择什么样的关键词或关键短语才能找到所需的信息。</p><p>知识和信息管理工具与技术应与项目过程和过程责任人相对应。例如，实践社区和主题专家（SME）可以提供见解，帮助改善控制过程；而设置内部发起人可以确保改善措施得到执行。可以分析经验教训登记册的条目来识别通过项目程序变更能够解决的常见问题。</p><h5 id="4-2-4-人际关系与团队技能"><a href="#4-2-4-人际关系与团队技能" class="headerlink" title="4.2.4 人际关系与团队技能"></a>4.2.4 人际关系与团队技能</h5><p>可用于本过程的人际关系与团队技能包括（但不限于）：</p><ul><li><p>积极倾听。积极倾听有助于减少误解并促进沟通和知识分享；</p></li><li><p>引导。引导有助于有效指引团队成功地达成决定、解决方案或结论；</p></li><li><p>领导力。领导力可帮助沟通愿景并鼓舞团队关注合适的知识和知识目标；</p></li><li><p>人际交往。人际交往促使项目相关方之间建立非正式的联系和关系，为线性和隐性知识的分享创造条件；</p></li><li><p>政治意识。政治意识有助于项目经理根据项目环境和组织的政治环境规划沟通。</p></li></ul><h4 id="4-3-管理项目知识：输出"><a href="#4-3-管理项目知识：输出" class="headerlink" title="4.3 管理项目知识：输出"></a>4.3 管理项目知识：输出</h4><h5 id="4-3-1-经验教训登记册"><a href="#4-3-1-经验教训登记册" class="headerlink" title="4.3.1 经验教训登记册"></a>4.3.1 经验教训登记册</h5><p>经验教训登记册可以包含情况的类别和描述，经验教训登记册还可包括与情况相关的影响、建议和行动方案。经验教训登记册可以记录遇到的挑战、问题、意识到的风险和机会，或其他适用的内容。</p><p>经验教训登记册在项目早期创建，作为本过程的输出。因此，在整个项目期间，它可以作为很多过程的输入，也可以作为输出而不断更新。参与工作的个人和团队也参与记录经验教训。可以通过视频、图片、音频或其他合适的方式记录知识，确保有效吸取经验教训。</p><p>在项目或阶段结束时，把相关信息归入经验教训知识库，成为组织过程资产的一部分。</p><h5 id="4-3-2-项目管理计划更新"><a href="#4-3-2-项目管理计划更新" class="headerlink" title="4.3.2 项目管理计划更新"></a>4.3.2 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。项目管理计划的任一组成部分都可在本过程中更新。</p><h5 id="4-3-3-组织过程资产更新"><a href="#4-3-3-组织过程资产更新" class="headerlink" title="4.3.3 组织过程资产更新"></a>4.3.3 组织过程资产更新</h5><p>所有项目都会生成新知识。有些知识应该被编撰，并在管理项目知识过程中被嵌入可交付成果，或者被用于改进过程和程序。在本过程中，也可以首次编撰或使用现有知识，例如，关于新程序的现有想法在本项目中试用并获得成功。</p><p>可在本过程更新任一组织过程资产。</p><hr><h3 id="五、监控项目工作"><a href="#五、监控项目工作" class="headerlink" title="五、监控项目工作"></a>五、监控项目工作</h3><p>监控项目工作是跟踪、审查和报告整体项目进展，以实现管理计划中确定的绩效目标的过程。本过程的主要作用是，让相关方了解项目的当前状态并认可为处理绩效问题而采取的行动，以及通过成本和进度预测，让相关方了解未来项目状态。本过程需要在整个项目期间开展。图4-10描述本过程的输入、工具与技术的输出。图4-11是本过程的数据流向图。</p><p><img src="/images/pmp-4/4-10.png" alt="监控项目工作：输入、工具与技术和输出"></p><p><img src="/images/pmp-4/4-11.png" alt="监控项目工作：数据流向图"></p><p>监督是贯穿于整个项目的项目管理活动之一，包括收集、测量和分析测量结果，以及预测趋势，以便推动过程改进。持续的监督使项目管理团队能洞察项目的健康状况，并识别须特别关注的任何方面。控制包括制定纠正或预防措施或重新规划，并跟踪行动计划的实施过程，以确保它们能有效解决问题。监控项目工作过程关注：</p><ul><li><p>把项目的实际绩效与项目管理计划进行比较；</p></li><li><p>定期评估项目绩效，决定是否需要采取纠正或预防措施，并推荐必要的措施；</p></li><li><p>检查单个项目风险的状态；</p></li><li><p>在整个项目期间，维护一个准确且及时更新的信息库，以反映项目产品及相关文件的情况；</p></li><li><p>为状态报告、进展测量和预测提供信息；</p></li><li><p>做出预测，以更新当前的成本与进度信息；</p></li><li><p>监督已批准变更的实施情况；</p></li><li><p>如果项目是项目集的一部分，还应向项目集管理层报告项目进展和状态；</p></li><li><p>确保项目与商业需求保持一致。</p></li></ul><h4 id="5-1-监控项目工作：输入"><a href="#5-1-监控项目工作：输入" class="headerlink" title="5.1 监控项目工作：输入"></a>5.1 监控项目工作：输入</h4><h5 id="5-1-1-项目管理计划"><a href="#5-1-1-项目管理计划" class="headerlink" title="5.1.1 项目管理计划"></a>5.1.1 项目管理计划</h5><p>监控项目工作包括查看项目的各个方面。项目管理计划的任一组成部分都可作为本过程的输入。</p><h5 id="5-1-2-项目文件"><a href="#5-1-2-项目文件" class="headerlink" title="5.1.2 项目文件"></a>5.1.2 项目文件</h5><p>可用于本过程输入的项目文件包括（但不限于）：</p><ul><li><p>假设日志。假设日志包含会影响项目的假设条件和制约因素的信息。</p></li><li><p>估算依据。估算依据说明不同估算是如何得出的，用于决定如何应对偏差。</p></li><li><p>成本预测。成本预测基于项目以往的绩效，用于确定项目是否仍处于预算的公差区间内，并识别任何必要的变更。</p></li><li><p>问题日志。问题日志用于记录和监督由谁负责在目标日期内解决特定问题。</p></li><li><p>经验教训登记册。经验教训登记册可能包含应对偏差的有效方式以及纠正措施和预防措施。</p></li><li><p>里程碑清单。里程碑清单列出特定里程碑的实现日期，用于检查是否达到计划的里程碑。</p></li><li><p>质量报告。质量报告包含质量管理问题，针对过程、项目和产品的改善建议，纠正措施建议（包括返工、缺陷（漏洞）补救、100%检查等），以及在控制质量过程中发现的情况的概述。</p></li><li><p>风险登记册。风险登记册提供在项目执行过程中发生的各种威胁和机会的相关信息。</p></li><li><p>风险报告。风险报告提供关于整体项目风险和单个风险的信息。</p></li><li><p>进度预测。进度预测基于项目以往的绩效，用于确定项目是否仍处于进度的公差区间内，并识别任何必要的变更。</p></li></ul><h5 id="5-1-3-工作绩效信息"><a href="#5-1-3-工作绩效信息" class="headerlink" title="5.1.3 工作绩效信息"></a>5.1.3 工作绩效信息</h5><p>在工作执行过程中收集绩效数据，再交由控制过程做进一步分析。将工作绩效数据与项目管理计划组件、项目文件和其他项目变量比较之后生成工作绩效信息。通过这种比较可以了解项目的执行情况。</p><p>在项目开始时，就在项目管理计划中规定关于范围、进度、预算和质量的具体工作绩效测量指标。项目期间通过控制过程收集绩效数据，与计划和其他变量比较，为工作绩效提供背景。</p><p>例如，关于成本的工作绩效数据可能包含已支出的资金，但必须与预算、已执行的工作、用于完成工作的资源以及资金使用计划比较之后才能有用。这些附加信息为确定项目是否符合预算或是否存在偏差提供了相应的情境；还有助于了解偏差的严重程度。通过与项目管理计划中的偏差临界值进行比较，就可以确定是否需要采取预防或纠正措施。对工作绩效数据和附加信息进行综合分析，可以为项目决策提供可靠的基础。</p><h5 id="5-1-4-协议"><a href="#5-1-4-协议" class="headerlink" title="5.1.4 协议"></a>5.1.4 协议</h5><p>采购协议中包括条款和条件，也可包括其他条目，如买方就卖方应实施的工作或应交付的产品所做的规定。如果项目将部分工作外包出去，项目经理需要监督承包商的工作，确保所有协议都符合项目的特定要求，以及组织的采购政策。</p><h5 id="5-1-5-事业环境因素"><a href="#5-1-5-事业环境因素" class="headerlink" title="5.1.5 事业环境因素"></a>5.1.5 事业环境因素</h5><p>能够影响监控项目工作过程的事业环境因素包括（但不限于）：</p><ul><li><p>项目管理信息系统，例如进度、成本、资源工作、绩效指标、数据库、项目记录和财务依据；</p></li><li><p>基础设施；</p></li><li><p>相关方的期望和风险临界值；</p></li><li><p>政府或行业标准（如监管机构条例、产品标准、质量标准和工艺标准）。</p></li></ul><h5 id="5-1-6-组织过程资产"><a href="#5-1-6-组织过程资产" class="headerlink" title="5.1.6 组织过程资产"></a>5.1.6 组织过程资产</h5><p>能够影响监控项目工作过程的组织过程资产包括（但不限于）：</p><ul><li><p>组织的标准政策、流程和程序；</p></li><li><p>财务控制程序（如必需的费用与支付审查、会计编码及标准合同条款等）；</p></li><li><p>监督和报告方法；</p></li><li><p>问题管理程序，用于定义问题控制、问题识别及其解决，以及行动事项跟踪；</p></li><li><p>缺陷管理程序，用于定义缺陷控制、缺陷识别及其解决，以及行动事项跟踪；</p></li><li><p>组织知识库，尤其是过程测量和经验教训知识库。</p></li></ul><h4 id="5-2-监控项目工作：工具与技术"><a href="#5-2-监控项目工作：工具与技术" class="headerlink" title="5.2 监控项目工作：工具与技术"></a>5.2 监控项目工作：工具与技术</h4><h5 id="5-2-1-专家判断"><a href="#5-2-1-专家判断" class="headerlink" title="5.2.1 专家判断"></a>5.2.1 专家判断</h5><p>应该就以下主题，考虑具备相关专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>挣值分析；</p></li><li><p>数据的解释和情境化；</p></li><li><p>持续时间和成本的估算技术；</p></li><li><p>趋势分析；</p></li><li><p>关于项目所在的行业以及项目关注的领域的技术知识；</p></li><li><p>风险管理；</p></li><li><p>合同管理。</p></li></ul><h5 id="5-2-2-数据分析"><a href="#5-2-2-数据分析" class="headerlink" title="5.2.2 数据分析"></a>5.2.2 数据分析</h5><p>可用于本过程的数据分析技术包括（但不限于）：</p><ul><li><p>备选方案分析。备选方案分析用于在出现偏差时选择要执行的纠正措施或纠正措施和预防措施的组合。</p></li><li><p>成本效益分析。成本效益分析有助于在项目出现偏差时确定最节约成本的纠正措施。</p></li><li><p>挣值分析。挣值分析对范围、进度和成本绩效进行了综合分析。</p></li><li><p>根本原因分析。根本原因分析关注识别问题的主要原因，它可用于识别出现偏差的原因以及项目经理为达成项目目标应重点关注的领域。</p></li><li><p>趋势分析。趋势分析根据以往结果预测未来绩效，它可以预测项目的进度延误，提前让项目经理意识到，按照既定趋势发展，后期进度可能出现的问题。应该在足够早的项目时间进行趋势分析，使项目团队有时间分析和纠正任何异常。可以根据趋势分析的结果，提出必要的预防措施建议。</p></li><li><p>偏差分析。偏差分析审查目标绩效与实际绩效之间的差异（或偏差），可涉及持续时间估算、成本估算、资源使用、资源费率、技术绩效和其他测量指标。可以在每个知识领域，针对特定变量，开展偏差分析。在监控项目工作过程中，通过偏差分析对成本、时间、技术和资源偏差进行综合分析，以了解项目的总体偏差情况。这样就便于采取合适的预防或纠正措施。</p></li></ul><h5 id="5-2-3-决策"><a href="#5-2-3-决策" class="headerlink" title="5.2.3 决策"></a>5.2.3 决策</h5><p>可用于本过程的决策技术包括（但不限于）投票。投票可以包括用下列方法进行决策：一致同意、大多数同意或相对多数同意。</p><h5 id="5-2-4-会议"><a href="#5-2-4-会议" class="headerlink" title="5.2.4 会议"></a>5.2.4 会议</h5><p>会议可以是面对面或虚拟会议，正式或非正式会议。参会者可以包括项目团队成员和其他合适的项目相关方；会议的类型包括（但不限于）用户小组会议和用户审查会议。</p><h4 id="5-3-监控项目工作：输出"><a href="#5-3-监控项目工作：输出" class="headerlink" title="5.3 监控项目工作：输出"></a>5.3 监控项目工作：输出</h4><h5 id="5-3-1-工作绩效报告"><a href="#5-3-1-工作绩效报告" class="headerlink" title="5.3.1 工作绩效报告"></a>5.3.1 工作绩效报告</h5><p>工作绩效信息可以用实体或电子形式加以合并、记录和分发。基于工作绩效信息，以实体或电子形式编制工作绩效报告，以制定决策、采取行动或引起关注。根据项目沟通管理计划，通过沟通过程向项目相关方发送工作绩效报告。</p><p>工作绩效报告的示例包括状态报告和进展报告。工作绩效报告可以包含挣值图表和信息、趋势线和预测、储备燃尽图、缺陷直方图、合同绩效信息和风险情况概述。可以表现为有助于引起关注、制定决策和采取行动的仪表指示图、热点报告、信号灯图或其他形式。</p><h5 id="5-3-2-变更请求"><a href="#5-3-2-变更请求" class="headerlink" title="5.3.2 变更请求"></a>5.3.2 变更请求</h5><p>通过比较实际情况与计划要求，可能需要提出变更请求，来扩大、调整或缩小项目范围与产品范围，或者提高、调整或降低质量要求和进度或成本基准。变更请求可能导致需要收集和记录新的需求。变更可能会影响项目管理计划、项目文件或产品可交付成果。应该通过实施整体变更控制过程对变更请求进行审查和处理。变更可能包括（但不限于）：</p><ul><li><p>纠正措施。为使项目工作绩效重新与项目管理计划一致，而进行的有目的的活动；</p></li><li><p>预防措施。为确保项目工作的未来绩效符合项目管理计划，而进行的有目的的活动；</p></li><li><p>缺陷补救。为了修正不一致产品或产品组件而进行的有目的的活动。</p></li></ul><h5 id="5-3-3-项目管理计划更新"><a href="#5-3-3-项目管理计划更新" class="headerlink" title="5.3.3 项目管理计划更新"></a>5.3.3 项目管理计划更新</h5><p>项目管理计划的任何变更都以变更请求的形式提出，且通过组织的变更控制过程进行处理。在监控项目工作过程中提出的变更可能会影响整体项目管理计划。</p><h5 id="5-3-4-项目文件更新"><a href="#5-3-4-项目文件更新" class="headerlink" title="5.3.4 项目文件更新"></a>5.3.4 项目文件更新</h5><p>可在本过程更新的项目文件包括（但不限于）：</p><ul><li><p>成本预测。本过程引起的成本预测的变更应通过成本管理过程进行记录；</p></li><li><p>问题日志。在本过程中产生的新问题应该记录到问题日志中；</p></li><li><p>经验教训登记册。更新经验教训登记册，记录应对偏差的有效方式以及纠正措施和预防措施；</p></li><li><p>风险登记册。在本过程中识别的信丰县应记录在风险登记册中，并通过风险管理过程进行管理；</p></li><li><p>进度预测。本过程引起的进度预测的变更应通过进度管理过程进行记录。</p></li></ul><hr><h3 id="六、实施整体变更控制"><a href="#六、实施整体变更控制" class="headerlink" title="六、实施整体变更控制"></a>六、实施整体变更控制</h3><p>实施整体变更控制是审查所有变更请求、批准变更，管理对可交付成果、项目文件和项目管理计划的变更，并对变更处理结果进行沟通的过程。本过程审查对项目文件、可交付成果或项目管理计划的所有变更请求，并决定对变更请求的处置方案。本过程的主要作用是确保对项目中已记录在案的变更做综合评审。如果不考虑变更对整体项目目标或计划的影响就开展变更，往往会加剧整体项目风险。本过程需要在整个项目期间开展。图4-12描述本过程的输入、工具与技术和输出。图4-13是本过程的数据流向图。</p><p><img src="/images/pmp-4/4-12.png" alt="实施整体变更控制：输入、工具与技术和输出"></p><p><img src="/images/pmp-4/4-13.png" alt="实施整体变更控制：数据流向图"></p><p>实施整体变更控制过程贯穿项目始终，项目经理对此承担最终责任。变更请求可能影响项目范围、产品范围以及任一项目管理计划组件或任一项目文件。在整个项目生命周期的任何时间，参与项目的任何相关方都可以提出变更请求。变更控制的实施程度，取决于项目所在应用领域、项目复杂程度、合同要求，以及项目所处的背景与环境。</p><p>在基准确定之前，变更无需正式受控于实施整体变更控制过程。一旦确定了项目基准，就必须通过本过程来处理变更请求。依照常规，每个项目的配置管理计划应规定哪些项目工件受控于配置控制程序。对配置要素的任何变更都应该提出变更请求，并经过正式控制。</p><p>尽管也可以口头提出，但所有变更请求都必须以书面形式记录，并纳入变更管理和（或）配置管理系统中。在批准变更之前，可能需要了解变更对进度的影响和对成本的影响。在变更请求可能影响任一项目基准的情况下，都需要开展正式的整体变更控制过程。每项记录在案的变更请求都必须由一位责任人批准、退出或否决，这个责任人通常是项目发起人或项目经理。应该在项目管理计划或组织程序中指定这位责任人，必要时，应该由变更控制委员会（CCB）来开展实施整体变更控制过程。CCB是一个正式组成的团体，负责审查、评价、批准、推迟或否决项目变更，以及记录和传达变更处理决定。</p><p>变更请求得到批准后，可能需要新编（或修订）成本估算、活动排序、进度日期、资源需求和（或）风险应对方案分析，这些变更可能要求调整项目管理计划和其他项目文件。某些特定的变更请求，在CCB批准之后，可能还需要得到客户或发起人的批准，除非他们本身就是CCB的成员。</p><h4 id="6-1-实施整体变更控制：输入"><a href="#6-1-实施整体变更控制：输入" class="headerlink" title="6.1 实施整体变更控制：输入"></a>6.1 实施整体变更控制：输入</h4><h5 id="6-1-1-项目管理计划"><a href="#6-1-1-项目管理计划" class="headerlink" title="6.1.1 项目管理计划"></a>6.1.1 项目管理计划</h5><p>项目管理计划组件包括（但不限于）：</p><ul><li><p>变更管理计划。变更管理计划为管理变更控制过程提供指导，并记录变更控制委员会（CCB）的角色和职责。</p></li><li><p>配置管理计划。配置管理计划描述项目的配置项、识别应记录和更新的配置项，以便保持项目产品的一致性和有效性。</p></li><li><p>范围基准。范围基准提供项目和产品定义。</p></li><li><p>进度基准。进度基准用于评估变更对项目进度的影响。</p></li><li><p>成本基准。成本基准用于评估变更对项目成本的影响。</p></li></ul><h5 id="6-1-2-项目文件"><a href="#6-1-2-项目文件" class="headerlink" title="6.1.2 项目文件"></a>6.1.2 项目文件</h5><p>可用于本过程输入的项目文件包括（但不限于）：</p><ul><li><p>估算依据。估算依据指出了持续时间、成本和资源估算是如何得出的，可用于计算变更对时间、预算和资源的影响。</p></li><li><p>需求跟踪矩阵。需求跟踪矩阵有助于评估变更对项目范围的影响。</p></li><li><p>风险报告。风险报告提供了与变更请求有关的整体和单个项目风险的来源的信息。</p></li></ul><h5 id="6-1-3-工作绩效报告"><a href="#6-1-3-工作绩效报告" class="headerlink" title="6.1.3 工作绩效报告"></a>6.1.3 工作绩效报告</h5><p>对实施整体变更控制过程特别有用的工作绩效报告包括：资源可用情况、进度和成本数据、挣值报告、燃烧图或燃尽图。</p><h4 id="6-1-4-变更请求"><a href="#6-1-4-变更请求" class="headerlink" title="6.1.4 变更请求"></a>6.1.4 变更请求</h4><p>很多过程都会输出变更请求。变更请求可能包含纠正措施、预防措施、缺陷补救，以及对正式受控的项目文件或可交付成果的更新，以反映修改或增加的意见或内容。变更可能影响项目基准，也可能不影响项目基准，而只影响相对于基准的项目绩效。变更决定通常由项目经理做出。</p><p>对于会影响项目基准的变更，通常应该在变更请求中说明执行变更的成本、所需的计划日期修改、资源需求以及相关的风险。这种变更应由CCB（如果有）和客户或发起人审批，除非他们本身就是CCB成员。只有经批准的变更才能纳入修改后的基准。</p><h5 id="6-1-5-事业环境因素"><a href="#6-1-5-事业环境因素" class="headerlink" title="6.1.5 事业环境因素"></a>6.1.5 事业环境因素</h5><p>能够影响实施整体变更控制过程的事业环境因素包括（但不限于）：</p><ul><li><p>法律限制，例如国家或地区法规；</p></li><li><p>政府或行业标准（如产品标准、质量标准、安全标准和工艺标准）；</p></li><li><p>法律法规要求和（或）制约因素；</p></li><li><p>组织治理框架（通过安排人员、制定政策和确定过程，以结构化的方式实施控制、指导和协调，以实现组织的战略和运营目标）；</p></li><li><p>合同和采购制约因素。</p></li></ul><h5 id="6-1-6-组织过程资产"><a href="#6-1-6-组织过程资产" class="headerlink" title="6.1.6 组织过程资产"></a>6.1.6 组织过程资产</h5><p>能够影响实施整体变更控制过程的组织过程资产包括（但不限于）：</p><ul><li><p>变更控制程序，包括修改组织标准、政策、计划和程序（或任一项目文件）所须遵循的步骤，以及如何批准和确认变更；</p></li><li><p>批准与签发变更的程序；</p></li><li><p>配置管理知识库，包括组织标准、政策、程序和项目文件的各种版本和基准。</p></li></ul><h4 id="6-2-实施整体变更控制：工具与技术"><a href="#6-2-实施整体变更控制：工具与技术" class="headerlink" title="6.2 实施整体变更控制：工具与技术"></a>6.2 实施整体变更控制：工具与技术</h4><h5 id="6-2-1-专家判断"><a href="#6-2-1-专家判断" class="headerlink" title="6.2.1 专家判断"></a>6.2.1 专家判断</h5><p>应该就以下主题，考虑征求具备以下相关专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>关于项目所在的行业以及项目关注的领域的技术知识；</p></li><li><p>法律法规；</p></li><li><p>法规与采购；</p></li><li><p>配置管理；</p></li><li><p>风险管理。</p></li></ul><h5 id="6-2-2-变更控制工具"><a href="#6-2-2-变更控制工具" class="headerlink" title="6.2.2 变更控制工具"></a>6.2.2 变更控制工具</h5><p>为了便于开展配置和变更管理，可以使用一些手动或自动化的工具。配置控制重点关注可交付成果及各个过程的技术规范，而变更控制则着眼于识别、记录、批准或否决对项目文件、可交付成果或基准的变更。</p><p>工具的选择应基于项目相关方的需要，包括考虑组织和环境情况和（或）制约因素。工具应支持一下配置管理活动：</p><ul><li><p>识别配置项。识别与选择配置项，从而为定义与核实产品配置、标记产品和文件、管理变更和明确责任提供基础。</p></li><li><p>记录并报告配置项状态。关于各个配置项的信息记录和报告。</p></li><li><p>进行配置项核实与审计。通过配置核实与审计，确保项目的配置项组成的正确性，以及相应的变更都被登记、评估、批准、跟踪和正确实施，从而确保配置文件所规定的的功能要求都已实现。</p></li></ul><p>工具还应支持以下变更管理活动：</p><ul><li><p>识别变更。识别并选择过程或项目文件的变更项。</p></li><li><p>记录变更。将变更记录为合适的变更请求。</p></li><li><p>做出变更决定。审查变更，批准、否决、推迟对项目文件、可交付成果或基准的变更或作出其他决定。</p></li><li><p>跟踪变更。确认变更被登记、评估、批准、跟踪并向相关方传达最终结果。</p></li></ul><p>也可以使用工具来管理变更请求和后续的决策，同时还要格外关注沟通，以帮助变更控制委员会的成员履行职责，以及向相关方传达决定。</p><h5 id="6-2-3-数据分析"><a href="#6-2-3-数据分析" class="headerlink" title="6.2.3 数据分析"></a>6.2.3 数据分析</h5><p>可用于本过程的数据分析技术包括（但不限于）：</p><ul><li><p>备选方案分析。该技术用于评估变更请求，并决定哪些请求可接受、应否决或需修改。</p></li><li><p>成本效益分析。该分析有助于确定变更请求是否值得投入相关成本。</p></li></ul><h5 id="6-2-4-决策"><a href="#6-2-4-决策" class="headerlink" title="6.2.4 决策"></a>6.2.4 决策</h5><p>可用于本过程的决策技术包括（但不限于）：</p><ul><li><p>投票。投票可以采取一致同意、大多数同意或相对多数原则的方式，以决定是否接受、推迟或否决变更请求。</p></li><li><p>独裁型决策制定。采用这种决策技术，将由一个人负责为整个集体制定决策。</p></li><li><p>多标准决策分析。该技术借助决策矩阵，根据一系列预定义的准则，用系统分析方法评估变更请求。</p></li></ul><h5 id="6-2-5-会议"><a href="#6-2-5-会议" class="headerlink" title="6.2.5 会议"></a>6.2.5 会议</h5><p>与变更控制委员会（CCB）一起召开变更控制会。变更控制会员会负责审查变更请求，并做出批准、否决或推迟的决定。大部分变更会对时间、成本、资源或风险产生一定的影响，因此，评估变更的影响也是会议的基本工作。此外，会议上可能还要讨论并提议所有变更的备选方案。最后，将会议决定传达给提出变更请求的责任人或小组。</p><p>CCB也可以审查配置管理活动。应该明确规定变更控制委员会的角色和职责，并经相关方一致同意后，记录在变更管理计划中。CCB的决定都应记录在案，并向相关方传达，以便其知晓并采取后续行动。</p><h4 id="6-3-实施整体变更控制：输出"><a href="#6-3-实施整体变更控制：输出" class="headerlink" title="6.3 实施整体变更控制：输出"></a>6.3 实施整体变更控制：输出</h4><h5 id="6-3-1-批准的变更请求"><a href="#6-3-1-批准的变更请求" class="headerlink" title="6.3.1 批准的变更请求"></a>6.3.1 批准的变更请求</h5><p>由项目经理、CCB或指定的团队成员，根据变更管理计划处理变更请求，作出批准、推迟或否决的决定。批准的变更请求应通过指导与管理项目工作过程加以实施。对于推迟或否决的变更请求，应通知提出变更请求的个人或小组。</p><p>以项目文件更新的形式，在变更日志中记录所有变更请求的处理情况。</p><h5 id="6-3-2-项目管理计划更新"><a href="#6-3-2-项目管理计划更新" class="headerlink" title="6.3.2 项目管理计划更新"></a>6.3.2 项目管理计划更新</h5><p>项目管理计划的任一正式受控的组成部分，都可通过本过程进行变更。对基准的变更，只能基于最新版本的基准且针对将来的情况，而不能变更以往的绩效。这有助于保护基准和历史绩效数据的严肃性和完整性。</p><h5 id="6-3-3-项目文件更新"><a href="#6-3-3-项目文件更新" class="headerlink" title="6.3.3 项目文件更新"></a>6.3.3 项目文件更新</h5><p>正式受控的任一项目文件都可在本过程变更，通常在本过程更新的一种项目文件是变更日志。变更日志用于记录项目期间发生的变更。</p><hr><h3 id="七、结束项目或阶段"><a href="#七、结束项目或阶段" class="headerlink" title="七、结束项目或阶段"></a>七、结束项目或阶段</h3><p>结束项目或阶段是终结项目、阶段或合同的所有活动的过程。本过程的主要作用是，存档项目或阶段信息，完成计划的工作，释放组织团队资源以展开新的工作。它仅开展一次或仅在项目的预定义点开展。图4-14描述本过程的输入、工具与技术和输出。图4-15是本过程的数据流向图。</p><p><img src="/images/pmp-4/4-14.png" alt="结束项目或阶段：输入、工具与技术和输出"></p><p><img src="/images/pmp-4/4-15.png" alt="结束项目或阶段：数据流向图"></p><p>在结束项目时，项目经理需要回顾项目管理计划，确保所有项目工作都已完成以及项目目标均已实现。项目或阶段行政收尾所需的必要活动包括（但不限于）：</p><ul><li><p>为达到阶段或项目的完工或退出标准所必须的行动和活动，例如：</p><ul><li><p>确保所有文件和可交付成果都已是最新版本，且所有问题都已得到解决；</p></li><li><p>确认可交付成果已交付给客户并已获得客户的正式验收；</p></li><li><p>确保所有成本都已记入项目成本账；</p></li><li><p>关闭项目账户；</p></li><li><p>重新分配人员；</p></li><li><p>处理多余的项目材料；</p></li><li><p>重新分配项目设施、设备和其他资源；</p></li><li><p>根据组织政策编制详尽的最终项目报告。</p></li></ul></li><li><p>为关闭项目合同协议或项目阶段合同协议所必须开展的活动，例如：</p><ul><li><p>确认卖方的工作已通过正式验收；</p></li><li><p>最终处置未决索赔；</p></li><li><p>更新记录以反映最后的结果；</p></li><li><p>存档相关信息供未来使用。</p></li></ul></li><li><p>为完成下列工作所必须开展的活动：</p><ul><li><p>收集项目或阶段记录；</p></li><li><p>审计项目成败；</p></li><li><p>管理知识分享和传递；</p></li><li><p>总结经验教训；</p></li><li><p>存档项目信息以供组织未来使用。</p></li></ul></li><li><p>为向下一个阶段，或者向生产和（或）运营部门移交项目的产品、服务和成果所必须开展的行动和活动。</p></li><li><p>收集关于改进或更新组织政策和程序的建议，并将它们发送给相应的组织部门。</p></li><li><p>测量相关方的满意程度。</p></li></ul><p>如果项目在完工前就提前终止，结束项目或阶段过程还需要制定程序，来调查和记录提前终止的原因。为了实现上述目的，项目经理应该引导所有合适的相关方参与本过程。</p><h4 id="7-1-结束项目或阶段：输入"><a href="#7-1-结束项目或阶段：输入" class="headerlink" title="7.1 结束项目或阶段：输入"></a>7.1 结束项目或阶段：输入</h4><h5 id="7-1-1-项目章程"><a href="#7-1-1-项目章程" class="headerlink" title="7.1.1 项目章程"></a>7.1.1 项目章程</h5><p>项目章程记录了项目成功标准、审批要求，以及由谁来签署项目结束。</p><h5 id="7-1-2-项目管理计划"><a href="#7-1-2-项目管理计划" class="headerlink" title="7.1.2 项目管理计划"></a>7.1.2 项目管理计划</h5><p>项目管理计划的所有组成部分均为本过程的输入。</p><h5 id="7-1-3-项目文件"><a href="#7-1-3-项目文件" class="headerlink" title="7.1.3 项目文件"></a>7.1.3 项目文件</h5><p>可用于本过程输入的项目文件包括（但不限于）：</p><ul><li><p>假设日志。假设日志记录了与技术规范、估算、进度和风险等有关的全部假设条件和制约因素。</p></li><li><p>估算依据。估算依据用于根据实际结果来评估持续时间、成本和资源估算，以及成本控制。</p></li><li><p>变更日志。变更日志包含了整个项目或阶段期间的所有变更请求的状态。</p></li><li><p>问题日志。问题日志用于确认没有未决问题。</p></li><li><p>经验教训登记册。在归入经验教训知识库之前，完成对阶段或项目经验教训的总结。</p></li><li><p>里程碑清单。里程碑清单列出了完成项目里程碑的最终日期。</p></li><li><p>项目沟通记录。项目沟通记录包含整个项目期间所有的沟通。</p></li><li><p>质量控制测量结果。质量控制测量结果记录了控制质量活动的结果，证明符合质量要求。</p></li><li><p>质量报告。质量报告的内容可包括由团队管理或需上报的全部质量保证事项、改进建议，以及在控制质量过程中发现的情况的概述。</p></li><li><p>需求文件。需求文件用于证明符合项目范围。</p></li><li><p>风险登记册。风险登记册提供了有关项目期间发生的风险的信息。</p></li><li><p>风险报告。风险报告提供了有关风险状态的信息，用于确认项目结束时没有未关闭的风险。</p></li></ul><h5 id="7-1-4-验收的可交付成果"><a href="#7-1-4-验收的可交付成果" class="headerlink" title="7.1.4 验收的可交付成果"></a>7.1.4 验收的可交付成果</h5><p>验收的可交付成果可包括批准的产品规范、交货收据和工作绩效文件。对于分阶段实施的项目或提前取消的项目，还可能包括部分完成或中间的可交付成果。</p><h5 id="7-1-5-商业文件"><a href="#7-1-5-商业文件" class="headerlink" title="7.1.5 商业文件"></a>7.1.5 商业文件</h5><p>商业文件包括（但不限于）：</p><ul><li><p>商业论证。商业论证记录了作为项目依据的商业需求和成本效益分析。</p></li><li><p>效益管理计划。效益管理计划概述了项目的目标收益。</p></li></ul><p>商业论证用于确定项目是否达到了经济可行性研究的预期结果。效益管理计划用于测量项目是否达到了计划的效益。</p><h5 id="7-1-6-协议"><a href="#7-1-6-协议" class="headerlink" title="7.1.6 协议"></a>7.1.6 协议</h5><p>通常在合同条款和条件中定义对正式关闭采购的要求，并包括在采购管理计划中。在复杂项目中，可能需要同时或先后管理多个合同。</p><h5 id="7-1-7-采购文档"><a href="#7-1-7-采购文档" class="headerlink" title="7.1.7 采购文档"></a>7.1.7 采购文档</h5><p>为关闭合同，需收集全部采购文档，并建立索引和加以归档。有关合同进度、范围、质量和成本绩效的信息，以及全部合同变更文档、支付记录和检查结果，都要归类收录。在项目结束时，应将“实际执行的”计划（图纸）或“初始编制的”文档、手册、故障排除文档和其他技术文档视为采购文件的组成部分。这些信息可用于总结经验教训，并为签署以后的合同而用作评价承包商的基础。</p><h5 id="7-1-8-组织过程资产"><a href="#7-1-8-组织过程资产" class="headerlink" title="7.1.8 组织过程资产"></a>7.1.8 组织过程资产</h5><p>能够影响结束项目或阶段过程的组织过程资产包括（但不限于）：</p><ul><li><p>项目或阶段收尾指南或要求（如经验教训、项目终期审计、项目评价、产品确认、验收标准、合同收尾、资源重新分配、团队绩效评估，以及知识传递）；</p></li><li><p>配置管理知识库，包括组织标准、政策、程序和项目文件的各种版本及基准。</p></li></ul><h4 id="7-2-结束项目或阶段：工具与技术"><a href="#7-2-结束项目或阶段：工具与技术" class="headerlink" title="7.2 结束项目或阶段：工具与技术"></a>7.2 结束项目或阶段：工具与技术</h4><h5 id="7-2-1-专家判断"><a href="#7-2-1-专家判断" class="headerlink" title="7.2.1 专家判断"></a>7.2.1 专家判断</h5><p>应该就以下主题，考虑具备相关专业知识或接受过相关培训的个人或小组的意见：</p><ul><li><p>管理控制；</p></li><li><p>审计；</p></li><li><p>法规与采购；</p></li><li><p>法律法规。</p></li></ul><h5 id="7-2-2-数据分析"><a href="#7-2-2-数据分析" class="headerlink" title="7.2.2 数据分析"></a>7.2.2 数据分析</h5><p>可用于项目收尾的数据分析技术包括（但不限于）：</p><ul><li><p>文件分析。评估现有文件有助于总结经验教训和分享知识，以改进未来项目和组织资产。</p></li><li><p>回归分析。该技术分析作用于项目结果的不同项目变量之间的相互关系，以提高未来项目的绩效。</p></li><li><p>趋势分析。趋势分析可用于确认组织所用模式的有效性，并且为了未来项目而进行相应的模式调整。</p></li><li><p>偏差分析。偏差分析可通过比较计划目标与最终结果来改进组织的测量指标。</p></li></ul><h5 id="7-2-3-会议"><a href="#7-2-3-会议" class="headerlink" title="7.2.3 会议"></a>7.2.3 会议</h5><p>会议用于确认可交付成果已通过验收，确定已达到退出标准，正式关闭合同，评估相关方满意度，收集经验教训，传递项目知识和信息，以及庆祝成功。参会者可包括项目团队成员，以及参与项目或受项目影响的其他相关方。会议可以是面对面或虚拟会议，正式或非正式会议。会议的类型包括（但不限于）：收尾报告会、客户总结会、经验教训总结会，以及庆祝会。</p><h4 id="7-3-结束项目或阶段：输出"><a href="#7-3-结束项目或阶段：输出" class="headerlink" title="7.3 结束项目或阶段：输出"></a>7.3 结束项目或阶段：输出</h4><h5 id="7-3-1-项目文件更新"><a href="#7-3-1-项目文件更新" class="headerlink" title="7.3.1 项目文件更新"></a>7.3.1 项目文件更新</h5><p>可在本过程更新所有项目文件，并标记为最终版本。特别值得注意的是，经验教训登记册的最终版本要包含阶段或项目收尾的最终信息。最终版本的经验教训登记册可包含关于以下事项的信息：效益管理、商业论证的准确性、项目和开发生命周期、风险和问题管理、相关方参与，以及其他项目管理过程。</p><h5 id="7-3-2-最终产品、服务或成果移交"><a href="#7-3-2-最终产品、服务或成果移交" class="headerlink" title="7.3.2 最终产品、服务或成果移交"></a>7.3.2 最终产品、服务或成果移交</h5><p>项目交付的产品、服务或成果可移交给另一团队或组织，并由其在整个生命周期中进行运营、维护和支持。</p><p>本输出所指的正是把项目交付的最终产品、服务或成果（对于阶段收尾，则是所在阶段的中间产品、服务或成果）从一个团队转交到另一个团队。</p><h5 id="7-3-3-最终报告"><a href="#7-3-3-最终报告" class="headerlink" title="7.3.3 最终报告"></a>7.3.3 最终报告</h5><p>用最终报告总结项目绩效，其中可包含诸如以下信息：</p><ul><li><p>项目或阶段的概述；</p></li><li><p>范围目标、范围的评估标准，以及证明达到完工标准的证据；</p></li><li><p>质量目标、项目和产品质量的评估标准、相关核实信息和实际里程碑交付日期以及偏差原因；</p></li><li><p>成本目标，包括可接受的成本区间、实际成本，以及产生任何偏差的原因；</p></li><li><p>最终产品、服务或成果的确认信息的总结；</p></li><li><p>进度计划目标包括成果是否实现项目所预期的收益。如果在项目结束时未能实现效益，则指出效益实现程度并预计未来实现情况；</p></li><li><p>关于最终产品、服务或成果如何满足商业机会所述业务需求的概述。如果在项目结束时未能满足业务需求，则指出需求满足程度并预计业务需求何时能够得到满足；</p></li><li><p>关于项目过程中发生的风险或问题及其解决情况的概述。</p></li></ul><h5 id="7-3-4-组织过程资产更新"><a href="#7-3-4-组织过程资产更新" class="headerlink" title="7.3.4 组织过程资产更新"></a>7.3.4 组织过程资产更新</h5><p>需要更新的组织过程资产包括（但不限于）：</p><ul><li><p>项目文件。在项目活动中产生的各种文件，例如项目管理计划，范围文件、成本文件、进度文件和项目日历，以及变更管理文件。</p></li><li><p>运营和支持文件。组织维护、运营和支持项目交付的产品或服务时所需的文件。可包括新生成的文件，或对已有文件的更新。</p></li><li><p>项目或阶段收尾文件。项目或阶段收尾文件包括表明项目或阶段完工的正式文件，以及用来将完成的项目或阶段可交付成果移交给他人（如运营部门或下一阶段）的正式文件。在项目收尾期间，项目经理应该回顾以往的阶段文件，确认范围过程所产生的客户验收文件，以及合同协议（如果有的话），以确保在达到全部项目要求之后才正式关闭项目。如果项目在完工前提前终止，则需要在正式的收尾文件中说明项目终止的原因，并规定正式程序，把该项目的已完成和未完成的可交付成果移交他人。</p></li><li><p>经验教训知识库。将在整个项目期间获得的经验教训和知识归入经验教训知识库，供未来项目使用。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《PMBOK第六版》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目整合管理包括对隶属于项目管理过程组的各种过程和项目管理活动进行识别、定义、组合、统一和协调的各个过程。在项目管理中，整合兼具统一、合并、沟通和建立联系的性质，这些行动应该贯穿项目始终。&lt;/p&gt;
    
    </summary>
    
      <category term="PMP抄书系列" scheme="http://www.xiaoleon.cn/categories/PMP%E6%8A%84%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="pmp" scheme="http://www.xiaoleon.cn/tags/pmp/"/>
    
  </entry>
  
  <entry>
    <title>PMP(3) 项目经理的角色</title>
    <link href="http://www.xiaoleon.cn/2019/02/02/pmp-3/"/>
    <id>http://www.xiaoleon.cn/2019/02/02/pmp-3/</id>
    <published>2019-02-02T09:43:37.000Z</published>
    <updated>2019-05-13T09:47:14.687Z</updated>
    
    <content type="html"><![CDATA[<!-- Todo --><a id="more"></a><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>项目经理在领导项目团队达成项目目标方面发挥至关重要的作用。在整个项目期间，这个角色的作用非常明显。很多项目经理从项目启动时参与项目，直到项目结束。不过，在某些组织内，项目经理可能会在项目启动之前就参与评估和分析活动。这些活动可能包括咨询管理层和业务部门领导者的想法，以推进战略目标的实现、提高组织绩效，或满足客户需求。某些组织可能还要求项目经理管理或协助项目的商业分析、商业论证的指定以及项目组合管理事宜。项目经理还可能参与后续跟进活动，以实现项目的商业效益。不同组织对项目经理的角色有不同的定义，但本质上它们的裁剪方式都一样——项目管理角色需要符合组织需求，如同项目管理过程需要符合项目需求一般。</p><p>下面将大型项目的项目经理与大型管弦乐队的指挥做比较，以帮助理解项目经理角色：</p><ul><li><p>成员与角色。大型项目和管弦乐队都包含了很多成员，每个成员都扮演着不同的角色。一个大型管弦乐队可能包括由一位指挥带领的上百位演奏者。这些演奏者需要演奏25种不同的乐器，组成了多个主要乐器组，例如弦乐器、木管乐器、铜管乐器和打击乐器。类似的，一个大型项目可能包括由一位项目经理领导的上百位项目成员。这些团队成员需要承担各种不同的角色，例如设计、制造和设施管理。与乐队的主要乐器组一样，项目团队成员也组成了多个业务部门或小组。演奏者和项目成员都会形成对应的团队。</p></li><li><p>在团队中的职责。项目经理和指挥都需要为团队的成果负责，分别是项目成果和交响音乐会。这两个领导者都需要从整体的角度看待团队产品，以便进行规划、协调和完成。首先，应审查各自组织的愿景、使命和目标，确保与产品保持一致。然后解释与成功完成产品相关的愿景、使命和目标。最后向团队沟通自己的想法，激励团队成功完成目标。</p></li><li><p>知识和技能：</p><ul><li><p>指挥不需要掌握每种乐器，但应具备音乐知识、理解和经验。指挥通过沟通领导乐队并进行规划和协调，采用乐谱和排练计划作为书面沟通形式，还通过指挥棒与其他肢体语言与团队进行实时沟通。</p></li><li><p>项目经理无需承担项目中的每个角色，但应具备项目管理知识、技术知识、理解和经验。项目经理通过沟通领导项目团队进行规划和协调。项目经理采用书面沟通（文档计划和进度），还通过会议和口头提示或非语言提示与团队进行实时沟通。</p></li></ul></li></ul><p>本章节下来的部分讨论项目经理角色的主要方面。关于这个话题有数以千计书籍和文章，但本章不涵盖全部内容，而是旨在通过概述让从业者对这个话题有个基本的认识，为深入研究文中提及的各个方面做好准备。</p><hr><h3 id="二、项目经理的定义"><a href="#二、项目经理的定义" class="headerlink" title="二、项目经理的定义"></a>二、项目经理的定义</h3><p>项目经理的角色不同于职能经理或运营经理。一般而言，职能经理专注于对某个职能领域或业务部门的管理监督。运营经理负责保证业务运营的高效性。项目经理是由执行组织委派，领导团队实现项目目标的个人。</p><hr><h3 id="三、项目经理的影响力范围"><a href="#三、项目经理的影响力范围" class="headerlink" title="三、项目经理的影响力范围"></a>三、项目经理的影响力范围</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>项目经理在其影响力范围内担任多种角色。这些角色反映了项目经理的能力，体现了项目经理这一职业的价值和作用。本章将重点讲述项目经理在图3-1所示的各种影响力范围内的角色。</p><p><img src="/images/pmp-2/3-1.png" alt="项目经理的影响力范围示例"></p><h4 id="3-2-项目"><a href="#3-2-项目" class="headerlink" title="3.2 项目"></a>3.2 项目</h4><p>项目经理领导项目团队实现项目目标和相关方的期望。项目经理利用可用资源，以平衡相互竞争的制约因素。</p><p>项目经理还充当项目发起人、团队成员与其他相关方之间的沟通者，包括提供指导和展示项目成功的愿景。项目经理使用软技能（例如人际关系技能和人员管理技能）来平衡项目相关方之间互相冲突和竞争的目标，以达成共识。这种情况下的共识指即便不100%赞同，相关方还会支持项目决定和行动。</p><p>研究表明，成功的项目经理可以持续和有效地使用某些基本技能。研究指出，在由上级和团队成员指定的项目经理中，排名前2%的项目经理之所以脱颖而出，是因为他们展现出了超凡的人际关系和沟通技能以及积极的态度。</p><p>与团队和发起人等相关方沟通的能力适用于项目的各个方面，包括（但不限于）以下各个方面：</p><ul><li><p>通过多种方法（例如口头、书面和非言语）培养完善的技能；</p></li><li><p>创建、维护和遵循沟通计划和进度计划；</p></li><li><p>不断地以可预见的方式进行沟通；</p></li><li><p>寻求了解项目相关方的沟通需求（沟通可能是某些相关方在最终产品或服务实现之前获取信息的唯一渠道）；</p></li><li><p>以简练、清晰、完整、简单、相关和经过裁剪的方式进行沟通；</p></li><li><p>包含重要的正面和负面消息；</p></li><li><p>合并反馈渠道；</p></li><li><p>人际关系技能，即通过项目经理的影响力范围拓展广泛的人际网络。这些人际网络包括正式的人际网络，例如组织架构图；但项目经理发展、维护和培养非正式人际网络更加重要。非正式人际网络包括与主题专家和具有影响力的领导者建立的个人人际关系。通过这些正式和非正式的人际网络，项目经理可以让很多人参与解决问题并探寻项目中遇到的官僚主义障碍。</p></li></ul><h4 id="3-3-组织"><a href="#3-3-组织" class="headerlink" title="3.3 组织"></a>3.3 组织</h4><p>项目经理需要积极地与其他项目经理互动。其他独立项目或同一项目集的其他项目可能会对项目造成影响，原因包括（但不限于）：</p><ul><li><p>对相同资源的需求；</p></li><li><p>资金分配的优先顺序；</p></li><li><p>可交付成果的接受和发布；</p></li><li><p>项目与组织的目的和目标的一致性。</p></li></ul><p>与其他项目经理互动有助于产生积极的影响，以满足项目的各种需求。这些需求可能是团队为完成项目而需要的人力、技术或财力资源和可交付成果。项目经理需要寻求各种方法来培养人际关系，从而帮助团队实现项目目的和目标。</p><p>此外，项目经理在组织内扮演强有力的倡导者的角色。在项目过程中，项目经理积极地与组织中的各位经理互动。此外，项目经理应与项目发起人合作处理内部的政治和战略问题，这些问题可能会影响团队或项目的可行性或质量。</p><p>项目经理可以致力于提高自己在组织内的总体项目管理能力和技能，并参与隐性和显性知识的转移或整合计划。项目经理还应致力于：</p><ul><li><p>展现项目管理的价值；</p></li><li><p>提高组织对项目管理的接受度；</p></li><li><p>提高组织内现有PMO的效率。</p></li></ul><p>基于组织结构，项目经理可能向职能经理报告。而在其他情况下，项目经理可能与其他项目经理一起，向PMO、项目组合或项目集经理报告。项目组合或项目集经理对整个组织范围内的一个或多个项目承担最终责任。为了实现项目目标，项目经理需要与所有相关经历紧密合作，确保项目管理计划符合所在项目组合或项目集的计划。项目经理还需与其他角色紧密合作，如组织经理、主题专家以及商业分析人员。在某些情况下，项目经理可以是临时管理角色的外部顾问。</p><h4 id="3-4-行业"><a href="#3-4-行业" class="headerlink" title="3.4 行业"></a>3.4 行业</h4><p>项目经理应时刻关注行业的最新发展趋势，获得并思考这一信息对当前项目是否有影响或可用。这些趋势包括（但不限于）：</p><ul><li><p>产品和技术开发；</p></li><li><p>新且正在变化的市场空间；</p></li><li><p>标准（例如项目管理标准、质量管理标准、信息安全管理标准）；</p></li><li><p>技术支持工具；</p></li><li><p>影响当前项目的经济力量；</p></li><li><p>影响项目管理学科的影响力；</p></li><li><p>过程改进和可持续发展战略。</p></li></ul><h4 id="3-5-专业学科"><a href="#3-5-专业学科" class="headerlink" title="3.5 专业学科"></a>3.5 专业学科</h4><p>对项目经理而言，持续的知识传递和整合非常重要。项目管理专业和项目经理担任主题专家的其他领域都在持续推进相应的专业发展。知识传递和整合包括（但不限于）：</p><ul><li><p>在当地、全国和全球层面（例如实践社区、国际组织）向其他专业人员分享知识和专业技能；</p></li><li><p>参与培训、继续教育和发展：</p><ul><li><p>项目管理专业（例如大学、PMI）；</p></li><li><p>相关专业（例如系统工程、配置管理）；</p></li><li><p>其他专业（例如信息技术、航空航天）。</p></li></ul></li></ul><h4 id="3-6-跨领域"><a href="#3-6-跨领域" class="headerlink" title="3.6 跨领域"></a>3.6 跨领域</h4><p>专业的项目经理针对组织的价值可以选择指导和教育其他专业人员项目管理方法。项目经理还可以担任非正式的宣传大使，让组织了解项目管理在及时性、质量、创新和资源管理方面的优势。</p><hr><h3 id="四、项目经理的能力"><a href="#四、项目经理的能力" class="headerlink" title="四、项目经理的能力"></a>四、项目经理的能力</h3><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>近期的PMI研究通过PMI人才三角指出了项目经理根据《项目经理能力发展（PMCD）框架》需要具备的技能。人才三角重点关注三个关键技能组合：</p><ul><li><p>技术项目管理。与项目、项目集和项目组合管理特定领域相关的知识、技能和行为，即角色履行的技术方面。</p></li><li><p>领导力。指导、激励和带领团队所需的知识、技能和行为，可帮助组织达成业务目标。</p></li><li><p>战略和商务管理。关于行业和组织的知识和专业技能，有助于提高绩效并取得更好的业务成果。</p></li></ul><p><img src="/images/pmp-3/3-2.png" alt="PMI人才三角"></p><p>虽然技术项目管理技能是项目集和项目管理的核心，但PMI研究指出，当今全球市场越来越复杂，竞争也越来越激烈，只有技术项目管理技能是不够的。各个组织正在寻求其他有关领导力和商业智慧技能。来自不同组织的成员均提出，这些能力可以有助于支持更长远的战略目标，以实现赢利。为发挥最大的效果，项目经理需要平衡这三种技能。</p><h4 id="4-2-技术项目管理技能"><a href="#4-2-技术项目管理技能" class="headerlink" title="4.2 技术项目管理技能"></a>4.2 技术项目管理技能</h4><p>技术项目管理技能指有效运用项目管理知识实现项目集或项目的预期成果的能力。有很多技术项目管理技能。本指南的知识领域部分描述了很多必要的项目管理技能。项目经理经常会依赖专家判断来有效开展工作。要获得成功，重要的是项目经理必须了解个人专长以及如何找到具备所需专业知识的人员。</p><p>研究表明，顶尖的项目经理会持续展现出几种关键技能，包括（但不限于）：</p><ul><li><p>重点关注所管理的各个项目的关键技术项目管理要素。简单来说就是随时准备好合适的资料。最主要的是：</p><ul><li><p>项目成功的关键因素；</p></li><li><p>进度；</p></li><li><p>指定的财务报告；</p></li><li><p>问题日志。</p></li></ul></li><li><p>针对每个项目裁剪传统和敏捷工具、技术和方法。</p></li><li><p>花时间制定完整的计划并谨慎排定优先顺序。</p></li><li><p>管理项目要素，包括（但不限于）进度、成本、资源和风险。</p></li></ul><h4 id="4-3-战略和商务管理技能"><a href="#4-3-战略和商务管理技能" class="headerlink" title="4.3 战略和商务管理技能"></a>4.3 战略和商务管理技能</h4><p>战略和商务管理技能包括纵览组织概况并有效协商和执行有利于战略调整和创新的决策和行动的能力。这项能力可能涉及其他职能部门的工作知识，例如财务部、市场部和运营部。战略和商务管理技能可能还包括发展和运用相关的产品和行业专业知识。这种业务知识也被称为领域知识。项目经理应掌握足够的业务知识，以：</p><ul><li><p>向其他人解释关于项目的必要商业信息；</p></li><li><p>与项目发起人、团队和主题专家合作制定合适的项目交付策略；</p></li><li><p>以实现项目商业价值最大化的方式执行策略。</p></li></ul><p>为制定关于项目成功交付的最佳决策，项目经理应咨询具备关于组织运营的专业知识的运营经理。这些经历应了解组织的工作以及项目计划会对工作造成的影响。对项目经理而言，对项目主题的了解越多越好，至少应能够向其他人说明关于组织的以下方面：</p><ul><li><p>战略；</p></li><li><p>使命；</p></li><li><p>目的和目标；</p></li><li><p>产品和服务；</p></li><li><p>运营（例如位置、类型、技术）；</p></li><li><p>市场和市场条件，例如客户、市场状况（发展或萎缩）和上市时间因素等；</p></li><li><p>竞争（例如什么、谁、市场地位）。</p></li></ul><p>为确保一致性，项目经理应将以下关于组织的知识和信息运用到项目中：</p><ul><li><p>战略；</p></li><li><p>使命；</p></li><li><p>目的和目标；</p></li><li><p>优先级；</p></li><li><p>策略；</p></li><li><p>产品或服务（例如可交付成果）。</p></li></ul><p>战略和商业技能有助于项目经理确定应为其项目考虑哪些商业因素。项目经理应确定这些商业和战略因素会对项目造成的影响，同时了解项目与组织之间的相互关系。这些因素包括（但不限于）：</p><ul><li><p>风险和问题；</p></li><li><p>财务影响；</p></li><li><p>成本效益分析（例如净现值、投资回报率），包括各种可选方案；</p></li><li><p>商业价值；</p></li><li><p>效益预期实现情况和战略；</p></li><li><p>范围、预算、进度和质量。</p></li></ul><p>通过运用这些商务知识，项目经理能够为项目提出合适的决策和建议。随着条件的变化，项目经理应与项目发起人持续合作，使业务战略和项目策略保持一致。</p><h4 id="4-4-领导力技能"><a href="#4-4-领导力技能" class="headerlink" title="4.4 领导力技能"></a>4.4 领导力技能</h4><p>领导力技能包括指导、激励和带领团队的能力。这些技能可能包括协商、抗压、沟通、解决问题、批判性思考和人际关系技能等基本能力。随着越来越多的公司通过项目执行战略，项目变得越来越复杂。项目管理不仅仅涉及数字、模板、图表、图形和计算机系统方面的工作。人是所有项目中的共同点。人可以计数，但不仅仅是数字。</p><h5 id="4-4-1-人际交往"><a href="#4-4-1-人际交往" class="headerlink" title="4.4.1 人际交往"></a>4.4.1 人际交往</h5><p>人际交往占据项目经理工作的很大一部分。项目经理应研究人的行为和动机，应尽力成为一个好的领导者，因为领导力对组织项目是否成功至关重要。项目经理需要运用领导力技能和品质与所有项目相关方合作，包括项目团队、团队指导和项目发起人。</p><h5 id="4-4-2-领导者的品质和技能"><a href="#4-4-2-领导者的品质和技能" class="headerlink" title="4.4.2 领导者的品质和技能"></a>4.4.2 领导者的品质和技能</h5><p>研究显示，领导者的品质和技能包括（但不限于）：</p><ul><li><p>有远见（例如帮助描述项目的产品、目的和目标；能够有梦想并向他人诠释愿景）；</p></li><li><p>积极乐观；</p></li><li><p>乐于合作；</p></li><li><p>通过以下方式管理关系和冲突：</p><ul><li><p>建立信任；</p></li><li><p>解决顾虑；</p></li><li><p>寻求共识；</p></li><li><p>平衡相互竞争和对立的目标；</p></li><li><p>运用说服、协商、拖鞋和解决冲突的技能；</p></li><li><p>发展和培养个人及专业网络；</p></li><li><p>以长远的眼光来看待人际关系是与项目同样重要；</p></li><li><p>持续发展和运用政治敏锐性。</p></li></ul></li><li><p>通过以下方式进行沟通：</p><ul><li><p>花大量的时间沟通（研究显示，顶尖的项目经理投入有90%左右的时间是花在沟通上）；</p></li><li><p>管理期望；</p></li><li><p>诚恳地接受反馈；</p></li><li><p>提出建设性的反馈；</p></li><li><p>询问和倾听。</p></li></ul></li><li><p>尊重他人（帮助他人保持独立自主）、谦恭有礼、友善待人、诚实可信、忠诚可靠、遵守职业道德；</p></li><li><p>展现出诚实正直和文化敏感性，果断、勇敢，能够解决问题；</p></li><li><p>适当时称赞他人；</p></li><li><p>终身学习，以结果和行动为导向；</p></li><li><p>关注重要的事情，包括：</p><ul><li><p>通过必要的审查和调整，持续优化工作；</p></li><li><p>寻求并采用适用于团队和项目的优先级排序方法；</p></li><li><p>区分高层级战略优先级，尤其是与项目成功的关键因素相关的事项；</p></li><li><p>对项目的主要制约因素保持警惕；</p></li><li><p>在战术优先级上保持灵活；</p></li><li><p>能够从大量信息中筛选出最重要的信息。</p></li></ul></li><li><p>以整体和系统的角度来看待项目，同等对待内部和外部因素；</p></li><li><p>能够运用批判性思维（例如运用分析方法来制定决策）并将自己视为变革推动者。</p></li><li><p>能够创建高效的团队、以服务为导向、展现出幽默的一面，与团队成员有效地分享乐趣。</p></li></ul><h5 id="4-4-3-权术、权力和办好事情"><a href="#4-4-3-权术、权力和办好事情" class="headerlink" title="4.4.3 权术、权力和办好事情"></a>4.4.3 权术、权力和办好事情</h5><p>领导和管理的最终目的是办好事情。这些技能和品质有助于项目经理实现项目目的和目标。很多技能和品质归根究底就是处理政治的能力。政治涉及影响、谈判、自主和权力。</p><p>政治及其相关要素不局限于“好”与“不好”以及“正面”与“负面”之分。项目经理对组织运行方式的了解越多，就越有可能获得成功。项目经理应观察并收集有关项目和组织概况的数据，然后从项目、相关人员、组织以及整个环境出发来审查这些数据，从而得出计划和执行大多数行动所需的信息和知识。这些行动是项目经理运用适当地权力影响他人和进行协商之后的成果。有了权力就有了职责，项目经理应体察并尊重他人。项目经理的有效行动保持相关人员的独立自主。项目经理的行动成果就是让合适的人执行必要的活动来实现项目目标。</p><p>权力可能体现个人或组织的特征。人们对领导者的认知通常是因为权力；因此，项目经理应注意自己与他人的关系是非常重要的。借助人际关系可以让项目相关事项得以落实。行使权力的方式有很多，项目经理可自行决定。由于权力的性质以及影响项目的各种因素，权利及其运用变得非常复杂。行使权力的方式包括（但不限于）：</p><ul><li><p>地位（有时称为正式的、权威的、合法的，例如组织或团队授予的正式职位）；</p></li><li><p>信息（例如收集或分发的控制）；</p></li><li><p>参考（例如因为他人的尊重和赞赏，获得的信任）；</p></li><li><p>情境（例如在危机等特殊情况下获得的权力）；</p></li><li><p>个性或魅力（例如魅力、吸引力）；</p></li><li><p>关系（例如参与人际交往、联系或结盟）；</p></li><li><p>专家（例如拥有的技能和信息、经验、培训、教育、证书）；</p></li><li><p>奖励相关的（例如能够给予表扬、金钱或其他奖励）；</p></li><li><p>处罚或强制力（例如给予纪律处分或施加负面后果的能力）；</p></li><li><p>迎合（例如运用顺从或其他常用手段赢得青睐或合作）；</p></li><li><p>施加压力（例如限制选择或活动自由，以符合预期的行动）；</p></li><li><p>出于愧疚（例如能够提供论据，使他人执行预期的行动方案）；</p></li><li><p>说服力（例如能够提供论据，使他人执行预期的行动方案）；</p></li><li><p>回避（例如拒绝参与）。</p></li></ul><p>在权利方面，顶尖的项目经理积极主动且目的明确。这些项目经理会在组织政策、协议和程序许可的范围内主动寻求所需的权力和职权，而不是坐等组织授权。</p><h4 id="4-5-领导力和管理之比较"><a href="#4-5-领导力和管理之比较" class="headerlink" title="4.5 领导力和管理之比较"></a>4.5 领导力和管理之比较</h4><p>“领导力”和“管理”这两个词经常被互换使用，但它们并不是同义词。“管理”更接近于运用一系列已知的预期行为指示另一个人从一个位置到另一个位置。相反，“领导力”指通过讨论或辩论与他人合作，带领他们从一个位置到另一个位置。</p><p>项目经理所选择的方法体现了他们在行为、自我认知和项目角色方面的显著差异。表3-1从几个重要的层面对管理和领导力进行比较。</p><p>未获得成功，项目经理必须同时采用领导力和管理这两种方式。技巧在于如何针对各种情况找到恰当的平衡点。项目经理的领导风格通常体现了他们所采用的管理和领导力方式。</p><p><img src="/images/pmp-3/表3-1.png" alt="团队管理与团队领导力之比较"></p><h5 id="4-5-1-领导力风格"><a href="#4-5-1-领导力风格" class="headerlink" title="4.5.1 领导力风格"></a>4.5.1 领导力风格</h5><p>项目经理领导团队的方式可以分为很多种。项目经理可能会出于个人偏好或在综合考虑了与项目有关的多个因素之后选择领导力风格。根据作用因素的不同，项目经理可能会改变风格。要考虑的主要因素包括（但不限于）：</p><ul><li><p>领导者的特点（例如态度、心情、需求、价值观、道德观）；</p></li><li><p>团队成员的特点（例如态度、心情、需求、价值观、道德观）；</p></li><li><p>组织的特点（例如目标、结构、工作类型）；</p></li><li><p>环境特点（例如社会形势、经济状况和政治因素）。</p></li></ul><p>研究显示项目经理可以采用多种领导力风格。在这些风格中，最常见的包括（但不限于）：</p><ul><li><p>放任型领导（例如，允许团队自主决策和设定目标，又被称为“无为而治”）；</p></li><li><p>交易型领导（例如，关注目标、反馈和成就以确定奖励，例如管理）；</p></li><li><p>服务型领导（例如，做出服务承诺，处处先为他人着想；关注他人的成长、学习、发展、自主性和福祉；关注人际关系、团体与合作；服务优先于领导）；</p></li><li><p>变革型领导（例如，通过理想化特质和行为、鼓舞型激励、促进创新和创造，以及个人关怀提高追随者的能力）；</p></li><li><p>魅力型领导（例如，能够激励他人；精神饱满、热情洋溢、充满自信；说服力强）；</p></li><li><p>交互性领导（例如，结合了交易型、变革型和魅力型的特点）。</p></li></ul><h5 id="4-5-2-个性"><a href="#4-5-2-个性" class="headerlink" title="4.5.2 个性"></a>4.5.2 个性</h5><p>个性指人与人之间在思维、情感和行为的特征模式方面的差异。个人性格特点或特征可能包括（但不限于）：</p><ul><li><p>真诚（例如，接受他人不同的个性，表现出包容的态度）；</p></li><li><p>谦恭（例如，能够举止得体、有礼貌）；</p></li><li><p>创造力（例如，抽象思维、不同看法、创新的能力）；</p></li><li><p>文化（例如，具备对其他文化的敏感性，包括价值观、规范和信仰）；</p></li><li><p>情绪（例如，能够感知情绪及其包含的信息并管理情绪，衡量人际关系技能）；</p></li><li><p>智力（例如，以多元智能理论衡量的人的智商）；</p></li><li><p>管理（例如，管理实践和潜力的衡量）；</p></li><li><p>政治（例如，政治智商和把事办好的衡量）；</p></li><li><p>以服务为导向（例如，展现出愿意服务他人的态度）；</p></li><li><p>社会（例如，能够理解和管理他人）；</p></li><li><p>系统化（例如，了解和构建系统的驱动力）。</p></li></ul><p>高效的项目经理在上述各个方面都具备一定程度的能力。每个项目、组织和情况都要求项目经理重视个性的不同方面。</p><p>–</p><h3 id="五、执行整合"><a href="#五、执行整合" class="headerlink" title="五、执行整合"></a>五、执行整合</h3><p>执行项目整合时，项目经理承担双重角色：</p><ul><li><p>项目经理扮演重要角色，与项目发起人携手合作，既要了解战略目标并确保项目目标和成果与项目组合、项目集以及业务领域保持一致。项目经理以这种方式有助于项目的整合与执行。</p></li><li><p>在项目层面上，项目经理负责指导团队关注真正重要的事务并协同工作。为此，项目经理需要整合过程、知识和人员。</p></li></ul><p>整合是项目经理的一项关键技能。本指南的项目整合管理知识领域对整合更深入地进行了探讨。</p><h4 id="5-1-在过程层面上执行整合"><a href="#5-1-在过程层面上执行整合" class="headerlink" title="5.1 在过程层面上执行整合"></a>5.1 在过程层面上执行整合</h4><p>项目管理可被看作为实现项目目标而采取的一系列过程和活动。有些过程可能只发生一次（例如项目章程的初始创建），但很多过程在整个项目期间会相互重叠并重复发生多次。这种重叠和多次出现的过程，比如需求变更，它会影响范围、进度或预算，并需要提出变更请求。控制范围过程和实施整体变更控制等若干项目管理过程可包括变更请求。在整个项目期间实施整体变更控制过程是为了整合变更请求。</p><p>虽然对项目过程的整合方式没有明确的定义，但如果项目经理无法整合相互作用的项目过程，那么实现项目目标的机会将会很小。</p><h5 id="5-2-认知层面的整合"><a href="#5-2-认知层面的整合" class="headerlink" title="5.2 认知层面的整合"></a>5.2 认知层面的整合</h5><p>管理项目的方法有很多，而方法的选择通常取决于项目的具体特点，包括规模、项目或组织的复杂性，以及执行组织的文化。显然，项目经理的人际关系技能和能力与其管理项目的方式有紧密的关系。</p><p>项目经理应尽量掌握所有项目管理知识领域。熟练掌握这些知识领域之后，项目经理可以将经验、见解、领导力、技术以及商业管理技能运用到项目管理中。最后，项目经理需要整合这些知识领域所涵盖的过程才有可能实现预期的项目结果。</p><h5 id="5-3-背景层面的整合"><a href="#5-3-背景层面的整合" class="headerlink" title="5.3 背景层面的整合"></a>5.3 背景层面的整合</h5><p>与几十年前相比，当今企业和项目所处的环境有了很大的变化。新技术不断涌现。社交网络、多元文化、虚拟团队和新的价值观都是项目所要面临的全新现实。整合涉及多个组织的、大规模、跨职能项目实施中的知识和人员便是一例。项目经理在指导项目团队进行沟通规划和知识管理时需要考虑这个背景所产生的影响。</p><p>在管理整合时，项目经理需要意识到项目背景和这些新因素，然后项目经理可以决定如何在项目中最好地利用这些新环境因素，以获得项目成功。</p><h5 id="5-4-整合与复杂性"><a href="#5-4-整合与复杂性" class="headerlink" title="5.4 整合与复杂性"></a>5.4 整合与复杂性</h5><p>有些项目可能非常复杂，难以管理。简单来说，“复杂”一词通常被用来描述难以理解或错综复杂的事物。</p><p>项目的复杂性来源于组织的系统行为、人类行为以及组织或环境中的不确定性。《项目复杂性管理：实践指南》将复杂性的三个维度定义为：</p><ul><li><p>系统行为。组成部分与系统之间的依赖关系。</p></li><li><p>人类行为。不同个体和群体之间的相互作用。</p></li><li><p>不明确性。出现问题、缺乏理解或造成困惑引发的不确定性。</p></li></ul><p>复杂性本身指个体基于自身经验、观察和技能的一种感知，更准确的描述应该是项目包含复杂性的要素，而不是项目本身复杂。项目组合、项目集和项目可能包含复杂性的要素。</p><p>项目整合之前，项目经理应考虑项目内外的要素。项目经理应检查项目的特征或属性。作为项目的一种特征或属性，复杂性通常被定义为：</p><ul><li><p>包含多个部分；</p></li><li><p>不同部分之间存在一系列连接；</p></li><li><p>不同部分之间有动态交互作用；</p></li><li><p>这些交互作用所产生的行为远远大于各部分简单的相加（例如突发性行为）。</p></li></ul><p>这些因素会增加项目的复杂性，通过检查，有助于项目经理在规划、管理和控制项目时可以识别关键领域，确保完成整合。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《PMBOK第六版》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- Todo --&gt;
    
    </summary>
    
      <category term="PMP抄书系列" scheme="http://www.xiaoleon.cn/categories/PMP%E6%8A%84%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="pmp" scheme="http://www.xiaoleon.cn/tags/pmp/"/>
    
  </entry>
  
  <entry>
    <title>PMP(2) 项目运行环境</title>
    <link href="http://www.xiaoleon.cn/2019/02/01/pmp-2/"/>
    <id>http://www.xiaoleon.cn/2019/02/01/pmp-2/</id>
    <published>2019-02-01T14:54:47.000Z</published>
    <updated>2019-05-13T09:47:04.923Z</updated>
    
    <content type="html"><![CDATA[<!-- Todo --><a id="more"></a><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>项目所处的环境可能对项目的开展产生有利或不利的影响。这些影响的两大主要来源为事业环境因素（EEF）和组织过程资产（OPA）。</p><p>事业环境因素源于项目外部（往往是企业外部）的环境，事业环境因素可能对整个企业、项目组合、项目集或项目产生影响。</p><p>组织过程资产源于企业内部，可能来自企业自身、项目组合、项目集、其他项目或这些的组合。图2-1分解了事业环境因素和组织过程资产所涵盖的项目影响。</p><p><img src="/images/pmp-2/2-1.png" alt="项目影响"></p><p>除了事业环境因素和组织过程资产，组织系统对项目生命周期也起着重要的作用。组织系统进一步讨论了影响了组织系统内部人员的权力、影响力、利益、技能和政治能力的系统因素。</p><hr><h3 id="二、事业环境因素"><a href="#二、事业环境因素" class="headerlink" title="二、事业环境因素"></a>二、事业环境因素</h3><p>事业环境因素（EEFs）是指项目团队不能控制的，将对项目产生影响、限制或指令作用的各种条件。这些条件可能来自于组织的内部和（或）外部。事业环境因素是很多项目管理过程，尤其是大多数规划过程的输入。这些因素可能会提高或限制项目管理的灵活性，并可能对项目结果产生积极或消极的影响。</p><p>从性质或类型上讲，事业环境因素是多种多样的。有效开展项目，就必须考虑这些因素。事业环境因素包括（但不限于）如下所描述的因素。</p><h4 id="2-1-组织内部的事业环境因素"><a href="#2-1-组织内部的事业环境因素" class="headerlink" title="2.1 组织内部的事业环境因素"></a>2.1 组织内部的事业环境因素</h4><p>以下是组织内部的事业环境因素：</p><ul><li><p>组织文化、结构和治理。例如包括愿景、使命、价值观、信念、文化规范、领导风格、等级制度和职权关系、组织风格、道德和行为规范。</p></li><li><p>设施和资源的地理分布。例如包括工厂位置、虚拟团队、共享系统和云计算。</p></li><li><p>信息技术软件。例如包括进度计划软件工具、配置管理系统、进入其他在线自动化系统的网络界面和工作授权系统。</p></li><li><p>资源可用性。例如包括合同和采购制约因素、获得批准的供应商和分包商以及合作协议。</p></li><li><p>员工能力。例如包括现有人力资源的专业知识、技能、能力和特定知识。</p></li></ul><h4 id="2-2-组织外部的事业环境因素"><a href="#2-2-组织外部的事业环境因素" class="headerlink" title="2.2 组织外部的事业环境因素"></a>2.2 组织外部的事业环境因素</h4><p>以下是组织外部的事业环境因素：</p><ul><li><p>市场条件。例如包括竞争对手、市场份额、品牌认知度和商标。</p></li><li><p>社会和文化影响与问题。例如包括政治氛围、行为规范、道德和观念。</p></li><li><p>法律限制。例如包括与安全、数据保护、商业行为、雇佣和采购有关的国家或地方法律法规。</p></li><li><p>商业数据库。例如包括标杆对照成果、标准化的成本估算数据、行业风险研究资料和风险数据库。</p></li><li><p>学术研究。例如包括行业研究、出版物和标杆对照成果。</p></li><li><p>政府或行业标准。例如包括与产品、生产、环境、质量和工艺有关的监管机构条例和标准。</p></li><li><p>财务考虑因素。例如包括货币汇率、利率、通货膨胀率、关税和地理位置。</p></li><li><p>物理环境要素。例如包括工作环境、天气和制约因素。</p></li></ul><hr><h3 id="三、组织过程资产"><a href="#三、组织过程资产" class="headerlink" title="三、组织过程资产"></a>三、组织过程资产</h3><p>组织过程资产是执行组织所特有并使用的计划、过程、政策、程序和知识库，会影响对具体项目的管理。</p><p>组织过程资产包括来自任何（或所有）项目执行组织的，可用于执行或治理项目的任何工件、实践或知识，还包括来自组织以往项目的经验教训和历史信息。组织过程资产可能还包括完成的进度计划、风险数据和挣值数据。组织过程资产是许多项目管理过程的输入。由于组织过程资产存在于组织内部，在整个项目期间，项目团队成员可对组织过程资产进行必要的更新和增补。组织过程资产可分成以下两大类：</p><ul><li><p>过程、政策和程序；</p></li><li><p>组织知识库。</p></li></ul><p>第一类资产的更新通常不是项目工作的一部分，而是由项目管理办公室（PMO）或项目以外的其他职能部门完成。更新工作仅须遵循与过程、政策和程序更新相关的组织政策。有些组织鼓励团队裁剪项目的模版、生命周期和核对单。在这种情况下，项目管理团队应根据项目需求裁剪这些资产。</p><p>第二类资产是在整个项目期间结合项目信息而更新的。例如，整个项目期间会持续更新与财务绩效、经济教训、绩效指标和问题以及缺陷相关的信息。</p><h4 id="3-1-过程、政策和程序"><a href="#3-1-过程、政策和程序" class="headerlink" title="3.1 过程、政策和程序"></a>3.1 过程、政策和程序</h4><p>组织用于执行项目工作的流程与程序，包括（但不限于）：</p><ul><li><p>启动和规划</p><ul><li><p>指南和标准，用于裁剪组织标准流程和程序以满足项目的特定要求；</p></li><li><p>特定的组织标准，例如政策（如人力资源政策、健康与安全政策、安保与保密政策、质量政策、采购政策和环境政策）；</p></li><li><p>产品和项目生命周期，以及方法和程序（如项目管理方法、评估指标、过程审计、改进目标、核对单、组织内使用的标准化的过程定义）；</p></li><li><p>模板（如项目管理计划、项目文件、项目登记册、报告格式、合同模板、风险分类、风险描述模板、概率与影响的定义、概率和影响矩阵、以及相关方登记册模板）；</p></li><li><p>预先批准的供应商清单和各种合同协议类型（如总价合同、成本补偿合同和工料合同）。</p></li></ul></li><li><p>执行、监控</p><ul><li><p>变更控制程序，包括修改组织标准、政策、计划和程序（或任何项目文件）所须遵循的步骤，以及如何批准和确认变更；</p></li><li><p>跟踪矩阵；</p></li><li><p>财务控制程序（如定期报告、必须的费用与支付审查、会计编码及标准合同条款等）；</p></li><li><p>问题与缺陷管理程序（如定义问题和缺陷控制、识别与解决问题和缺陷，以及跟踪行动方案）；</p></li><li><p>资源的可用性控制和分配管理；</p></li><li><p>组织对沟通的要求（如可用的沟通技术、许可的沟通媒介、记录保存政策、视频会议、协同工具和安全要求）；</p></li><li><p>确定工作优先顺序、批准工作与签发工作授权的程序；</p></li><li><p>模板（如风险登记册、问题日志和变更日志）；</p></li><li><p>标准化的指南、工作指示、建议书评价准则和绩效测量准则；</p></li><li><p>产品、服务或成果的核实和确认程序。</p></li></ul></li><li><p>收尾</p><p>  项目收尾指南或要求（如项目终期审计、项目评价、可交付成果验收、合同收尾、资源分配，以及向生产和（或）运营部门转移知识）。</p></li></ul><h4 id="3-2-组织知识库"><a href="#3-2-组织知识库" class="headerlink" title="3.2 组织知识库"></a>3.2 组织知识库</h4><p>组织用来存取信息的知识库，包括（但不限于）：</p><ul><li><p>配置管理知识库，包括软件和硬件组件版本以及所有执行组织的标准、政策、程序和任何项目文件的基准；</p></li><li><p>财务数据库，包括人工时、实际成本、预算和成本超支等方面的信息；</p></li><li><p>历史信息与经验教训知识库（如项目记录与文件、完整的项目收尾信息与文件、关于以往项目选择决策的结果及以往项目绩效的信息，以及从风险管理活动中获取的信息）；</p></li><li><p>问题与缺陷管理数据库，包括问题与缺陷的状态、控制信息、解决方案以及相关行动的结果；</p></li><li><p>测量指标数据库，用来收集与提供过程和产品的测量数据；</p></li><li><p>以往项目的项目档案（如范围、成本、进度与绩效测量基准，项目日历，项目进度网络图，风险登记册，风险报告以及相关方登记册）。</p></li></ul><hr><h3 id="四、组织系统"><a href="#四、组织系统" class="headerlink" title="四、组织系统"></a>四、组织系统</h3><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>运行项目时需要应对组织结构和治理框架带来的制约因素。为有效且高效地开展项目，项目经理需要了解组织内的职责、终责和职权的分配情况。这有助于项目经理有效地利用其权力、影响力、能力、领导力和政治能力成功完成项目。</p><p>单个组织内多种因素的交互影响创造出一个独特的系统，会对在该系统内运行的项目造成影响。这种组织系统决定了组织系统内部人员的权力、影响力、利益、能力和政治能力。系统因素包括（但不限于）：</p><ul><li><p>管理要素；</p></li><li><p>治理框架；</p></li><li><p>组织结构类型。</p></li></ul><p>组织系统因素的完整信息和说明，以及这些因素组合对项目的影响方式并不在本指南范围之内。本指南并不像有些与文献、方法论和实践相关的学科那样深入地探索这些因素，只是在本节概述了这些因素及其相互关系。</p><p>本概述先简要介绍一下系统。系统是各种组件的集合，可以实现单个组件无法实现的成果。组件是项目货组织内的可识别要素，提供了某种特定功能或一组相关的功能。各种系统组件的相互作用创造出组织文化和能力。以下是关于系统的几个原则：</p><ul><li><p>系统是动态的；</p></li><li><p>系统是可以优化；</p></li><li><p>系统组件是可以优化；</p></li><li><p>系统及其组件不能同时优化；</p></li><li><p>系统呈现非线性响应（输入的变更并不会产生可预测的输出）。</p></li></ul><p>系统内部以及系统与其环境之间可能会发生多个变更。出现这些变更时，各组件内部发生的适应性行为反过来会增加系统的动态特性。这种特性取决于组件之间的联系和依赖关系的相互作用。</p><p>系统通常由组织管理层负责。组织管理层检查组件与系统之间的优化权衡，以便采取合适的措施为组织实现最佳结果。这一检查工作的结果将对相应的项目造成影响。因此，项目经理在确定如何达成项目目标时务必要考虑这些结果。此外，项目经理应考虑到组织的治理框架。</p><h4 id="4-2-组织治理框架"><a href="#4-2-组织治理框架" class="headerlink" title="4.2 组织治理框架"></a>4.2 组织治理框架</h4><p>近期的PMI研究指出，治理指组织各个层面的有组织的或有结构的安排，旨在确定和影响组织成员的行为。研究结果表明，治理是一个多方面概念，并且：</p><ul><li><p>包括考虑人员、角色、结构和政策；</p></li><li><p>要求通过数据和反馈提供指导和监督。</p></li></ul><h5 id="4-2-1-治理框架"><a href="#4-2-1-治理框架" class="headerlink" title="4.2.1 治理框架"></a>4.2.1 治理框架</h5><p>治理是在组织内行使职权的框架，其包括（但不限于）：</p><ul><li><p>规则；</p></li><li><p>政策；</p></li><li><p>程序；</p></li><li><p>规范；</p></li><li><p>关系；</p></li><li><p>系统；</p></li><li><p>过程。</p></li></ul><p>这个框架会影响：</p><ul><li><p>组织目标的设定和实现方式；</p></li><li><p>风险监控和评估方式；</p></li><li><p>绩效优化方式；</p></li></ul><h5 id="4-2-2-项目组合、项目集和项目治理"><a href="#4-2-2-项目组合、项目集和项目治理" class="headerlink" title="4.2.2 项目组合、项目集和项目治理"></a>4.2.2 项目组合、项目集和项目治理</h5><p>《项目组合、项目集和项目治理：实践指南》描述了协调组织级项目管理（OPM）与项目组合、项目集和项目管理的常见治理框架，涉及四个治理领域：一致性、风险、绩效和沟通。各个领域都具备以下职能部门：监督、控制、整合与决策。各个职能部门都可针对独立项目或项目组合/项目集中的项目的支持过程与活动进行治理。</p><p>项目治理是指用于指导项目管理活动的框架、功能和过程，从而创造独特的产品、服务或结果以满足组织、战略和运营目标。不存在一种治理框架适用于所有组织。组织应根据组织文化、项目类型和组织需求裁剪治理框架，才能发挥其作用。</p><p>关于项目治理及其实施的更多信息，请参见《项目组合、项目集和项目治理：实践指南》。</p><h4 id="4-3-管理要素"><a href="#4-3-管理要素" class="headerlink" title="4.3 管理要素"></a>4.3 管理要素</h4><p>管理要素指组织内部关键职能部门或一般管理原则的组成部分。组织根据其选择的治理框架和组织结构类型分配一般管理要素。</p><p>关键职能部门或一般管理原则包括（但不限于）：</p><ul><li><p>基于专业技能和可用性开展工作的部门；</p></li><li><p>组织授予的工作职权；</p></li><li><p>工作职责，开展组织根据技能和经验等属性合理分派的工作任务；</p></li><li><p>具有纪律性的行为（例如尊重职权、人员和规定）；</p></li><li><p>统一指挥原则（例如一位员工仅接受一个上级对任何行动或活动给出的指示）；</p></li><li><p>统一领导原则（例如针对一组活动只能有一个计划或一个领导人，以及相同的目标）；</p></li><li><p>组织的总体目标优先于个人目标；</p></li><li><p>支付合理的薪酬；</p></li><li><p>资源的优化使用；</p></li><li><p>畅通的沟通渠道；</p></li><li><p>在正确的时间让正确的人使用正确的材料做正确的事情；</p></li><li><p>公正、平等地对待所有员工；</p></li><li><p>明确工作岗位的安全职责；</p></li><li><p>明确员工安全；</p></li><li><p>允许任何员工参与计划和实施；</p></li><li><p>保持员工士气。</p></li></ul><p>组织将这些管理要素的绩效分派到选定的员工身上。这些员工可能在不同的组织层级上执行上述职能。例如，组织的层级结构有平级和上下级的关系。从基层到高层，这些管理层级关系多种多样。分配到各个层级的职责、终责和职权表明了各个层级的员工在组织结构内执行上述职能的方式。</p><h4 id="4-4-组织结构类型"><a href="#4-4-组织结构类型" class="headerlink" title="4.4 组织结构类型"></a>4.4 组织结构类型</h4><p>组织需要权衡两个关键变量之后才可确定合适的组织结构类型。这两个变量指可以采用的组织结构类型以及针对特定组织如何优化组织结构类型的方式。不存在一种结构类型适用于任何特定组织。因要考虑各种可变因素，特定组织的最终结构是独特的。</p><h5 id="4-4-1-组织结构类型"><a href="#4-4-1-组织结构类型" class="headerlink" title="4.4.1 组织结构类型"></a>4.4.1 组织结构类型</h5><p>组织结构的形式或类型是多种多样的。表2-1比较了几种组织结构类型及其对项目的影响。</p><p><img src="/images/pmp-2/表2-1.png" alt="组织结构对项目的影响"></p><h5 id="4-4-2-组织结构选择的考虑因素"><a href="#4-4-2-组织结构选择的考虑因素" class="headerlink" title="4.4.2 组织结构选择的考虑因素"></a>4.4.2 组织结构选择的考虑因素</h5><p>在确定组织结构时，每个组织都需要考虑大量的因素。在最终分析中，每个因素的重要性也各不相同。综合考虑因素及其价值和相对重要性为组织决策者提供了正确的信息，以便进行分析。</p><p>选择组织结构时应考虑的因素包括（但不限于）：</p><ul><li><p>与组织目标的一致性；</p></li><li><p>专业能力；</p></li><li><p>控制、效率与效果的程度；</p></li><li><p>明确的决策升级渠道；</p></li><li><p>明确的职权线和范围；</p></li><li><p>授权方面的能力；</p></li><li><p>终责分配；</p></li><li><p>职责分配；</p></li><li><p>设计的灵活性；</p></li><li><p>简单的设计；</p></li><li><p>实施效率；</p></li><li><p>成本考虑；</p></li><li><p>物理位置（例如集中办公、区域办公和虚拟远程办公）；</p></li><li><p>清晰的沟通（例如政策、工作状态和组织愿景）。</p></li></ul><h5 id="4-4-3-项目管理办公室"><a href="#4-4-3-项目管理办公室" class="headerlink" title="4.4.3 项目管理办公室"></a>4.4.3 项目管理办公室</h5><p>项目管理办公室（PMO）是对与项目相关的治理过程进行标准化，并促进资源、方法论、工具和技术共享的一个组织结构。PMO的职责范围可大可小，从提供项目管理支持服务，到直接管理一个或多个项目。</p><p>PMO有几种不同类型，它们对项目的控制和影响程度各不相同，例如：</p><ul><li><p>支持型。支持型PMO担当顾问的角色，向项目提供模板、最佳实践、培训，以及来自其他项目的信息和经验教训。这种类型的PMO其实就是一个项目资源库，对项目的控制程度很低。</p></li><li><p>控制型。控制型PMO不仅给项目提供支持，而且通过各种手段要求项目服从，这种类型的PMO对项目的控制程度属于中等。服从可能包括：</p><ul><li><p>采用项目管理框架或方法论；</p></li><li><p>使用特定的模板、格式和工具；</p></li><li><p>服从治理。</p></li></ul></li><li><p>指令型。指令型PMO直接管理和控制项目。项目经理由PMO指定并向其报告。这种类型的PMO对项目的控制程度很高。</p></li></ul><p>项目管理办公室可能会承担整个组织范围的职责，在支持战略调整和创造组织价值方面发挥重要的作用。PMO从组织战略项目中获取数据和信息，进行综合分析，评估如何实现更高级别的战略目标的。PMO从组织战略项目中获取数据和信息，进行综合分析，评估如何实现更高级别的战略目标的。PMO在组织的项目组合、项目集、项目与组织考评体系（如平衡记分卡）之间建立联系。</p><p>除了被集中管理以外，PMO所支持和管理的项目不一定彼此关联。PMO的具体形式、智能和结构取决于所在组织的需要。</p><p>为了保证项目符合组织的业务目标，PMO可能有权在每个项目的生命周期中充当重要的相关方和关键决策者。PMO可以：</p><ul><li><p>提出建议；</p></li><li><p>领导知识传递；</p></li><li><p>终止项目；</p></li><li><p>根据需要采取其他行动。</p></li></ul><p>PMO的一个主要职能是通过各种方式向项目经理提供支持，这些方式包括（但不限于）：</p><ul><li><p>对PMO所辖的全部项目的共享资源进行管理；</p></li><li><p>识别和制定项目管理方法、最佳实践和标准；</p></li><li><p>指导、辅导、培训和监督；</p></li><li><p>通过项目审计，监督对项目管理标准、政策、程序和模板的遵守程度；</p></li><li><p>指定和管理项目政策、程序、模板和其他共享的文件（组织过程资产）；</p></li><li><p>对跨项目的沟通进行协调。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《PMBOK第六版》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- Todo --&gt;
    
    </summary>
    
      <category term="PMP抄书系列" scheme="http://www.xiaoleon.cn/categories/PMP%E6%8A%84%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="pmp" scheme="http://www.xiaoleon.cn/tags/pmp/"/>
    
  </entry>
  
  <entry>
    <title>PMP(1) 引论</title>
    <link href="http://www.xiaoleon.cn/2019/01/22/pmp-1/"/>
    <id>http://www.xiaoleon.cn/2019/01/22/pmp-1/</id>
    <published>2019-01-22T14:34:02.000Z</published>
    <updated>2019-05-13T09:46:55.002Z</updated>
    
    <content type="html"><![CDATA[<!-- Todo --><a id="more"></a><h3 id="一、指南概述和目的"><a href="#一、指南概述和目的" class="headerlink" title="一、指南概述和目的"></a>一、指南概述和目的</h3><p>项目管理并非新概念，它已存在数百年之久。项目成果的例子包括：</p><ul><li><p>吉萨金字塔</p></li><li><p>奥林匹克运动会</p></li><li><p>中国长城</p></li><li><p>泰姬陵</p></li><li><p>儿童读物出版</p></li><li><p>巴拿马运河</p></li><li><p>商用喷气式飞机的发明</p></li><li><p>脊髓灰质炎疫苗</p></li><li><p>人类登陆月球</p></li><li><p>商业软件应用程序</p></li><li><p>使用全球定位系统（GPS）的便携式设备</p></li><li><p>地球轨道上的国际空间站</p></li></ul><p>这些项目成果是领导者和项目经理在工作中应用项目管理实践、原则、过程、工具和技术的结果。这些项目经理运用一系列关键技能和知识来满足客户和参与项目或受项目影响的其他人的要求。二十世纪中期，项目经理开始致力于将项目管理确立为一种职业，其中一个方面就是对知识体系（BOK）的内容，即项目管理达成一致意见。这一知识体系后来成为“项目管理知识体系”（PMBOK）。项目管理协会（PMI）指定了一套有关项目管理知识体系的图表和词汇基准。项目经理很快意识到，并非一本书就可以包含项目管理知识体系的所有内容。因此，PMI制定并发布了《项目管理知识体系指南》（简称《PMBOK指南》）。</p><p>PMI将项目管理知识体系（PMBOK）定义为描述项目管理专业范围内知识的术语。项目管理知识体系包括已被验证并广泛应用的传统做法，以及本专业新近涌现的创新做法。</p><p>知识体系（BOK）包括已发布和未发布的材料。这一知识体系仍在不断演变发展。本《PMBOK指南》收录项目管理知识体系中被普遍认可为“良好实践”的那一部分。</p><ul><li><p>所谓“普遍认可”，是指这些知识和做法在大多数时候适用于大多数项目，并且其价值和有效性已获得一致认可。</p></li><li><p>所谓“良好实践”，则指人们普遍认为，在项目管理过程中使用这些知识、技能、工具和技术，能够达成预期的商业价值和成果，从而提高很多项目成功的可能性。</p></li></ul><p>项目经理与项目团队和其他相关方携手合作，共同确定并采用适用于各个项目且被普遍认可的良好实践。确定过程、输入、工具、技术、输出和生命周期阶段的恰当组合以管理项目的过程，即指本指南所述知识的“裁剪”应用。</p><p>本《PMBOK指南》与方法论有所不同。方法论是由专门的从业人员所采用的实践、技术、程序和规则所组成的体系。而本《PMBOK指南》是组织制定实践项目管理所需方法论、政策、程序、规则、工具、技术和生命周期阶段的基础。</p><h4 id="1-项目管理标准"><a href="#1-项目管理标准" class="headerlink" title="1 项目管理标准"></a>1 项目管理标准</h4><p>本指南基于《项目管理标准》。标准是基于权威、惯例或共识而建立并用做模式或范例的文件。作为美国国家标准协会（ANSI）的标准，《项目管理标准》根据协商一致、开放公开、程序公正和各方平衡等概念予以制定。《项目管理标准》是PMI项目管理专业发展计划和项目管理实践的基本参考资料。由于项目管理需要根据项目需求进行调整，标准和指南均基于描述性实践，而不是规范性实践。因此，标准确认了在大多数时候都被大多数项目视作良好实践的过程。另外，标准还确认了通常与这些过程相关的输入和输出。标准不要求执行任何特定过程或实践。《项目管理标准》是《项目管理知识体系指南》的第二部分。</p><p>《PMBOK指南》更详细地说明了核心概念、新型趋势、裁剪项目管理过程时应考虑的因素，以及如何将工具和技术应用于项目中。项目经理可以采用一种或多种方法论执行本标准所描述的项目管理过程。</p><p>本指南的范围仅限于项目管理领域，而不涉及任何项目组合、项目集和多个项目的领域；仅在与项目有关时才会提及项目组合和项目集。PMI同时还发布了针对项目组合和项目集的两部标准：</p><ul><li><p>《项目组合管理标准》</p></li><li><p>《项目集管理标准》</p></li></ul><h4 id="2-通用词汇"><a href="#2-通用词汇" class="headerlink" title="2 通用词汇"></a>2 通用词汇</h4><p>通用词汇是专业学科的基本要素。《PMI项目管理术语词典》收录了基本的专业词汇，供组织、项目组合、项目集和项目经理及其他项目相关方统一使用。《术语词典》会随着时间的推移而更改。本指南的词汇表包含了《术语词典》中的词汇以及其他定义。项目可能会采用由行业文献定义的相关行业特定的术语。</p><h4 id="3-道德与专业行为规范"><a href="#3-道德与专业行为规范" class="headerlink" title="3 道德与专业行为规范"></a>3 道德与专业行为规范</h4><p>PMI发布了《道德与专业行为规范》，为项目管理专业人员增强了信心并帮助个人做出明智的决策，尤其是在面对被要求违背正直诚信或价值观的困境时。全球项目管理业界定义的最重要的价值观是责任、尊重、公正和诚实。《道德与专业行为规范》确立了这四个价值观的基础地位。</p><p>《道德与专业行为规范》包括期望标准和强制标准。期望标准描述了身为PMI会员、证书持有者或志愿者的从业者力求遵循的行为规范。尽管对期望标准的遵循情况进行衡量并非易事，依照这些标准行事仍是对从业人员专业性的期待，并非可有可无的要求。强制标准做出了硬性要求，在某些情况下限制或禁止从业者的某些行为。身为PMI会员、证书持有者或志愿者以及不依照这些标准行事的从业者将受到PMI道德委员会的纪律处罚。</p><hr><h3 id="二、基本要素"><a href="#二、基本要素" class="headerlink" title="二、基本要素"></a>二、基本要素</h3><p>本章描述了从事项目管理和了解项目管理领域所需的基本要素。</p><h4 id="1-项目"><a href="#1-项目" class="headerlink" title="1 项目"></a>1 项目</h4><p>项目是为创造独特的产品、服务或成果而进行的临时性工作。</p><p>1.1 独特的产品、服务或成果。开展项目是为了通过可交付成果达成目标。目标指的是工作所指向的结果，要达到的战略地位，要达到的目的，要取得的成果，要生产的产品，或者准备提供的服务。可交付成果指的是在某一过程、阶段或项目完成时，必须产出的任何独特并可核实的产品、成果或服务能力。可交付成果可能是有形的，也可能是无形的。</p><p>实现项目目标可能会产生以下一个或多个可交付成果：</p><ul><li><p>一个独特的产品，可能是其他产品的组成部分、某个产品的升级版或修正版，也可能其本身就是新的最终产品（例如一个最终产品缺陷的修正）；</p></li><li><p>一种独特的服务或提供某种服务的能力（如支持生产或配送的业务职能）；</p></li><li><p>一项独特的成果，例如某个结果或文件（如某研究项目所创造的知识，可据此判断某种趋势是否存在，或判断某个新过程是否有益于社会）；</p></li><li><p>一个或多个产品、服务或成果的独特组合（例如一个软件应用程序及其相关文件和帮助中心服务）。</p></li></ul><p>某些项目可交付成果和活动中可能存在重复的元素，但这种重复并不会改变项目工作本质上的独特性。例如，即便采用相同或相似的材料，由相同或不同的团队来建设，但每个建筑项目仍具备独特性（例如位置、设计、环境、情况、参与项目的人员）。</p><p>项目可以在组织的任何层面上开展。一个项目可能只涉及一个人，也可能涉及一组人；可能只涉及一个组织单元，也可能涉及多个组织的多个单元。</p><p>项目的例子包括（但不限于）：</p><ul><li><p>为市场开发新的复方药；</p></li><li><p>扩展导游服务；</p></li><li><p>合并两家组织；</p></li><li><p>改进组织内的业务流程；</p></li><li><p>为组织采购和安装新的计算机硬件系统；</p></li><li><p>一个地区的石油勘探</p></li><li><p>修改组织内使用的计算机软件；</p></li><li><p>开展研究以开发新的制造过程；</p></li><li><p>建造一座大楼。</p></li></ul><p>1.2 临时性工作。项目的“临时性”是指项目有明确的起点和终点。“临时性”并不一定意味着项目的持续时间短。在以下一种或多种情况下，项目即宣告结束：</p><ul><li><p>达成项目目标；</p></li><li><p>不会或不能达到目标；</p></li><li><p>项目资金缺乏或没有可分配资金；</p></li><li><p>项目需求不复存在（例如，客户不再要求完成项目，战略或优先级的变更致使项目终止，组织管理层下达终止项目的指示）；</p></li><li><p>无法获得所需人力或物力资源；</p></li><li><p>出于法律或便利原因而终止项目。</p></li></ul><p>虽然项目是临时性工作，但其可交付成果可能会在项目的终止后依然存在。项目可能产生与社会、经济、材料或环境相关的可交付成果。例如，国家纪念碑建设项目就是要创造一个流传百世的可交付成果。</p><p>1.3 项目驱动变更。项目驱动组织进行变更。从商业角度来看，项目旨在推动组织从一个状态转到另一个状态，从而达成特定目标。在项目开始之前，通常将此时的组织描述为“当前状态”。项目驱动变更是为了获得期望的结果，即“将来状态”。</p><p>有些项目可能会创造一个过渡状态，即有多个步骤组成的连续区间，以过渡到将来状态。通过成功完成项目，组织可以实现将来状态并达成特定目标。关于项目管理和变更的更多信息，请参见《管理组织变更：实践指南》。</p><p><img src="/images/pmp-1/1-1.png" alt="组织通过项目进行状态转换"></p><p>1.4 项目创造商业价值。PMI将商业价值定义为从商业运作中获得的可量化净效益。效益可以是有形的、无形的或两者兼有之。在商业分析中，商业价值被视为回报，即以某种投入换取时间、资金、货物或无形的回报（参见《从业者商业分析：实践指南》）。</p><p>项目的商业价值指特定项目的成果能够为相关方带来的效益。项目带来的效益可以是有形的、无形的或两者兼有之。</p><p>有形效益的例子包括：</p><ul><li><p>货币资产；</p></li><li><p>股东权益；</p></li><li><p>公共事业；</p></li><li><p>固定设施；</p></li><li><p>工具；</p></li><li><p>市场份额。</p></li></ul><p>无形效益的例子包括：</p><ul><li><p>商誉；</p></li><li><p>品牌认知度；</p></li><li><p>公共利益；</p></li><li><p>商标；</p></li><li><p>战略一致性；</p></li><li><p>声誉。</p></li></ul><p>1.5 项目启动背景。组织领导者启动项目是为了应对影响该组织的因素。这些基本因素说明了项目背景，大致分为四类：</p><ul><li><p>符合法规、法律或社会要求；</p></li><li><p>满足相关方的要求或需求；</p></li><li><p>执行、变更业务或技术战略；</p></li><li><p>创造、改进或修复产品、过程或服务。</p></li></ul><p><img src="/images/pmp-1/1-2.png" alt="项目启动背景"></p><p>这些因素会影响组织的持续运营和业务战略。领导者应对这些因素，以便组织持续运营。项目为组织提供了一个有效的途径，使其能够成功做出应对这些因素所需的变更。这些因素最终应与组织的战略目标以及各个项目的商业价值相关联。</p><p>表1-1展示了如何将示例因素归入一个或多个基本因素类别。</p><p><img src="/images/pmp-1/表1-1.png" alt="促成项目创建的因素示例"></p><h4 id="2-项目管理的重要性"><a href="#2-项目管理的重要性" class="headerlink" title="2 项目管理的重要性"></a>2 项目管理的重要性</h4><p>项目管理就是将知识、技能、工具与技术应用于项目活动，以满足项目的要求。项目管理通过合理运用与整合特定项目所需的项目管理过程得以实现。项目管理使组织能够有效且高效地开展项目。</p><p>有效的项目管理能够帮助个人、群体以及公共和私人组织：</p><ul><li><p>达成业务目标；</p></li><li><p>满足相关方的期望；</p></li><li><p>提高可预测性；</p></li><li><p>提高成功的概率；</p></li><li><p>在适当的时间交付正确的产品；</p></li><li><p>解决问题和争议；</p></li><li><p>及时应对风险；</p></li><li><p>优化组织资源的使用；</p></li><li><p>识别、挽救或终止失败项目；</p></li><li><p>管理制约因素（例如范围、质量、进度、成本、资源）；</p></li><li><p>平衡制约因素对项目的影响（例如范围扩大可能会增加成本或延长进度）；</p></li><li><p>以更好的方式管理变更。</p></li></ul><p>项目管理不善或缺乏项目管理可能会导致：</p><ul><li><p>超过时限；</p></li><li><p>成本超支；</p></li><li><p>质量低劣；</p></li><li><p>返工；</p></li><li><p>项目范围扩大失控；</p></li><li><p>组织声誉受损；</p></li><li><p>相关方不满意；</p></li><li><p>正在实施的项目无法达成目标。</p></li></ul><p>项目是组织创造价值和效益的主要方式。在当今商业环境下，组织领导者需要应对预算紧缩、时间缩短、资源稀缺以及技术快速变化的情况。商业环境动荡不定，变化越来越快。为了在全球经济中保持竞争力，公司日益广泛利用项目管理，来持续创造商业价值。</p><p>有效和高效的项目管理应被视为组织的战略能力。它使组织能够：</p><ul><li><p>将项目成果与业务目标联系起来；</p></li><li><p>更有效地展开市场竞争；</p></li><li><p>支持组织发展；</p></li><li><p>通过适当调整项目管理计划，以应对商业环境改变给项目带来的影响。</p></li></ul><h4 id="3-项目、项目集、项目组合以及运营管理之间的关系"><a href="#3-项目、项目集、项目组合以及运营管理之间的关系" class="headerlink" title="3 项目、项目集、项目组合以及运营管理之间的关系"></a>3 项目、项目集、项目组合以及运营管理之间的关系</h4><h5 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h5><p>项目管理过程、工具和技术的运用为组织达成目的和目标奠定了坚实的基础。一个项目可以采用三种不同的模式进行管理：作为一个独立项目（不包括在项目组合或项目集中）、在项目集内或在项目组合内。如果在项目组合或项目集内管理某个项目，则项目经理需要与项目集和项目组合经理互动合作。例如，为达成组织的一系列目的和目标，可能需要实施多个项目。在这种情况下，项目可能被归入项目集中。项目集是一组相互关联且被协调管理的项目、子项目集和项目集活动，以便获得分别管理所无法获得的利益。项目集不是大项目。规模特别大的项目称为“大型项目”。一般定义，大型项目通常需要10亿美元或以上的成本，可影响上百万人，并且将持续数年。</p><p>有些组织可能会采用项目组合，以有效管理在任何特定的时间内同时进行的多个项目集和项目。项目组合是指为了实现战略目标而组合在一起管理的项目、项目集、子项目组合和运营工作。图1-3展示了项目组合、项目集、项目和运营在特定情况下如何关联的。</p><p>项目集管理和项目组合管理的生命周期、活动、目标、重点和效益都与项目管理不同；但是，项目组合、项目集、项目和运营通常都涉及相同的相关方，还可能需要使用同样的资源，而这可能会导致组织内出现冲突。这种情况促使组织增强内部协调，通过项目组合、项目集和项目管理达成组织内部的有效平衡。</p><p>图1-3所示的项目组合结构示例表明了项目集、项目、共享资源和相关方之间的关系。将项目组合组成部分合为一组能够促进这项工作的有效治理和管理，从而有助于实现组织战略和相关优先级。在开展组织和项目组合规划时，要基于风险、资金和其他考虑因素对项目组合组件排列优先级。项目组合方法有利于组织了解战略目标在项目组合中的实施情况，还能促进适当项目组合、项目集和项目治理的实施和协调。这种协调治理方式可为实现预期绩效和效益而分配人力、财力和实物资源。</p><p><img src="/images/pmp-1/1-3.png" alt="项目组合、项目集、项目和运营"></p><p>从组织的角度来看项目、项目集和项目组合管理：</p><ul><li><p>项目集和项目管理的重点在于以“正确”的方式开展项目集和项目；</p></li><li><p>项目组合管理则注重于开展“正确”的项目集和项目。</p></li></ul><p>表1-2概述了项目组合、项目集和项目组合管理的比较。</p><p><img src="/images/pmp-1/表1-2.png" alt="项目、项目集、项目组合管理的比较概述"></p><h5 id="3-2-项目集管理"><a href="#3-2-项目集管理" class="headerlink" title="3.2 项目集管理"></a>3.2 项目集管理</h5><p>项目集管理指在项目集中应用知识、技能与原则来实现项目集的目标，获得分别管理项目集组成部分所无法实现的利益和控制。项目集组成部分指项目集中的项目和其它项目集。项目管理注重项目本身的相互依赖关系，以确定管理这些项目的最佳方法。项目集和项目间依赖关系的具体管理措施可能包括：</p><ul><li><p>调整对项目集和项目的目的和目标有影响的组织或战略方向；</p></li><li><p>将项目集范围分配到项目集组成部分；</p></li><li><p>管理项目集组成部分之间的依赖关系，从而以最佳方式实施项目集；</p></li><li><p>管理可能影响项目集内多个项目的项目集风险；</p></li><li><p>解决影响项目集内多个项目的制约因素和冲突；</p></li><li><p>解决作为组成部分的项目与项目集之间的问题；</p></li><li><p>在同一个治理框架内管理变更请求；</p></li><li><p>将预算分配到项目集内的多个项目；</p></li><li><p>确保项目集及其包含的项目能够实现效益。</p></li></ul><p>建立一个新的通信卫星系统就是项目集的一个实例，其所辖项目包括卫星与地面站的设计和建设、卫星发射以及系统整合。</p><p>关于项目集管理的更多信息，请参见《项目集管理标准》。</p><h5 id="3-3-项目组合管理"><a href="#3-3-项目组合管理" class="headerlink" title="3.3 项目组合管理"></a>3.3 项目组合管理</h5><p>项目组合是指为实现战略目标而组合在一起管理的项目、项目集、子项目组合和运营工作。</p><p>项目组合管理是指为了实现战略目标而对一个或多个项目组合进行的集中管理。项目组合中的项目集或项目不一定彼此依赖或直接相关。</p><p>项目组合管理的目的是：</p><ul><li><p>指导组织的投资决策；</p></li><li><p>选择项目集和项目的最佳组合方式，以达成战略目标；</p></li><li><p>提供决策透明度；</p></li><li><p>确定团队和实物资源分配的优先顺序；</p></li><li><p>提高实现预期投资回报的可能性；</p></li><li><p>实现对所有组成部分的综合风险预测的集中式管理。</p></li></ul><p>此外，项目组合管理还可确定项目组合是否符合组织战略。</p><p>要实现项目组合价值的最大化，需要精心检查项目组合的组成部分。确定组成部分的优先顺序，使最有利于组织战略目标的组成部分拥有所需的财力、人力和实物资源。</p><p>例如，以“投资回报最大化”为战略目标的某基础设施公司，可以把油气、供电、供水、道路、铁路和机场等项目归并成一个项目组合。在这些归并的项目中，组织又可以把互相关联的项目作为项目组合来管理。所有供电项目归类成供电项目组合，同里，所有供水项目归类成供水项目组合。然而，如果组织的项目是设计和建造发电站并运营发电站，这些相互关联的项目可以归类成一个项目集。这样的话，供电项目集和类似的供水项目集就是该基础设施公司项目组合中的基本组成部分。</p><p>关于项目组合管理的更多信息，请参见《项目组合管理标准》。</p><h5 id="3-4-运营管理"><a href="#3-4-运营管理" class="headerlink" title="3.4 运营管理"></a>3.4 运营管理</h5><p>运营管理是另外一个领域，超出了本指南所描述的规范的项目管理范围。</p><p>运营管理关注产品的持续生产和（或）服务的持续运作。它使用最优资源满足客户要求，来保证业务运作的持续高效。它重点管理那些把各种输入（如材料、零件、能源和劳力）转变为输出（如产品、商品和（或）服务）的过程。</p><h5 id="3-5-运营与项目管理"><a href="#3-5-运营与项目管理" class="headerlink" title="3.5 运营与项目管理"></a>3.5 运营与项目管理</h5><p>业务或组织运营的改变也许就是某个项目的关注焦点，油气当项目交付的新产品或新服务将导致业务运营的有实质性改变时。持续运营不属于项目的范畴，但是它们之间存在交叉。</p><p>项目与运营会在产品生命周期的不同时点交叉，例如：</p><ul><li><p>在新产品开发、产品升级或提高产量时；</p></li><li><p>在改进运营或产品开发流程时；</p></li><li><p>在产品生命周期结束阶段；</p></li><li><p>在每个收尾阶段。</p></li></ul><p>在每个交叉点，可交付成果及知识在项目与运营之间转移，以完成工作交接。在这一过程中，将转移项目资源或知识到运营中，或转移运营资源到项目中。</p><h5 id="3-6-组织机构项目管理（OPM）和战略"><a href="#3-6-组织机构项目管理（OPM）和战略" class="headerlink" title="3.6 组织机构项目管理（OPM）和战略"></a>3.6 组织机构项目管理（OPM）和战略</h5><p>项目组合、项目集和项目均需符合组织战略，或由组织战略驱动，并以不同的方式服务于战略目标的实现：</p><ul><li><p>项目组合管理通过选择适当的项目集或项目，对工作进行优先排序，以及提供所需资源，来与组织战略保持一致。</p></li><li><p>项目集管理对其组成部分进行协调，对它们之间的依赖关系进行控制，从而实现既定收益。</p></li><li><p>项目管理使组织的目的和目标得以实现。</p></li></ul><p>作为项目组合或项目集的组成部分，项目是实现组织战略和目标的一种手段，常常应用于作为项目投资主要引导因素的战略规划之中。为了使项目符合组织的战略业务目标，对项目组合、项目集和项目进行系统化管理，可以应用组织级项目管理（OPM）。OPM指为实现战略目标而整合项目组合、项目集和项目管理与组织驱动因素的框架。</p><p>OPM旨在确保组织开展正确的项目并合适地分配关键资源。OPM有助于确保组织的各个层级都了解组织的战略愿景、支持愿景的举措、目标以及可交付成果。图1-4展示了战略、项目组合、项目集、项目和运营相互作用的组织环境。</p><p>关于OPM的更多信息，请参见《实施组织项目管理：实践指南》。</p><p><img src="/images/pmp-1/1-4.png" alt="组织项目管理"></p><h4 id="4-指南的组成部分"><a href="#4-指南的组成部分" class="headerlink" title="4 指南的组成部分"></a>4 指南的组成部分</h4><p>项目包含了几个关键组成部分，如果有效管理这些组成部分，项目才能成功完成。本指南识别并阐述了这些组成部分，各个组成部分在项目管理期间相互关联。</p><p>表1-3简单描述了关键组成部分，之后的章节会对这些组成部分详细描述。</p><p><img src="/images/pmp-1/表1-3.png" alt="指南关键组成部分的描述"></p><p><img src="/images/pmp-1/1-5.png" alt="指南关键组成部分在项目中的相互关系"></p><h5 id="4-1-项目和开发生命周期"><a href="#4-1-项目和开发生命周期" class="headerlink" title="4.1 项目和开发生命周期"></a>4.1 项目和开发生命周期</h5><p>项目生命周期指项目从启动到完成所经历的一系列阶段。它为项目管理提供了一个基本框架。不论项目涉及的具体工作是什么，这个基本框架都适用。这些阶段之间的关系可以顺序、迭代或交叠进行。所有项目都呈现图1-5所示的通用的生命周期。</p><p>项目生命周期可以是预测性或适应型。项目生命周期内通常有一个或多个阶段与产品、服务或成果的开发相关，这些阶段称为开发生命周期。开发生命周期可以是预测型、迭代型、增量型、适应型或混合型的模式：</p><ul><li><p>预测型生命周期，在生命周期的早期阶段确定项目范围、时间和成本。对任何范围的变更都要进行仔细管理。预测型生命周期也称为瀑布型生命周期。</p></li><li><p>迭代型生命周期，项目范围通常于项目生命周期的早期确定，但时间及成本估算将随着项目团队对产品理解的不断深入而定期修改。迭代方法是通过一系列重复的循环活动来开发产品，而增量方法是渐进地增加产品的功能。</p></li><li><p>增量型生命周期是通过在预定的时间区间内渐进增加产品功能的一系列迭代来产出可交付成果。只有在最后一次迭代后，可交付成果具有了必要和足够的能力，才能被视为完整的。</p></li><li><p>适应型生命周期属于敏捷性、迭代型或增量型。详细范围在迭代开始之前就得到了定义和批准。适应型生命周期也被称为敏捷或变更驱动型生命周期。请参见附录X3。</p></li><li><p>混合型生命周期是预测型生命周期和适应型生命周期的组合。充分了解或有确定需求的项目要素遵循预测型开发生命周期，而仍在发展中的要素遵循适应型开发生命周期。</p></li></ul><p>由项目管理团队确定各个项目最适合的生命周期。项目生命周期需要足够灵活，能够应对项目包含的各种因素。可以通过以下方法实现生命周期的灵活性：</p><ul><li><p>确定需要再各个阶段实施的一个或多个过程；</p></li><li><p>在合适的阶段实施确定的一个或多个过程；</p></li><li><p>调整阶段的各种属性（例如名称、持续时间、退出标准和准入标准）。</p></li></ul><p>项目生命周期与产品生命周期相互独立，后者可能由项目产生。产品生命周期指一个产品从概念、交付、成长、成熟到衰退的整个演变过程的一系列阶段。</p><h5 id="4-2-项目阶段"><a href="#4-2-项目阶段" class="headerlink" title="4.2 项目阶段"></a>4.2 项目阶段</h5><p>项目阶段是一组有逻辑关系的项目活动的集合，通常以一个或多个可交付成果的完成为结束。生命周期的各个阶段可以通过各种不同的属性来描述。对于特定阶段，属性是可测量且独特的。属性可能包括（但不限于）：</p><ul><li><p>名称（例如阶段A、阶段B、阶段1、阶段2、提建议阶段）；</p></li><li><p>数量（例如项目的三个阶段、项目的五个阶段）；</p></li><li><p>持续时间（例如一个星期、一个月、一个季度）；</p></li><li><p>资源需求（例如人力、建筑、设备）；</p></li><li><p>项目进入某一阶段的准入标准（例如已获得特定批准文件、已完成特定文件）；</p></li><li><p>项目完成某一阶段的退出标准（例如已获得批准文件、已完成文件、已达成可交付成果）。</p></li></ul><p>项目可以分解为不同的阶段或子组件，这些阶段或子组件的名称通常说明了该阶段完成的工作类型。阶段名称的例子包括（但不限于）：</p><ul><li><p>概念开发；</p></li><li><p>可行性研究；</p></li><li><p>客户要求；</p></li><li><p>解决方案开发；</p></li><li><p>设计；</p></li><li><p>原型法；</p></li><li><p>建造；</p></li><li><p>测试；</p></li><li><p>转换；</p></li><li><p>试运行；</p></li><li><p>里程碑审查；</p></li><li><p>经验教训。</p></li></ul><p>项目阶段可基于各种因素而建立，其中包括（但不限于）：</p><ul><li><p>管理需求；</p></li><li><p>项目性质；</p></li><li><p>组织、行业或技术的独特性；</p></li><li><p>项目的组成要素，包括但不限于技术、工程、业务、过程或法律；</p></li><li><p>决策点（例如资金、继续/终止项目，里程碑审查）。</p></li></ul><p>分为多个阶段的方式有助于更好地掌控项目管理，同时还提供了评估项目绩效并在后续阶段采取必要的纠正或预防措施的机会。项目阶段的其中一个关键组成部分是阶段审查。</p><h5 id="4-3-阶段关口"><a href="#4-3-阶段关口" class="headerlink" title="4.3 阶段关口"></a>4.3 阶段关口</h5><p>阶段关口在项目阶段结束时进行，将项目的绩效和进度与项目和业务文件比较，这些文件包括（但不限于）：</p><ul><li><p>项目商业论证；</p></li><li><p>项目章程：</p></li><li><p>项目管理计划：</p></li><li><p>效益管理计划。</p></li></ul><p>根据比较结果作出决定（例如继续/终止的决定），以便：</p><ul><li><p>进入下个阶段；</p></li><li><p>整改后进入下个阶段；</p></li><li><p>结束项目；</p></li><li><p>停留在当前阶段；</p></li><li><p>重复阶段或某个要素。</p></li></ul><p>在不同的组织、行业或工作类型中，阶段关口可能被称为阶段审查、阶段门、关键决策点和阶段入口或阶段出口。组织可以通过这些审查来检查本指南范围之外的其他相关项，例如产品相关文件或模型。</p><h5 id="4-4-项目管理过程"><a href="#4-4-项目管理过程" class="headerlink" title="4.4 项目管理过程"></a>4.4 项目管理过程</h5><p>项目生命周期是通过一系列项目管理活动进行的，即项目管理过程。每个项目管理过程通过合适的项目管理工具和技术将一个或多个输入转化成一个或多个输出。输出可以是可交付成果或结果。结果是过程的最终成果。项目管理过程适用于全球各个行业。</p><p>各项目管理过程通过它们所产生的输出建立逻辑联系。过程可能包含了在整个项目期间互相重叠的活动。一个过程的输出通常成为一下二者之一：</p><ul><li><p>另一个过程的输入；</p></li><li><p>项目或项目阶段的可交付成果。</p></li></ul><p>图1-6的示例说明了一个过程的输入、工具、技术和输出的关系以及与其他过程的关系。</p><p><img src="/images/pmp-1/1-6.png" alt="输入、工具与技术和输出"></p><p>过程迭代的次数和过程间的相互作用因具体项目的需求而不同。过程通常分为三类：</p><ul><li><p>仅开展一次或仅在项目预定义点开展的过程。例如制定项目章程以及结束项目或阶段。</p></li><li><p>根据需要定期开展的过程。在需要资源时执行获取资源。在需要采购之前执行实施采购。</p></li><li><p>贯穿项目始终执行的过程。在整个项目生命周期中可能执行的过程定义活动，特别是当项目使用滚动式规划或适应型开发方法时。从项目开始到项目结束需要持续开展许多监控过程。</p></li></ul><p>项目管理通过合理运用与整合按逻辑分组的项目管理过程而得以实现。过程分类方法有很多种，但《PMBOK指南》把过程归纳为五大类，即五大过程组。</p><h5 id="4-5-项目管理过程组"><a href="#4-5-项目管理过程组" class="headerlink" title="4.5 项目管理过程组"></a>4.5 项目管理过程组</h5><p>项目管理过程组指对项目管理过程进行逻辑分组，以达成项目的特定目标。过程组不同于项目阶段。项目管理过程可分为以下五个项目管理过程组：</p><ul><li><p><strong>启动过程组</strong>定义一个新项目或现有项目的一个新阶段，授权开始该项目或阶段的一组过程。</p></li><li><p><strong>规划过程组</strong>明确项目范围，优化目标，为实现目标制定行动方案的一组过程。</p></li><li><p><strong>执行过程组</strong>完成项目管理计划中确定的工作，以满足项目要求的一组过程。</p></li><li><p><strong>监控过程组</strong>跟踪、审查和调整项目进展与绩效，识别必要的计划变更并启动相应变更的一组过程。</p></li><li><p><strong>收尾过程组</strong>正式完成或结束项目、阶段或合同所执行的过程。</p></li></ul><p>本指南采用流程图。项目管理过程通过具体的输入和输出相互联系，即一个过程的成果或结果可能成为另一个过程的输入。请注意，过程组与项目阶段不同。</p><h5 id="4-6-项目管理知识领域"><a href="#4-6-项目管理知识领域" class="headerlink" title="4.6 项目管理知识领域"></a>4.6 项目管理知识领域</h5><p>除了过程组，过程还可以按知识领域进行分类。知识领域指按所需知识内容来定义的知识管理领域，并用其所含过程、实践、输入、输出、工具和技术进行描述。</p><p>虽然知识领域相互联系，但从项目管理的角度来看，它们是分别定义的。本指南确定了大多数情况下大部分项目通常使用的十个知识领域。本指南描述的十个知识领域包括：</p><ul><li><p><strong>项目整合管理</strong>包括为识别、定义、组合、统一和协调各项目管理过程组的各个过程和活动而开展的过程与活动。</p></li><li><p><strong>项目范围管理</strong>包括确保项目做且只做所需的全部工作以成功完成项目的各个过程。</p></li><li><p><strong>项目进度管理</strong>包括为管理项目按时完成所需的各个过程。</p></li><li><p><strong>项目成本管理</strong>包括为使项目在批准的预算内完成而对成本进行规划、估算、预算、融资、筹资、管理和控制的各个过程。</p></li><li><p><strong>项目质量管理</strong>包括把组织的质量政策应用于规划、管理、控制项目和产品质量要求，以满足相关方的期望的各个过程。</p></li><li><p><strong>项目资源管理</strong>包括识别、获取和管理所需资源以成功完成项目的各个过程。</p></li><li><p><strong>项目沟通管理</strong>包括为确保项目信息及时且恰当地规划、收集、生成、发布、存储、检索、管理、控制、监督和最终处置所需的各个过程。</p></li><li><p><strong>项目风险管理</strong>包括规划风险管理、识别风险、开展风险分析、规划风险应对、实施风险应对和监督风险的各个过程。</p></li><li><p><strong>项目采购管理</strong>包括从项目团队外部采购或获取所需产品、服务或成果的各个过程。</p></li><li><p><strong>项目相关方管理</strong>包括用于开展下列工作的各个过程：识别影响或受项目影响的人员、团队或组织，分析相关方对项目的期望和影响，制定合适的管理策略来有效调动相关方参与项目决策和执行。</p></li></ul><p>某些项目可能需要一个或多个其他的知识领域，例如，建造项目可能需要财务管理或安全与健康管理。表1-4列出了项目管理过程组和知识领域。</p><p><img src="/images/pmp-1/表1-4.png" alt="项目管理过程组与知识领域"></p><h5 id="4-7-项目管理数据和信息"><a href="#4-7-项目管理数据和信息" class="headerlink" title="4.7 项目管理数据和信息"></a>4.7 项目管理数据和信息</h5><p>整个项目生命周期需要收集、分析和转化大量的数据。从各个过程收集项目数据，并在项目团队内共享。在各个过程中所收集的数据经过结合相关背景的分析、汇总，并加工成项目信息。信息通过口头形式进行传达，或以各种格式的报告存储和分发。</p><p>在整个项目生命周期中需要定期收集和分析项目数据。关于项目数据和信息的主要术语定义如下：</p><ul><li><p>工作绩效数据。在执行项目工作的过程中，从每个正在执行的活动中收集到的原始观察结果和测量值。例如包括工作完成百分比、质量和技术绩效测量结果、进度计划活动的开始和结束日期、变更请求的数量、缺陷的数量、实际成本和实际持续时间等。项目数据通常记录在项目管理信息系统（PMIS）和项目文件中。</p></li><li><p>工作绩效信息。从各控制过程收集，并结合相关背景和跨领域关系进行整合分析而得到的绩效数据。绩效信息的例子包括可交付成果的状态、变更请求的落实情况及预测的完工尚需估算。</p></li><li><p>工作绩效报告。为制定决策、提出问题、采取行动或引起关注，而汇编工作绩效信息所形成的实物或电子项目文件。例如包括状况报告、备忘录、论证报告、信息札记、电子仪表盘、推荐意见和情况更新。</p></li></ul><p>图1-7展示了项目管理各个过程中的项目信息流。</p><p><img src="/images/pmp-1/1-7.png" alt="项目数据、信息和报告流向"></p><h4 id="5-裁剪"><a href="#5-裁剪" class="headerlink" title="5 裁剪"></a>5 裁剪</h4><p>项目经理通常将项目管理方法论应用于工作。方法论是由专门的从业人员所采用的实践、技术、程序和规则所组成的体系。根据这一定义，本指南本身并不是方法论。</p><p>建议在裁剪时参考本指南和《项目管理标准》，因为这些标准文件可识别项目管理知识体系中被普遍认可为“良好实践”的那一部分。“良好实践”并不意味着这些知识总是一成不变地应用于所有项目。本指南不讨论具体的方法论。</p><p>项目管理方法论可能：</p><ul><li><p>由组织内的专家开发；</p></li><li><p>从供应商采购而来；</p></li><li><p>从专业协会获取；</p></li><li><p>从政府机构获取。</p></li></ul><p>应选择恰当的项目管理过程、输入、工具、技术、输出和生命周期阶段以管理项目。这一选择活动即为针对项目裁剪的项目管理。项目经理与项目团队、发起人或组织管理层合作进行裁剪。在某些情况下，组织可能要求采用特定的项目管理方法论。</p><p>由于每个项目都是独特的，所以有必要进行裁剪；并非每个项目都需要《PMBOK指南》所确定的每个过程、工具、技术、输入或输出。裁剪应处理关于范围、进度、成本、资源、质量和风险的相互竞争的制约因素。各个制约因素对不同项目的重要性不一样，项目经理应根据项目环境、组织文化、相关方需求和其他变量裁剪管理这些制约因素的方法。</p><p>在裁剪项目管理时，项目经理还应考虑运行项目所需的各个治理层级，并考虑组织文化。此外，还需要考虑来自于组织内部还是外部的项目客户也可能会影响项目管理的裁剪决定。</p><p>合理的项目管理方法论需要考虑项目的独特性，允许项目经理做出一定程度的裁剪。不过，对某一特定项目而言，方法论中的裁剪法本身可能也需要进行裁剪。</p><h4 id="6-项目管理商业文件"><a href="#6-项目管理商业文件" class="headerlink" title="6 项目管理商业文件"></a>6 项目管理商业文件</h4><p>项目经理需要确保项目管理方法紧扣商业文件的意图。表1-5列出了这些文件的定义。在整个项目生命周期中，这两种文件互相依赖并得到反复制定和维护。</p><p><img src="/images/pmp-1/表1-5.png" alt="项目商业文件"></p><p>项目发起人通常负责项目商业论证文件的制定和维护。项目经理负责提供建议和见解，使项目商业论证、项目管理计划、项目章程和项目效益管理计划中的成功标准相一致，并与组织的目的和目标保持一致。</p><p>项目经理应适当地为项目裁剪上述项目管理文件。某些组织会维护项目集层面的商业论证和效益管理计划。项目经理应与相应的项目集经理合作，确保项目管理文件与项目集文件保持一致。图1-8说明了这些关键项目管理商业文件与需求评估之间的相互关系。图1-8展示了项目生命周期内各种文件大概的生命周期。</p><p><img src="/images/pmp-1/1-8.png" alt="需求评估与关键业务/项目文件的相互关系"></p><h5 id="6-1-项目商业论证"><a href="#6-1-项目商业论证" class="headerlink" title="6.1 项目商业论证"></a>6.1 项目商业论证</h5><p>项目商业论证指文档化的经济可行性研究报告，用来对尚缺乏充分定义的所选方案的收益进行有效性论证，是启动后续项目管理活动的依据。商业论证列出了项目启动的目标和理由。它有助于在项目结束时根据项目目标衡量项目是否成功。商业论证是一种项目商业文件，可在整个项目生命周期中使用。在项目启动之前通过商业论证，可能会做出继续/终止项目的决策。</p><p>需求评估通常是在商业论证之前进行，包括了解业务目的和目标、问题及机会，并提出处理建议。需求评估结果可能会在商业论证文件中进行总结。</p><p>定义业务需要、分析形势、提出建议和定义评估标准的过程，适用于任何组织的项目。商业论证可能包括（但不限于）记录以下内容：</p><ul><li><p>业务需要：</p><ul><li><p>确定促进采取行动的动机；</p></li><li><p>情况说明，记录了待处理的业务问题或机会，包括能够为组织创造的价值；</p></li><li><p>确定受影响的相关方；</p></li><li><p>确定范围。</p></li></ul></li><li><p>形势分析：</p><ul><li><p>确定组织战略、目的和目标；</p></li><li><p>确定问题的根本原因或机会的触发因素；</p></li><li><p>分析项目所需能力与组织现有能力之间的差距；</p></li><li><p>识别已知风险；</p></li><li><p>识别成功的关键因素；</p></li><li><p>确定可能用于评估各种行动的决策准则；</p><p>  用于形势分析的准则可分为：</p><ul><li><p>必须。必须践行的准则，可处理问题或机会。</p></li><li><p>预期。希望践行的准则，可处理问题或机会。</p></li><li><p>可选。非必要的准则。这一准则的践行情况可能成为区分备选行动方案的因素。</p></li></ul></li><li><p>确定一套方案，用以处理业务问题或机会。可选方案指组织可能采取的备选行动方案。可选方案也可称为商业场景。例如，商业论证可提供以下三种可选方案：</p><ul><li><p>不采取任何行动。亦称为“一切照常”方案。选择这种方案会使项目未被授权。</p></li><li><p>尽最小的努力处理问题或机会。最小的努力可能指确定一系列对处理问题或机会而言极为关键的既定准则。</p></li><li><p>以超过最低限度的努力处理问题或机会。这一方案可满足最低限度的准则以及一些或所有其他在案准则。商业论证可能会提供上述多个方案。</p></li></ul></li></ul></li><li><p>推荐：</p><ul><li><p>一种给出了针对项目的建议方案的说明书；</p></li><li><p>说明书的内容可能包括（但不限于）：</p><ul><li><p>潜在方案的分析结果；</p></li><li><p>潜在方案的制约因素、假设、风险和依赖关系；</p></li><li><p>成功标准。</p></li></ul></li><li><p>一种实施方法，可能包括（但不限于）：</p><ul><li><p>里程碑；</p></li><li><p>依赖关系；</p></li><li><p>角色与职责。</p></li></ul></li></ul></li><li><p>评估：</p><ul><li>一种描述了衡量项目交付效益的计划的说明书，应包含在初步实施之后，任何持续运营层面的可选方案。</li></ul></li></ul><p>通过将成果与目标和确定的成功标准进行比较，商业论证文件为衡量整个项目生命周期的成功和进展奠定了基础。请参见《从业者商业分析：实践指南》。</p><h5 id="6-2-项目效益管理计划"><a href="#6-2-项目效益管理计划" class="headerlink" title="6.2 项目效益管理计划"></a>6.2 项目效益管理计划</h5><p>项目效益管理计划描述了项目实现效益的方式和时间，以及应制定的效益衡量机制。项目效益指为发起组织和项目预期受益方创造价值的行动、行为、产品、服务或成果的结果。项目生命周期早期应确定目标效益，并据此制定效益管理计划。它描述了效益的关键要素，可能包括（但不限于）记录以下内容：</p><ul><li><p>目标效益（例如预计通过项目实施可以创造的有形价值和无形价值；财物价值体现为净现值）；</p></li><li><p>战略一致性（例如项目效益与组织业务战略的一致程度）；</p></li><li><p>实现效益的时限（例如阶段效益、短期效益、长期效益和持续效益）；</p></li><li><p>效益责任人（例如在计划确定的整个时限内负责监督、记录和报告已实现效益的负责人）；</p></li><li><p>测量指标（例如用于显示已实现效益的直接测量值和间接测量值）；</p></li><li><p>假设（例如预计存在或显而易见的因素）；</p></li><li><p>风险（例如实现效益的风险）。</p></li></ul><p>指定效益管理计划需要使用商业论证和需求评估中的数据和信息，例如，成本效益分析数据。在成本效益分析中已经把成本估算与项目拟实现的效益进行了比较。效益管理计划和项目管理计划描述了项目创造的商业价值如何能够成为组织持续运营的一部分，包括使用的测量指标。测量指标可核实商业价值并确认项目成功与否。</p><p>项目效益管理计划的制定和维护是一项迭代活动。它是商业论证、项目章程和项目管理计划的补充性文件。项目经理与发起人共同确保项目章程、项目管理计划和效益管理计划在整个项目生命周期内始终保持一致。请参见《从业者商业分析：实践指南》、《项目集管理标准》和《项目组合管理标准》。</p><h5 id="6-3-项目章程和项目管理计划"><a href="#6-3-项目章程和项目管理计划" class="headerlink" title="6.3 项目章程和项目管理计划"></a>6.3 项目章程和项目管理计划</h5><p>项目章程是有项目发起人发布的，正式批准项目成立，并授权项目经理动用组织资源开展项目活动的文件。</p><p>项目管理计划是描述如何执行、监督和控制项目的一份文件。</p><p>关于项目章程和项目管理计划的更多信息，请参见项目整合管理。</p><h5 id="6-4-项目成功标准"><a href="#6-4-项目成功标准" class="headerlink" title="6.4 项目成功标准"></a>6.4 项目成功标准</h5><p>确定项目是否成功是项目管理中最常见的挑战之一。</p><p>时间、成本、范围和质量等项目管理测量指标历来被视为确定项目是否成功的最重要的因素。最近，从业者和学者提出，确定项目是否成功还应考虑项目目标的实现情况。</p><p>关于项目成功的定义和最重要的因素，项目相关方可能有不同的看法。明确记录项目目标并选择可测量的目标是项目成功的关键。主要相关方和项目经理应思考以下三个问题：</p><ul><li><p>怎样才是项目成功？</p></li><li><p>如何评估项目成功？</p></li><li><p>哪些因素会影响项目成功？</p></li></ul><p>主要相关方和项目经理应就这些问题达成共识并予以记录。</p><p>项目成功可能涉及与组织战略和业务成果交付有关的其他标准。这些项目目标可能包括（但不限于）：</p><ul><li><p>完成项目效益管理计划；</p></li><li><p>打到商业论证中记录的已商定的财务测量指标。这些财务测量指标可能包括（但不限于）：</p><ul><li><p>净现值（NPV）；</p></li><li><p>投资回报率（ROI）；</p></li><li><p>内部报酬率（IRR）；</p></li><li><p>回收期（PBP）；</p></li><li><p>效益成本比率（BCR）。</p></li></ul></li><li><p>达到商业论证的非财务目标；</p></li><li><p>完成组织从“当前状态”转到“将来状态”；</p></li><li><p>履行合同条款和条件；</p></li><li><p>达到组织战略、目的和目标；</p></li><li><p>使相关方满意；</p></li><li><p>可接受的客户/最终用户的采纳度；</p></li><li><p>将可交付成果整合到组织的运营环境中；</p></li><li><p>满足商定的交付质量；</p></li><li><p>遵循治理规则；</p></li><li><p>满足商定的其他成功标准或准则（例如过程产出率）。</p></li></ul><p>为了取得项目成功，项目团队必须能够正确评估项目状况，平衡项目要求，并与相关方保持积极主动的沟通。</p><p>但在业务环境中，如果项目能够与组织的战略方向持续保持一致，那么项目成功的概率就会显著提高。</p><p>有可能一个项目从范围/进度/预算来看是成功的，但从商业角度来看并不成功。这是因为业务需要和市场环境在项目完成之前发生了变化。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《PMBOK第六版》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- Todo --&gt;
    
    </summary>
    
      <category term="PMP抄书系列" scheme="http://www.xiaoleon.cn/categories/PMP%E6%8A%84%E4%B9%A6%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="pmp" scheme="http://www.xiaoleon.cn/tags/pmp/"/>
    
  </entry>
  
  <entry>
    <title>ES6(17) 数组的扩展</title>
    <link href="http://www.xiaoleon.cn/2018/07/09/es6-17/"/>
    <id>http://www.xiaoleon.cn/2018/07/09/es6-17/</id>
    <published>2018-07-09T01:25:07.000Z</published>
    <updated>2019-01-22T14:35:18.837Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中对数组的扩展。节选自<a href="(http://es6.ruanyifeng.com/#docs/array">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><h3 id="一、扩展运算符"><a href="#一、扩展运算符" class="headerlink" title="一、扩展运算符"></a>一、扩展运算符</h3><h4 id="1-含义"><a href="#1-含义" class="headerlink" title="1. 含义"></a>1. 含义</h4><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比rest参数的逆运算，讲一个数组转为用逗号分隔的参数序列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure><p>该运算符主要用于函数调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">    array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>array.push(...items)</code>和<code>add(...numbers)</code>这两行，都是函数的调用，它们都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p><p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v, w, x, y, z</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">f(<span class="number">-1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>扩展运算符后面还可以放置表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">    ...(x &gt; <span class="number">0</span> ? [<span class="string">'a'</span>] : []),</span><br><span class="line">    <span class="string">'b'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>如果扩展运算符后面是一个空数组，则不产生任何效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[], <span class="number">1</span>]</span><br><span class="line"><span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><h4 id="2-替代函数的apply方法"><a href="#2-替代函数的apply方法" class="headerlink" title="2. 替代函数的apply方法"></a>2. 替代函数的apply方法</h4><p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure><p>下面是扩展运算符取代<code>apply</code>方法的一个实际的例子，应用<code>Math.max</code>方法，简化求出一个数组最大元素的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>)</span><br></pre></td></tr></table></figure><p>上面代码中，由于JavaScript不提供求数组最大元素的函数，所以只能套用<code>Math.max</code>函数，将数组转为一个参数序列。有了扩展运算符以后，就可以直接用<code>Math.max</code>了。</p><p>另一个例子是通过<code>push</code>函数，讲一个数组添加到另一个数组的尾部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure><p>上面代码的ES5写法中，<code>push</code>方法的参数不能是数组，所以只好通过<code>apply</code>方法变通使用<code>push</code>方法。有了扩展运算符，就可以直接将数组传入<code>push</code>方法。</p><p>下面是另外一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">new</span> (<span class="built_in">Date</span>.bind.apply(<span class="built_in">Date</span>, [<span class="literal">null</span>, <span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(...[<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h4 id="3-扩展运算符的应用"><a href="#3-扩展运算符的应用" class="headerlink" title="3. 扩展运算符的应用"></a>3. 扩展运算符的应用</h4><ul><li>1) 复制数组</li></ul><p>数组是符合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1  <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a2</code>并不是<code>a1</code>的克隆，而是指向同一份数据的另一个指针。修改<code>a2</code>，会直接导致<code>a1</code>的变化。</p><p>ES5只能用变通方法来复制数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1  <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a1</code>会返回原数组的克隆，再修改<code>a2</code>就不会对<code>a1</code>产生影响。</p><p>扩展运算符提供了复制数组的简便方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><p>上面两种写法，<code>a2</code>都是<code>a1</code>的克隆。</p><ul><li>2) 合并数组</li></ul><p>扩展运算符提供了数组合并的新写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure><p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [&#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;];</span><br><span class="line"><span class="keyword">const</span> a2 = [&#123;<span class="attr">bar</span>: <span class="number">2</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a3 = a1.concat(a2);</span><br><span class="line"><span class="keyword">const</span> a4 = [...a1, ...a2];</span><br><span class="line"></span><br><span class="line">a3[<span class="number">0</span>] === a1[<span class="number">0</span>]     <span class="comment">// true</span></span><br><span class="line">a4[<span class="number">0</span>] === a1[<span class="number">0</span>]     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a3</code>和<code>a4</code>是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。</p><ul><li>3) 与解构赋值结合</li></ul><p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">a = list[<span class="number">0</span>], rest = list.slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[a, ...rest] = list;</span><br></pre></td></tr></table></figure><p>下面是另外一些例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first   <span class="comment">// 1</span></span><br><span class="line">rest    <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = []</span><br><span class="line">first   <span class="comment">// undefined</span></span><br><span class="line">rest    <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">'foo'</span>];</span><br><span class="line">first   <span class="comment">// 'foo'</span></span><br><span class="line">rest    <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]  <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><ul><li>4) 字符串</li></ul><p>扩展运算符还可以将字符串转为真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[... <span class="string">'hello'</span>]</span><br><span class="line"><span class="comment">// ['h', 'e', 'l', 'l', 'o']</span></span><br></pre></td></tr></table></figure><p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的Unicode字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x\uD83D\uDE80y'</span>.length     <span class="comment">// 4</span></span><br><span class="line">[...<span class="string">'x\uD83D\uDE80y'</span>].length    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码的第一种写法，JavaScript会将四个字节的Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...str].length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length(<span class="string">'x\uD83D\uDE80y'</span>)    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>凡是涉及到操作四个字节的Unicode字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'x\uD83D\uDE80y'</span>;</span><br><span class="line"></span><br><span class="line">str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line"><span class="comment">// 'y\uDE80\uD83Dx'</span></span><br><span class="line"></span><br><span class="line">[...str].reverse().join(<span class="string">''</span>)</span><br><span class="line"><span class="comment">// 'y\uD83D\uDE80x'</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果不是扩展运算符，字符串的<code>reverse</code>操作就不正确。</p><ul><li>5) 实现了Iterator接口的对象</li></ul><p>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure><p>上面代码中，<code>querySelectorAll</code>方法返回的是一个<code>nodeList</code>对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于<code>NodeList</code>对象实现了Iterator。</p><p>对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...arrayLike]</span><br><span class="line"><span class="comment">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>arrayLike</code>是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用<code>Array.from</code>方法将<code>arrayLike</code>转为真正的数组。</p><ul><li>6) Map和Set结构，Generator函数</li></ul><p>扩展运算符内部调用的都是数据结构的Iterator接口，因此只要有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="string">'three'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.keys()];  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> go = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()]   <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>go</code>是一个Generator函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p><hr><h3 id="二、Array-from"><a href="#二、Array-from" class="headerlink" title="二、Array.from()"></a>二、Array.from()</h3><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括Set、Map）。</p><p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike);    <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike);   <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure><p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。<code>Array.from</code>都可以将它们转为真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectAll(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(ps).filter(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.textContent.length &gt; <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，字符串和Set结构都具有Iterator接口，因此可以被<code>Array.from</code>转为真正的数组。</p><p>如果参数是一个真正的数组，<code>Array.from</code>会返回一个一模一样的新数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>值得注意的是，扩展运算符（<code>...</code>）也可以将某些数据结构转为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br></pre></td></tr></table></figure><p>扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。<code>Array.from</code>方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// [undefined, undefined, undefined]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Array.from</code>返回了一个具有三个成员的数组，每个位置的值都是<code>undefined</code>。扩展运算符转换不了这个对象。</p><p>对于还没有部署该方法的浏览器，可以用<code>Array.prototype.slice</code>方法替代。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toArray = <span class="function">(<span class="params">(</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">Array</span>.from ? <span class="built_in">Array</span>.from : <span class="function"><span class="params">obj</span> =&gt;</span> [].slice.call(obj)</span><br><span class="line">)();</span><br></pre></td></tr></table></figure><p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, x =&gt; x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], x =&gt; x * x);</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><p>下面的例子是取出一组DOM节点的文本内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> spans = <span class="built_in">document</span>.querySelectorAll(<span class="string">'span.name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map()</span></span><br><span class="line"><span class="keyword">let</span> name1 = <span class="built_in">Array</span>.prototype.map.call(spans, s =&gt; s.textContent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from()</span></span><br><span class="line"><span class="keyword">let</span> name2 = <span class="built_in">Array</span>.from(spans, s =&gt; s.textContent);</span><br></pre></td></tr></table></figure><p>下面的例子将数组中布尔值为false的成员转为0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, , <span class="number">2</span>, , <span class="number">3</span>], n =&gt; n || <span class="number">0</span>);</span><br><span class="line"><span class="comment">// [1, 0, 2, 0, 3]</span></span><br></pre></td></tr></table></figure><p>另一个例子是返回各种数据的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typesOf</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, value =&gt; <span class="keyword">typeof</span> value)</span><br><span class="line">&#125;</span><br><span class="line">typesOf(<span class="literal">null</span>, [], <span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// ['object', 'object', 'number']</span></span><br></pre></td></tr></table></figure><p>如果<code>map</code>函数里面用到了<code>this</code>关键字，还可以传入<code>Array.from</code>的第三个参数，用来绑定<code>this</code>。</p><p><code>Array.from</code>可以将各种值转为真正的数组，并且还提供<code>map</code>功能。这实际上意味着，只要有一个原始的数据结构，就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">2</span> &#125;, () =&gt; <span class="string">'jack'</span>)</span><br><span class="line"><span class="comment">// ['jack', 'jack']</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Array.from</code>的第一个参数指定了第二个参数运行时的次数。这种特性可以让该方法的用法变得非常灵活。</p><p><code>Array.from</code>的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能够正确处理各种Unicode字符，可以避免JavaScript将大于<code>\uFFFF</code>的Unicode字符，算作两个字符的bug。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSymbols</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(string).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、Array-of"><a href="#三、Array-of" class="headerlink" title="三、Array.of()"></a>三、Array.of()</h3><p><code>Array.of</code>方法用于将一组值，转换为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>)      <span class="comment">// [3, 11, 8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>)             <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length      <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这个方法的主要目的，是弥补数组构造函数的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>()     <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>)    <span class="comment">// [,,,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>)     <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，<code>Array()</code>才会返回由参数组成的新书组。参数个数只有一个时，实际上是指定数组的长度。</p><p><code>Array.of</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of()      <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="literal">undefined</span>)     <span class="comment">// [undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>)     <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p><code>Array.of</code>方法可以用下面的代码模拟实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、数组实例的copyWithin"><a href="#四、数组实例的copyWithin" class="headerlink" title="四、数组实例的copyWithin()"></a>四、数组实例的copyWithin()</h3><p>数组实例的<code>copyWithin</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="keyword">this</span>.length)</span><br></pre></td></tr></table></figure><p>它接受三个参数。</p><ul><li><p>target（必须）：从该位置开始替换数据。如果是负值，表示倒数。</p></li><li><p>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</p></li><li><p>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</p></li></ul><p>这三个参数都应该是数值，如果不是，会自动转为数值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到0号位开始的位置，结果覆盖了原来的1和2。</p><p>下面是更多例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -2相当于3号位，-1相当于4号位</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[].copyWithin.call(&#123;<span class="attr">length</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// &#123;0: 1, 3: 1, length: 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将2号位到数组结束，复制到0号位</span></span><br><span class="line"><span class="keyword">let</span> i32a = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">i32a.copyWithin(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// Int32Array [3, 4, 5, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于没有部署TypedArray的copyWithin方法的平台</span></span><br><span class="line"><span class="comment">// 需要采用下面的写法</span></span><br><span class="line">[].copyWithin.call(<span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// Int32Array [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><hr><h3 id="五、数组实例的find-和findeIndex"><a href="#五、数组实例的find-和findeIndex" class="headerlink" title="五、数组实例的find()和findeIndex()"></a>五、数组实例的find()和findeIndex()</h3><p>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>)     <span class="comment">// -5</span></span><br></pre></td></tr></table></figure><p>上面代码找出数组第一个小于0的成员。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> value &gt; <span class="number">9</span>)   <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>find</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p><p>数组实例的<code>findIndex</code>方法的用法和<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> value &gt; <span class="number">9</span>)  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v &gt; <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">'John'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">15</span>].find(f, person);       <span class="comment">// 26</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>find</code>函数接受了第二个参数<code>person</code>对象，回调函数中的<code>this</code>对象指向<code>person</code>对象。</p><p>另外，这两个方法都可以发现<code>NaN</code>，弥补数组的<code>indexOf</code>方法的不足。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)      <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))     <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><hr><h3 id="六、数组实例的fill"><a href="#六、数组实例的fill" class="headerlink" title="六、数组实例的fill()"></a>六、数组实例的fill()</h3><p><code>fill</code>方法使用给定值，填充一个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)     <span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)        <span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure><p>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p><p><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure><p>上面代码表示，<code>fill</code>方法从1号位开始，向原数组填充7，到2号位之前结束。</p><p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(&#123;<span class="attr">name</span>: <span class="string">'Mike'</span>&#125;);</span><br><span class="line">arr[<span class="number">0</span>].name = <span class="string">'Ben'</span>;</span><br><span class="line">arr     <span class="comment">// [&#123;name: 'Ben'&#125;, &#123;name: 'Ben'&#125;, &#123;name: 'Ben'&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill([]);</span><br><span class="line">arr[<span class="number">0</span>].push(<span class="number">5</span>);</span><br><span class="line">arr     <span class="comment">// [[5], [5], [5]]</span></span><br></pre></td></tr></table></figure><hr><h3 id="七、数组实例的entries-、keys-和values"><a href="#七、数组实例的entries-、keys-和values" class="headerlink" title="七、数组实例的entries()、keys()和values()"></a>七、数组实例的entries()、keys()和values()</h3><p>ES6提供的三个新方法<code>entries()</code>、<code>keys()</code>和<code>values()</code>，用于遍历数组。它们都返回一个遍历器对象，可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(elem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index, elem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 'a'</span></span><br><span class="line"><span class="comment">// 1 'b'</span></span><br></pre></td></tr></table></figure><p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value);  <span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value);  <span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value);  <span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure><hr><h3 id="八、数组实例的includes"><a href="#八、数组实例的includes" class="headerlink" title="八、数组实例的includes()"></a>八、数组实例的includes()</h3><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)       <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)       <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">1</span>, <span class="number">-3</span>);      <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">1</span>, <span class="number">-1</span>);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>没有该方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) !=== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>indexOf</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（<code>===</code>）进行判断，这会导致对<code>NaN</code>的误判。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)  <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p><code>includes</code>使用的是不一样的判断算法，就没有这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contains = <span class="function">(<span class="params">(</span>) =&gt;</span> </span><br><span class="line">    <span class="built_in">Array</span>.prototype.includes</span><br><span class="line">        ? <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.includes(value)</span><br><span class="line">        : <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.some(<span class="function"><span class="params">el</span> =&gt;</span> el === value)</span><br><span class="line">)();</span><br><span class="line"></span><br><span class="line">contains([<span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="string">'baz'</span>)     <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>另外，Map和Set数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p><ul><li><p>Map结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</p></li><li><p>Set结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</p></li></ul><hr><h3 id="九、数组的空位"><a href="#九、数组的空位" class="headerlink" title="九、数组的空位"></a>九、数组的空位</h3><p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>)    <span class="comment">// [,,,]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Array(3)</code>返回一个具有3个空位的数组。</p><p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>]  <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [,,,]  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。</p><p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p><ul><li><p><code>forEach()</code>、<code>filter()</code>、<code>reduce()</code>、<code>every()</code>和<code>some()</code>都会跳过空位。</p></li><li><p><code>map()</code>会跳过空位，但会保留这个值。</p></li><li><p><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach方法</span></span><br><span class="line">[, <span class="string">'a'</span>].forEach(<span class="function">(<span class="params">x, i</span>) =&gt;</span> <span class="built_in">console</span>.log(i));      <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter方法</span></span><br><span class="line">[<span class="string">'a'</span>,, <span class="string">'b'</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>)    <span class="comment">// ['a', 'b']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// every方法</span></span><br><span class="line">[, <span class="string">'a'</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x === <span class="string">'a'</span>)   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce方法</span></span><br><span class="line">[<span class="number">1</span>,, <span class="number">2</span>].reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)     <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some方法</span></span><br><span class="line">[, <span class="string">'a'</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">'a'</span>)    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map方法</span></span><br><span class="line">[, <span class="string">'a'</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>)     <span class="comment">// [, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join方法</span></span><br><span class="line">[, <span class="string">'a'</span>, <span class="literal">undefined</span>, <span class="literal">null</span>].join(<span class="string">'#'</span>)  <span class="comment">// #a##</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toString方法</span></span><br><span class="line">[, <span class="string">'a'</span>, <span class="literal">undefined</span>, <span class="literal">null</span>].toString() <span class="comment">// ',a,,'</span></span><br></pre></td></tr></table></figure><p>ES6则是明确将空位转为<code>undefined</code>。</p><p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="string">'a'</span>,, <span class="string">'b'</span>])</span><br><span class="line"><span class="comment">// ['a', undefined, 'b']</span></span><br></pre></td></tr></table></figure><p>扩展运算符也会将空位转为<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[<span class="string">'a'</span>,,<span class="string">'b'</span>]]</span><br><span class="line"><span class="comment">// ['a', undefined, 'b']</span></span><br></pre></td></tr></table></figure><p><code>copyWithin()</code>会连空位一起拷贝。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[, <span class="string">'a'</span>, <span class="string">'b'</span>,,].copyWithin(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// [, 'a',, 'a']</span></span><br></pre></td></tr></table></figure><p><code>fill()</code>会将空位视为正常的数组位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment">// ['a', 'a', 'a']</span></span><br></pre></td></tr></table></figure><p><code>for...of</code>循环也会遍历空位。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [,,];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p><p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entries()</span></span><br><span class="line">[...[, <span class="string">'a'</span>].entries()]      <span class="comment">// [[0, undefined], [1, 'a']]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// keys()</span></span><br><span class="line">[...[, <span class="string">'a'</span>].keys()]         <span class="comment">// [0, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// values()</span></span><br><span class="line">[...[, <span class="string">'a'</span>].values()]       <span class="comment">// [undefined, 'a']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find()</span></span><br><span class="line">[, <span class="string">'a'</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>)     <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// findIndex()</span></span><br><span class="line">[, <span class="string">'a'</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>)    <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/array">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍ES6新标准中对数组的扩展。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/array&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id=&quot;一、扩展运算符&quot;&gt;&lt;a href=&quot;#一、扩展运算
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/categories/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/categories/JavaScript/ES6/"/>
    
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/tags/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6(16) 函数的扩展</title>
    <link href="http://www.xiaoleon.cn/2018/07/05/es6-16/"/>
    <id>http://www.xiaoleon.cn/2018/07/05/es6-16/</id>
    <published>2018-07-05T08:01:01.000Z</published>
    <updated>2019-01-22T14:35:01.561Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中对函数的扩展。节选自<a href="(http://es6.ruanyifeng.com/#docs/function">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、函数参数的默认值"><a href="#一、函数参数的默认值" class="headerlink" title="一、函数参数的默认值"></a>一、函数参数的默认值</h3><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><p>ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    y = y || <span class="string">'World'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'Hello'</span>)    <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>)   <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>)    <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure><p>上面代码检查函数<code>log</code>的参数<code>y</code>有没有赋值，如果没有，则指定默认值为<code>World</code>。这种写法的缺点在于，如果参数<code>y</code>赋值了，但是对应的布尔值为<code>false</code>，则该赋值不起作用。就像上面代码的最后一行，参数<code>y</code>等于空字符，结果被改为默认值。</p><p>为了避免这个问题，通常需要先判断一下参数<code>y</code>是否被赋值，如果没有，再等于默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    y = <span class="string">'World'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'Hello'</span>)    <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>)   <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>)    <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>可以看到，ES6的写法比ES5简洁许多，而且非常自然。下面是另一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Point();</span><br><span class="line">p   <span class="comment">// &#123;x: 0, y: 0&#125;</span></span><br></pre></td></tr></table></figure><p>除了简洁，ES6的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p><p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;  <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span>;    <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，参数变量<code>x</code>是默认声明的，在函数体中，不能用<code>let</code>或<code>const</code>再次声明，否则会报错。</p><p>使用参数默认值时，函数不能有同名参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, x, y = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError: Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure><p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()   <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">foo()   <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>p</code>的默认值是<code>x + 1</code>。这时，每次调用函数<code>foo</code>，都会重新计算<code>x + 1</code>，而不是默认<code>p</code>等于100。</p><h4 id="2-与解构赋值默认值结合使用"><a href="#2-与解构赋值默认值结合使用" class="headerlink" title="2. 与解构赋值默认值结合使用"></a>2. 与解构赋值默认值结合使用</h4><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;)     <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;)     <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;)       <span class="comment">// 1 2</span></span><br><span class="line">foo()       <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br></pre></td></tr></table></figure><p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数<code>foo</code>的参数是一个对象时，变量<code>x</code>和<code>y</code>才会通过解构赋值生成。如果函数<code>foo</code>调用时没有提供参数，变量<code>x</code>和<code>y</code>就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()   <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure><p>上面代码指定，如果没有提供参数，函数<code>foo</code>的参数默认为一个空对象。</p><p>下面是另一个解构赋值默认值的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123;body = <span class="string">''</span>, method = <span class="string">'get'</span>, headers = &#123;&#125;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// 'get'</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>)</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果函数<code>fetch</code>的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个擦拭农户，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123;body = <span class="string">''</span>, method = <span class="string">'get'</span>, headers = &#123;&#125;&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>)</span><br><span class="line"><span class="comment">// 'get'</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量<code>method</code>才会取到默认值<code>get</code>。</p><p>作为练习，请问下面两种写法有什么差别？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数没有参数的情况</span></span><br><span class="line">m1()    <span class="comment">// [0, 0]</span></span><br><span class="line">m2()    <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x和y都有值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;)    <span class="comment">// [3, 8]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;)    <span class="comment">// [3, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x有值，y无值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;)      <span class="comment">// [3, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;)      <span class="comment">// [3, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x和y都无值的情况</span></span><br><span class="line">m1(&#123;&#125;)      <span class="comment">// [0, 0]</span></span><br><span class="line">m2(&#123;&#125;)      <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br><span class="line">m1(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;)  <span class="comment">// [0, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;)  <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure><h4 id="3-参数默认值的位置"><a href="#3-参数默认值的位置" class="headerlink" title="3. 参数默认值的位置"></a>3. 参数默认值的位置</h4><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()     <span class="comment">// [1, undefined]</span></span><br><span class="line">f(<span class="number">2</span>)    <span class="comment">// [2, undefined]</span></span><br><span class="line">f(, <span class="number">1</span>)  <span class="comment">// 报错</span></span><br><span class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>)     <span class="comment">// [1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">5</span>, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()     <span class="comment">// [undefined, 5, undefined]</span></span><br><span class="line">f(<span class="number">1</span>)    <span class="comment">// [1, 5, undefined]</span></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 报错</span></span><br><span class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>)  <span class="comment">// [1, 5, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入<code>undefined</code>。</p><p>如果传入<code>undefined</code>，将触发该参数等于默认值，<code>null</code>则没有这个效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span>, y = <span class="number">6</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="literal">undefined</span>, <span class="literal">null</span>)    <span class="comment">// 5 null</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>x</code>参数对应<code>undefined</code>，结果触发了默认值，<code>y</code>参数等于<code>null</code>，就没有触发默认值。</p><h4 id="4-函数的length属性"><a href="#4-函数的length属性" class="headerlink" title="4. 函数的length属性"></a>4. 函数的length属性</h4><p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length        <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).lenth     <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>length</code>属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了3个参数，其中有一个参数<code>c</code>指定了默认值，因此<code>length</code>属性等于<code>3</code>减去<code>1</code>，最后得到<code>2</code>。</p><p>这是因为<code>length</code>属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的rest参数也不会计入<code>length</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;&#125;).length   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length      <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length      <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="5-作用域"><a href="#5-作用域" class="headerlink" title="5. 作用域"></a>5. 作用域</h4><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>)    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</p><p>再看下面的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()     <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。</p><p>如果此时，全局变量<code>x</code>不存在，就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()     <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>下面这样写，也会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = x</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()   <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>x = x</code>形成一个单独的作用域。实际执行的是<code>let x = x</code>，由于暂时性死区的原因，这行代码会报错“x未定义”。</p><p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">'outer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">func = (</span>) =&gt; <span class="title">foo</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> foo = <span class="string">'inner'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();      <span class="comment">// outer</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>bar</code>的参数<code>func</code>的默认值是一个匿名函数，返回值是变量<code>foo</code>。函数参数形成的单独作用域里面，并没有定义变量<code>foo</code>，所以<code>foo</code>指向外层的全局变量<code>foo</code>，因此输出<code>outer</code>。</p><p>如果写成下面这样，就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">func = (</span>) =&gt; <span class="title">foo</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> foo = <span class="string">'inner'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(func())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar()       <span class="comment">// ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，匿名函数里面的<code>foo</code>指向函数外层，但是函数外层并没有声明变量<code>foo</code>，所以就报错了。</p><p>下面是一个更复杂的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">    y();</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()       <span class="comment">// 3</span></span><br><span class="line">x           <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>foo</code>的参数形成了一个单独作用域。这个作用域里面，首先声明了变量<code>x</code>，然后声明了变量<code>y</code>，<code>y</code>的默认值是一个匿名函数。这个匿名函数内部的变量<code>x</code>，指向同一个作用域的第一个参数<code>x</code>。函数<code>foo</code>内部又声明了一个内部变量<code>x</code>，该变量与第一个参数<code>x</code>由于不是同一个作用域，所以不是同一个变量，因此执行<code>y</code>后，内部变量<code>x</code>和外部全局变量<code>x</code>的值都没变。</p><p>如果将<code>var x = 3</code>的<code>var</code>去除，函数<code>foo</code>的内部变量就指向第一个参数<code>x</code>，与匿名函数内部的<code>x</code>是一致的，所以最后输出的就是<code>2</code>，而外层的全局变量<code>x</code>依然不受影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</span><br><span class="line">    x = <span class="number">3</span>;</span><br><span class="line">    y();</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()       <span class="comment">// 2</span></span><br><span class="line">x           <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="6-应用"><a href="#6-应用" class="headerlink" title="6. 应用"></a>6. 应用</h4><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()   <span class="comment">// Error: Missing parameter</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>foo</code>函数，如果调用的时候没有参数，就会调用默认值<code>throwIfMissing</code>函数，从而抛出一个错误。</p><p>从上面代码还可以看到，参数<code>mustBeProvided</code>的默认值等于<code>throwIfMissing</code>函数的运行结果（注意函数名<code>throwIfMissing</code>之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p><p>另外，可以将参数默认值设为<code>undefined</code>，表明这个参数是可以省略的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">optional = undefined</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、rest参数"><a href="#二、rest参数" class="headerlink" title="二、rest参数"></a>二、rest参数</h3><p>ES6引入rest参数（形式为<code>...变量名</code>），用于获取函数的多于参数，这样就不需要使用<code>arguments</code>对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">        sum += val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>)        <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>add</code>函数是一个求和函数，利用rest参数，可以向该函数传入任意数目的参数。</p><p>下面是一个rest参数代替<code>arguments</code>变量的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments变量的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure><p>上面代码的两种写法，比较后可以发现，rest参数的写法更自然也更简洁。</p><p><code>arguments</code>对象不是数组，而是一个类数组对象，所以为了使用数组的方法，必须使用<code>Array.prototype.slice.call</code>先将其转为数组。rest参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用rest参数改写数组<code>push</code>方法的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...item</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">        <span class="built_in">console</span>.log(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, ...b, c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的<code>length</code>属性，不包括rest参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;&#125;).length     <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...a</span>) </span>&#123;&#125;).length  <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a, ...b</span>) </span>&#123;&#125;).length   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><hr><h3 id="三、严格模式"><a href="#三、严格模式" class="headerlink" title="三、严格模式"></a>三、严格模式</h3><p>从ES5开始，函数内部可以设定为严格模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES2016做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b = a</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;a, b&#125;</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">...a</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    doSomething(&#123;a, b&#125;) &#123;</span><br><span class="line"><span class="meta">        'use strict'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能直到参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">value = <span class="number">070</span></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>value</code>的默认值是八进制数<code>070</code>，但是严格模式下不能使用前缀<code>0</code>表示八进制，所以应该报错。但是实际上，JavaScript引擎会先成功执行<code>value = 070</code>，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p><p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</p><p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b = a</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是把函数包在一个无参数的立即执行函数里面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value = <span class="number">42</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><hr><h3 id="四、name属性"><a href="#四、name属性" class="headerlink" title="四、name属性"></a>四、name属性</h3><p>函数的<code>name</code>属性，返回该函数的函数名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.name    <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><p>这个属性早就被浏览器广泛支持，但是直到ES6，才将其写入了标准。</p><p>需要注意的是，ES6对这个属性的行为做出了一些修改。如果讲一个匿名函数赋值给一个变量，ES5的<code>name</code>属性，会返回空字符串，而ES6的name属性将会返回实际的函数名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f.name  <span class="comment">// ''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f.name  <span class="comment">// 'f'</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>f</code>等于一个匿名函数，ES5和ES6的<code>name</code>属性返回的值不一样。</p><p>如果将一个具名函数赋值给一个变量，则ES5和ES6的<code>name</code>属性都返回这个具名函数原本的名字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">bar.name    <span class="comment">// 'baz'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">bar.name    <span class="comment">// 'baz'</span></span><br></pre></td></tr></table></figure><p><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name     <span class="comment">// 'anonymous'</span></span><br></pre></td></tr></table></figure><p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">foo.bind(&#123;&#125;).name       <span class="comment">// 'bound foo'</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name    <span class="comment">// 'bound'</span></span><br></pre></td></tr></table></figure><hr><h3 id="五、箭头函数"><a href="#五、箭头函数" class="headerlink" title="五、箭头函数"></a>五、箭头函数</h3><h4 id="1-基本用法-1"><a href="#1-基本用法-1" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><p>ES6允许使用“箭头”（<code>=&gt;</code>）定义函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或者需要多个参数，就是用一个圆括号代表参数部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">'Temp'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> getTmepItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">'Temp'</span> &#125;);</span><br></pre></td></tr></table></figure><p>下面是一种特殊情况，虽然可以运行，但是会得到错误的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">foo()   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，原示意图是返回一个对象<code>{a: 1}</code>，但是由于引擎认为大括号是代码块，所以执行了一行语句<code>a: 1</code>。这时，<code>a</code>可以被解释为语句的标签，因此实际执行的语句是<code>1;</code>，然后函数就结束了，没有返回值。</p><p>如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span> dosNotReturn();</span><br></pre></td></tr></table></figure><p>箭头函数可以与变量结构结合使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123;first, second&#125;</span>) =&gt;</span> first + <span class="string">' '</span> + second;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数使得表达式更加简洁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br></pre></td></tr></table></figure><p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p><p>箭头函数的一个用处是简化回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure><p>另一个例子是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure><p>下面是rest参数与箭头函数结合的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = <span class="function">(<span class="params">...nums</span>) =&gt;</span> nums;</span><br><span class="line"></span><br><span class="line">numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)      <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> headAndTail = <span class="function">(<span class="params">head, ...tail</span>) =&gt;</span> [head, tail];</span><br><span class="line"></span><br><span class="line">headAndTail(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)  <span class="comment">// [1, [2, 3, 4, 5]]</span></span><br></pre></td></tr></table></figure><h4 id="2-使用注意点"><a href="#2-使用注意点" class="headerlink" title="2. 使用注意点"></a>2. 使用注意点</h4><p>箭头函数有几个使用注意点。</p><ul><li><p>1) 函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p></li><li><p>2) 不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p></li><li><p>3) 不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。</p></li><li><p>4) 不可以使用<code>yield</code>命令，因此箭头函数不能用作Generator函数。</p></li></ul><p>上面四点中，第一点尤其值得注意。<code>this</code>对象的指向是可变的，但是在箭头函数中，它是固定的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123;<span class="attr">id</span>: <span class="number">42</span>&#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到100毫秒以后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>{id: 42}</code>），所以输出的是<code>42</code>。</p><p>箭头函数可以让<code>setTimeout</code>里面的<code>this</code>，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.s2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 箭头函数</span></span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.s1++, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 普通函数</span></span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s2++;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'s1: '</span>, timer.s1), <span class="number">3000</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'s2: '</span>, timer.s2), <span class="number">3000</span>);</span><br><span class="line"><span class="comment">// s1: 3</span></span><br><span class="line"><span class="comment">// s2: 0</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Timer</code>函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的<code>this</code>绑定定义时所在的作用域（即<code>Timer</code>函数），后者的<code>this</code>指向运行时所在的作用域（即全局对象）。所以，3100毫秒以后，<code>timer.s1</code>被更新了3次，而<code>timer.s2</code>一次都没更新。</p><p>箭头函数可以让<code>this</code>指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数被封装在一个对象里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    id: <span class="string">'12345'</span>,</span><br><span class="line"></span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Handling '</span> + type + <span class="string">' for '</span> + <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<code>init</code>方法中，使用了箭头函数，这导致这个箭头函数里面的<code>this</code>，总是指向<code>handler</code>对象。否则，回调函数运行时，<code>this.doSomething</code>这一行会报错，因为此时<code>this</code>指向<code>document</code>对象。</p><p><code>this</code>指向的固定化，并不是因为箭头函数内部有绑定<code>this</code>的机制，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。</p><p>所以，箭头函数转成ES5的代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'id:'</span>, _this.id);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，转换后的ES5版本清楚地说明了，箭头函数里面根本没有自己的<code>this</code>，而是引用外层的<code>this</code>。</p><p>请问下面的代码之中有几个<code>this</code>？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = foo.call(&#123;<span class="attr">id</span>: <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = f.call(&#123;<span class="attr">id</span>: <span class="number">2</span>&#125;)()();       <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t2 = f().call(&#123;<span class="attr">id</span>: <span class="number">3</span>&#125;)();       <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t3 = f()().call(&#123;<span class="attr">id</span>: <span class="number">4</span>&#125;);       <span class="comment">// id: 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，只有一个<code>this</code>，就是函数<code>foo</code>的<code>this</code>，所以<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的<code>this</code>，它们的<code>this</code>其实都是最外层<code>foo</code>函数的<code>this</code>。</p><p>除了<code>this</code>，以下三个变量在箭头函数中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'args:'</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment">// args: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>上面代码中，箭头函数内部的变量<code>arguments</code>，其实是函数<code>foo</code>的<code>arguments</code>变量。</p><p>另外，由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        (<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.x).bind(&#123;<span class="attr">x</span>: <span class="string">'inner'</span>&#125;)()</span><br><span class="line">    ];</span><br><span class="line">&#125;).call(&#123;<span class="attr">x</span>: <span class="string">'outer'</span>&#125;);</span><br><span class="line"><span class="comment">// ['outer']</span></span><br></pre></td></tr></table></figure><p>上面代码中，箭头函数没有自己的<code>this</code>，所以<code>bind</code>方法无效，内部的<code>this</code>指向外部的<code>this</code>。</p><p>长期以来，JavaScript语言的<code>this</code>对象一直是一个令人头疼的问题，在对象方法中使用<code>this</code>，必须非常小心。箭头函数“绑定”<code>this</code>，很大程度上解决了这个困扰。</p><h4 id="3-嵌套的箭头函数"><a href="#3-嵌套的箭头函数" class="headerlink" title="3. 嵌套的箭头函数"></a>3. 嵌套的箭头函数</h4><p>箭头函数内部，还可以再使用箭头函数。下面是一个ES5语法的多重嵌套。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">into</span>: <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">after</span>: <span class="function"><span class="keyword">function</span>(<span class="params">afterValue</span>) </span>&#123;</span><br><span class="line">            array.splice(array.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>);    <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面这个函数，可以使用箭头函数改写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> insert = <span class="function">(<span class="params">value</span>) =&gt;</span> (&#123;<span class="attr">into</span>: <span class="function">(<span class="params">array</span>) =&gt;</span> (&#123;<span class="attr">after</span>: <span class="function">(<span class="params">afterValue</span>) =&gt;</span> &#123;</span><br><span class="line">    array.splice(array.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>);    <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是最后一个函数的输入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipeline = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> </span><br><span class="line">    val =&gt; funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b(a), val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> andThenMult = pipeline(plus1, mult2);</span><br><span class="line"></span><br><span class="line">addThenMult(<span class="number">5</span>)  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">mult2(plus1(<span class="number">5</span>))     <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><hr><h3 id="六、双冒号运算符"><a href="#六、双冒号运算符" class="headerlink" title="六、双冒号运算符"></a>六、双冒号运算符</h3><p>箭头函数可以绑定<code>this</code>对象，大大减少了显式绑定<code>this</code>对象的写法（<code>call</code>、<code>apply</code>、<code>bind</code>）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代<code>call</code>、<code>apply</code>、<code>bind</code>调用。</p><p>函数绑定运算符是并排的两个冒号（<code>::</code>），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即<code>this</code>对象），绑定到右边的函数上面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo::bar;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.bind(foo);</span><br><span class="line"></span><br><span class="line">foo::bar(...arguments);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.apply(foo, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasOwn</span>(<span class="params">obj, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj::hasOwnProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定到该对象上面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> method = obj::obj.foo;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> method = ::obj.foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> log = ::<span class="built_in">console</span>.log;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>);</span><br></pre></td></tr></table></figure><p>如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;map, takeWhile, forEach&#125; <span class="keyword">from</span> <span class="string">'iterlib'</span>;</span><br><span class="line"></span><br><span class="line">getPlayers()</span><br><span class="line">::map(<span class="function"><span class="params">x</span> =&gt;</span> x.character())</span><br><span class="line">::takeWhile(<span class="function"><span class="params">x</span> =&gt;</span> x.strength &gt; <span class="number">100</span>)</span><br><span class="line">::forEach(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure><hr><h3 id="七、尾调用优化"><a href="#七、尾调用优化" class="headerlink" title="七、尾调用优化"></a>七、尾调用优化</h3><h4 id="1-什么是尾调用"><a href="#1-什么是尾调用" class="headerlink" title="1. 什么是尾调用"></a>1. 什么是尾调用</h4><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>的最后一步是调用函数<code>g</code>，这就叫尾调用。</p><p>以下三种情况，都不属于尾调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = g(x);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，情况一是调用函数<code>g</code>之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    g(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾调用不一定出现在函数尾部，只要是最后一部操作即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> m(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>m</code>和<code>n</code>都属于尾调用，因为它们都是函数<code>f</code>的最后一步操作。</p><h4 id="2-尾调用优化"><a href="#2-尾调用优化" class="headerlink" title="2. 尾调用优化"></a>2. 尾调用优化</h4><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p><p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧。所有的调用帧，就形成一个“调用栈”（call stack）。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">g(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果函数<code>g</code>不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。</p><p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一帧，这将大大节省内存。这就是“尾调用优化”的意义。</p><p>注意，只有不再用到外层函数的内变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p><h4 id="3-严格模式"><a href="#3-严格模式" class="headerlink" title="3. 严格模式"></a>3. 严格模式</h4><p>ES6的尾递归优化只在严格模式下开启，正常模式下是无效的。</p><p>这是因为正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><ul><li><p><code>func.arguments</code>：返回调用时函数的参数。</p></li><li><p><code>func.caller</code>：返回调用当前函数的那个函数。</p></li></ul><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restricted</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    restriced.caller;       <span class="comment">// 报错</span></span><br><span class="line">    restricted.arguments;   <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line">restricted();</span><br></pre></td></tr></table></figure><h4 id="4-尾递归优化的实现"><a href="#4-尾递归优化的实现" class="headerlink" title="4. 尾递归优化的实现"></a>4. 尾递归优化的实现</h4><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p><p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p><p>下面是一个正常的递归函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>);</span><br><span class="line"><span class="comment">// Uncaught RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>sum</code>是一个递归函数，参数<code>x</code>是需要累加的值，参数<code>y</code>控制递归次数。一旦指定<code>sum</code>递归100000次，就会报错，提示超出调用栈的最大次数。</p><p>蹦床函数（trampoline）可以将递归执行转换为循环执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(f &amp;&amp; f <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">        f = f();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是蹦床函数的一个实现，它接受一个函数<code>f</code>作为参数。只要<code>f</code>执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p><p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum.bind(<span class="literal">null</span>, x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>sum</code>函数的每次执行，都会返回自身的另一个版本。</p><p>现在，使用蹦床函数执行<code>sum</code>，就不会发生调用栈溢出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trampoline(sum(<span class="number">1</span>, <span class="number">100000</span>));</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure><p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tco</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">var</span> active = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> accumulated = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">accumulator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        accumulated.push(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">            active = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(accumulated.length) &#123;</span><br><span class="line">                value = f.apply(<span class="keyword">this</span>, accumulated.shift());</span><br><span class="line">            &#125;</span><br><span class="line">            active = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = tco(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>);</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<code>sum</code>返回的都是<code>undefined</code>，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/function">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中对函数的扩展。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/function&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/categories/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/categories/JavaScript/ES6/"/>
    
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/tags/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6(15) class的继承</title>
    <link href="http://www.xiaoleon.cn/2018/07/03/es6-15/"/>
    <id>http://www.xiaoleon.cn/2018/07/03/es6-15/</id>
    <published>2018-07-03T08:02:50.000Z</published>
    <updated>2019-01-22T14:34:47.529Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中class的继承。节选自<a href="(http://es6.ruanyifeng.com/#docs/class-extends">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>Class可以通过<code>extends</code>关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。下面，我们在<code>ColorPoint</code>内部加上代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类字迹的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> ColorPoint();  <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p><p>ES5的继承，实质是新创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6的继承机制完全不同，实质是先创造父类的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p><p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">        <span class="keyword">super</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个需要注意的地方是，在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有<code>super</code>方法才能返回父类实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;     <span class="comment">// ReferenceError</span></span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.color = color;     <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，子类的<code>constructor</code>方法没有调用<code>super</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super</code>方法之后就是正确的。</p><p>下面是生成子类实例的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> ColorPoint(<span class="number">25</span>, <span class="number">8</span>, <span class="string">'green'</span>);</span><br><span class="line"></span><br><span class="line">cp <span class="keyword">instanceof</span> ColorPoint    <span class="comment">// true</span></span><br><span class="line">cp <span class="keyword">instanceof</span> Point     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致。</p><p>最后，父类的静态方法，也会被子类继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> hello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.hello()   <span class="comment">// 'hello world'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>hello()</code>是A类的静态方法，B继承A，也继承了A的静态方法。</p><hr><h3 id="二、Object-getPrototypeOf"><a href="#二、Object-getPrototypeOf" class="headerlink" title="二、Object.getPrototypeOf()"></a>二、Object.getPrototypeOf()</h3><p><code>Object.getPrototypeOf(ColorPoint)</code>方法可以用来从子类上获取父类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(ColorPoint) === Point     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><hr><h3 id="三、super关键字"><a href="#三、super关键字" class="headerlink" title="三、super关键字"></a>三、super关键字</h3><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6要求，子类的构造函数必须执行一次<code>super</code>函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，子类B的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则JavaScript引擎会报错。</p><p>注意，<code>super</code>虽然代表了父类A的构造函数，但是返回的是子类B的实例，即<code>super</code>内部的<code>this</code>指的是B，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A()     <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> B()     <span class="comment">// B</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是B。</p><p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    m() &#123;</span><br><span class="line">        <span class="keyword">super</span>();        <span class="comment">// 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>super()</code>用在B类的m方法之中，就会造成句法错误。</p><p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    p() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.p());     <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>上面代码中，子类B当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p><p>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.p = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    get m() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m     <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p</code>是父类A实例的属性，<code>super.p</code>就引用不到它。</p><p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">A.prototype.x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.x)    <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>上面代码中，属性<code>x</code>是定义在<code>A.prototype</code>上面的，所以<code>super.x</code>可以取到它的值。</p><p>ES6规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    print() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m() &#123;</span><br><span class="line">        <span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m()       <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是<code>super.print.call(this)</code>。</p><p>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">super</span>.x = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.x);   <span class="comment">// undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);    <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.x</code>赋值为3，这时等同于对<code>this.x</code>赋值为3。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p><p>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> myMethod(msg) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'static'</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    myMethod(msg) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'instance'</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> myMethod(msg) &#123;</span><br><span class="line">        <span class="keyword">super</span>.myMethod(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    myMethod(msg) &#123;</span><br><span class="line">        <span class="keyword">super</span>.myMethod(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.myMethod(<span class="number">1</span>);      <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</span><br><span class="line">child.myMethod(<span class="number">2</span>);      <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p><p>另外，在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> print() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> m() &#123;</span><br><span class="line">        <span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.x = <span class="number">3</span>;</span><br><span class="line">B.m()   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是B，而不是B的实例。</p><p>注意，使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>);     <span class="comment">// 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>console.log(super)</code>当中的<code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以JavaScript引擎解析代码的时候就会报错。这时，如果能清晰地表明<code>super</code>的数据类型，就不会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.valueOf() <span class="keyword">instanceof</span> B);  <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.valueOf()</code>表明<code>super</code>是一个对象，因此就不会报错。同时，由于<code>super</code>使得<code>this</code>指向B的实例，所以<code>super.valueOf()</code>返回的是一个B的实例。</p><p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'MyObject: '</span> + <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.toString();     <span class="comment">// MyObject: [object Object]</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、类的prototype属性和proto属性"><a href="#四、类的prototype属性和proto属性" class="headerlink" title="四、类的prototype属性和proto属性"></a>四、类的prototype属性和<strong>proto</strong>属性</h3><p>大多数浏览器的ES5实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><ul><li><p>1) 子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p></li><li><p>2) 子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A   <span class="comment">// true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，子类B的<code>__proto__</code>属性指向父类A，子类B的<code>prototype</code>属性的<code>__proto__</code>属性指向父类A的<code>prototype</code>属性。</p><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B的实例继承A的实例</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B继承A的静态属性</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B, A);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>《对象的扩展》一章给出过<code>Object.setPrototypeOf</code>方法的实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf = <span class="function"><span class="keyword">function</span>(<span class="params">obj, proto</span>) </span>&#123;</span><br><span class="line">    obj.__proto__ = proto;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，就得到了上面的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B, A);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.__proto__ = A;</span><br></pre></td></tr></table></figure><p>这两条继承链，可以这样理解：作为一个对象，子类B的原型（<code>__proto__</code>）是父类A；作为一个构造函数，子类B的原型对象（<code>prototype</code>）是父类的原型对象（<code>prototype</code>）的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(A.prototype);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br></pre></td></tr></table></figure><p><code>extends</code>关键字后面可以跟多种类型的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面代码的A，只要是一个有<code>prototype</code>属性的函数，就能被B继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此A可以是任意函数。</p><p>下面，讨论两种情况。第一种，子类继承Object类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这种情况下，A其中就是构造函数Object的赋值，A的实例就是Object的实例。</p><p>第二种情况，不存在任何继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这种情况下，A作为一个基类，就是一个普通函数，所以直接继承<code>Function.prototype</code>。但是，A调用后返回一个空对象（即Object实例），所以<code>A.prototype.__proto__</code>指向构造函数（Object）的<code>prototype</code>属性。</p><hr><h3 id="五、原生构造函数的继承"><a href="#五、原生构造函数的继承" class="headerlink" title="五、原生构造函数的继承"></a>五、原生构造函数的继承</h3><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。</p><ul><li><p>Boolean()</p></li><li><p>Number()</p></li><li><p>String()</p></li><li><p>Array()</p></li><li><p>Date()</p></li><li><p>Function()</p></li><li><p>RegExp()</p></li><li><p>Error()</p></li><li><p>Object()</p></li></ul><p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个<code>Array</code>的子类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: MyArray,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码定义了一个继承Array的<code>MyArray</code>类。但是，这个类的行为与<code>Array</code>完全不一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span>;</span><br><span class="line">colors.length   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">0</span>;</span><br><span class="line">colors[<span class="number">0</span>]   <span class="comment">// 'red'</span></span><br></pre></td></tr></table></figure><p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。</p><p>ES5是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。</p><p>下面的例子中，我们想让一个普通对象继承<code>Error</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Error</span>.call(e))</span><br><span class="line"><span class="comment">// ['stack']</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(e)</span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>上面代码中，我们想通过<code>Error.call(e)</code>这种写法，让普通对象<code>e</code>具有<code>Error</code>对象的实例属性。但是，<code>Error.call()</code>完全忽略传入的第一个参数，而是返回一个新对象，<code>e</code>本身没有任何变化。这证明了<code>Error.call(e)</code>这种写法，无法继承原生构造函数。</p><p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">        <span class="keyword">super</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> MyArray();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.length;     <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>];         <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。</p><p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionedArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.history = [[]];</span><br><span class="line">    &#125;</span><br><span class="line">    commit() &#123;</span><br><span class="line">        <span class="keyword">this</span>.history.push(<span class="keyword">this</span>.slice());</span><br><span class="line">    &#125;</span><br><span class="line">    revert() &#123;</span><br><span class="line">        <span class="keyword">this</span>.splice(<span class="number">0</span>, <span class="keyword">this</span>.length, ...this.histroy[<span class="keyword">this</span>.history.length - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> VersionedArray();</span><br><span class="line"></span><br><span class="line">x.push(<span class="number">1</span>);</span><br><span class="line">x.push(<span class="number">2</span>);</span><br><span class="line">x   <span class="comment">// [1, 2]</span></span><br><span class="line">x.history   <span class="comment">// [[]]</span></span><br><span class="line"></span><br><span class="line">x.commit();</span><br><span class="line">x.history   <span class="comment">// [[], [1, 2]]</span></span><br><span class="line"></span><br><span class="line">x.push(<span class="number">3</span>);</span><br><span class="line">x   <span class="comment">// [1, 2, 3]</span></span><br><span class="line">x.history   <span class="comment">// [[], [1, 2]]</span></span><br><span class="line"></span><br><span class="line">x.revert();</span><br><span class="line">x   <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，VersionedArray会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，VersionedArray依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p><p>下面是一个自定义Error子类的例子，可以用来定制报错时的行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendableError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(message) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.stack = (<span class="keyword">new</span> <span class="built_in">Error</span>()).stack;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="keyword">this</span>.constructor.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span> <span class="keyword">extends</span> <span class="title">ExtenableError</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(m) &#123;</span><br><span class="line">        <span class="keyword">super</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myerror = <span class="keyword">new</span> MyError(<span class="string">'11'</span>);</span><br><span class="line">myerror.message     <span class="comment">// 11</span></span><br><span class="line">myerror <span class="keyword">instanceof</span> <span class="built_in">Error</span>    <span class="comment">// true</span></span><br><span class="line">myerror.name        <span class="comment">// 'MyError'</span></span><br><span class="line">myerror.stack</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="comment">// at Myerror.ExtendableError</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>注意，继承Object的子类，有一个行为差异。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewObj</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> NewObj(&#123;<span class="attr">attr</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">o.attr === <span class="literal">true</span>     <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，NewObj继承了Object，但是无法通过<code>super</code>方法向父类Object传参。这是因为ES6改变了Object构造函数的行为，一旦发现Object不是通过<code>new Object()</code>这种形式调用，ES6规定Object构造函数会忽略参数。</p><hr><h3 id="六、Mixin模式的实现"><a href="#六、Mixin模式的实现" class="headerlink" title="六、Mixin模式的实现"></a>六、Mixin模式的实现</h3><p>Mixin指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">a</span>: <span class="string">'a'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">b</span>: <span class="string">'b'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = &#123; ...a, ...b &#125;;   <span class="comment">// &#123;a: 'a', b: 'b'&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>c</code>对象是<code>a</code>对象和<code>b</code>对象的合成，具有两者的接口。</p><p>下面是一个更完备的实现，将多个类的接口“混入”另一个类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mix</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">        <span class="comment">// 拷贝实例属性</span></span><br><span class="line">        copyProperties(Mix.prototype, mixin);</span><br><span class="line">        <span class="comment">// 拷贝原型属性</span></span><br><span class="line">        copyProperties(Mix.prototype, <span class="built_in">Reflect</span>.getPrototypeOf(mixin));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Mix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyProperties</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(source)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== <span class="string">'constructor'</span> &amp;&amp;</span><br><span class="line">            key !== <span class="string">'prototype'</span> &amp;&amp;</span><br><span class="line">            key !== <span class="string">'name'</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, key);</span><br><span class="line">                <span class="built_in">Object</span>.defineProperty(target, key, desc);</span><br><span class="line">            &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<code>mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DistributedEdit</span> <span class="keyword">extends</span> <span class="title">mix</span>(<span class="title">Loggable</span>, <span class="title">Serializable</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/class-extends">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中class的继承。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/class-extends&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/categories/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/categories/JavaScript/ES6/"/>
    
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/tags/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6(14) class的基本语法</title>
    <link href="http://www.xiaoleon.cn/2018/07/03/es6-14/"/>
    <id>http://www.xiaoleon.cn/2018/07/03/es6-14/</id>
    <published>2018-07-03T08:02:41.000Z</published>
    <updated>2019-01-22T14:34:29.102Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中class的基本语法。节选自<a href="(http://es6.ruanyifeng.com/#docs/class">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>JavaScript语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p><p>基本上，ES6的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的<code>class</code>改写，就是下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。也就是说，ES5的构造函数<code>Point</code>，对应ES6的<code>Point</code>类的构造方法。</p><p><code>Point</code>类除了构造方法，还定义了一个<code>toString</code>方法。注意，定义“类”的方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p><p>ES6的类，完全可以看作构造函数的另一种写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Point <span class="comment">// 'function'</span></span><br><span class="line">Point === Point.prototype.constructor   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p><p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    doStuff() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'stuff'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Bar();</span><br><span class="line">b.doStuff();        <span class="comment">// 'stuff'</span></span><br></pre></td></tr></table></figure><p>构造函数的<code>prototype</code>属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toValue() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">    toString() &#123;&#125;,</span><br><span class="line">    toValue() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在类的实例上面调用方法，其实就是调用原型上的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">b.constructor === B.prototype.constructor   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，b是B的实例，它的<code>constructor</code>方法就是B类原型的<code>constructor</code>方法。</p><p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</span><br><span class="line">    toString() &#123;&#125;,</span><br><span class="line">    toValue() &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>prototype</code>对象的<code>constructor</code>属性，直接指向“类”的本身，这与ES5的行为是一致的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point.prototype.constructor === Point   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class="line"><span class="comment">// ['constructor', 'toString']</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>toString</code>方法是<code>Point</code>类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Point = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// ['toString']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class="line"><span class="comment">// ['constructor', 'toString']</span></span><br></pre></td></tr></table></figure><p>上面代码采用ES5的写法，<code>toString</code>就是可枚举的。</p><p>类的属性名，可以采用表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">'getArea'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [methodName]() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Square</code>类的方法名<code>getArea</code>，是从表达式得到的。</p><hr><h3 id="二、严格模式"><a href="#二、严格模式" class="headerlink" title="二、严格模式"></a>二、严格模式</h3><p>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p><p>考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。</p><hr><h3 id="三、constructor方法"><a href="#三、constructor方法" class="headerlink" title="三、constructor方法"></a>三、constructor方法</h3><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显示定义，一个空的<code>constructor</code>方法会被默认添加。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，定义了一个空的类<code>Point</code>，JavaScript引擎会自动为它添加一个空的<code>constructor</code>方法。</p><p><code>constructor</code>方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>constructor</code>函数返回一个全新的对象，结果导致实力对象不是Foo类的实例。</p><p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo()   <span class="comment">// TypeError: Class constructor Foo connot be invoked without 'new'</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、类的实例对象"><a href="#四、类的实例对象" class="headerlink" title="四、类的实例对象"></a>四、类的实例对象</h3><p>生成类的实例对象的写法，与ES5完全一样，也是使用<code>new</code>命令。前面说过，如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> point = Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>与ES5一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'('</span> + x + <span class="string">', '</span> + y + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point  = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">point.toString()    <span class="comment">// (2, 3)</span></span><br><span class="line"></span><br><span class="line">point.hasOwnProperty(<span class="string">'x'</span>)   <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'y'</span>)   <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'toString'</span>)    <span class="comment">// false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">'toString'</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性（因为定义在<code>this</code>变量上），所以<code>hasOwnProperty</code>方法返回<code>true</code>，而<code>toString</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty</code>方法返回<code>false</code>。这些都与ES5的行为保持一致。</p><p>与ES5一样，类的所有实例共享一个原型对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.__proto__ === p2.__proto__   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Point</code>的实例，它们的原型都是<code>Point.prototype</code>，所以<code>__proto__</code>属性是相等的。</p><p>这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.__proto__.printName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'Oops'</span>; &#125;;</span><br><span class="line"></span><br><span class="line">p1.printName()      <span class="comment">// 'Oops'</span></span><br><span class="line">p2.printName()      <span class="comment">// 'Oops'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> Point(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">p3.printName()      <span class="comment">// 'Oops'</span></span><br></pre></td></tr></table></figure><p>上面代码在<code>p1</code>的原型上添加了一个<code>printName</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。这意味着，使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p><hr><h3 id="五、Class表达式"><a href="#五、Class表达式" class="headerlink" title="五、Class表达式"></a>五、Class表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">    getClassName() &#123;</span><br><span class="line">        <span class="keyword">return</span> Me.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是<code>MyClass</code>而不是<code>Me</code>，<code>Me</code>只在Class的内部代码可用指代当前类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line">inst.getClassName()     <span class="comment">// Me</span></span><br><span class="line">Me.name     <span class="comment">// ReferenceError: Me is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码表示，<code>Me</code>只在Class内部有定义。</p><p>如果类的内部没用到的话，可以省略<code>Me</code>，也就是可以写成下面的形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>采用Class表达式，可以写出立即执行的Class。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line">person.sayName();   <span class="comment">// '张三'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>person</code>是一个立即执行的类的实例。</p><hr><h3 id="六、不存在变量提升"><a href="#六、不存在变量提升" class="headerlink" title="六、不存在变量提升"></a>六、不存在变量提升</h3><p>类不存在变量提升（hoist），这一点与ES5完全不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo();      <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Foo</code>类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> Foo = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码不会报错，因为<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>已经有定义了。但是，如果存在<code>class</code>的提升，上面代码就会报错，因为<code>class</code>会被提升到代码头部，而<code>let</code>命令是不提升的，所以导致<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>还没有定义。</p><hr><h3 id="七、私有方法和私有属性"><a href="#七、私有方法和私有属性" class="headerlink" title="七、私有方法和私有属性"></a>七、私有方法和私有属性</h3><h4 id="1-现有的方法"><a href="#1-现有的方法" class="headerlink" title="1. 现有的方法"></a>1. 现有的方法</h4><p>私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。</p><p>一种做法是在命名上加以区别。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 公有方法</span></span><br><span class="line">    foo (baz) &#123;</span><br><span class="line">        <span class="keyword">this</span>._bar(baz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    _bar (baz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>_bar</code>方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用这个方法。</p><p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    foo (baz) &#123;</span><br><span class="line">        bar.call(<span class="keyword">this</span>.baz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>foo</code>是公有方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar</code>实际上成为了当前模块的私有方法。</p><p>还有一种方法是利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">'snaf'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 公有方法</span></span><br><span class="line">    foo (baz) &#123;</span><br><span class="line">        <span class="keyword">this</span>[bar](baz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [bar] (baz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[snaf] = baz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>bar</code>和<code>snaf</code>都是<code>Symbol</code>值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p><h4 id="2-私有属性的提案"><a href="#2-私有属性的提案" class="headerlink" title="2. 私有属性的提案"></a>2. 私有属性的提案</h4><p>与私有方法一样，ES6不支持私有属性。目前有一个提案，为<code>class</code>添加了私有属性。方法是在属性名之前，使用<code>#</code>表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    #x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(x = 0) &#123;</span><br><span class="line">        #x = +x;    // 写成 this.#x 亦可</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get x() &#123; return #x; &#125;</span><br><span class="line">    set x(value &#123; #x = +value; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>#x</code>就是私有属性，在Point类之外是无法读取到这个属性的。由于<code>#</code>是属性名的一部分，使用时必须带有<code>#</code>一起使用，所以<code>#x</code>和<code>x</code>是两个不同的属性。</p><p>私有属性可以指定初始值，在构造函数执行时进行初始化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    #x = 0;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        #x;     // 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以要引入一个新的前缀<code>#</code>表示私有属性，而没有采用<code>private</code>关键字，是因为JavaScript是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是否为私有属性。另外，Ruby语言使用<code>@</code>表示私有属性，ES6没有用这个符号而使用<code>#</code>，是因为<code>@</code>已经被留给了Decorator。</p><p>这种写法不仅可以写私有属性，还可以用来写私有方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    #a;</span><br><span class="line">    #b;</span><br><span class="line">    #sum() &#123; return #a + #b; &#125;</span><br><span class="line">    printSum() &#123; console.log(#sum()); &#125;</span><br><span class="line">    constructor(a, b) &#123; #a = a; #b = b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>#sum()</code>就是一个私有方法。</p><p>另外，私有属性也可以设置getter和setter方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    #xValue = 0;</span><br><span class="line"></span><br><span class="line">    get #x() &#123; return #xValue; &#125;</span><br><span class="line">    set #x(value) &#123;</span><br><span class="line">        #xValue = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>#x</code>是一个私有属性，它的读写都通过<code>get #x()</code>和<code>set #x()</code>来完成。</p><hr><h3 id="八、this的指向"><a href="#八、this的指向" class="headerlink" title="八、this的指向"></a>八、this的指向</h3><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    printName(name = <span class="string">'there'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(text) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</span><br><span class="line">printName();    <span class="comment">// TypeError: Cannot read property 'print' of undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境，因为找不到<code>print</code>方法而导致报错。</p><p>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.printName = <span class="keyword">this</span>.printName.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种解决方法是使用箭头函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.printName = <span class="function">(<span class="params">name = <span class="string">'there'</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种解决方法是使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selfish</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">    <span class="keyword">const</span> handler = &#123;</span><br><span class="line">        get(target, key) &#123;</span><br><span class="line">            <span class="keyword">const</span> value = <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!cache.has(value)) &#123;</span><br><span class="line">                cache.set(value, value.bind(target));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cache.get(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = selfish(<span class="keyword">new</span> Logger());</span><br></pre></td></tr></table></figure><hr><h3 id="九、name属性"><a href="#九、name属性" class="headerlink" title="九、name属性"></a>九、name属性</h3><p>由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line">Point.name      <span class="comment">// "Point"</span></span><br></pre></td></tr></table></figure><p><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p><hr><h3 id="十、Class的取值函数（getter）和存值函数（setter）"><a href="#十、Class的取值函数（getter）和存值函数（setter）" class="headerlink" title="十、Class的取值函数（getter）和存值函数（setter）"></a>十、Class的取值函数（getter）和存值函数（setter）</h3><p>与ES5一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get prop() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'getter'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    set prop(value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setter: '</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;        <span class="comment">// setter: 123</span></span><br><span class="line">inst.prop;              <span class="comment">// getter</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p><p>存值函数和取值函数是设置在属性的Descriptor对象上的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get html() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set html(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element.innerHTML = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(</span><br><span class="line">    CustomeHTMLElement.prototype, <span class="string">'html'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="string">'get'</span> <span class="keyword">in</span> descriptor     <span class="comment">// true</span></span><br><span class="line"><span class="string">'set'</span> <span class="keyword">in</span> descriptor     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，存值函数和取值函数是定义在<code>html</code>属性的描述对象上面，这与ES5完全一致。</p><hr><h3 id="十一、Class的Generator方法"><a href="#十一、Class的Generator方法" class="headerlink" title="十一、Class的Generator方法"></a>十一、Class的Generator方法</h3><p>如果某个方法之前加上星号（<code>*</code>），就表示该方法是一个Generator函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">        <span class="keyword">this</span>.args = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="keyword">this</span>.args) &#123;</span><br><span class="line">            <span class="keyword">yield</span> arg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="keyword">new</span> Foo(<span class="string">'hello'</span>, <span class="string">'world'</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Foo</code>类的<code>Symbol.iterator</code>方法前有一个星号，表示该方法是一个Generator函数。<code>Symbol.iterator</code>方法返回一个<code>Foo</code>类的默认遍历器，<code>for...of</code>循环会自动调用这个遍历器。</p><hr><h3 id="十二、Class的静态方法"><a href="#十二、Class的静态方法" class="headerlink" title="十二、Class的静态方法"></a>十二、Class的静态方法</h3><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod()       <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()       <span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p><p>注意，如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> bar() &#123;</span><br><span class="line">        <span class="keyword">this</span>.baz();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> baz() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    baz() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar()       <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure><p>上面代码中，静态方法<code>bar</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>Foo</code>类，而不是<code>Foo</code>的实例，等同于调用<code>Foo.baz</code>。另外，从这个例子中还可以看出，静态方法可以与非静态方法重名。</p><p>父类的静态方法，可以被子类继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod()   <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure><p>上面代码中，父类<code>Foo</code>有一个静态方法，子类<code>Bar</code>可以调用这个方法。</p><p>静态方法也是可以从<code>super</code>对象上调用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.classMethod() + <span class="string">', too'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod()   <span class="comment">// 'hello, too'</span></span><br></pre></td></tr></table></figure><hr><h3 id="十三、Class的静态属性和实例属性"><a href="#十三、Class的静态属性和实例属性" class="headerlink" title="十三、Class的静态属性和实例属性"></a>十三、Class的静态属性和实例属性</h3><p>静态属性指的是Class本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop    <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面的写法为<code>Foo</code>类定义了一个静态属性<code>prop</code>。</p><p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下写法都无效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写法一</span></span><br><span class="line">    prop: <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写法二</span></span><br><span class="line">    <span class="keyword">static</span> prop: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>目前有一个静态属性的提案，对实例属性和静态属性都规定了新的写法。</p><ul><li>1) 类的实例属性</li></ul><p>类的实例属性可以用等式，写入类的定义之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    myProp = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.myProp);       <span class="comment">// 42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>myProp</code>就是<code>MyClass</code>的实例属性。在<code>MyClass</code>的实例上，可以读取这个属性。</p><p>以前，我们定义实例属性，只能写在类的<code>constructor</code>方法里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，构造方法<code>constructor</code>里面，定义了<code>this.state</code>属性。</p><p>有了新的写法以后，可以不在<code>constructor</code>方法里面定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法比以前更清晰。</p><p>为了可读性的目的，对于那些在<code>constructor</code>里面已经定义的实例属性，新写法允许直接列出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2) 类的静态属性</li></ul><p>类的静态属性只要在上面的实例属性写法前面，加上<code>static</code>关键字就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> myStaticProp = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(MyClass.myStaticProp);  <span class="comment">// 42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，这个新写法大大方便了静态属性的表达。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> prop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性，这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p><hr><h3 id="十四、new-target属性"><a href="#十四、new-target属性" class="headerlink" title="十四、new.target属性"></a>十四、new.target属性</h3><p><code>new</code>是从构造函数生成实例对象的命令。ES6为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用new命令生成实例'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用new命令生成实例'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'张三'</span>);    <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">'张三'</span>)    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码确保构造函数只能通过<code>new</code>命令调用。</p><p>Class内部调用<code>new.target</code>，返回当前Class。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>需要注意的是，子类继承父类，<code>new.target</code>会返回子类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>)     <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>new.target</code>会返回子类。</p><p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'本类不能实例化'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Shape();        <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Shape</code>类不能被实例化，只能用于继承。</p><p>注意，在函数外部，使用<code>new.target</code>会报错。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/class">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中class的基本语法。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/class&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/categories/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/categories/JavaScript/ES6/"/>
    
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/tags/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6(13) async函数</title>
    <link href="http://www.xiaoleon.cn/2018/06/13/es6-13/"/>
    <id>http://www.xiaoleon.cn/2018/06/13/es6-13/</id>
    <published>2018-06-13T02:14:46.000Z</published>
    <updated>2018-06-13T23:20:41.816Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中async函数。节选自<a href="(http://es6.ruanyifeng.com/#docs/async">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、含义"><a href="#一、含义" class="headerlink" title="一、含义"></a>一、含义</h3><p>ES2017标准引入了async函数，使得异步操作变得更加方便。</p><p>async函数是什么？一句话，它就是Generator函数的语法糖。</p><p>前文有一个Generator函数，依次读取两个文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写成<code>async</code>函数，就是下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一比较就会发现，<code>async</code>函数就是将Generator函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p><p><code>async</code>函数对Generator函数的改进，体现在以下四点。</p><ul><li>1) 内置执行器</li></ul><p>Generator函数的执行必须依靠执行器，所以才有了co模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure><p>上面代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像Generator函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p><ul><li>2) 更好的语义</li></ul><p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更加清楚。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p><ul><li>3) 更广的适用性</li></ul><p><code>co</code>模块约定，<code>yield</code>命令后面只能是Thunk函数或Promise对象，而<code>async</code>函数的<code>await</code>命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p><ul><li>4) 返回值是Promise</li></ul><p><code>async</code>函数的返回值是Promise对象，这笔Generator函数的返回值是Iterator对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p><p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成一个Promise对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p><hr><h3 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h3><p><code>async</code>函数返回一个Promise对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><p>下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> symbol = <span class="keyword">await</span> getStockSymbol(name);</span><br><span class="line">    <span class="keyword">const</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</span><br><span class="line">    <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。</p><p>下面是另一个例子，指定多少毫秒后输出一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve, ms);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> timeout(ms);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>上面代码指定50毫秒以后，输出<code>hello world</code>。</p><p>由于<code>async</code>函数返回的是Promise对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimout(resolve, ms);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> timeout(ms);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>async函数有多种使用形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> foo () &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.cachePromise = caches.open(<span class="string">'avatars'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> getAvatar(name) &#123;</span><br><span class="line">        <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="keyword">this</span>.cachePromise;</span><br><span class="line">        <span class="keyword">return</span> cache.match(<span class="string">`/avatar/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> Storage();</span><br><span class="line">storage.getAvatar(<span class="string">'jake'</span>).then(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h3><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p><h4 id="1-返回Promise对象"><a href="#1-返回Promise对象" class="headerlink" title="1. 返回Promise对象"></a>1. 返回Promise对象</h4><p><code>async</code>函数返回一个Promise对象。</p><p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 'hello world'</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p><p><code>async</code>函数内部抛出错误，会导致返回的Promise对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(</span><br><span class="line">    v =&gt; <span class="built_in">console</span>.log(v),</span><br><span class="line">    e =&gt; <span class="built_in">console</span>.log(e)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Error: 出错了</span></span><br></pre></td></tr></table></figure><h4 id="2-Promise对象的状态变化"><a href="#2-Promise对象的状态变化" class="headerlink" title="2. Promise对象的状态变化"></a>2. Promise对象的状态变化</h4><p><code>async</code>函数返回的Promise对象，必须等到内部所有<code>await</code>命令后面的Promise对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p><p>下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">let</span> html = <span class="keyword">await</span> response.text();</span><br><span class="line">    <span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span><span class="regexp">/)[1];</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">getTitle('https:/</span><span class="regexp">/tc39.github.io/</span>ecma262<span class="string">').then(console.log)</span></span><br><span class="line"><span class="string">// '</span>ECMAScript <span class="number">2017</span> Language Specification<span class="string">'</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>getTitle</code>内部有三项操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p><h4 id="3-await命令"><a href="#3-await命令" class="headerlink" title="3. await命令"></a>3. await命令</h4><p>正常情况下，<code>await</code>命令后面是一个Promise对象。如果不是，会被转成一个立即<code>resolve</code>的Promise对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，它被转成Promise对象，并立即<code>resolve</code>。</p><p><code>await</code>命令后面的Promise对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v)).catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p><p>只要一个<code>await</code>语句后面的Promise变为<code>reject</code>，那么整个<code>async</code>函数都会中断执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);   <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v));</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>另一种方法是<code>await</code>后面的Promise对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>)</span><br><span class="line">        .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><h4 id="4-错误处理"><a href="#4-错误处理" class="headerlink" title="4. 错误处理"></a>4. 错误处理</h4><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的Promise对象被<code>reject</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v)).catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// Error：出错了</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的Promise对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async函数的实现原理”。</p><p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span>(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> val1 = <span class="keyword">await</span> firstStep();</span><br><span class="line">        <span class="keyword">const</span> val2 = <span class="keyword">await</span> secondStep(val1);</span><br><span class="line">        <span class="keyword">const</span> val3 = <span class="keyword">await</span> thridStep(val1, val2);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Final: '</span>, val3);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> superagent = <span class="built_in">require</span>(<span class="string">'superagent'</span>);</span><br><span class="line"><span class="keyword">const</span> NUM_RETRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_RETRIES; ++i) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> superagent.get(<span class="string">'http://google.com/this-throws-an-error'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i);     <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p><h4 id="5-使用注意点"><a href="#5-使用注意点" class="headerlink" title="5. 使用注意点"></a>5. 使用注意点</h4><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>reject</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> somethingThatReturnsAPromise();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise()</span><br><span class="line">        .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar  = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure><p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p><p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    docs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">await</span> db.post(doc);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">functon dbFuc(db) &#123;     <span class="comment">// 这里不需要async</span></span><br><span class="line">    <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可能得到错误结果</span></span><br><span class="line">    docs.forEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">await</span> db.post(doc);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可能不会正常工作，原因是这时三个<code>db.post</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确地写法是采用<code>for</code>循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">        <span class="keyword">await</span> db.post(doc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果却是系统多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">    <span class="keyword">let</span> promises = docs.map(<span class="function"><span class="params">doc</span> =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">    <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">    <span class="keyword">let</span> promises = docs.map(<span class="function"><span class="params">doc</span> =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> results = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">        results.push(<span class="keyword">await</span> promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前，<code>esm</code>模块加载器支持顶层<code>await</code>，即<code>await</code>命令可以不放在<code>async</code>函数里面，直接使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async函数的写法</span></span><br><span class="line"><span class="keyword">const</span> start = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">'google.com'</span>);</span><br><span class="line">    <span class="keyword">return</span> res.text();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">start().then(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶层await的写法</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">'google.com'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">await</span> res.text());</span><br></pre></td></tr></table></figure><p>上面代码中，第二种写法的脚本必须使用<code>esm</code>加载器，才会生效。</p><hr><h3 id="四、async函数的实现原理"><a href="#四、async函数的实现原理" class="headerlink" title="四、async函数的实现原理"></a>四、async函数的实现原理</h3><p>async函数的实现原理，就是将Generator函数和自动执行器，包装在一个函数里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。下面给出的<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> gen = genF();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> next;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                next = nextF();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next.done) &#123;</span><br><span class="line">                <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(v); &#125;);</span><br><span class="line">            &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.throw(e); &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="五、与其他异步处理方法的比较"><a href="#五、与其他异步处理方法的比较" class="headerlink" title="五、与其他异步处理方法的比较"></a>五、与其他异步处理方法的比较</h3><p>我们通过一个例子，来看async函数与Promise、Generator函数的比较。</p><p>假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p><p>首先是Promise的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsPromise</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 变量ret用来保存上一个动画的返回值</span></span><br><span class="line">    <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个空的Promise</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用then方法，添加所有动画</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">        p = p.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">            ret = val;</span><br><span class="line">            <span class="keyword">return</span> anim(elem);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个部署了错误捕捉机制的Promise</span></span><br><span class="line">    <span class="keyword">return</span> p.catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然Promise的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是Promise的API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p><p>接着是Generator函数的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsGenerator</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">                ret = <span class="keyword">yield</span> anim(elem);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用Generator函数遍历了每个动画，语义比Promise写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行Generator函数，上面代码的<code>spawn</code>就是自动执行器，它返回一个Promise对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个Promise。</p><p>最后是async函数的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">            ret = <span class="keyword">await</span> anim(elem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。</p><hr><h3 id="六、实例：按顺序完成异步操作"><a href="#六、实例：按顺序完成异步操作" class="headerlink" title="六、实例：按顺序完成异步操作"></a>六、实例：按顺序完成异步操作</h3><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组URL，然后按照读取顺序输出结果。</p><p>Promise的写法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 远程读取所有URL</span></span><br><span class="line">    <span class="keyword">const</span> textPromises = urls.map(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fetch(url).then(<span class="function"><span class="params">response</span> =&gt;</span> response.text());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按次序输出</span></span><br><span class="line">    textPromises.reduce(<span class="function">(<span class="params">chain, textPromise</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> chain.then(<span class="function"><span class="params">()</span> =&gt;</span> textPromise)</span><br><span class="line">            .then(<span class="function"><span class="params">text</span> =&gt;</span> <span class="built_in">console</span>.log(text));</span><br><span class="line">    &#125;, <span class="built_in">Promise</span>.resolve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用<code>fetch</code>方法，同时远程读取一组URL。每个<code>fetch</code>操作都返回一个Promise对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个Promise对象，然后使用<code>then</code>，将所有Promise对象连起来，因此就可以依次输出结果。</p><p>这种写法不太直观，可读性比较差。下面是async函数实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> response.text());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个URL返回结果，才会去读取下一个URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 并发读取远程URL</span></span><br><span class="line">    <span class="keyword">const</span> textPromises = urls.map(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">        <span class="keyword">return</span> response.text();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按次序输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> textPromise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for...of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</p><hr><h3 id="七、异步遍历器"><a href="#七、异步遍历器" class="headerlink" title="七、异步遍历器"></a>七、异步遍历器</h3><p>《遍历器》一章说过，Iterator接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p><p>这里隐含着一个规定，<code>next</code>方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行<code>next</code>方法，就必须同步地得到<code>value</code>和<code>done</code>这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。目前的解决方案是，Generator函数里面的异步操作，返回一个Thunk函数或者Promise对象，即<code>value</code>属性是一个Thunk函数或者Promise对象，等待以后返回真正的值，而<code>done</code>属性则还是同步产生的。</p><p>ES2018引入了“异步遍历器”（Async Iterator），为异步操作提供原生的遍历器接口，即<code>value</code>和<code>done</code>这两个属性都是异步产生。</p><h4 id="1-异步遍历的接口"><a href="#1-异步遍历的接口" class="headerlink" title="1. 异步遍历的接口"></a>1. 异步遍历的接口</h4><p>异步遍历器的最大的语法特点，就是调用遍历器的<code>next</code>方法，返回的是一个Promise对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asyncIterator</span><br><span class="line">    .next()</span><br><span class="line">    .then(</span><br><span class="line">        (&#123;value, done&#125;) =&gt; &#123; ... &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>上面代码中，<code>asyncIterator</code>是一个异步遍历器，调用<code>next</code>方法以后，返回一个Promise对象。因此，可以使用<code>then</code>方法指定，这个Promise对象的状态变为<code>resolve</code>以后的回调函数。回调函数的参数，是一个具有<code>value</code>和<code>done</code>两个属性的对象，这个跟同步遍历器是一样的。</p><p>我们知道，一个对象的同步遍历器的接口，部署在<code>Symbol.iterator</code>属性上面。同样地，对象的异步遍历器接口，部署在<code>Symbol.asyncIterator</code>属性上面。不管是什么样的对象，只要它的<code>Symbol.asyncIterator</code>属性有值，就表示应该对它进行异步遍历。下面是一个异步遍历器的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncIterable = createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"><span class="keyword">const</span> asyncIterator = asyncIterable[<span class="built_in">Symbol</span>.asyncIterator]();</span><br><span class="line"></span><br><span class="line">asyncIterator.next()</span><br><span class="line">    .then(<span class="function"><span class="params">iterResult1</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(iterResult1);   <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line">        <span class="keyword">return</span> asyncIterator.next();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">iterResult2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(iterResult2);   <span class="comment">// &#123;value: 'b', done: false&#125;</span></span><br><span class="line">        <span class="keyword">return</span> asyncIterator.next();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">iterResult3</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(iterResult3);   <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个Promise对象；等到Promise对象<code>resolve</code>了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回Promise对象，作为中介。</p><p>由于异步遍历器的<code>next</code>方法，返回的是一个Promise对象。因此，可以把它放在<code>await</code>命令后面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> asyncIterable = createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line">    <span class="keyword">const</span> asyncIterator = asyncIterable[<span class="built_in">Symbol</span>.asyncIterator]();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncIterator.next());</span><br><span class="line">    <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncIterator.next());</span><br><span class="line">    <span class="comment">// &#123;value: 'b', done: false&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncIterator.next());</span><br><span class="line">    <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>next</code>方法用<code>await</code>处理以后，就不必使用<code>then</code>方法了。整个流程已经很接近同步处理了。</p><p>注意，异步遍历器的<code>next</code>方法是可以连续调用的，不必等到上一步产生的Promise对象<code>resolve</code>以后再调用。这种情况下，<code>next</code>方法会累积起来，自动按照每一步的顺序执行下去。下面是一个例子，把所有的<code>next</code>方法放在<code>Promise.all</code>方法里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncGenObj = createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"><span class="keyword">const</span> [&#123;<span class="attr">value</span>: v1&#125;, &#123;<span class="attr">value</span>: v2&#125;] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    asyncGenObj.next(), asyncGenObj.next()</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(v1, v2);        <span class="comment">// a b</span></span><br></pre></td></tr></table></figure><p>另一种用法是一次性调用所有的<code>next</code>方法，然后<code>await</code>最后一步操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">runner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> writer = openFile(<span class="string">'someFile.txt'</span>);</span><br><span class="line">    writer.next(<span class="string">'hello'</span>);</span><br><span class="line">    writer.next(<span class="string">'world'</span>);</span><br><span class="line">    <span class="keyword">await</span> writer.return();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runner();</span><br></pre></td></tr></table></figure><h4 id="2-for-await…of"><a href="#2-for-await…of" class="headerlink" title="2. for await…of"></a>2. for await…of</h4><p>前面介绍过，<code>for...of</code>循环用于遍历同步的Iterator接口。新引入的<code>for await...of</code>循环，则是用于遍历异步的Iterator接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>  <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>])) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>createAsyncIterable()</code>返回一个拥有异步遍历器接口的对象，<code>for...of</code>循环自动调用这个对象的异步遍历器的<code>next</code>方法，会得到一个Promise对象。<code>await</code>用来处理这个Promise对象，一旦<code>resolve</code>，就把得到的值（<code>x</code>）传入<code>for...of</code>的循环体。</p><p><code>for await...of</code>循环的一个用途，是部署了asyncIterable操作的异步接口，可以直接放入这个循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> body = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> data <span class="keyword">of</span> req) body += data;</span><br><span class="line">    <span class="keyword">const</span> parsed = <span class="built_in">JSON</span>.parse(body);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'got'</span>, parsed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>req</code>是一个asyncIterable对象，用来异步读取数据。可以看到，使用<code>for await...of</code>循环以后，代码会非常简洁。</p><p>如果<code>next</code>方法返回的Promise对象被<code>reject</code>，<code>for await...of</code>就会报错，要用<code>try...catch</code>捕捉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> createRejectingIterable()) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>for await...of</code>循环也可以用于同步遍历器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>]) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br></pre></td></tr></table></figure><p>Node V10支持异步遍历器，Stream就部署了这个接口。下面是读取文件的传统写法和异步遍历器写法的差异。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">inputFilePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> readStream = fs.createReadStream(</span><br><span class="line">        inputFilePath,</span><br><span class="line">        &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>, <span class="attr">highWaterMark</span>: <span class="number">1024</span>&#125;</span><br><span class="line">    );</span><br><span class="line">    readStream.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'&gt;&gt;&gt;'</span> + chunk);</span><br><span class="line">    &#125;);</span><br><span class="line">    readStream.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'### DONE ###'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步遍历器写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">inputFilePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> readStream = fs.createReadStream(</span><br><span class="line">        inputFilePath,</span><br><span class="line">        &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>, <span class="attr">highWaterMark</span>: <span class="number">1024</span>&#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span>(<span class="keyword">const</span> chunk <span class="keyword">of</span> readStream) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'&gt;&gt;&gt;'</span> + chunk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'### DONE ###'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-异步Generator函数"><a href="#3-异步Generator函数" class="headerlink" title="3. 异步Generator函数"></a>3. 异步Generator函数</h4><p>就像Generator函数返回一个同步遍历器对象一样，异步Generator函数的作用，是返回一个异步遍历器对象。</p><p>在语法上，异步Generator函数就是<code>async</code>函数与Generator函数的结合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> genObj = gen();</span><br><span class="line">genObj.next().then(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br><span class="line"><span class="comment">// &#123;value: 'hello', done: false&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>gen</code>是一个异步Generator函数，执行后返回一个异步Iterator对象。对该对象调用<code>next</code>方法，返回一个Promise对象。</p><p>异步遍历器的设计目的之一，就是Generator函数处理同步操作和异步操作时，能够使用同一套接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步Generator函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">map</span>(<span class="params">iterable, func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> iter = iterable[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;value, done&#125; = iter.next();</span><br><span class="line">        <span class="keyword">if</span> (done) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">yield</span> func(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步Generator函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">map</span>(<span class="params">iterable, func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> iter = iterable[<span class="built_in">Symbol</span>.asyncIterator]();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;value, done&#125; = <span class="keyword">await</span> iter.next();</span><br><span class="line">        <span class="keyword">if</span> (done) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">yield</span> func(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>map</code>是一个Generator函数，第一个参数是可遍历对象<code>iterable</code>，第二个参数是一个回调函数<code>func</code>。<code>map</code>的作用是将<code>iterable</code>每一步返回的值，使用<code>func</code>进行处理。上面有两个版本的<code>map</code>，前一个处理同步遍历器，后一个处理异步遍历器，可以看到两个版本的写法基本上是一致的。</p><p>下面是另一个异步Generator函数的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">readLines</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> file = <span class="keyword">await</span> fileOpen(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!file.EOF) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">await</span> file.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> file.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，异步操作前面使用<code>await</code>关键字标明，即<code>await</code>后面的操作，应该返回Promise对象。凡是<code>yield</code>关键字的地方，就是<code>next</code>方法停下来的地方，它后面的表达式的值（即<code>await file.readLine()</code>的值），会作为<code>next()</code>返回对象的<code>value</code>属性，这一点是与Generator函数一致的。</p><p>异步Generator函数内部，能够同时使用<code>await</code>和<code>yield</code>命令。可以这样理解，<code>await</code>命令用于将外部操作产生的值输入函数内部，<code>yield</code>命令用于将函数内部的值输出。</p><p>上面代码定义的异步Generator函数的用法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span>(<span class="keyword">const</span> line <span class="keyword">of</span> readLines(filepath)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>异步Generator函数可以与<code>for await...of</code>循环结合起来使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">prefixLines</span>(<span class="params">asyncIterable</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> line <span class="keyword">of</span> asyncIterable) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'&gt;'</span> + line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步Generator函数的返回值是一个异步Iterator，即每次调用它的<code>next</code>方法，会返回一个Promise对象，也就是说，跟在<code>yield</code>命令后面的，应该是一个Promise对象。如果像上面那个例子一样，<code>yield</code>命令后面是一个字符串，会被自动包装成一个Promise对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchRandom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">'http://example.com/someapi?num=1'</span>;</span><br><span class="line">    <span class="keyword">return</span> fetch(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">asyncGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Start'</span>);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> fetchRandom();     <span class="comment">// (A)</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'Result: '</span> + <span class="keyword">await</span> result.text();     <span class="comment">// (B)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Done'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ag = asyncGenerator();</span><br><span class="line">ag.next().then(<span class="function">(<span class="params">&#123;value, done&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>ag</code>是<code>asyncGenerator</code>函数返回的异步遍历器对象。调用<code>ag.next()</code>以后，上面代码的执行顺序如下。</p><ul><li><p>1) <code>ag.next()</code>立刻返回一个Promise对象。</p></li><li><p>2) <code>asyncGenerator</code>函数开始执行，打印出<code>Start</code>。</p></li><li><p>3) <code>await</code>命令返回一个Promise对象，<code>asyncGenerator</code>函数停在这里。</p></li><li><p>4) A处变成fulfilled状态，产生的值放入<code>result</code>变量，<code>asyncGenerator</code>函数继续往下执行。</p></li><li><p>5) 函数在B处的<code>yield</code>暂停执行，一旦<code>yield</code>命令取到值，<code>ag.next()</code>返回的那个Promise对象变成fulfilled状态。</p></li><li><p>6) <code>ag.next()</code>后面的<code>then</code>方法指定的回调函数开始执行。该回调函数的参数是一个对象<code>{value, done}</code>，其中<code>value</code>的值是<code>yield</code>命令后面的那个表达式的值，<code>done</code>的值是<code>false</code>。</p></li></ul><p>A和B两行的作用类似于下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fetchRandom()</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> result.text())</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(&#123;</span><br><span class="line">            value: <span class="string">'Result: '</span> + result,</span><br><span class="line">            done: <span class="literal">false</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果异步Generator函数抛出错误，会导致Promise对象的状态变为<code>reject</code>，然后抛出的错误被<code>catch</code>方法捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">asyncGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Problem!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncGenerator()</span><br><span class="line">.next()</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line"><span class="comment">// Error: Problem!</span></span><br></pre></td></tr></table></figure><p>注意，普通的async函数返回的是一个Promise对象，而异步Generator函数返回的是一个异步Iterator对象。可以这样理解，async函数和异步Generator函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过<code>for await...of</code>执行，或者字迹编写执行器。下面就是一个异步Generator函数的执行器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">takeAsync</span>(<span class="params">asyncIterable, count = Infinity</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">const</span> iterator = asyncIterable[<span class="built_in">Symbol</span>.asyncIterator]();</span><br><span class="line">    <span class="keyword">while</span>(result.length &lt; count) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;value, done&#125; = <span class="keyword">await</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (done) <span class="keyword">break</span>;</span><br><span class="line">        result.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，异步Generator函数产生的异步遍历器，会通过<code>while</code>循环自动执行，每当<code>await iterator.next()</code>完成，就会进入下一轮循环。一旦<code>done</code>属性变为<code>true</code>，就会跳出循环，异步遍历器执行结束。</p><p>下面是这个自动执行器的一个使用实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'c'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> takeAsync(gen());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line"><span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure><p>异步Generator函数出现以后，JavaScript就有了四种函数形式：普通函数、async函数、Generator函数和异步Generator函数。请注意区分每种函数的不同之处。基本上，如果是一系列按照顺序执行的异步操作（比如读取文件，然后写入新内容，再存入硬盘），可以使用async函数；如果是一系列产生相同数据结构的异步操作（比如一行一行读取文件），可以使用异步Generator函数。</p><p>异步Generator函数也可以通过<code>next</code>方法的参数，接收外部传入的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> writer = openFile(<span class="string">'someFile.txt'</span>);</span><br><span class="line">writer.next(<span class="string">'hello'</span>);       <span class="comment">// 立即执行</span></span><br><span class="line">writer.next(<span class="string">'world'</span>);       <span class="comment">// 立即执行</span></span><br><span class="line"><span class="keyword">await</span> writer.return();      <span class="comment">// 等待写入结束</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>openFile</code>是一个异步Generator函数。<code>next</code>方法的参数，向该函数内部的操作传入数据。每次<code>next</code>方法都是同步执行的，最后的<code>await</code>命令用于等待整个写入操作结束。</p><p>最后，同步的数据结构，也可以使用异步Generator函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">createAsyncIterable</span>(<span class="params">syncIterable</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> elem <span class="keyword">of</span> syncIterable) &#123;</span><br><span class="line">        <span class="keyword">yield</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，由于没有异步操作，所以也就没有使用<code>await</code>关键字。</p><h4 id="4-yield-语句"><a href="#4-yield-语句" class="headerlink" title="4. yield* 语句"></a>4. yield* 语句</h4><p><code>yield*</code>语句也可以跟一个异步遍历器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// result最终会等于2</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">yield</span>* gen1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>gen2</code>函数里面的<code>result</code>变量，最后的值是<code>2</code>。</p><p>与同步Generator函数一样，<code>for await...of</code>循环会展开<code>yield*</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> gen2()) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/async">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中async函数。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/async&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/categories/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/categories/JavaScript/ES6/"/>
    
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/tags/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6(12) Generator函数的异步应用</title>
    <link href="http://www.xiaoleon.cn/2018/06/11/es6-12/"/>
    <id>http://www.xiaoleon.cn/2018/06/11/es6-12/</id>
    <published>2018-06-11T05:16:11.000Z</published>
    <updated>2018-06-11T11:26:03.593Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中Generator函数的异步应用。节选自<a href="(http://es6.ruanyifeng.com/#docs/generator-async">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><p>异步编程对JavaScript语言太重要。JavaScript语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍Generator函数如何完成异步操作。</p><hr><h3 id="一、传统方法"><a href="#一、传统方法" class="headerlink" title="一、传统方法"></a>一、传统方法</h3><p>ES6诞生以前，异步编程的方法，大概有下面四种。</p><ul><li><p>回调函数</p></li><li><p>事件监听</p></li><li><p>发布/订阅</p></li><li><p>Promise对象</p></li></ul><p>Generator函数将JavaScript异步编程带入了一个全新的阶段。</p><hr><h3 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h3><h4 id="1-异步"><a href="#1-异步" class="headerlink" title="1. 异步"></a>1. 异步</h4><p>所谓“异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被认为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p><p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p><p>相应的，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p><h4 id="2-回调函数"><a href="#2-回调函数" class="headerlink" title="2. 回调函数"></a>2. 回调函数</h4><p>JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字<code>callback</code>，直译过来就是“重新调用”。</p><p>读取文件进行处理，是这样写的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>readFile</code>函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p><p>一个有趣的问题是，为什么Node约定，回调函数的第一个参数，必须是错误对象<code>err</code>（如果没有错误，该参数就是<code>null</code>）？</p><p>原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。</p><h4 id="3-Promise"><a href="#3-Promise" class="headerlink" title="3. Promise"></a>3. Promise</h4><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(fileA, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileB, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为“回调函数地狱”（callback hell）。</p><p>Promise对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用Promise，连续读取多个文件，写法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="built_in">require</span>(<span class="string">'fs-readfile-promise'</span>);</span><br><span class="line"></span><br><span class="line">readFile(fileA)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">dta</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readFile(fileB);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，我们使用了<code>fs-readfile-promise</code>模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供<code>then</code>方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。</p><p>可以看到，Promise的写法只是回调函数的改进，使用<code>then</code>方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p><p>Promise的最大问题是代码冗余，原来的任务被Promise包装了一下，不管什么操作，一眼看去都是一堆<code>then</code>，原来的语义变得很不清楚。</p><p>那么有没有更好的写法呢？</p><hr><h3 id="三、Generator函数"><a href="#三、Generator函数" class="headerlink" title="三、Generator函数"></a>三、Generator函数</h3><h4 id="1-协程"><a href="#1-协程" class="headerlink" title="1. 协程"></a>1. 协程</h4><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做“协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p><p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p><ul><li><p>第一步，协程A开始执行。</p></li><li><p>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</p></li><li><p>第三步，（一段时间后）协程B交还执行权。</p></li><li><p>第四步，协程A恢复执行。</p></li></ul><p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p><p>举例来说，读取文件的协程写法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...其他代码</span></span><br><span class="line">    <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">    <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的函数<code>asyncJob</code>是一个协程，它的奥妙就在其中的<code>yield</code>命令。它表示执行到此处，执行权将交给其他协程。也就是说，<code>yield</code>命令是异步两个阶段的分界线。</p><p>协程遇到<code>yield</code>命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除<code>yield</code>命令，简直一模一样。</p><h4 id="2-协程的Generator函数实现"><a href="#2-协程的Generator函数实现" class="headerlink" title="2. 协程的Generator函数实现"></a>2. 协程的Generator函数实现</h4><p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p><p>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用<code>yield</code>语句注明。Generator函数的执行方法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next();           <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">g.next();           <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用Generator函数，会返回一个内部指针（即遍历器）<code>g</code>。这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针<code>g</code>的<code>next</code>方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的<code>yield</code>语句，上例是执行到<code>x + 2</code>为止。</p><p>换言之，<code>next</code>方法的作用是分阶段执行<code>Generator</code>函数。每次调用<code>next</code>方法，会返回一个对象，表示当前阶段的信息（<code>value</code>属性和<code>done</code>属性）。<code>value</code>属性是<code>yield</code>语句后面表达式的值，表示当前阶段的值；<code>done</code>属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一阶段。</p><h4 id="3-Generator函数的数据交换和错误处理"><a href="#3-Generator函数的数据交换和错误处理" class="headerlink" title="3. Generator函数的数据交换和错误处理"></a>3. Generator函数的数据交换和错误处理</h4><p>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p><p><code>next</code>返回值的value属性，是Generator函数向外输出数据；<code>next</code>方法还可以接受参数，向Generator函数体内输入数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next()        <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">g.next(<span class="number">2</span>)       <span class="comment">// &#123;value: 2, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>next</code>方法的<code>value</code>属性，返回表达式<code>x + 2</code>的值<code>3</code>。第二个<code>next</code>方法带有参数<code>2</code>，这个参数可以传入Generator函数，作为上个阶段异步任务的返回结果，被函数体内的变量<code>y</code>接收。因此，这一步的<code>value</code>属性，返回的就是<code>2</code>（变量<code>y</code>的值）。</p><p>Generator函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next();</span><br><span class="line">g.throw(<span class="string">'出错了'</span>);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，Generator函数体外，使用指针对象的<code>throw</code>方法抛出的错误，可以被函数体内的<code>try...catch</code>代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p><h4 id="4-异步任务的封装"><a href="#4-异步任务的封装" class="headerlink" title="4. 异步任务的封装"></a>4. 异步任务的封装</h4><p>下面看看如何使用Generator函数，执行一个真实的异步任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">'https://api.github.com/users/github'</span>;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">    <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了<code>yield</code>命令。</p><p>执行这段代码的方法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，首先执行Generator函数，获取遍历器对象，然后使用<code>next</code>方法（第二行），执行异步任务的第一阶段。由于<code>Fetch</code>模块返回的是一个Promise对象，因此要用<code>then</code>方法调用下一个<code>next</code>方法。</p><p>可以看到，虽然Generator函数将异步操作表示得很简单，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p><hr><h3 id="四、Thunk函数"><a href="#四、Thunk函数" class="headerlink" title="四、Thunk函数"></a>四、Thunk函数</h3><p>Thunk函数是自动执行Generator函数的一种方法。</p><h4 id="1-参数的求值策略"><a href="#1-参数的求值策略" class="headerlink" title="1. 参数的求值策略"></a>1. 参数的求值策略</h4><p>Thunk函数早在上个世纪60年代就诞生了。</p><p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是“求值策略”，即函数的参数到底应该何时求值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(x + <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>上面代码先定义函数<code>f</code>，然后向它传入表达式<code>x + 5</code>。请问，这个表达式应该何时求值？</p><p>一种意见是“传值调用”（call by value），即在进入函数体之前，就计算<code>x + 5</code>的值（等于6），再将这个值传入函数<code>f</code>。C语言就采用这种策略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 传值调用时，等同于</span></span><br><span class="line">f(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>另一种意见是“传名调用”（call by name），即直接将表达式<code>x + 5</code>传入函数体，只在用到它的时候求值。Haskell语言采用这种策略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 传名调用时，等同于</span></span><br><span class="line">(x + <span class="number">5</span>) * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>传值调用和传名调用，哪一种比较好？</p><p>回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">3</span> * x * x - <span class="number">2</span> * x - <span class="number">1</span>, x);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>的第一个参数是一个复杂的表达式，但是函数体内根本没用到，对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于“传名调用”，即只在执行时求值。</p><h4 id="2-Thunk函数的含义"><a href="#2-Thunk函数的含义" class="headerlink" title="2. Thunk函数的含义"></a>2. Thunk函数的含义</h4><p>编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(x + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同股</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">thunk</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> thunk() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>的参数<code>x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code>Thunk</code>函数求值即可。</p><p>这就是Thunk函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。</p><h4 id="3-JavaScript语言的Thunk函数"><a href="#3-JavaScript语言的Thunk函数" class="headerlink" title="3. JavaScript语言的Thunk函数"></a>3. JavaScript语言的Thunk函数</h4><p>JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换为一个只接受回调函数作为参数的单参数函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fs.readFile(fileName, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reafFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>fs</code>模块的<code>readFile</code>方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。</p><p>任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5版本</span></span><br><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            args.push(callback);</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6版本</span></span><br><span class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, ...args, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上面的转换器，生成<code>fs.readFile</code>的Thunk函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(fs.readFile);</span><br><span class="line">readFileThunk(fileA)(callback);</span><br></pre></td></tr></table></figure><p>下面是另一个完整的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, callback</span>) </span>&#123;</span><br><span class="line">    callback(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ft = Thunk(f);</span><br><span class="line"></span><br><span class="line">ft(<span class="number">1</span>)(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="4-Thunkify模块"><a href="#4-Thunkify模块" class="headerlink" title="4. Thunkify模块"></a>4. Thunkify模块</h4><p>生产环境的转换器，建议使用Thunkify模块。</p><p>首先是安装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install thunkify</span><br></pre></td></tr></table></figure><p>使用方法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = requrie(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> read = thunkify(fs.readFile);</span><br><span class="line">read(<span class="string">'package.json'</span>)(<span class="function"><span class="keyword">function</span>(<span class="params">err, str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Thunkify的源码与上一节那个简单的转换器非常像。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</span><br><span class="line">        <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> called;</span><br><span class="line"></span><br><span class="line">            args.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                called = <span class="literal">true</span>;</span><br><span class="line">                done.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fn.apply(ctx, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                done(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的源码主要多了一个检查机制，变量<code>called</code>确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = a + b;</span><br><span class="line">    callback(sum);</span><br><span class="line">    callback(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ft = thunkify(f);</span><br><span class="line"><span class="keyword">var</span> print = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>);</span><br><span class="line">ft(<span class="number">1</span>, <span class="number">2</span>)(print);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于<code>thunkify</code>只允许回调函数执行一次，所以只输出了一行结果。</p><h4 id="5-Generator函数的流程管理"><a href="#5-Generator函数的流程管理" class="headerlink" title="5. Generator函数的流程管理"></a>5. Generator函数的流程管理</h4><p>你可能会问，Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了Generator函数，Thunk函数现在可以用于Generator函数的自动流程管理。</p><p>Generator函数可以自动执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> res = g.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!res.done) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.value);</span><br><span class="line">    res = g.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Generator函数<code>gen</code>会自动执行完所有步骤。</p><p>但是，这并不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk函数就能派上用场。以读取文件为例。下面的Generator函数封装了两个异步操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line"><span class="keyword">var</span> readFileThunk = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = <span class="keyword">yield</span> readFileThunk(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(r1.toString());</span><br><span class="line">    <span class="keyword">var</span> r2 = <span class="keyword">yield</span> readFileThunk(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(r2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>yield</code>命令用于将程序的执行权移出Generator函数，那么就需要一种方法，将执行权再交还给Generator函数。</p><p>这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给Generator函数。为了便于理解，我们先看如何手动执行上面这个Generator函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1 = g.next();</span><br><span class="line">r1.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> r2 = g.next(data);</span><br><span class="line">    r2.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        g.next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>g</code>是Generator函数的内部指针，表示目前执行到哪一步。<code>next</code>方法负责将指针移动到下一步，并返回该步的信息（<code>value</code>属性和<code>done</code>属性）。</p><p>仔细查看上面的代码，可以发现Generator函数的执行过程，其实是将同一个回调函数，反复传入<code>next</code>方法的<code>value</code>属性。这使得我们可以用递归来自动完成这个过程。</p><h4 id="6-Thunk函数的自动流程管理"><a href="#6-Thunk函数的自动流程管理" class="headerlink" title="6. Thunk函数的自动流程管理"></a>6. Thunk函数的自动流程管理</h4><p>Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = fn();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = gen.next(data);</span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line">        result.value(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functon* g() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure><p>上面代码的<code>run</code>函数，就是一个Generator函数的自动执行器。内部的<code>next</code>函数就是Thunk的回调函数。<code>next</code>函数先将指针移到Generator函数的下一步（<code>gen.next</code>方法），然后判断Generator函数是否结束（<code>result.done</code>属性），如果没结束，就将<code>next</code>函数再传入Thunk函数（<code>result.value</code>属性），否则就直接退出。</p><p>有了这个执行器，执行Generator函数方便多了。不管内部有多少个异步操作，直接把Generator函数传入<code>run</code>函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在<code>yield</code>命令后面的必须是Thunk函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFileThunk(<span class="string">'fileA'</span>);</span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFileThunk(<span class="string">'fileB'</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> fn = <span class="keyword">yield</span> readFileThunk(<span class="string">'fileN'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>g</code>封装了<code>n</code>个异步的读取文件操作，只要执行<code>run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步，而且一行代码就可以执行。</p><p>Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交换程序的执行权。回调函数可以做到这一点，Promise对象也可以做到这一点。</p><hr><h3 id="五、co模块"><a href="#五、co模块" class="headerlink" title="五、co模块"></a>五、co模块</h3><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><p>co模块是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。</p><p>下面是一个Generator函数，用于依次读取两个文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>co模块可以让你不用编写Generator函数的执行器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line">co(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，Generator函数只要传入<code>co</code>函数，就会自动执行。</p><p><code>co</code>函数返回一个<code>Promise</code>对象，因此可以用<code>then</code>方法添加回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">co(gen).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Generator函数执行完毕'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，等到Generator函数执行结束，就会输出一行提示。</p><h4 id="2-co模块的原理"><a href="#2-co模块的原理" class="headerlink" title="2. co模块的原理"></a>2. co模块的原理</h4><p>为什么co可以自动执行Generator函数？</p><p>前面说过，Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p><p>两种方法可以做到这一点。</p><ul><li><p>回调函数。将异步操作包装成Thunk函数，在回调函数里交回执行权。</p></li><li><p>Promise对象。将异步操作包装成Promise对象，用<code>then</code>方法交回执行权。</p></li></ul><p>co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的<code>yield</code>命令后面，只能是Thunk函数或Promise对象。如果数组或对象的成员，全部都是Promise对象，也可以使用co，详见后文的例子。</p><p>上一节已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这时理解co模块必须的。</p><h4 id="3-基于Promise对象的自动执行"><a href="#3-基于Promise对象的自动执行" class="headerlink" title="3. 基于Promise对象的自动执行"></a>3. 基于Promise对象的自动执行</h4><p>还是沿用上面的例子。首先，把<code>fs</code>模块的<code>readFile</code>方法包装成一个Promise对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f1 = readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    <span class="keyword">var</span> f2 = readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，手动执行上面的Generator函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next().value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    g.next(data).value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        g.next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>手动执行其实就是用<code>then</code>方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">        result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            next(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，只要Generator函数还没执行到最后一步，<code>next</code>函数就调用自身，以此实现自动执行。</p><h4 id="4-co模块的源码"><a href="#4-co模块的源码" class="headerlink" title="4. co模块的源码"></a>4. co模块的源码</h4><p>co就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p><p>首先，co函数接受Generator函数作为参数，返回一个Promise对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在返回的Promise对象里面，co先检查参数<code>gen</code>是否为Generator函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将Promise对象的状态改为<code>resolved</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.call(ctx);</span><br><span class="line">        <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，co将Generator函数的内部指针对象的<code>next</code>方法，包装成<code>onFulfilled</code>函数。这主要是为了能够捕捉抛出的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.call(ctx);</span><br><span class="line">        <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line"></span><br><span class="line">        onFulfilled();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> ret;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ret = gen.next(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">            next(ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，就是关键的<code>next</code>函数，它会反复调用自身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br><span class="line">    <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">    <span class="keyword">return</span> onRejected(</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">            <span class="string">'You may only yield a function, promise, generator, array, or object, '</span></span><br><span class="line">            + <span class="string">'but the following object was passed: "'</span></span><br><span class="line">            + <span class="string">'String(ret.value)'</span></span><br><span class="line">            + <span class="string">'"'</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>next</code>函数的内部代码，一共只有四行命令。</p><p>第一行，检查当前是否为Generator函数的最后一步，如果是就返回。</p><p>第二行，确保每一步的返回值，都是Promise对象。</p><p>第三行，使用<code>then</code>方法，为返回值加上回调函数，然后通过<code>onFulfilled</code>函数再次调用<code>next</code>函数。</p><p>第四行，在参数不符合要求的情况下（参数非Thunk函数和Promise对象），将Promise对象的状态改为<code>rejected</code>，从而终止执行。</p><h4 id="5-处理并发的异步操作"><a href="#5-处理并发的异步操作" class="headerlink" title="5. 处理并发的异步操作"></a>5. 处理并发的异步操作</h4><p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p><p>这时，要把并发的操作都放在数组或对象里面，跟在<code>yield</code>语句后面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">yield</span> [</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">    ];</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">        <span class="number">1</span>: <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">        <span class="number">2</span>: <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = [n1, n2, n3];</span><br><span class="line">    <span class="keyword">yield</span> values.map(somethingAsync);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">somethingAsync</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something async</span></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码允许并发三个<code>somethingAsync</code>异步操作，等到它们全部完成，才会进行下一步。</p><h4 id="6-实例：处理Stream"><a href="#6-实例：处理Stream" class="headerlink" title="6. 实例：处理Stream"></a>6. 实例：处理Stream</h4><p>Node提供Stream模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream模式使用EventEmitter API，会释放三个事件。</p><ul><li><p>data事件：下一块数据块已经准备好了。</p></li><li><p>end事件：整个数据流处理完了。</p></li><li><p>error事件：发生错误。</p></li></ul><p>使用<code>Promise.race()</code>函数，可以判断这三个事件之中哪一个最先发生，只有当<code>data</code>事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个<code>while</code>循环，完成所有数据的读取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stream = fs.createReadStream(<span class="string">'./les_miserables.txt'</span>);</span><br><span class="line"><span class="keyword">let</span> valjeanCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">yield</span> <span class="built_in">Promise</span>.race([</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> stream.once(<span class="string">'data'</span>, resolve)),</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> stream.once(<span class="string">'end'</span>, resolve)),</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> stream.once(<span class="string">'error'</span>, reject)),</span><br><span class="line">        ]);</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stream.removeAllListeners(<span class="string">'data'</span>);</span><br><span class="line">        stream.removeAllListeners(<span class="string">'end'</span>);</span><br><span class="line">        stream.removeAllListeners(<span class="string">'error'</span>);</span><br><span class="line">        valjeanCount += (res.toString().match(<span class="regexp">/valjean/ig</span>) || []).length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'count:'</span>, valjeanCount);        <span class="comment">// count: 1120</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码采用Stream模式读取《悲惨世界》的文本文件，对于每个数据库都是用<code>stream.once</code>方法，在<code>data</code>、<code>end</code>、<code>error</code>三个事件上添加一次性回调函数。变量<code>res</code>只有在<code>data</code>事件发生时才有值，然后累加每个数据块之中<code>valjean</code>这个词出现的次数。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/generator-async">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中Generator函数的异步应用。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/generator-async&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(11) 字符串的扩展</title>
    <link href="http://www.xiaoleon.cn/2018/06/07/es6-11/"/>
    <id>http://www.xiaoleon.cn/2018/06/07/es6-11/</id>
    <published>2018-06-07T02:59:39.000Z</published>
    <updated>2018-06-11T11:25:12.909Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中对字符串的扩展。节选自<a href="(http://es6.ruanyifeng.com/#docs/string">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、字符的Unicode表示法"><a href="#一、字符的Unicode表示法" class="headerlink" title="一、字符的Unicode表示法"></a>一、字符的Unicode表示法</h3><p>JavaScript允许采用<code>\uxxxx</code>形式表示一个字符串，其中<code>xxxx</code>表示字符的Unicode码点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u0061"</span></span><br><span class="line"><span class="comment">// 'a'</span></span><br></pre></td></tr></table></figure><p>但是，这种表示法只限于码点在<code>\u0000</code>~<code>\uFFFF</code>之间的字符。超出这个范围的字符，必须采用两个双字节的形式表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\uD842\uDFB7"</span></span><br><span class="line"><span class="comment">// '𠮷'</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u20BB7"</span></span><br><span class="line"><span class="comment">// " 7"</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果直接在<code>\u</code>后面跟上超过<code>0xFFFF</code>的数值（比如<code>u20BB7</code>），JavaScript会理解成<code>\u20BB+7</code>。由于<code>\u20BB</code>是一个不可打印的字符，所以只会显示一个空格，后面跟着一个<code>7</code>。</p><p>ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span></span><br><span class="line"><span class="comment">// '𠮷'</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"</span></span><br><span class="line"><span class="comment">// 'ABC'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="number">123</span>;</span><br><span class="line">hell\u&#123;<span class="number">6</span>F&#125;</span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;1F680&#125;'</span> === <span class="string">'\uD83D\uDE80'</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，最后一个例子表明，大括号表示法与四字节的UTF16编码是等价的。</p><p>有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\z'</span> === <span class="string">'z'</span>    <span class="comment">// true</span></span><br><span class="line"><span class="string">'\172'</span> === <span class="string">'z'</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">'\x7A'</span> === <span class="string">'z'</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u007A'</span> === <span class="string">'z'</span>    <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u&#123;7A&#125;'</span> === <span class="string">'z'</span>    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h3 id="二、codePointAt"><a href="#二、codePointAt" class="headerlink" title="二、codePointAt()"></a>二、codePointAt()</h3><p>JavaScript内部，字符以UTF-16的格式存储，每个字符固定为2个字节。对于那些需要4个字节存储的字符（Unicode码点大于<code>0xFFFF</code>的字符），JavaScript会认为它们是两个字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷'</span>;</span><br><span class="line"></span><br><span class="line">s.length        <span class="comment">// 2</span></span><br><span class="line">s.charAt(<span class="number">0</span>)     <span class="comment">// ''</span></span><br><span class="line">s.charAt(<span class="number">1</span>)     <span class="comment">// ''</span></span><br><span class="line">s.charCodeAt(<span class="number">0</span>)     <span class="comment">// 55362</span></span><br><span class="line">s.charCodeAt(<span class="number">1</span>)     <span class="comment">// 57271</span></span><br></pre></td></tr></table></figure><p>上面代码中，汉字“𠮷”的码点是<code>0x20BB7</code>，UTF-16编码为<code>0xDB42 0xDFB7</code>（十进制为<code>55362 57271</code>），需要4个字节存储。对于这种4个字节的字符，JavaScript不能正确处理，字符串长度会误判为2，而且<code>charAt</code>方法无法读取整个字符，<code>charCodeAt</code>方法只能分别返回前两个字节和后两个字节的值。</p><p>ES6提供了<code>codePointAt</code>方法，能够正确处理4个字节存储的字符，返回一个字符的码点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>)        <span class="comment">// 134071</span></span><br><span class="line">s.codePointAt(<span class="number">1</span>)        <span class="comment">// 57271</span></span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">2</span>)        <span class="comment">// 97</span></span><br></pre></td></tr></table></figure><p><code>codePointAt</code>方法的参数，是字符在字符串中的位置（从0开始）。上面代码中，JavaScript将“𠮷a”视为三个字符，<code>codePointAt</code>方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点134071（即十六进制的<code>20BB7</code>）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，<code>codePointAt</code>方法的结果与<code>charCodeAt</code>方法相同。</p><p>总之，<code>codePointAt</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString</code>方法转换一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>)       <span class="comment">// '20bb7'</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>).toString(<span class="number">16</span>)       <span class="comment">// '61'</span></span><br></pre></td></tr></table></figure><p>我们注意到，<code>codePointAt</code>方法的参数，仍然是不正确的。比如，上面代码中，字符<code>a</code>在字符串<code>s</code>中的正确位置序号应该是1，但是必须向<code>codePointAt</code>方法传入2。解决这个问题的一个办法是使用<code>for...of</code>循环，因为它会正确识别32位的UTF-16字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure><p><code>codePointAt</code>方法是测试一个字符由两个字节还是四个字节组成的最简单方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is32Bit(<span class="string">'𠮷'</span>)       <span class="comment">// true</span></span><br><span class="line">is32Bit(<span class="string">'a'</span>)        <span class="comment">// false</span></span><br></pre></td></tr></table></figure><hr><h3 id="三、String-fromCodePoint"><a href="#三、String-fromCodePoint" class="headerlink" title="三、String.fromCodePoint()"></a>三、String.fromCodePoint()</h3><p>ES5提供<code>String.fromCharCode</code>方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于<code>0xFFFF</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// 'ஷ'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>String.fromCharCode</code>不能识别大于<code>0xFFFF</code>的码点，所以<code>0x20BB7</code>就发生了溢出，最高位<code>2</code>被舍弃了，最后返回码点<code>\u0BB7</code>对应的字符，而不是码点<code>\u20BB7</code>对应的字符。</p><p>ES6提供了<code>String.fromCodePoint</code>方法，可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode</code>方法的不足。在作用上，正好与<code>codePointAt</code>方法相反。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// '𠮷'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">'x\uD83D\uDE80y'</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成为一个字符串返回。</p><p>注意，<code>fromCodePoint</code>方法定义在<code>String</code>对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上。</p><hr><h3 id="四、字符串的遍历器接口"><a href="#四、字符串的遍历器接口" class="headerlink" title="四、字符串的遍历器接口"></a>四、字符串的遍历器接口</h3><p>ES6为字符串添加了遍历器接口，使得字符串可以被<code>for...of</code>循环遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(codePoint);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'f'</span></span><br><span class="line"><span class="comment">// 'o'</span></span><br><span class="line"><span class="comment">// 'o'</span></span><br></pre></td></tr></table></figure><p>除了遍历字符串，这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ' '</span></span><br><span class="line"><span class="comment">// ' '</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串<code>text</code>只有一个字符，但是<code>for</code>循环会认为它包含两个字符（都不可打印），而<code>for...of</code>循环会正确识别出这是一个字符。</p><hr><h3 id="五、at"><a href="#五、at" class="headerlink" title="五、at()"></a>五、at()</h3><p>ES5对字符串对象提供的<code>charAt</code>方法，返回字符串给定位置的字符。该方法不能识别码点大于<code>0xFFFF</code>的字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.charAt(<span class="number">0</span>)     <span class="comment">// 'a'</span></span><br><span class="line"><span class="string">'𠮷'</span>.charAt(<span class="number">0</span>)      <span class="comment">// '\uD842'</span></span><br></pre></td></tr></table></figure><p>上面代码中的第二条语句，<code>charAt</code>方法期望返回的是用2个字节表示的字符，但汉字“𠮷”占用了4个字节，<code>charAt(0)</code>表示获取这4个字节中的前2个字节，很显然，这是无法正常显示的。</p><p>目前，有一个提案，提出字符串实例的<code>at</code>方法，可以识别Unicode编号大于<code>0xFFFF</code>的字符，返回正确的字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.at(<span class="number">0</span>)     <span class="comment">// 'a'</span></span><br><span class="line"><span class="string">'𠮷'</span>.at(<span class="number">0</span>)      <span class="comment">// '𠮷'</span></span><br></pre></td></tr></table></figure><p>这个方法可以通过垫片库实现。</p><hr><h3 id="六、normalize"><a href="#六、normalize" class="headerlink" title="六、normalize()"></a>六、normalize()</h3><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如<code>Ǒ</code>（<code>\u01D1</code>）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如<code>o</code>（<code>\u004F</code>）和<code>ˇ</code>（<code>\u030C</code>）合成<code>Ǒ</code>（<code>\u004F\u030C</code>）。</p><p>这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span> === <span class="string">'\u004F\u030C'</span>     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u01D1'</span>.length             <span class="comment">// 1</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span>.length       <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码表示，JavaScript将合成字符视为两个字符，导致两种表示方法不相等。</p><p>ES6提供字符串实例的<code>normalize()</code>方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize()</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>normalize</code>方法可以接受一个参数来指定<code>normalize</code>的方式，参数的四个可选值如下。</p><ul><li><p><code>NFC</code>，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</p></li><li><p><code>NFD</code>，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</p></li><li><p><code>NFKC</code>，表示“兼容等价合成”（Normalization Form Campatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，<code>normalize</code>方法不能识别中文。）</p></li><li><p><code>NFKD</code>，表示“兼容等价分解”（Normalization Form Campatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFC'</span>).length      <span class="comment">// 1</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFD'</span>).length      <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码表示，<code>NFC</code>参数返回字符的合成形式，<code>NFD</code>参数表示返回字符的分解形式。</p><p>不过，<code>normalize</code>方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过Unicode编号区间判断。</p><hr><h3 id="七、includes-、startsWith-、endsWith"><a href="#七、includes-、startsWith-、endsWith" class="headerlink" title="七、includes()、startsWith()、endsWith()"></a>七、includes()、startsWith()、endsWith()</h3><p>传统上，JavaScript只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串上。ES6又提供了三种新方法。</p><ul><li><p><code>includes()</code>：返回布尔值，表示是否找到了参数字符串</p></li><li><p><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部</p></li><li><p><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello World!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'Hello'</span>);      <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'!'</span>);            <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>);            <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>);       <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>);         <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>);         <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p><hr><h3 id="八、repeat"><a href="#八、repeat" class="headerlink" title="八、repeat()"></a>八、repeat()</h3><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>);      <span class="comment">// 'xxx'</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>);  <span class="comment">// 'hellohello'</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">0</span>);     <span class="comment">// ''</span></span><br></pre></td></tr></table></figure><p>参数如果是小数，会被取整。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="number">2.9</span>)    <span class="comment">// 'nana'</span></span><br></pre></td></tr></table></figure><p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="literal">Infinity</span>)       <span class="comment">// RangeError</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">-1</span>)             <span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure><p>但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，<code>repeat</code>视同为0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="number">-0.9</span>)       <span class="comment">// ''</span></span><br></pre></td></tr></table></figure><p>参数<code>NaN</code>等同于0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="literal">NaN</span>)        <span class="comment">// ''</span></span><br></pre></td></tr></table></figure><p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>)       <span class="comment">// ''</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>)        <span class="comment">// 'nanana'</span></span><br></pre></td></tr></table></figure><hr><h3 id="九、padStart-、padEnd"><a href="#九、padStart-、padEnd" class="headerlink" title="九、padStart()、padEnd()"></a>九、padStart()、padEnd()</h3><p>ES7引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于补全头部，<code>padEnd()</code>用于补全尾部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>)       <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>)       <span class="comment">// 'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>)         <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>)         <span class="comment">// 'xaba'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>padStart</code>和<code>padEnd</code>一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p><p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'xxx'</span>.padStart(<span class="number">2</span>, <span class="string">'ab'</span>)     <span class="comment">// 'xxx'</span></span><br><span class="line"><span class="string">'xxx'</span>.padEnd(<span class="number">2</span>, <span class="string">'ab'</span>)       <span class="comment">// 'xxx'</span></span><br></pre></td></tr></table></figure><p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">'0123456789'</span>)    <span class="comment">// '0123456abc'</span></span><br></pre></td></tr></table></figure><p>如果省略第二个参数，默认使用空格补全长度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>)     <span class="comment">// '   x'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>)       <span class="comment">// 'x   '</span></span><br></pre></td></tr></table></figure><p><code>padStart</code>的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>)       <span class="comment">// '0000000001'</span></span><br><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>)      <span class="comment">// '0000000012'</span></span><br><span class="line"><span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>)  <span class="comment">// '0000123456'</span></span><br></pre></td></tr></table></figure><p>另一个用途是提示字符串格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>)     <span class="comment">// 'YYYY-MM-12'</span></span><br><span class="line"><span class="string">'09-12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>)  <span class="comment">// 'YYYY-09-12'</span></span><br></pre></td></tr></table></figure><hr><h3 id="十、matchAll"><a href="#十、matchAll" class="headerlink" title="十、matchAll()"></a>十、matchAll()</h3><p><code>matchAll</code>方法返回一个正则表达式在当前字符串的所有匹配，详见正则的扩展一章。</p><hr><h3 id="十一、模板字符串"><a href="#十一、模板字符串" class="headerlink" title="十一、模板字符串"></a>十一、模板字符串</h3><p>传统的JavaScript语言，输出模板通常是这样写的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(</span><br><span class="line">    <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</span><br><span class="line">    <span class="string">'items in your basket, '</span> +</span><br><span class="line">    <span class="string">'&lt;em&gt;'</span> + basket.onSale +</span><br><span class="line">    <span class="string">'&lt;/em&gt; are on sale!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(<span class="string">`</span></span><br><span class="line"><span class="string">    There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">    in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">    are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string">not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'Bob'</span>, time = <span class="string">'today'</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure><p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">`\`Yo\` World!`</span>;</span><br></pre></td></tr></table></figure><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>)</span><br></pre></td></tr></table></figure><p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果不想要这个换行，可以使用<code>trim</code>方法消除它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>).trim();</span><br></pre></td></tr></table></figure><p>模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></span><br><span class="line"><span class="comment">// '1 + 2 = 3'</span></span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// '1 + 4 = 5'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span></span><br><span class="line"><span class="comment">// '3'</span></span><br></pre></td></tr></table></figure><p>模板字符串中还能调用函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure><p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法。</p><p>如果模板字符串中的变量没有声明，将报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量place没有声明</span></span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">`Hello, <span class="subst">$&#123;place&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`Hello <span class="subst">$&#123;<span class="string">'World'</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// 'Hello World'</span></span><br></pre></td></tr></table></figure><p>模板字符串甚至还能嵌套。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;table&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">        &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">        &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.second&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    `</span>).join(<span class="string">''</span>)&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/table&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123; <span class="attr">first</span>: <span class="string">'&lt;Jane&gt;'</span>, <span class="attr">last</span>: <span class="string">'Bond'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">first</span>: <span class="string">'Lars'</span>, <span class="attr">last</span>: <span class="string">'&lt;Croft&gt;'</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tmpl(data));</span><br><span class="line"><span class="comment">//  &lt;table&gt;</span></span><br><span class="line"><span class="comment">//      </span></span><br><span class="line"><span class="comment">//      &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//      &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//      &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  &lt;/table&gt;</span></span><br></pre></td></tr></table></figure><p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'return '</span> + <span class="string">'`Hello $&#123;name&#125;!`'</span>;</span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'name'</span>, str);</span><br><span class="line">func(<span class="string">'Jack'</span>)        <span class="comment">// 'Hello Jack!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'(name) =&gt; `Hello $&#123;name&#125;!`'</span>;</span><br><span class="line"><span class="keyword">let</span> func = <span class="built_in">eval</span> call(<span class="literal">null</span>, str);</span><br><span class="line">func(<span class="string">'Jack'</span>)        <span class="comment">// 'Hello Jack!'</span></span><br></pre></td></tr></table></figure><hr><h3 id="十二、实例：模板编译"><a href="#十二、实例：模板编译" class="headerlink" title="十二、实例：模板编译"></a>十二、实例：模板编译</h3><p>下面，我们来看一个通过模板字符串，生成正式模板的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;    </span></span><br><span class="line"><span class="string">    &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用<code>&lt;%...%&gt;</code>放置JavaScript代码，使用<code>&lt;%=...%&gt;</code>输出JavaScript表达式。</p><p>怎么编译这个模板字符串呢？</p><p>一种思路是将其转换为JavaScript表达式字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo(<span class="string">'&lt;ul&gt;'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.supplies.length; i++) &#123;</span><br><span class="line">    echo(<span class="string">'&lt;li&gt;'</span>);</span><br><span class="line">    echo(data.supplies[i]);</span><br><span class="line">    echo(<span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">echo(<span class="string">'&lt;/ul&gt;'</span>);</span><br></pre></td></tr></table></figure><p>这个转换使用正则表达式就行了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</span><br><span class="line"><span class="keyword">let</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</span><br><span class="line"></span><br><span class="line">template = template</span><br><span class="line">    .replace(evalExpr, <span class="string">'`); \n echo($1); \n echo(`'</span>)</span><br><span class="line">    .replace(expr, <span class="string">'`); \n $1 \n echo(`'</span>);</span><br><span class="line"></span><br><span class="line">template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br></pre></td></tr></table></figure><p>然后，将<code>template</code>封装在一个函数里面返回，就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = </span><br><span class="line"><span class="string">`(function parse(data) &#123;</span></span><br><span class="line"><span class="string">    let output = '';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    funtion echo(html) &#123;</span></span><br><span class="line"><span class="string">        output += html;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;template&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return output;</span></span><br><span class="line"><span class="string">&#125;)`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> script;</span><br></pre></td></tr></table></figure><p>将上面的内容拼装成一个模板编译函数<code>compile</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">template</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</span><br><span class="line">    <span class="keyword">const</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</span><br><span class="line"></span><br><span class="line">    template = template</span><br><span class="line">        .replace(evalExpr, <span class="string">'`); echo($1); \n echo(`'</span>)</span><br><span class="line">        .replace(expr, <span class="string">'`); \n $1 \n echo(`'</span>);</span><br><span class="line"></span><br><span class="line">    template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> script = </span><br><span class="line">    <span class="string">`(function parse(data) &#123;</span></span><br><span class="line"><span class="string">        let output = '';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        function echo(html) &#123;</span></span><br><span class="line"><span class="string">            output += html;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;template&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return output</span></span><br><span class="line"><span class="string">    &#125;)`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> script;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compile</code>函数的用法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parse = <span class="built_in">eval</span>(compile(template));</span><br><span class="line">div.innerHTML = parse(&#123; <span class="attr">supplies</span>: [<span class="string">'broom'</span>, <span class="string">'mop'</span>, <span class="string">'cleaner'</span>] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  &lt;ul&gt;</span></span><br><span class="line"><span class="comment">//      &lt;li&gt;broom&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//      &lt;li&gt;mop&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//      &lt;li&gt;cleaner&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//  &lt;/ul&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="十三、标签模板"><a href="#十三、标签模板" class="headerlink" title="十三、标签模板"></a>十三、标签模板</h3><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="string">`123`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">alert(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p><p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123;a + b&#125;</span> world <span class="subst">$&#123;a * b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串前面有一个标识名<code>tag</code>，它是一个函数。整个表达式的返回值，就是<code>tag</code>函数处理模板字符串后的返回值。</p><p>函数<code>tag</code>依次会接收到多个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，依此类推。</p><p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。</p><p>也就是说，<code>tag</code>函数实际上以下面的形式调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>我们可以按照需要编写<code>tag</code>函数的代码。下面是<code>tag</code>函数的一种写法，以及运行结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">s, v1, v2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(s[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(s[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(v1);</span><br><span class="line">    <span class="built_in">console</span>.log(v2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'OK'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123;a + b&#125;</span> world <span class="subst">$&#123;a * b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 'Hello '</span></span><br><span class="line"><span class="comment">// ' world '</span></span><br><span class="line"><span class="comment">// ''</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 50</span></span><br><span class="line"><span class="comment">// 'OK'</span></span><br></pre></td></tr></table></figure><p>下面是一个更复杂的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> msg = passthru<span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total * <span class="number">1.05</span>&#125;</span> with tax)`</span>;</span><br><span class="line"></span><br><span class="line">functon passthru(literals) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; literals.length) &#123;</span><br><span class="line">        result += literals[i++];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">            result += <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg</span><br><span class="line"><span class="comment">// 'The toal is 30 (31.5 with tax)'</span></span><br></pre></td></tr></table></figure><p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p><p><code>passthru</code>函数采用rest参数的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> output = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">let</span> index;</span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">        output += literals[index] + values[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output += literals[index];</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Escape special characters in the subinsitution.</span></span><br><span class="line">        s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">                .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">                .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't escape special charaters in the template.</span></span><br><span class="line">        s += templateData[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 恶意代码</span></span><br><span class="line"><span class="keyword">let</span> sender = <span class="string">'&lt;script&gt;alert("abc")&lt;/script&gt;'</span>;</span><br><span class="line"><span class="keyword">let</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">message</span><br><span class="line"><span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")%lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><p>标签模板的另一个应用，就是多语言转换（国际化处理，i18n）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i18n<span class="string">`Welcom to <span class="subst">$&#123;siteName&#125;</span>, you are visitor number <span class="subst">$&#123;visitorNumber&#125;</span>!`</span></span><br><span class="line"><span class="comment">// '欢迎访问xxx，您是第xxxx位访问者！'</span></span><br></pre></td></tr></table></figure><p>模板字符串本身并不能取代Mustache之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的hashTemplate函数</span></span><br><span class="line"><span class="comment">// 是一个自定义的模板处理函数</span></span><br><span class="line"><span class="keyword">let</span> libraryHtml = hasTemplate<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">        #for book in <span class="subst">$&#123;myBooks&#125;</span></span></span><br><span class="line"><span class="string">            &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        #end</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>除此之外，你甚至可以使用标签模板，在JavaScript语言之中嵌入其他语言。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsx<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;input</span></span><br><span class="line"><span class="string">            ref='input'</span></span><br><span class="line"><span class="string">            onChange='<span class="subst">$&#123;<span class="keyword">this</span>.handleChange&#125;</span>'</span></span><br><span class="line"><span class="string">            defaultValue='<span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span>'</span></span><br><span class="line"><span class="string">        /&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>上面的代码通过<code>jsx</code>函数，将一个DOM字符串转为React对象，你可以在Github上找到<code>jsx</code>函数的具体实现。</p><p>下面则是一个假想的例子，通过java函数，在JavaScript代码之中运行Java代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java<span class="string">`</span></span><br><span class="line"><span class="string">class HelloWorldApp &#123;</span></span><br><span class="line"><span class="string">    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="string">        System.out.println("Hello World!");</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line">HelloWorldApp.main();</span><br></pre></td></tr></table></figure><p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log<span class="string">`123`</span></span><br><span class="line"><span class="comment">// ['123', raw: Array[1]]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>console.log</code>接受的参数，实际上是一个数组。该数组有一个<code>raw</code>属性，保存的是转义后的原字符。</p><p>请看下面的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tag<span class="string">`First line\nSecond line`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">srings</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// string.raw[0] 为 "First line\\nSecond line"</span></span><br><span class="line">    <span class="comment">// 打印输出 "First line\nSecond line"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>tag</code>函数的第一个参数<code>strings</code>，有一个<code>raw</code>属性，也指向一个数组。该数组的成员与<code>strings</code>数组完全一致。比如，<code>strings</code>数组是<code>[&quot;First line\nSecond line&quot;]</code>，那么<code>strings.raw</code>数组就是<code>[&quot;First line\\nSecond line&quot;]</code>。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw数组会将<code>\n</code>视为<code>\\</code>和<code>n</code>两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p><hr><h3 id="十四、String-raw"><a href="#十四、String-raw" class="headerlink" title="十四、String.raw()"></a>十四、String.raw()</h3><p>ES6还为原生的String对象，提供了一个<code>raw</code>方法。</p><p><code>String.raw</code>方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应替换变量后的模板字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span> + <span class="number">3</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// 返回 'Hi\\n5!'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// 返回 'Hi\\u000A!'</span></span><br></pre></td></tr></table></figure><p>如果原字符串的斜杠已经转义，那么<code>String.raw</code>会再次转义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\\n`</span></span><br><span class="line"><span class="comment">// 返回 'Hi\\\\n'</span></span><br></pre></td></tr></table></figure><p><code>String.raw</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p><p><code>String.raw</code>方法也可以作为正常的函数。这时，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw(&#123;<span class="attr">raw</span>: <span class="string">'test'</span>&#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 't0e1s2t'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">String</span>.raw(&#123;<span class="attr">raw</span>: [<span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>]&#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>作为函数，<code>String.raw</code>的代码实现基本如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw = <span class="function"><span class="keyword">function</span>(<span class="params">strings, ...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> output = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">let</span> index;</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">        output += strings.raw[index] + values[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output += strings.raw[index];</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="十五、模板字符串的限制"><a href="#十五、模板字符串的限制" class="headerlink" title="十五、模板字符串的限制"></a>十五、模板字符串的限制</h3><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p><p>举例来说，标签模板里面可以嵌入LaTEX语言。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">latex</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">document</span> = latex<span class="string">`</span></span><br><span class="line"><span class="string">\newcommand&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125;        // 正常工作</span></span><br><span class="line"><span class="string">\newcommand&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125;    // 报错</span></span><br><span class="line"><span class="string">\newcommand&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125;    // 报错</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Breve over the h goes \u&#123;h&#125;ere      // 报错</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>document</code>内嵌的模板字符串，对于LaTEX语言来说完全是合法的，但是JavaScript引擎会报错，原因就在于字符串的转义。</p><p>模板字符串会将<code>\u00FF</code>和<code>\u{42}</code>当作Unicode字符进行转义，所以<code>\unicode</code>解析时报错；而<code>\x56</code>会被当作十六进制字符串转义，所以<code>\xerxes</code>会报错。也就是说，<code>\u</code>和<code>\x</code>在LaTEX里面有特殊含义，但是JavaScript将它们转义了。</p><p>为了解决这个问题，ES2018放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回<code>undefined</code>，而不是报错，并且从<code>raw</code>属性上面可以取到原始字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(strs[<span class="number">0</span>] === <span class="literal">undefined</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(strs.raw[<span class="number">0</span>] === <span class="string">'\\unicode and \\u&#123;55&#125;'</span>);</span><br><span class="line">&#125;</span><br><span class="line">tag<span class="string">`\unicode and \u&#123;55&#125;`</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript引擎将第一个字符设置为<code>undefined</code>，但是<code>raw</code>属性依然可以得到原始字符串，因此<code>tag</code>函数还是可以对原字符串进行处理。</p><p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bad = <span class="string">`bad escape sequence: \unicode`</span>;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/string">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中对字符串的扩展。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/string&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
</feed>
