<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张啸</title>
  
  <subtitle>世界上最快乐的事，莫过于为理想而奋斗。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaoleon.cn/"/>
  <updated>2018-06-11T11:26:03.593Z</updated>
  <id>http://www.xiaoleon.cn/</id>
  
  <author>
    <name>Leon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6(12) Generator函数的异步应用</title>
    <link href="http://www.xiaoleon.cn/2018/06/11/es6-12/"/>
    <id>http://www.xiaoleon.cn/2018/06/11/es6-12/</id>
    <published>2018-06-11T05:16:11.000Z</published>
    <updated>2018-06-11T11:26:03.593Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中Generator函数的异步应用。节选自<a href="(http://es6.ruanyifeng.com/#docs/generator-async">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><p>异步编程对JavaScript语言太重要。JavaScript语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍Generator函数如何完成异步操作。</p><hr><h3 id="一、传统方法"><a href="#一、传统方法" class="headerlink" title="一、传统方法"></a>一、传统方法</h3><p>ES6诞生以前，异步编程的方法，大概有下面四种。</p><ul><li><p>回调函数</p></li><li><p>事件监听</p></li><li><p>发布/订阅</p></li><li><p>Promise对象</p></li></ul><p>Generator函数将JavaScript异步编程带入了一个全新的阶段。</p><hr><h3 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h3><h4 id="1-异步"><a href="#1-异步" class="headerlink" title="1. 异步"></a>1. 异步</h4><p>所谓“异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被认为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p><p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p><p>相应的，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p><h4 id="2-回调函数"><a href="#2-回调函数" class="headerlink" title="2. 回调函数"></a>2. 回调函数</h4><p>JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字<code>callback</code>，直译过来就是“重新调用”。</p><p>读取文件进行处理，是这样写的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>readFile</code>函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p><p>一个有趣的问题是，为什么Node约定，回调函数的第一个参数，必须是错误对象<code>err</code>（如果没有错误，该参数就是<code>null</code>）？</p><p>原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。</p><h4 id="3-Promise"><a href="#3-Promise" class="headerlink" title="3. Promise"></a>3. Promise</h4><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(fileA, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileB, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为“回调函数地狱”（callback hell）。</p><p>Promise对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用Promise，连续读取多个文件，写法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="built_in">require</span>(<span class="string">'fs-readfile-promise'</span>);</span><br><span class="line"></span><br><span class="line">readFile(fileA)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">dta</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readFile(fileB);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，我们使用了<code>fs-readfile-promise</code>模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供<code>then</code>方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。</p><p>可以看到，Promise的写法只是回调函数的改进，使用<code>then</code>方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p><p>Promise的最大问题是代码冗余，原来的任务被Promise包装了一下，不管什么操作，一眼看去都是一堆<code>then</code>，原来的语义变得很不清楚。</p><p>那么有没有更好的写法呢？</p><hr><h3 id="三、Generator函数"><a href="#三、Generator函数" class="headerlink" title="三、Generator函数"></a>三、Generator函数</h3><h4 id="1-协程"><a href="#1-协程" class="headerlink" title="1. 协程"></a>1. 协程</h4><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做“协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p><p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p><ul><li><p>第一步，协程A开始执行。</p></li><li><p>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</p></li><li><p>第三步，（一段时间后）协程B交还执行权。</p></li><li><p>第四步，协程A恢复执行。</p></li></ul><p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p><p>举例来说，读取文件的协程写法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...其他代码</span></span><br><span class="line">    <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">    <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的函数<code>asyncJob</code>是一个协程，它的奥妙就在其中的<code>yield</code>命令。它表示执行到此处，执行权将交给其他协程。也就是说，<code>yield</code>命令是异步两个阶段的分界线。</p><p>协程遇到<code>yield</code>命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除<code>yield</code>命令，简直一模一样。</p><h4 id="2-协程的Generator函数实现"><a href="#2-协程的Generator函数实现" class="headerlink" title="2. 协程的Generator函数实现"></a>2. 协程的Generator函数实现</h4><p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p><p>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用<code>yield</code>语句注明。Generator函数的执行方法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next();           <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">g.next();           <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用Generator函数，会返回一个内部指针（即遍历器）<code>g</code>。这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针<code>g</code>的<code>next</code>方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的<code>yield</code>语句，上例是执行到<code>x + 2</code>为止。</p><p>换言之，<code>next</code>方法的作用是分阶段执行<code>Generator</code>函数。每次调用<code>next</code>方法，会返回一个对象，表示当前阶段的信息（<code>value</code>属性和<code>done</code>属性）。<code>value</code>属性是<code>yield</code>语句后面表达式的值，表示当前阶段的值；<code>done</code>属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一阶段。</p><h4 id="3-Generator函数的数据交换和错误处理"><a href="#3-Generator函数的数据交换和错误处理" class="headerlink" title="3. Generator函数的数据交换和错误处理"></a>3. Generator函数的数据交换和错误处理</h4><p>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p><p><code>next</code>返回值的value属性，是Generator函数向外输出数据；<code>next</code>方法还可以接受参数，向Generator函数体内输入数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next()        <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">g.next(<span class="number">2</span>)       <span class="comment">// &#123;value: 2, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>next</code>方法的<code>value</code>属性，返回表达式<code>x + 2</code>的值<code>3</code>。第二个<code>next</code>方法带有参数<code>2</code>，这个参数可以传入Generator函数，作为上个阶段异步任务的返回结果，被函数体内的变量<code>y</code>接收。因此，这一步的<code>value</code>属性，返回的就是<code>2</code>（变量<code>y</code>的值）。</p><p>Generator函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next();</span><br><span class="line">g.throw(<span class="string">'出错了'</span>);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，Generator函数体外，使用指针对象的<code>throw</code>方法抛出的错误，可以被函数体内的<code>try...catch</code>代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p><h4 id="4-异步任务的封装"><a href="#4-异步任务的封装" class="headerlink" title="4. 异步任务的封装"></a>4. 异步任务的封装</h4><p>下面看看如何使用Generator函数，执行一个真实的异步任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">'https://api.github.com/users/github'</span>;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">    <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了<code>yield</code>命令。</p><p>执行这段代码的方法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，首先执行Generator函数，获取遍历器对象，然后使用<code>next</code>方法（第二行），执行异步任务的第一阶段。由于<code>Fetch</code>模块返回的是一个Promise对象，因此要用<code>then</code>方法调用下一个<code>next</code>方法。</p><p>可以看到，虽然Generator函数将异步操作表示得很简单，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p><hr><h3 id="四、Thunk函数"><a href="#四、Thunk函数" class="headerlink" title="四、Thunk函数"></a>四、Thunk函数</h3><p>Thunk函数是自动执行Generator函数的一种方法。</p><h4 id="1-参数的求值策略"><a href="#1-参数的求值策略" class="headerlink" title="1. 参数的求值策略"></a>1. 参数的求值策略</h4><p>Thunk函数早在上个世纪60年代就诞生了。</p><p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是“求值策略”，即函数的参数到底应该何时求值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(x + <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>上面代码先定义函数<code>f</code>，然后向它传入表达式<code>x + 5</code>。请问，这个表达式应该何时求值？</p><p>一种意见是“传值调用”（call by value），即在进入函数体之前，就计算<code>x + 5</code>的值（等于6），再将这个值传入函数<code>f</code>。C语言就采用这种策略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 传值调用时，等同于</span></span><br><span class="line">f(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>另一种意见是“传名调用”（call by name），即直接将表达式<code>x + 5</code>传入函数体，只在用到它的时候求值。Haskell语言采用这种策略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 传名调用时，等同于</span></span><br><span class="line">(x + <span class="number">5</span>) * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>传值调用和传名调用，哪一种比较好？</p><p>回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">3</span> * x * x - <span class="number">2</span> * x - <span class="number">1</span>, x);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>的第一个参数是一个复杂的表达式，但是函数体内根本没用到，对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于“传名调用”，即只在执行时求值。</p><h4 id="2-Thunk函数的含义"><a href="#2-Thunk函数的含义" class="headerlink" title="2. Thunk函数的含义"></a>2. Thunk函数的含义</h4><p>编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(x + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同股</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">thunk</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> thunk() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>的参数<code>x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code>Thunk</code>函数求值即可。</p><p>这就是Thunk函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。</p><h4 id="3-JavaScript语言的Thunk函数"><a href="#3-JavaScript语言的Thunk函数" class="headerlink" title="3. JavaScript语言的Thunk函数"></a>3. JavaScript语言的Thunk函数</h4><p>JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换为一个只接受回调函数作为参数的单参数函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fs.readFile(fileName, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reafFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>fs</code>模块的<code>readFile</code>方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。</p><p>任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5版本</span></span><br><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            args.push(callback);</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6版本</span></span><br><span class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, ...args, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上面的转换器，生成<code>fs.readFile</code>的Thunk函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(fs.readFile);</span><br><span class="line">readFileThunk(fileA)(callback);</span><br></pre></td></tr></table></figure><p>下面是另一个完整的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, callback</span>) </span>&#123;</span><br><span class="line">    callback(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ft = Thunk(f);</span><br><span class="line"></span><br><span class="line">ft(<span class="number">1</span>)(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="4-Thunkify模块"><a href="#4-Thunkify模块" class="headerlink" title="4. Thunkify模块"></a>4. Thunkify模块</h4><p>生产环境的转换器，建议使用Thunkify模块。</p><p>首先是安装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install thunkify</span><br></pre></td></tr></table></figure><p>使用方法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = requrie(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> read = thunkify(fs.readFile);</span><br><span class="line">read(<span class="string">'package.json'</span>)(<span class="function"><span class="keyword">function</span>(<span class="params">err, str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Thunkify的源码与上一节那个简单的转换器非常像。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</span><br><span class="line">        <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> called;</span><br><span class="line"></span><br><span class="line">            args.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                called = <span class="literal">true</span>;</span><br><span class="line">                done.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fn.apply(ctx, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                done(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的源码主要多了一个检查机制，变量<code>called</code>确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = a + b;</span><br><span class="line">    callback(sum);</span><br><span class="line">    callback(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ft = thunkify(f);</span><br><span class="line"><span class="keyword">var</span> print = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>);</span><br><span class="line">ft(<span class="number">1</span>, <span class="number">2</span>)(print);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于<code>thunkify</code>只允许回调函数执行一次，所以只输出了一行结果。</p><h4 id="5-Generator函数的流程管理"><a href="#5-Generator函数的流程管理" class="headerlink" title="5. Generator函数的流程管理"></a>5. Generator函数的流程管理</h4><p>你可能会问，Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了Generator函数，Thunk函数现在可以用于Generator函数的自动流程管理。</p><p>Generator函数可以自动执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> res = g.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!res.done) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.value);</span><br><span class="line">    res = g.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Generator函数<code>gen</code>会自动执行完所有步骤。</p><p>但是，这并不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk函数就能派上用场。以读取文件为例。下面的Generator函数封装了两个异步操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line"><span class="keyword">var</span> readFileThunk = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = <span class="keyword">yield</span> readFileThunk(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(r1.toString());</span><br><span class="line">    <span class="keyword">var</span> r2 = <span class="keyword">yield</span> readFileThunk(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(r2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>yield</code>命令用于将程序的执行权移出Generator函数，那么就需要一种方法，将执行权再交还给Generator函数。</p><p>这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给Generator函数。为了便于理解，我们先看如何手动执行上面这个Generator函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1 = g.next();</span><br><span class="line">r1.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> r2 = g.next(data);</span><br><span class="line">    r2.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        g.next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>g</code>是Generator函数的内部指针，表示目前执行到哪一步。<code>next</code>方法负责将指针移动到下一步，并返回该步的信息（<code>value</code>属性和<code>done</code>属性）。</p><p>仔细查看上面的代码，可以发现Generator函数的执行过程，其实是将同一个回调函数，反复传入<code>next</code>方法的<code>value</code>属性。这使得我们可以用递归来自动完成这个过程。</p><h4 id="6-Thunk函数的自动流程管理"><a href="#6-Thunk函数的自动流程管理" class="headerlink" title="6. Thunk函数的自动流程管理"></a>6. Thunk函数的自动流程管理</h4><p>Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = fn();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = gen.next(data);</span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line">        result.value(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functon* g() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure><p>上面代码的<code>run</code>函数，就是一个Generator函数的自动执行器。内部的<code>next</code>函数就是Thunk的回调函数。<code>next</code>函数先将指针移到Generator函数的下一步（<code>gen.next</code>方法），然后判断Generator函数是否结束（<code>result.done</code>属性），如果没结束，就将<code>next</code>函数再传入Thunk函数（<code>result.value</code>属性），否则就直接退出。</p><p>有了这个执行器，执行Generator函数方便多了。不管内部有多少个异步操作，直接把Generator函数传入<code>run</code>函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在<code>yield</code>命令后面的必须是Thunk函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFileThunk(<span class="string">'fileA'</span>);</span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFileThunk(<span class="string">'fileB'</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> fn = <span class="keyword">yield</span> readFileThunk(<span class="string">'fileN'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>g</code>封装了<code>n</code>个异步的读取文件操作，只要执行<code>run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步，而且一行代码就可以执行。</p><p>Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交换程序的执行权。回调函数可以做到这一点，Promise对象也可以做到这一点。</p><hr><h3 id="五、co模块"><a href="#五、co模块" class="headerlink" title="五、co模块"></a>五、co模块</h3><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><p>co模块是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。</p><p>下面是一个Generator函数，用于依次读取两个文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>co模块可以让你不用编写Generator函数的执行器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line">co(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，Generator函数只要传入<code>co</code>函数，就会自动执行。</p><p><code>co</code>函数返回一个<code>Promise</code>对象，因此可以用<code>then</code>方法添加回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">co(gen).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Generator函数执行完毕'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，等到Generator函数执行结束，就会输出一行提示。</p><h4 id="2-co模块的原理"><a href="#2-co模块的原理" class="headerlink" title="2. co模块的原理"></a>2. co模块的原理</h4><p>为什么co可以自动执行Generator函数？</p><p>前面说过，Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p><p>两种方法可以做到这一点。</p><ul><li><p>回调函数。将异步操作包装成Thunk函数，在回调函数里交回执行权。</p></li><li><p>Promise对象。将异步操作包装成Promise对象，用<code>then</code>方法交回执行权。</p></li></ul><p>co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的<code>yield</code>命令后面，只能是Thunk函数或Promise对象。如果数组或对象的成员，全部都是Promise对象，也可以使用co，详见后文的例子。</p><p>上一节已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这时理解co模块必须的。</p><h4 id="3-基于Promise对象的自动执行"><a href="#3-基于Promise对象的自动执行" class="headerlink" title="3. 基于Promise对象的自动执行"></a>3. 基于Promise对象的自动执行</h4><p>还是沿用上面的例子。首先，把<code>fs</code>模块的<code>readFile</code>方法包装成一个Promise对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f1 = readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    <span class="keyword">var</span> f2 = readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，手动执行上面的Generator函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next().value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    g.next(data).value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        g.next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>手动执行其实就是用<code>then</code>方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">        result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            next(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，只要Generator函数还没执行到最后一步，<code>next</code>函数就调用自身，以此实现自动执行。</p><h4 id="4-co模块的源码"><a href="#4-co模块的源码" class="headerlink" title="4. co模块的源码"></a>4. co模块的源码</h4><p>co就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p><p>首先，co函数接受Generator函数作为参数，返回一个Promise对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在返回的Promise对象里面，co先检查参数<code>gen</code>是否为Generator函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将Promise对象的状态改为<code>resolved</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.call(ctx);</span><br><span class="line">        <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，co将Generator函数的内部指针对象的<code>next</code>方法，包装成<code>onFulfilled</code>函数。这主要是为了能够捕捉抛出的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.call(ctx);</span><br><span class="line">        <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line"></span><br><span class="line">        onFulfilled();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> ret;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ret = gen.next(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">            next(ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，就是关键的<code>next</code>函数，它会反复调用自身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br><span class="line">    <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">    <span class="keyword">return</span> onRejected(</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">            <span class="string">'You may only yield a function, promise, generator, array, or object, '</span></span><br><span class="line">            + <span class="string">'but the following object was passed: "'</span></span><br><span class="line">            + <span class="string">'String(ret.value)'</span></span><br><span class="line">            + <span class="string">'"'</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>next</code>函数的内部代码，一共只有四行命令。</p><p>第一行，检查当前是否为Generator函数的最后一步，如果是就返回。</p><p>第二行，确保每一步的返回值，都是Promise对象。</p><p>第三行，使用<code>then</code>方法，为返回值加上回调函数，然后通过<code>onFulfilled</code>函数再次调用<code>next</code>函数。</p><p>第四行，在参数不符合要求的情况下（参数非Thunk函数和Promise对象），将Promise对象的状态改为<code>rejected</code>，从而终止执行。</p><h4 id="5-处理并发的异步操作"><a href="#5-处理并发的异步操作" class="headerlink" title="5. 处理并发的异步操作"></a>5. 处理并发的异步操作</h4><p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p><p>这时，要把并发的操作都放在数组或对象里面，跟在<code>yield</code>语句后面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">yield</span> [</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">    ];</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">        <span class="number">1</span>: <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">        <span class="number">2</span>: <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = [n1, n2, n3];</span><br><span class="line">    <span class="keyword">yield</span> values.map(somethingAsync);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">somethingAsync</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something async</span></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码允许并发三个<code>somethingAsync</code>异步操作，等到它们全部完成，才会进行下一步。</p><h4 id="6-实例：处理Stream"><a href="#6-实例：处理Stream" class="headerlink" title="6. 实例：处理Stream"></a>6. 实例：处理Stream</h4><p>Node提供Stream模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream模式使用EventEmitter API，会释放三个事件。</p><ul><li><p>data事件：下一块数据块已经准备好了。</p></li><li><p>end事件：整个数据流处理完了。</p></li><li><p>error事件：发生错误。</p></li></ul><p>使用<code>Promise.race()</code>函数，可以判断这三个事件之中哪一个最先发生，只有当<code>data</code>事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个<code>while</code>循环，完成所有数据的读取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stream = fs.createReadStream(<span class="string">'./les_miserables.txt'</span>);</span><br><span class="line"><span class="keyword">let</span> valjeanCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">yield</span> <span class="built_in">Promise</span>.race([</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> stream.once(<span class="string">'data'</span>, resolve)),</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> stream.once(<span class="string">'end'</span>, resolve)),</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> stream.once(<span class="string">'error'</span>, reject)),</span><br><span class="line">        ]);</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stream.removeAllListeners(<span class="string">'data'</span>);</span><br><span class="line">        stream.removeAllListeners(<span class="string">'end'</span>);</span><br><span class="line">        stream.removeAllListeners(<span class="string">'error'</span>);</span><br><span class="line">        valjeanCount += (res.toString().match(<span class="regexp">/valjean/ig</span>) || []).length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'count:'</span>, valjeanCount);        <span class="comment">// count: 1120</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码采用Stream模式读取《悲惨世界》的文本文件，对于每个数据库都是用<code>stream.once</code>方法，在<code>data</code>、<code>end</code>、<code>error</code>三个事件上添加一次性回调函数。变量<code>res</code>只有在<code>data</code>事件发生时才有值，然后累加每个数据块之中<code>valjean</code>这个词出现的次数。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/generator-async">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中Generator函数的异步应用。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/generator-async&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(11) 字符串的扩展</title>
    <link href="http://www.xiaoleon.cn/2018/06/07/es6-11/"/>
    <id>http://www.xiaoleon.cn/2018/06/07/es6-11/</id>
    <published>2018-06-07T02:59:39.000Z</published>
    <updated>2018-06-11T11:25:12.909Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中对字符串的扩展。节选自<a href="(http://es6.ruanyifeng.com/#docs/string">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、字符的Unicode表示法"><a href="#一、字符的Unicode表示法" class="headerlink" title="一、字符的Unicode表示法"></a>一、字符的Unicode表示法</h3><p>JavaScript允许采用<code>\uxxxx</code>形式表示一个字符串，其中<code>xxxx</code>表示字符的Unicode码点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u0061"</span></span><br><span class="line"><span class="comment">// 'a'</span></span><br></pre></td></tr></table></figure><p>但是，这种表示法只限于码点在<code>\u0000</code>~<code>\uFFFF</code>之间的字符。超出这个范围的字符，必须采用两个双字节的形式表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\uD842\uDFB7"</span></span><br><span class="line"><span class="comment">// '𠮷'</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u20BB7"</span></span><br><span class="line"><span class="comment">// " 7"</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果直接在<code>\u</code>后面跟上超过<code>0xFFFF</code>的数值（比如<code>u20BB7</code>），JavaScript会理解成<code>\u20BB+7</code>。由于<code>\u20BB</code>是一个不可打印的字符，所以只会显示一个空格，后面跟着一个<code>7</code>。</p><p>ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span></span><br><span class="line"><span class="comment">// '𠮷'</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"</span></span><br><span class="line"><span class="comment">// 'ABC'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="number">123</span>;</span><br><span class="line">hell\u&#123;<span class="number">6</span>F&#125;</span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;1F680&#125;'</span> === <span class="string">'\uD83D\uDE80'</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，最后一个例子表明，大括号表示法与四字节的UTF16编码是等价的。</p><p>有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\z'</span> === <span class="string">'z'</span>    <span class="comment">// true</span></span><br><span class="line"><span class="string">'\172'</span> === <span class="string">'z'</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">'\x7A'</span> === <span class="string">'z'</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u007A'</span> === <span class="string">'z'</span>    <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u&#123;7A&#125;'</span> === <span class="string">'z'</span>    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h3 id="二、codePointAt"><a href="#二、codePointAt" class="headerlink" title="二、codePointAt()"></a>二、codePointAt()</h3><p>JavaScript内部，字符以UTF-16的格式存储，每个字符固定为2个字节。对于那些需要4个字节存储的字符（Unicode码点大于<code>0xFFFF</code>的字符），JavaScript会认为它们是两个字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷'</span>;</span><br><span class="line"></span><br><span class="line">s.length        <span class="comment">// 2</span></span><br><span class="line">s.charAt(<span class="number">0</span>)     <span class="comment">// ''</span></span><br><span class="line">s.charAt(<span class="number">1</span>)     <span class="comment">// ''</span></span><br><span class="line">s.charCodeAt(<span class="number">0</span>)     <span class="comment">// 55362</span></span><br><span class="line">s.charCodeAt(<span class="number">1</span>)     <span class="comment">// 57271</span></span><br></pre></td></tr></table></figure><p>上面代码中，汉字“𠮷”的码点是<code>0x20BB7</code>，UTF-16编码为<code>0xDB42 0xDFB7</code>（十进制为<code>55362 57271</code>），需要4个字节存储。对于这种4个字节的字符，JavaScript不能正确处理，字符串长度会误判为2，而且<code>charAt</code>方法无法读取整个字符，<code>charCodeAt</code>方法只能分别返回前两个字节和后两个字节的值。</p><p>ES6提供了<code>codePointAt</code>方法，能够正确处理4个字节存储的字符，返回一个字符的码点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>)        <span class="comment">// 134071</span></span><br><span class="line">s.codePointAt(<span class="number">1</span>)        <span class="comment">// 57271</span></span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">2</span>)        <span class="comment">// 97</span></span><br></pre></td></tr></table></figure><p><code>codePointAt</code>方法的参数，是字符在字符串中的位置（从0开始）。上面代码中，JavaScript将“𠮷a”视为三个字符，<code>codePointAt</code>方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点134071（即十六进制的<code>20BB7</code>）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，<code>codePointAt</code>方法的结果与<code>charCodeAt</code>方法相同。</p><p>总之，<code>codePointAt</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString</code>方法转换一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>)       <span class="comment">// '20bb7'</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>).toString(<span class="number">16</span>)       <span class="comment">// '61'</span></span><br></pre></td></tr></table></figure><p>我们注意到，<code>codePointAt</code>方法的参数，仍然是不正确的。比如，上面代码中，字符<code>a</code>在字符串<code>s</code>中的正确位置序号应该是1，但是必须向<code>codePointAt</code>方法传入2。解决这个问题的一个办法是使用<code>for...of</code>循环，因为它会正确识别32位的UTF-16字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure><p><code>codePointAt</code>方法是测试一个字符由两个字节还是四个字节组成的最简单方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is32Bit(<span class="string">'𠮷'</span>)       <span class="comment">// true</span></span><br><span class="line">is32Bit(<span class="string">'a'</span>)        <span class="comment">// false</span></span><br></pre></td></tr></table></figure><hr><h3 id="三、String-fromCodePoint"><a href="#三、String-fromCodePoint" class="headerlink" title="三、String.fromCodePoint()"></a>三、String.fromCodePoint()</h3><p>ES5提供<code>String.fromCharCode</code>方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于<code>0xFFFF</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// 'ஷ'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>String.fromCharCode</code>不能识别大于<code>0xFFFF</code>的码点，所以<code>0x20BB7</code>就发生了溢出，最高位<code>2</code>被舍弃了，最后返回码点<code>\u0BB7</code>对应的字符，而不是码点<code>\u20BB7</code>对应的字符。</p><p>ES6提供了<code>String.fromCodePoint</code>方法，可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode</code>方法的不足。在作用上，正好与<code>codePointAt</code>方法相反。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// '𠮷'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">'x\uD83D\uDE80y'</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成为一个字符串返回。</p><p>注意，<code>fromCodePoint</code>方法定义在<code>String</code>对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上。</p><hr><h3 id="四、字符串的遍历器接口"><a href="#四、字符串的遍历器接口" class="headerlink" title="四、字符串的遍历器接口"></a>四、字符串的遍历器接口</h3><p>ES6为字符串添加了遍历器接口，使得字符串可以被<code>for...of</code>循环遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(codePoint);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'f'</span></span><br><span class="line"><span class="comment">// 'o'</span></span><br><span class="line"><span class="comment">// 'o'</span></span><br></pre></td></tr></table></figure><p>除了遍历字符串，这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ' '</span></span><br><span class="line"><span class="comment">// ' '</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串<code>text</code>只有一个字符，但是<code>for</code>循环会认为它包含两个字符（都不可打印），而<code>for...of</code>循环会正确识别出这是一个字符。</p><hr><h3 id="五、at"><a href="#五、at" class="headerlink" title="五、at()"></a>五、at()</h3><p>ES5对字符串对象提供的<code>charAt</code>方法，返回字符串给定位置的字符。该方法不能识别码点大于<code>0xFFFF</code>的字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.charAt(<span class="number">0</span>)     <span class="comment">// 'a'</span></span><br><span class="line"><span class="string">'𠮷'</span>.charAt(<span class="number">0</span>)      <span class="comment">// '\uD842'</span></span><br></pre></td></tr></table></figure><p>上面代码中的第二条语句，<code>charAt</code>方法期望返回的是用2个字节表示的字符，但汉字“𠮷”占用了4个字节，<code>charAt(0)</code>表示获取这4个字节中的前2个字节，很显然，这是无法正常显示的。</p><p>目前，有一个提案，提出字符串实例的<code>at</code>方法，可以识别Unicode编号大于<code>0xFFFF</code>的字符，返回正确的字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.at(<span class="number">0</span>)     <span class="comment">// 'a'</span></span><br><span class="line"><span class="string">'𠮷'</span>.at(<span class="number">0</span>)      <span class="comment">// '𠮷'</span></span><br></pre></td></tr></table></figure><p>这个方法可以通过垫片库实现。</p><hr><h3 id="六、normalize"><a href="#六、normalize" class="headerlink" title="六、normalize()"></a>六、normalize()</h3><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如<code>Ǒ</code>（<code>\u01D1</code>）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如<code>o</code>（<code>\u004F</code>）和<code>ˇ</code>（<code>\u030C</code>）合成<code>Ǒ</code>（<code>\u004F\u030C</code>）。</p><p>这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span> === <span class="string">'\u004F\u030C'</span>     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u01D1'</span>.length             <span class="comment">// 1</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span>.length       <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码表示，JavaScript将合成字符视为两个字符，导致两种表示方法不相等。</p><p>ES6提供字符串实例的<code>normalize()</code>方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize()</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>normalize</code>方法可以接受一个参数来指定<code>normalize</code>的方式，参数的四个可选值如下。</p><ul><li><p><code>NFC</code>，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</p></li><li><p><code>NFD</code>，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</p></li><li><p><code>NFKC</code>，表示“兼容等价合成”（Normalization Form Campatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，<code>normalize</code>方法不能识别中文。）</p></li><li><p><code>NFKD</code>，表示“兼容等价分解”（Normalization Form Campatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFC'</span>).length      <span class="comment">// 1</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFD'</span>).length      <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码表示，<code>NFC</code>参数返回字符的合成形式，<code>NFD</code>参数表示返回字符的分解形式。</p><p>不过，<code>normalize</code>方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过Unicode编号区间判断。</p><hr><h3 id="七、includes-、startsWith-、endsWith"><a href="#七、includes-、startsWith-、endsWith" class="headerlink" title="七、includes()、startsWith()、endsWith()"></a>七、includes()、startsWith()、endsWith()</h3><p>传统上，JavaScript只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串上。ES6又提供了三种新方法。</p><ul><li><p><code>includes()</code>：返回布尔值，表示是否找到了参数字符串</p></li><li><p><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部</p></li><li><p><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello World!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'Hello'</span>);      <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'!'</span>);            <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>);            <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>);       <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>);         <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>);         <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p><hr><h3 id="八、repeat"><a href="#八、repeat" class="headerlink" title="八、repeat()"></a>八、repeat()</h3><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>);      <span class="comment">// 'xxx'</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>);  <span class="comment">// 'hellohello'</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">0</span>);     <span class="comment">// ''</span></span><br></pre></td></tr></table></figure><p>参数如果是小数，会被取整。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="number">2.9</span>)    <span class="comment">// 'nana'</span></span><br></pre></td></tr></table></figure><p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="literal">Infinity</span>)       <span class="comment">// RangeError</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">-1</span>)             <span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure><p>但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，<code>repeat</code>视同为0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="number">-0.9</span>)       <span class="comment">// ''</span></span><br></pre></td></tr></table></figure><p>参数<code>NaN</code>等同于0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="literal">NaN</span>)        <span class="comment">// ''</span></span><br></pre></td></tr></table></figure><p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>)       <span class="comment">// ''</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>)        <span class="comment">// 'nanana'</span></span><br></pre></td></tr></table></figure><hr><h3 id="九、padStart-、padEnd"><a href="#九、padStart-、padEnd" class="headerlink" title="九、padStart()、padEnd()"></a>九、padStart()、padEnd()</h3><p>ES7引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于补全头部，<code>padEnd()</code>用于补全尾部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>)       <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>)       <span class="comment">// 'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>)         <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>)         <span class="comment">// 'xaba'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>padStart</code>和<code>padEnd</code>一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p><p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'xxx'</span>.padStart(<span class="number">2</span>, <span class="string">'ab'</span>)     <span class="comment">// 'xxx'</span></span><br><span class="line"><span class="string">'xxx'</span>.padEnd(<span class="number">2</span>, <span class="string">'ab'</span>)       <span class="comment">// 'xxx'</span></span><br></pre></td></tr></table></figure><p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">'0123456789'</span>)    <span class="comment">// '0123456abc'</span></span><br></pre></td></tr></table></figure><p>如果省略第二个参数，默认使用空格补全长度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>)     <span class="comment">// '   x'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>)       <span class="comment">// 'x   '</span></span><br></pre></td></tr></table></figure><p><code>padStart</code>的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>)       <span class="comment">// '0000000001'</span></span><br><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>)      <span class="comment">// '0000000012'</span></span><br><span class="line"><span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>)  <span class="comment">// '0000123456'</span></span><br></pre></td></tr></table></figure><p>另一个用途是提示字符串格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>)     <span class="comment">// 'YYYY-MM-12'</span></span><br><span class="line"><span class="string">'09-12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>)  <span class="comment">// 'YYYY-09-12'</span></span><br></pre></td></tr></table></figure><hr><h3 id="十、matchAll"><a href="#十、matchAll" class="headerlink" title="十、matchAll()"></a>十、matchAll()</h3><p><code>matchAll</code>方法返回一个正则表达式在当前字符串的所有匹配，详见正则的扩展一章。</p><hr><h3 id="十一、模板字符串"><a href="#十一、模板字符串" class="headerlink" title="十一、模板字符串"></a>十一、模板字符串</h3><p>传统的JavaScript语言，输出模板通常是这样写的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(</span><br><span class="line">    <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</span><br><span class="line">    <span class="string">'items in your basket, '</span> +</span><br><span class="line">    <span class="string">'&lt;em&gt;'</span> + basket.onSale +</span><br><span class="line">    <span class="string">'&lt;/em&gt; are on sale!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(<span class="string">`</span></span><br><span class="line"><span class="string">    There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">    in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">    are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string">not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'Bob'</span>, time = <span class="string">'today'</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure><p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">`\`Yo\` World!`</span>;</span><br></pre></td></tr></table></figure><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>)</span><br></pre></td></tr></table></figure><p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果不想要这个换行，可以使用<code>trim</code>方法消除它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>).trim();</span><br></pre></td></tr></table></figure><p>模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></span><br><span class="line"><span class="comment">// '1 + 2 = 3'</span></span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// '1 + 4 = 5'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span></span><br><span class="line"><span class="comment">// '3'</span></span><br></pre></td></tr></table></figure><p>模板字符串中还能调用函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure><p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法。</p><p>如果模板字符串中的变量没有声明，将报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量place没有声明</span></span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">`Hello, <span class="subst">$&#123;place&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`Hello <span class="subst">$&#123;<span class="string">'World'</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// 'Hello World'</span></span><br></pre></td></tr></table></figure><p>模板字符串甚至还能嵌套。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;table&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">        &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">        &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.second&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    `</span>).join(<span class="string">''</span>)&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/table&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123; <span class="attr">first</span>: <span class="string">'&lt;Jane&gt;'</span>, <span class="attr">last</span>: <span class="string">'Bond'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">first</span>: <span class="string">'Lars'</span>, <span class="attr">last</span>: <span class="string">'&lt;Croft&gt;'</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tmpl(data));</span><br><span class="line"><span class="comment">//  &lt;table&gt;</span></span><br><span class="line"><span class="comment">//      </span></span><br><span class="line"><span class="comment">//      &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//      &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//      &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  &lt;/table&gt;</span></span><br></pre></td></tr></table></figure><p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'return '</span> + <span class="string">'`Hello $&#123;name&#125;!`'</span>;</span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'name'</span>, str);</span><br><span class="line">func(<span class="string">'Jack'</span>)        <span class="comment">// 'Hello Jack!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'(name) =&gt; `Hello $&#123;name&#125;!`'</span>;</span><br><span class="line"><span class="keyword">let</span> func = <span class="built_in">eval</span> call(<span class="literal">null</span>, str);</span><br><span class="line">func(<span class="string">'Jack'</span>)        <span class="comment">// 'Hello Jack!'</span></span><br></pre></td></tr></table></figure><hr><h3 id="十二、实例：模板编译"><a href="#十二、实例：模板编译" class="headerlink" title="十二、实例：模板编译"></a>十二、实例：模板编译</h3><p>下面，我们来看一个通过模板字符串，生成正式模板的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;    </span></span><br><span class="line"><span class="string">    &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用<code>&lt;%...%&gt;</code>放置JavaScript代码，使用<code>&lt;%=...%&gt;</code>输出JavaScript表达式。</p><p>怎么编译这个模板字符串呢？</p><p>一种思路是将其转换为JavaScript表达式字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo(<span class="string">'&lt;ul&gt;'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.supplies.length; i++) &#123;</span><br><span class="line">    echo(<span class="string">'&lt;li&gt;'</span>);</span><br><span class="line">    echo(data.supplies[i]);</span><br><span class="line">    echo(<span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">echo(<span class="string">'&lt;/ul&gt;'</span>);</span><br></pre></td></tr></table></figure><p>这个转换使用正则表达式就行了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</span><br><span class="line"><span class="keyword">let</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</span><br><span class="line"></span><br><span class="line">template = template</span><br><span class="line">    .replace(evalExpr, <span class="string">'`); \n echo($1); \n echo(`'</span>)</span><br><span class="line">    .replace(expr, <span class="string">'`); \n $1 \n echo(`'</span>);</span><br><span class="line"></span><br><span class="line">template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br></pre></td></tr></table></figure><p>然后，将<code>template</code>封装在一个函数里面返回，就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = </span><br><span class="line"><span class="string">`(function parse(data) &#123;</span></span><br><span class="line"><span class="string">    let output = '';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    funtion echo(html) &#123;</span></span><br><span class="line"><span class="string">        output += html;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;template&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return output;</span></span><br><span class="line"><span class="string">&#125;)`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> script;</span><br></pre></td></tr></table></figure><p>将上面的内容拼装成一个模板编译函数<code>compile</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">template</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</span><br><span class="line">    <span class="keyword">const</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</span><br><span class="line"></span><br><span class="line">    template = template</span><br><span class="line">        .replace(evalExpr, <span class="string">'`); echo($1); \n echo(`'</span>)</span><br><span class="line">        .replace(expr, <span class="string">'`); \n $1 \n echo(`'</span>);</span><br><span class="line"></span><br><span class="line">    template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> script = </span><br><span class="line">    <span class="string">`(function parse(data) &#123;</span></span><br><span class="line"><span class="string">        let output = '';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        function echo(html) &#123;</span></span><br><span class="line"><span class="string">            output += html;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;template&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return output</span></span><br><span class="line"><span class="string">    &#125;)`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> script;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compile</code>函数的用法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parse = <span class="built_in">eval</span>(compile(template));</span><br><span class="line">div.innerHTML = parse(&#123; <span class="attr">supplies</span>: [<span class="string">'broom'</span>, <span class="string">'mop'</span>, <span class="string">'cleaner'</span>] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  &lt;ul&gt;</span></span><br><span class="line"><span class="comment">//      &lt;li&gt;broom&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//      &lt;li&gt;mop&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//      &lt;li&gt;cleaner&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//  &lt;/ul&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="十三、标签模板"><a href="#十三、标签模板" class="headerlink" title="十三、标签模板"></a>十三、标签模板</h3><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="string">`123`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">alert(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p><p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123;a + b&#125;</span> world <span class="subst">$&#123;a * b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串前面有一个标识名<code>tag</code>，它是一个函数。整个表达式的返回值，就是<code>tag</code>函数处理模板字符串后的返回值。</p><p>函数<code>tag</code>依次会接收到多个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，依此类推。</p><p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。</p><p>也就是说，<code>tag</code>函数实际上以下面的形式调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>我们可以按照需要编写<code>tag</code>函数的代码。下面是<code>tag</code>函数的一种写法，以及运行结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">s, v1, v2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(s[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(s[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(v1);</span><br><span class="line">    <span class="built_in">console</span>.log(v2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'OK'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123;a + b&#125;</span> world <span class="subst">$&#123;a * b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 'Hello '</span></span><br><span class="line"><span class="comment">// ' world '</span></span><br><span class="line"><span class="comment">// ''</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 50</span></span><br><span class="line"><span class="comment">// 'OK'</span></span><br></pre></td></tr></table></figure><p>下面是一个更复杂的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> msg = passthru<span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total * <span class="number">1.05</span>&#125;</span> with tax)`</span>;</span><br><span class="line"></span><br><span class="line">functon passthru(literals) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; literals.length) &#123;</span><br><span class="line">        result += literals[i++];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">            result += <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg</span><br><span class="line"><span class="comment">// 'The toal is 30 (31.5 with tax)'</span></span><br></pre></td></tr></table></figure><p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p><p><code>passthru</code>函数采用rest参数的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> output = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">let</span> index;</span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">        output += literals[index] + values[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output += literals[index];</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Escape special characters in the subinsitution.</span></span><br><span class="line">        s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">                .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">                .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't escape special charaters in the template.</span></span><br><span class="line">        s += templateData[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 恶意代码</span></span><br><span class="line"><span class="keyword">let</span> sender = <span class="string">'&lt;script&gt;alert("abc")&lt;/script&gt;'</span>;</span><br><span class="line"><span class="keyword">let</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">message</span><br><span class="line"><span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")%lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><p>标签模板的另一个应用，就是多语言转换（国际化处理，i18n）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i18n<span class="string">`Welcom to <span class="subst">$&#123;siteName&#125;</span>, you are visitor number <span class="subst">$&#123;visitorNumber&#125;</span>!`</span></span><br><span class="line"><span class="comment">// '欢迎访问xxx，您是第xxxx位访问者！'</span></span><br></pre></td></tr></table></figure><p>模板字符串本身并不能取代Mustache之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的hashTemplate函数</span></span><br><span class="line"><span class="comment">// 是一个自定义的模板处理函数</span></span><br><span class="line"><span class="keyword">let</span> libraryHtml = hasTemplate<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">        #for book in <span class="subst">$&#123;myBooks&#125;</span></span></span><br><span class="line"><span class="string">            &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        #end</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>除此之外，你甚至可以使用标签模板，在JavaScript语言之中嵌入其他语言。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsx<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;input</span></span><br><span class="line"><span class="string">            ref='input'</span></span><br><span class="line"><span class="string">            onChange='<span class="subst">$&#123;<span class="keyword">this</span>.handleChange&#125;</span>'</span></span><br><span class="line"><span class="string">            defaultValue='<span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span>'</span></span><br><span class="line"><span class="string">        /&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>上面的代码通过<code>jsx</code>函数，将一个DOM字符串转为React对象，你可以在Github上找到<code>jsx</code>函数的具体实现。</p><p>下面则是一个假想的例子，通过java函数，在JavaScript代码之中运行Java代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java<span class="string">`</span></span><br><span class="line"><span class="string">class HelloWorldApp &#123;</span></span><br><span class="line"><span class="string">    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="string">        System.out.println("Hello World!");</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line">HelloWorldApp.main();</span><br></pre></td></tr></table></figure><p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log<span class="string">`123`</span></span><br><span class="line"><span class="comment">// ['123', raw: Array[1]]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>console.log</code>接受的参数，实际上是一个数组。该数组有一个<code>raw</code>属性，保存的是转义后的原字符。</p><p>请看下面的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tag<span class="string">`First line\nSecond line`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">srings</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// string.raw[0] 为 "First line\\nSecond line"</span></span><br><span class="line">    <span class="comment">// 打印输出 "First line\nSecond line"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>tag</code>函数的第一个参数<code>strings</code>，有一个<code>raw</code>属性，也指向一个数组。该数组的成员与<code>strings</code>数组完全一致。比如，<code>strings</code>数组是<code>[&quot;First line\nSecond line&quot;]</code>，那么<code>strings.raw</code>数组就是<code>[&quot;First line\\nSecond line&quot;]</code>。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw数组会将<code>\n</code>视为<code>\\</code>和<code>n</code>两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p><hr><h3 id="十四、String-raw"><a href="#十四、String-raw" class="headerlink" title="十四、String.raw()"></a>十四、String.raw()</h3><p>ES6还为原生的String对象，提供了一个<code>raw</code>方法。</p><p><code>String.raw</code>方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应替换变量后的模板字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span> + <span class="number">3</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// 返回 'Hi\\n5!'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// 返回 'Hi\\u000A!'</span></span><br></pre></td></tr></table></figure><p>如果原字符串的斜杠已经转义，那么<code>String.raw</code>会再次转义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\\n`</span></span><br><span class="line"><span class="comment">// 返回 'Hi\\\\n'</span></span><br></pre></td></tr></table></figure><p><code>String.raw</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p><p><code>String.raw</code>方法也可以作为正常的函数。这时，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw(&#123;<span class="attr">raw</span>: <span class="string">'test'</span>&#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 't0e1s2t'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">String</span>.raw(&#123;<span class="attr">raw</span>: [<span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>]&#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>作为函数，<code>String.raw</code>的代码实现基本如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw = <span class="function"><span class="keyword">function</span>(<span class="params">strings, ...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> output = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">let</span> index;</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">        output += strings.raw[index] + values[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output += strings.raw[index];</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="十五、模板字符串的限制"><a href="#十五、模板字符串的限制" class="headerlink" title="十五、模板字符串的限制"></a>十五、模板字符串的限制</h3><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p><p>举例来说，标签模板里面可以嵌入LaTEX语言。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">latex</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">document</span> = latex<span class="string">`</span></span><br><span class="line"><span class="string">\newcommand&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125;        // 正常工作</span></span><br><span class="line"><span class="string">\newcommand&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125;    // 报错</span></span><br><span class="line"><span class="string">\newcommand&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125;    // 报错</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Breve over the h goes \u&#123;h&#125;ere      // 报错</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>document</code>内嵌的模板字符串，对于LaTEX语言来说完全是合法的，但是JavaScript引擎会报错，原因就在于字符串的转义。</p><p>模板字符串会将<code>\u00FF</code>和<code>\u{42}</code>当作Unicode字符进行转义，所以<code>\unicode</code>解析时报错；而<code>\x56</code>会被当作十六进制字符串转义，所以<code>\xerxes</code>会报错。也就是说，<code>\u</code>和<code>\x</code>在LaTEX里面有特殊含义，但是JavaScript将它们转义了。</p><p>为了解决这个问题，ES2018放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回<code>undefined</code>，而不是报错，并且从<code>raw</code>属性上面可以取到原始字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(strs[<span class="number">0</span>] === <span class="literal">undefined</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(strs.raw[<span class="number">0</span>] === <span class="string">'\\unicode and \\u&#123;55&#125;'</span>);</span><br><span class="line">&#125;</span><br><span class="line">tag<span class="string">`\unicode and \u&#123;55&#125;`</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript引擎将第一个字符设置为<code>undefined</code>，但是<code>raw</code>属性依然可以得到原始字符串，因此<code>tag</code>函数还是可以对原字符串进行处理。</p><p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bad = <span class="string">`bad escape sequence: \unicode`</span>;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/string">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中对字符串的扩展。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/string&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(10) 修饰器</title>
    <link href="http://www.xiaoleon.cn/2018/06/05/es6-10/"/>
    <id>http://www.xiaoleon.cn/2018/06/05/es6-10/</id>
    <published>2018-06-05T01:03:46.000Z</published>
    <updated>2018-06-11T11:25:12.899Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中添加的修饰器。节选自<a href="(http://es6.ruanyifeng.com/#docs/decorator">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、类的修饰"><a href="#一、类的修饰" class="headerlink" title="一、类的修饰"></a>一、类的修饰</h3><p>许多面向对象的语言都有修饰器（Decorator）函数，用来修改类的行为。目前，有一个提案将这项功能，引入了ECMAScript。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyTestableClass.isTestable  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>@testable</code>就是一个修饰器。它修改了<code>MyTestableClass</code>这个类的行为，为它加上了静态属性<code>isTestable</code>。<code>testable</code>函数的参数是<code>MyTestableClass</code>类本身。</p><p>基本上，修饰器的行为就是下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure><p>也就是说，修饰器是一个对类进行处理的函数。修饰器函数的第一个参数，就是所要修饰的目标类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>testable</code>函数的<code>target</code>，就是会被修饰的类。</p><p>如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        target.isTestable = isTestable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">true</span>) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line">MyTestableClass.isTestable      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line">MyClass.isTestable      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，修饰器<code>testable</code>可以接受参数，这就等于可以修改修饰器的行为。</p><p>注意，修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。</p><p>前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的<code>prototype</code>对象操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.prototype.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyTestableClass();</span><br><span class="line">obj.isTestable      <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，修饰器函数<code>testable</code>是在目标类的<code>prototype</code>对象上添加属性，因此就可以在实例上调用。</p><p>下面是另外一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mixins.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;mixins&#125; <span class="keyword">from</span> <span class="string">'./mixins'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    foo() &#123;<span class="built_in">console</span>.log(<span class="string">'foo'</span>)&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo()       <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><p>上面代码通过修饰器<code>mixins</code>，把<code>Foo</code>对象的方法添加到了<code>MyClass</code>的实例上面，可以用<code>Object.assign()</code>模拟这个功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    foo() &#123;<span class="built_in">console</span>.log(<span class="string">'foo'</span>)&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, Foo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo()       <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><p>实际开发中，React与Redux库结合使用时，常常要写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReactComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(MyReactComponent)</span><br></pre></td></tr></table></figure><p>有了装饰器，就可以改写上面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@connect(mapStateToProps, mapDispatchToProps)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>相对来说，后一种写法看上去更容易理解。</p><hr><h3 id="二、方法的修饰"><a href="#二、方法的修饰" class="headerlink" title="二、方法的修饰"></a>二、方法的修饰</h3><p>修饰器不仅可以修饰类，还可以修饰类的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    @readonly</span><br><span class="line">    name() &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，修饰器<code>readonly</code>用来修饰类的<code>name</code>方法。</p><p>修饰器函数<code>readonly</code>一共可以接受三个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// descriptor对象原来的值</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//      value: specifiedFunction,</span></span><br><span class="line">    <span class="comment">//      enumerable: false,</span></span><br><span class="line">    <span class="comment">//      configurable: true,</span></span><br><span class="line">    <span class="comment">//      writable: true</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readonly(Person.prototype, <span class="string">'name'</span>, descriptor);</span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">'name'</span>, descriptor)</span><br></pre></td></tr></table></figure><p>修饰器的第一个参数是类的原型对象，上例是<code>Person.prototype</code>，修饰器的本意是要“修饰”类的实例，但是这个时候实例还没生成，所以只能去修饰原型（这不同于类的修饰，那种情况时<code>target</code>参数指的是类本身）；第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。</p><p>另外，上面代码说明，修饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。</p><p>下面是另一个例子，修改属性描述对象的<code>enumerable</code>属性，使得该属性不可遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    @nonenumerable</span><br><span class="line">    get kidCount() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.children.length; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonenumerable</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    descriptor.enumerable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的<code>@log</code>修饰器，可以起到输出日志的作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">    @log</span><br><span class="line">    add(a, b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oldValue = descriptor.value;</span><br><span class="line"></span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Calling <span class="subst">$&#123;name&#125;</span> with`</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> oldValue.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> math = <span class="keyword">new</span> <span class="built_in">Math</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// passed parameters should get logged now</span></span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>@log</code>修饰器的作用就是在执行原始的操作之前，执行一次<code>console.log</code>，从而达到输出日志的目的。</p><p>修饰器有注释的作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    @readonly</span><br><span class="line">    @nonenumerable</span><br><span class="line">    name() &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中，我们一眼就能看出，<code>Person</code>类是可测试的，而<code>name</code>方法是只读和不可枚举的。</p><p>下面是使用Decorator写法的组件，看上去一目了然。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    tag: <span class="string">'my-component'</span>,</span><br><span class="line">    styleUrl: <span class="string">'my-component.scss'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">    @Prop() first: string;</span><br><span class="line">    @Prop() last: string;</span><br><span class="line">    @State() isVisible: boolean = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;p&gt;Hello, my name is $&#123;<span class="keyword">this</span>.first&#125; $&#123;<span class="keyword">this</span>.last&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>如果同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'evaluated'</span>, id);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">target, property, descriptor</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'executed'</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    @dec(<span class="number">1</span>)</span><br><span class="line">    @dec(<span class="number">2</span>)</span><br><span class="line">    method() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluated 1</span></span><br><span class="line"><span class="comment">// evaluated 2</span></span><br><span class="line"><span class="comment">// executed 2</span></span><br><span class="line"><span class="comment">// executed 1</span></span><br></pre></td></tr></table></figure><hr><h3 id="三、为什么修饰器不能用于函数？"><a href="#三、为什么修饰器不能用于函数？" class="headerlink" title="三、为什么修饰器不能用于函数？"></a>三、为什么修饰器不能用于函数？</h3><p>修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@add</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，意图是执行后<code>counter</code>等于1，但是实际上结果是<code>counter</code>等于0。因为函数提升，使得世纪之星的代码是下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@add</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter;</span><br><span class="line"><span class="keyword">var</span> add;</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是另一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readOnly = <span class="built_in">require</span>(<span class="string">'some-decorator'</span>);</span><br><span class="line"></span><br><span class="line">@readOnly</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码也有问题，因为实际执行是下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readOnly;</span><br><span class="line"></span><br><span class="line">@readOnly</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readOnly = <span class="built_in">require</span>(<span class="string">'some-decorator'</span>);</span><br></pre></td></tr></table></figure><p>总之，由于存在函数提升，使得修饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。</p><p>另一方面，如果一定要修饰函数，可以采用高阶函数的形式直接执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingDecorator</span>(<span class="params">wrapped</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Starting'</span>);</span><br><span class="line">        <span class="keyword">const</span> result = wrapped.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Finished'</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapped = loggingDecorator(doSomething);</span><br></pre></td></tr></table></figure><hr><h3 id="四、core-decorators-js"><a href="#四、core-decorators-js" class="headerlink" title="四、core-decorators.js"></a>四、core-decorators.js</h3><p><code>core-decorators.js</code>是一个第三方模块，提供了几个常见的修饰器，通过它可以更好地理解修饰器。</p><h4 id="1-autobind"><a href="#1-autobind" class="headerlink" title="1. @autobind"></a>1. @autobind</h4><p><code>autobind</code>修饰器使得方法中的<code>this</code>对象，绑定原始对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;autobind&#125; <span class="keyword">from</span> <span class="string">'core-decorators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    @autobind</span><br><span class="line">    getPerson() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> getPerson = person.getPerson();</span><br><span class="line"></span><br><span class="line">getPerson() === person       <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="2-readonly"><a href="#2-readonly" class="headerlink" title="2. @readonly"></a>2. @readonly</h4><p><code>readonly</code>修饰器使得属性或方法不可写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;readonly&#125; <span class="keyword">from</span> <span class="string">'core-decorators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    @readonly</span><br><span class="line">    entree = <span class="string">'steak'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dinner = <span class="keyword">new</span> Meal();</span><br><span class="line">dinner.entree = <span class="string">'salmon'</span>;</span><br><span class="line"><span class="comment">// Cannot assign to read only property 'entree' of [object Object]</span></span><br></pre></td></tr></table></figure><h4 id="3-override"><a href="#3-override" class="headerlink" title="3. @override"></a>3. @override</h4><p><code>override</code>修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;override&#125; <span class="keyword">from</span> <span class="string">'core-decorators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    speak(first, second) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    @override</span><br><span class="line">    speak() &#123;&#125;</span><br><span class="line">    <span class="comment">// SyntaxError: Child#speak() does not properly override Parent#speak(first, second)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    @override</span><br><span class="line">    speaks() &#123;&#125;</span><br><span class="line">    <span class="comment">// SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Did you mean 'speak'?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-deprecate（别名-deprecated）"><a href="#4-deprecate（别名-deprecated）" class="headerlink" title="4. @deprecate（别名@deprecated）"></a>4. @deprecate（别名@deprecated）</h4><p><code>deprecate</code>或<code>deprecated</code>修饰器在控制台显示一条警告，表示该方法将废除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;deprecate&#125; <span class="keyword">from</span> <span class="string">'core-decorators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    @deprecate</span><br><span class="line">    facepalm() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @deprecate(<span class="string">'We stopped facepalming'</span>)</span><br><span class="line">    facepalmHard() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @deprecate(<span class="string">'We stopped facepalming'</span>, &#123;<span class="attr">url</span>: <span class="string">'http://xxxxxx'</span>&#125;)</span><br><span class="line">    facepalmHarder() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.facepalm();</span><br><span class="line"><span class="comment">// DEPRECATION Person#facepalm: This function will be removed in future version.</span></span><br><span class="line"></span><br><span class="line">person.facepalmHard();</span><br><span class="line"><span class="comment">// DEPRECATION Person#facepalmHard: We stopped facepaling</span></span><br><span class="line"></span><br><span class="line">person.facepalmHarder();</span><br><span class="line"><span class="comment">// DEPRECATION Person#facepalmHarder: We stopped facepalming</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// See http://xxxxxxx</span></span><br></pre></td></tr></table></figure><h4 id="5-suppressWarnings"><a href="#5-suppressWarnings" class="headerlink" title="5. @suppressWarnings"></a>5. @suppressWarnings</h4><p><code>suppressWarnings</code>修饰器抑制<code>deprecated</code>修饰器导致的<code>console.warn()</code>调用。但是，异步代码发出的调用除外。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;deprecated, suppressWarnings&#125; <span class="keyword">from</span> <span class="string">'core-decorators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    @deprecated</span><br><span class="line">    facepalm() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @suppressWarnings</span><br><span class="line">    facepalmWithioutWarning() &#123;</span><br><span class="line">        <span class="keyword">this</span>.facepalm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.facepalmWithoutWarning();</span><br><span class="line"><span class="comment">// no warning is logged</span></span><br></pre></td></tr></table></figure><hr><h3 id="五、使用修饰器实现自动发布事件"><a href="#五、使用修饰器实现自动发布事件" class="headerlink" title="五、使用修饰器实现自动发布事件"></a>五、使用修饰器实现自动发布事件</h3><p>我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postal = <span class="built_in">require</span>(<span class="string">'postal/lib/postal.lodash'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">publish</span>(<span class="params">topic, channel</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> channelName = channel || <span class="string">'/'</span>;</span><br><span class="line">    <span class="keyword">const</span> msgChannel = postal.channel(channelName);</span><br><span class="line">    msgChannel.subscribe(topic, v =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'频道：'</span>, channelName);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'事件：'</span>, topic);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'数据：'</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> fn = descriptor.value;</span><br><span class="line"></span><br><span class="line">        descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> value = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">            msgChannel.publish(topic, value);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个名为<code>publish</code>的修饰器，它通过改写<code>descriptor.value</code>，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是Postal.js。</p><p>它的用法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> publish <span class="keyword">from</span> <span class="string">'./publish'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooComponent</span> </span>&#123;</span><br><span class="line">    @publish(<span class="string">'foo.some.message'</span>, <span class="string">'component'</span>)</span><br><span class="line">    someMethod() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">my</span>: <span class="string">'data'</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @publish(<span class="string">'foo.some.other'</span>)</span><br><span class="line">    anotherMethod() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> FooComponent();</span><br><span class="line"></span><br><span class="line">foo.someMethod();</span><br><span class="line">foo.anotherMethod();</span><br></pre></td></tr></table></figure><p>以后，只要调用<code>someMethod</code>或者<code>anotherMethod</code>，就会自动发出一个事件。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bash-node index.js</span><br><span class="line">频道：component</span><br><span class="line">事件：foo.some.message</span><br><span class="line">数据：&#123;my: 'data'&#125;</span><br><span class="line"></span><br><span class="line">频道：/</span><br><span class="line">事件：foo.some.other</span><br><span class="line">数据：undefined</span><br></pre></td></tr></table></figure><hr><h3 id="六、Mixin"><a href="#六、Mixin" class="headerlink" title="六、Mixin"></a>六、Mixin</h3><p>在修饰器的基础上，可以实现<code>Mixin</code>模式。所谓<code>Mixin</code>模式，就是对象继承的一种替代方案，中文译为“混入”，意为在一个对象之中混入另外一个对象的方法。</p><p>请看下面的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    foo() &#123;<span class="built_in">console</span>.log(<span class="string">'foo'</span>)&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, Foo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo()       <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>Foo</code>有一个<code>foo</code>方法，通过<code>Object.assign</code>方法，可以将<code>foo</code>方法“混入”<code>MyClass</code>类，导致<code>MyClass</code>的实例<code>obj</code>对象都具有<code>foo</code>方法。这就是“混入”模式的一个简单实现。</p><p>下面，我们部署一个通用脚本<code>mixins.js</code>，将Mixin写成一个修饰器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，就可以使用上面这个修饰器，为类“混入”各种方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mixins&#125; <span class="keyword">from</span> <span class="string">'./mixins'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    foo() &#123;<span class="built_in">console</span>.log(<span class="string">'foo'</span>)&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo()       <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><p>通过<code>mixins</code>这个修饰器，实现了在<code>MyClass</code>类上面“混入”<code>Foo</code>对象的<code>foo</code>方法。</p><p>不过，上面的方法会改写<code>MyClass</code>类的<code>prototype</code>对象，如果不喜欢这一点，也可以通过类的继承实现Mixin。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MyBaseClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>MyClass</code>继承了<code>MyBaseClass</code>。如果我们想在<code>MyClass</code>里面“混入”一个<code>foo</code>方法，一个办法是在<code>MyClass</code>和<code>MyBaseClass</code>之间插入一个混入类，这个类具有<code>foo</code>方法，并且继承了<code>MyBaseClass</code>的所有方法，然后<code>MyClass</code>再继承这个类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MyMixin = <span class="function">(<span class="params">superClass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superClass</span> </span>&#123;</span><br><span class="line">    foo () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'foo from MyMixin'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>MyMixin</code>是一个混入类生成器，接受<code>superClass</code>作为参数，然后返回一个继承<code>superClass</code>的子类，该子类包含一个<code>foo</code>方法。</p><p>接着，目标类再去继承这个混入类，就达到了“混入”<code>foo</code>方法的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MyMixin</span>(<span class="title">MyBaseClass</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> MyClass();</span><br><span class="line">c.foo();        <span class="comment">// 'foo from MyMixin'</span></span><br></pre></td></tr></table></figure><p>如果需要“混入”多个方法，就生成多个混入类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Mixin1</span>(<span class="title">Mixin2</span>(<span class="title">MyBaseClass</span>)) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法的一个好处，是可以调用<code>super</code>，因此可以避免在“混入”过程中覆盖父类的同名方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Mixin1 = <span class="function">(<span class="params">superClass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superClass</span> </span>&#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'foo from Mixin1'</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.foo) <span class="keyword">super</span>.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Mixin2 = <span class="function">(<span class="params">superClass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superClass</span> </span>&#123;</span><br><span class="line">    foo () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'foo from Mixin2'</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.foo) <span class="keyword">super</span>.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> </span>&#123;</span><br><span class="line">    foo () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'foo from S'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Mixin1</span>(<span class="title">Mixin2</span>(<span class="title">S</span>)) </span>&#123;</span><br><span class="line">    foo () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'foo from C'</span>);</span><br><span class="line">        <span class="keyword">super</span>.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，每一次“混入”发生时，都调用了父类的<code>super.foo</code>方法，导致父类的同名方法没有被覆盖，行为被保留了下来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> C().foo()</span><br><span class="line"><span class="comment">// foo from C</span></span><br><span class="line"><span class="comment">// foo from Mixin1</span></span><br><span class="line"><span class="comment">// foo from Mixin2</span></span><br><span class="line"><span class="comment">// foo from S</span></span><br></pre></td></tr></table></figure><hr><h3 id="七、Trait"><a href="#七、Trait" class="headerlink" title="七、Trait"></a>七、Trait</h3><p>Trait也是一种修饰器，效果与Mixin类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。</p><p>下面采用<code>traits-decorator</code>这个第三方模块作为例子。这个模块提供的<code>traits</code>修饰器，不仅可以接受对象，还可以接受ES6类作为参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;traits&#125; <span class="keyword">from</span> <span class="string">'traits-decorator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">    foo () &#123;<span class="built_in">console</span>.log(<span class="string">'foo'</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">    bar() &#123;<span class="built_in">console</span>.log(<span class="string">'bar'</span>)&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, TBar)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo()       <span class="comment">// foo</span></span><br><span class="line">obj.bar()       <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>上面代码中，通过<code>traits</code>修饰器，在<code>MyClass</code>类上面混入了<code>TFoo</code>类的<code>foo</code>方法和<code>TBar</code>对象的<code>bar</code>方法。</p><p>Trait不允许“混入”同名方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;traits&#125; <span class="keyword">from</span> <span class="string">'traits-decorator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">    foo () &#123;<span class="built_in">console</span>.log(<span class="string">'foo'</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">    bar() &#123;<span class="built_in">console</span>.log(<span class="string">'bar'</span>)&#125;,</span><br><span class="line">    foo() &#123;<span class="built_in">console</span>.log(<span class="string">'foo'</span>)&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, TBar)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Error: Method named: foo is defined twice</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>TFoo</code>和<code>TBar</code>都有<code>foo</code>方法，结果<code>traits</code>修饰器报错。</p><p>一种解决方法是排除<code>TBar</code>的<code>foo</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;traits, excluedes&#125; <span class="keyword">from</span> <span class="string">'traits-decorator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">    foo() &#123;<span class="built_in">console</span>.log(<span class="string">'foo'</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">    bar() &#123;<span class="built_in">console</span>.log(<span class="string">'bar'</span>)&#125;,</span><br><span class="line">    foo() &#123;<span class="built_in">console</span>.log(<span class="string">'foo'</span>)&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, <span class="attr">TBar</span>::excludes(<span class="string">'foo'</span>))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo()       <span class="comment">// foo</span></span><br><span class="line">obj.bar()       <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>上面代码使用绑定运算符（<code>::</code>）在<code>TBar</code>上排除<code>foo</code>方法，混入时就不会报错了。</p><p>另一种方法是为<code>TBar</code>的<code>foo</code>方法起一个别名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;traits, alias&#125; <span class="keyword">from</span> <span class="string">'traits-decorator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">    foo() &#123;<span class="built_in">console</span>.log(<span class="string">'foo'</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">    bar() &#123;<span class="built_in">console</span>.log(<span class="string">'bar'</span>)&#125;,</span><br><span class="line">    foo() &#123;<span class="built_in">console</span>.log(<span class="string">'foo'</span>)&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, <span class="attr">TBar</span>::alias(&#123;<span class="attr">foo</span>: <span class="string">'aliasFoo'</span>&#125;))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo()       <span class="comment">// foo</span></span><br><span class="line">obj.aliasFoo()  <span class="comment">// foo</span></span><br><span class="line">obj.bar()       <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>上面代码为<code>TBar</code>的<code>foo</code>方法起了别名<code>aliasFoo</code>，于是<code>MyClass</code>也可以混入<code>TBar</code>的<code>foo</code>方法了。</p><p><code>alias</code>和<code>excludes</code>方法，可以结合起来使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@traits(TExample::excludes(<span class="string">'foo'</span>, <span class="string">'bar'</span>)::alias(&#123;<span class="attr">baz</span>: <span class="string">'exampleBaz'</span>&#125;))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面代码排除了<code>TExample</code>的<code>foo</code>方法和<code>bar</code>方法，为<code>baz</code>方法起了别名<code>exampleBaz</code>。</p><p><code>as</code>方法则为上面的代码提供了另一种写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@traits(TExample::<span class="keyword">as</span>(&#123;<span class="attr">excludes</span>: [<span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="attr">alias</span>: &#123;<span class="attr">baz</span>: <span class="string">'exampleBaz'</span>&#125;&#125;))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="八、Babel转码器的支持"><a href="#八、Babel转码器的支持" class="headerlink" title="八、Babel转码器的支持"></a>八、Babel转码器的支持</h3><p>目前，Babel转码器已经支持Decorator。</p><p>首先，安装<code>babel-core</code>和<code>babel-plugin-transform-decorators</code>。由于后者包括在<code>babel-preset-stage-0</code>之中，所以改为安装<code>babel-preset-stage-0</code>亦可。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-core babel-plugin-transform-decorators</span><br></pre></td></tr></table></figure><p>然后，设置配置文件<code>.babelrc</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"plugins"</span>: [<span class="string">"transform-decorators"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，Babel就可以对Decorator转码了。</p><p>脚本中打开的命令如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel.transform(<span class="string">'code'</span>, &#123;<span class="attr">plugins</span>: [<span class="string">'transform-decorators'</span>]&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/decorator">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中添加的修饰器。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/decorator&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(9) Reflect</title>
    <link href="http://www.xiaoleon.cn/2018/06/04/es6-9/"/>
    <id>http://www.xiaoleon.cn/2018/06/04/es6-9/</id>
    <published>2018-06-04T01:10:11.000Z</published>
    <updated>2018-06-11T11:25:12.909Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中添加的Reflect。节选自<a href="(http://es6.ruanyifeng.com/#docs/reflect">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是ES6为了操作对象而提供的新API。<code>Reflect</code>对象的设计目的有这样几个。</p><p>1) 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p><p>2) 修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, property, attributes);</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3) 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="string">'assign'</span> <span class="keyword">in</span> <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">'assign'</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>4) <code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">target, name, value, receiver</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> success = <span class="built_in">Reflect</span>.set(target, name, value, receiver);</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            log(<span class="string">'property '</span> + name + <span class="string">' on '</span> + target + <span class="string">' set to '</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p><p>下面是另一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loggedObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    get(target, name) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'get'</span>, target, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, name);</span><br><span class="line">    &#125;,</span><br><span class="line">    deleteProperty(target, name) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'delete'</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, name);</span><br><span class="line">    &#125;,</span><br><span class="line">    has(target, name) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'has'</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(target, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，每一个<code>Proxy</code>对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p><p>有了<code>Reflect</code>对象以后，很多操作会更易读。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply.call(<span class="built_in">Math</span>.floor, <span class="literal">undefined</span>, [<span class="number">1.75</span>])    <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.floor, <span class="literal">undefined</span>, [<span class="number">1.75</span>])    <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><hr><h3 id="二、静态方法"><a href="#二、静态方法" class="headerlink" title="二、静态方法"></a>二、静态方法</h3><p><code>Reflect</code>对象一共有13个静态方法。</p><ul><li><p><code>Reflect.apply(target, thisArg, args)</code></p></li><li><p><code>Reflect.construct(target, args)</code></p></li><li><p><code>Reflect.get(target, name, receiver)</code></p></li><li><p><code>Reflect.set(target, name, value, receiver)</code></p></li><li><p><code>Reflect.defineProperty(target, name, desc)</code></p></li><li><p><code>Reflect.deleteProperty(target, name)</code></p></li><li><p><code>Reflect.has(target, name)</code></p></li><li><p><code>Reflect.ownKeys(target)</code></p></li><li><p><code>Reflect.isExtensible(target)</code></p></li><li><p><code>Reflect.preventExtensions(target)</code></p></li><li><p><code>Reflect.getOwnPropertyDescriptor(target, name)</code></p></li><li><p><code>Reflect.getPrototypeOf(target)</code></p></li><li><p><code>Reflect.setPrototypeOf(target, prototype)</code></p></li></ul><p>上面这些方法的作用，大部分与<code>Object</code>对象的同名方法的作用都是相同的，而且它与<code>Proxy</code>对象的方法是一一对应的。</p><h4 id="1-Reflect-get-target-name-receiver"><a href="#1-Reflect-get-target-name-receiver" class="headerlink" title="1. Reflect.get(target, name, receiver)"></a>1. Reflect.get(target, name, receiver)</h4><p><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span>,</span><br><span class="line">    get baz() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.foo + <span class="keyword">this</span>.bar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.get(myObject, <span class="string">'foo'</span>)    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(myObject, <span class="string">'bar'</span>)    <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(myObject, <span class="string">'baz'</span>)    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span>,</span><br><span class="line">    get baz() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.foo + <span class="keyword">this</span>.bar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line">    foo: <span class="number">4</span>,</span><br><span class="line">    bar: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.get(myObject, <span class="string">'baz'</span>, myReceiverObject)  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>如果第一个参数不是对象，<code>Reflect.get</code>方法会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.get(<span class="number">1</span>, <span class="string">'foo'</span>)       <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(<span class="literal">false</span>, <span class="string">'foo'</span>)   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="2-Reflect-set-target-name-value-receiver"><a href="#2-Reflect-set-target-name-value-receiver" class="headerlink" title="2. Reflect.set(target, name, value, receiver)"></a>2. Reflect.set(target, name, value, receiver)</h4><p><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    set bar(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.foo = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.foo    <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(myObject, <span class="string">'foo'</span>, <span class="number">2</span>);</span><br><span class="line">myObject.foo    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(myObject, <span class="string">'bar'</span>, <span class="number">3</span>);</span><br><span class="line">myObject.foo    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    foo: <span class="number">4</span>,</span><br><span class="line">    set bar(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.foo = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line">    foo: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(myObject, <span class="string">'bar'</span>, <span class="number">1</span>, myReceiverObject);</span><br><span class="line">myObject.foo    <span class="comment">// 4</span></span><br><span class="line">myReceiverObject.foo  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>注意，如果Proxy对象和Reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了<code>receiver</code>，那么<code>Reflect.set</code>会触发<code>Proxy.defineProperty</code>拦截。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">    a: <span class="string">'a'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    set(target, key, value, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'set'</span>);</span><br><span class="line">        <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    defineProperty(target, key, attribute) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'defineProperty'</span>);</span><br><span class="line">        <span class="built_in">Reflect</span>.defineProperty(target, key, attribute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(p, handler);</span><br><span class="line">obj.a = <span class="string">'A'</span>;</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="comment">// defineProperty</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Proxy.set</code>拦截里面使用了<code>Reflect.set</code>，而且传入了<code>receiver</code>，导致触发<code>Proxy.defineProperty</code>拦截。这是因为<code>Proxy.set</code>的<code>receiver</code>参数总是指向当前的Proxy实例（即上例的<code>obj</code>），导致触发<code>defineProperty</code>拦截。如果<code>Reflect.set</code>没有传入<code>receiver</code>，那么就不会触发<code>defineProperty</code>拦截。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">    a: <span class="string">'a'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    set(target, key, value, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'set'</span>);</span><br><span class="line">        <span class="built_in">Reflect</span>.set(target, key, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    defineProperty(target, key, attribute) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'defineProperty'</span>);</span><br><span class="line">        <span class="built_in">Reflect</span>.defineProperty(target, key, attribute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(p, handler);</span><br><span class="line">obj.a = <span class="string">'A'</span>;</span><br><span class="line"><span class="comment">// set</span></span><br></pre></td></tr></table></figure><p>如果第一个参数不是对象，<code>Reflect.set</code>会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.set(<span class="number">1</span>, <span class="string">'foo'</span>, &#123;&#125;)       <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">Reflect</span>.set(<span class="literal">false</span>, <span class="string">'foo'</span>, &#123;&#125;)   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="3-Reflect-has-obj-name"><a href="#3-Reflect-has-obj-name" class="headerlink" title="3. Reflect.has(obj, name)"></a>3. Reflect.has(obj, name)</h4><p><code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    foo: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="string">'foo'</span> <span class="keyword">in</span> myObject   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(myObject, <span class="string">'foo'</span>)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果第一个参数不是对象，<code>Reflect.has</code>和<code>in</code>运算符都会报错。</p><h4 id="4-Reflect-deleteProperty-obj-name"><a href="#4-Reflect-deleteProperty-obj-name" class="headerlink" title="4. Reflect.deleteProperty(obj, name)"></a>4. Reflect.deleteProperty(obj, name)</h4><p><code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">delete</span> myObj.foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(myObj, <span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure><p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，则返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。</p><h4 id="5-Reflect-construct-target-args"><a href="#5-Reflect-construct-target-args" class="headerlink" title="5. Reflect.construct(target, args)"></a>5. Reflect.construct(target, args)</h4><p><code>Reflect.construct</code>方法等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 的写法</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Greeting(<span class="string">'leon'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect.construct 的写法</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="built_in">Reflect</span>.construct(Greeting, [<span class="string">'leon'</span>]);</span><br></pre></td></tr></table></figure><h4 id="6-Reflect-getPrototypeOf-obj"><a href="#6-Reflect-getPrototypeOf-obj" class="headerlink" title="6. Reflect.getPrototypeOf(obj)"></a>6. Reflect.getPrototypeOf(obj)</h4><p><code>Reflect.getPrototypeOf</code>方法用于读取对象的<code>__proto__</code>属性，对应<code>Object.getPrototypeOf(obj)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = <span class="keyword">new</span> FancyThing();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(myObj) === FancyThing.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.getPrototypeOf(myObj) === FancyThing.prototype;</span><br></pre></td></tr></table></figure><p><code>Reflect.getPrototypeOf</code>和<code>Object.getPrototypeOf</code>的一个区别是，如果参数不是对象，<code>Object.getPrototypeOf</code>会将这个参数转为对象，然后再运行，而<code>Reflect.getPrototypeOf</code>会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>)    <span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span><br><span class="line"><span class="built_in">Reflect</span>.getPrototypeOf(<span class="number">1</span>)   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="7-Reflect-setPrototypeOf-obj-newProto"><a href="#7-Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="7. Reflect.setPrototypeOf(obj, newProto)"></a>7. Reflect.setPrototypeOf(obj, newProto)</h4><p><code>Reflect.setPrototypeOf</code>方法用于设置对象的<code>__proto__</code>属性，返回第一个参数对象，对应<code>Object.setPrototypeOf(obj, newProto)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = <span class="keyword">new</span> FancyThing();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(myObj, OtherThing.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(myObj, OtherThing.prototype);</span><br></pre></td></tr></table></figure><p>如果第一个参数不是对象，<code>Object.setPrototypeOf</code>会返回第一个参数本身，而<code>Reflect.setPrototypeOf</code>会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="number">1</span>, &#123;&#125;)    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(<span class="number">1</span>, &#123;&#125;)   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>如果第一个参数是<code>undefined</code>或<code>null</code>，<code>Object.setPrototypeOf</code>和<code>Reflect.setPrototypeOf</code>都会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="literal">null</span>, &#123;&#125;)     <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(<span class="literal">null</span>, &#123;&#125;)    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="8-Reflect-apply-func-thisArg-args"><a href="#8-Reflect-apply-func-thisArg-args" class="headerlink" title="8. Reflect.apply(func, thisArg, args)"></a>8. Reflect.apply(func, thisArg, args)</h4><p><code>Reflect.apply</code>方法等同于<code>Function.prototype.apply.call(func, thisArg, args)</code>，用于绑定<code>this</code>对象后执行给定函数。</p><p>一般来说，如果要绑定一个函数的<code>this</code>对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的<code>apply</code>方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用<code>Reflect</code>对象可以简化这种操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ages = [<span class="number">11</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">96</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">const</span> youngest = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> oldest = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> type = <span class="built_in">Object</span>.prototype.toString.call(youngest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">const</span> youngest = <span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.min, <span class="built_in">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> oldest = <span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.max, <span class="built_in">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> type = <span class="built_in">Reflect</span>.apply(<span class="built_in">Object</span>.prototype.toString, youngest, []);</span><br></pre></td></tr></table></figure><h4 id="9-Reflect-defineProperty-target-propertyKey-attributes"><a href="#9-Reflect-defineProperty-target-propertyKey-attributes" class="headerlink" title="9. Reflect.defineProperty(target, propertyKey, attributes)"></a>9. Reflect.defineProperty(target, propertyKey, attributes)</h4><p><code>Reflect.defineProperty</code>方法基本等同于<code>Object.defineProperty</code>，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用<code>Reflect.defineProperty</code>代替它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(MyDate, <span class="string">'now'</span>, &#123;</span><br><span class="line">    value: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Date</span>.now()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.defineProperty(MyDate, <span class="string">'now'</span>, &#123;</span><br><span class="line">    value: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Date</span>.now()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果<code>Reflect.defineProperty</code>的第一个参数不是对象，就会抛出错误，比如<code>Reflect.defineProperty(1, &#39;foo&#39;)</code>。</p><p>这个方法可以与<code>Proxy.defineProperty</code>配合使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    defineProperty(target, prop, descriptor) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(descriptor);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(target, prop, descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p.foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="comment">// &#123;value: 'bar', writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line">p.foo</span><br><span class="line"><span class="comment">// 'bar'</span></span><br></pre></td></tr></table></figure><h4 id="10-Reflect-getOwnPropertyDescriptor-target-propertyKey"><a href="#10-Reflect-getOwnPropertyDescriptor-target-propertyKey" class="headerlink" title="10. Reflect.getOwnPropertyDescriptor(target, propertyKey)"></a>10. Reflect.getOwnPropertyDescriptor(target, propertyKey)</h4><p><code>Reflect.getOwnPropertyDescriptor</code>基本等同于<code>Object.getOwnPropertyDescriptor</code>，用于得到指定属性的描述对象，将来会替代掉后者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">'hidden'</span>, &#123;</span><br><span class="line">    value: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">var</span> theDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(myObject, <span class="string">'hidden'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">var</span> theDescriptor = <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(myObject, <span class="string">'hidden'</span>);</span><br></pre></td></tr></table></figure><p><code>Reflect.getOwnPropertyDescriptor</code>和<code>Object.getOwnPropertyDescriptor</code>的一个区别是，如果第一个参数不是对象，<code>Object.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>不报错，返回<code>undefined</code>，而<code>Reflect.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>会抛出错误，表示参数非法。</p><h4 id="11-Reflect-isExtensible-target"><a href="#11-Reflect-isExtensible-target" class="headerlink" title="11. Reflect.isExtensible(target)"></a>11. Reflect.isExtensible(target)</h4><p><code>Reflect.isExtensible</code>方法对应<code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(myObject)   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.isExtensible(myObject)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数不是对象，<code>Object.isExtensible</code>会返回<code>false</code>，因为非对象本来就是不可扩展的，而<code>Reflect.isExtensible</code>会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.isExtensible(<span class="number">1</span>)      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Reflect</span>.isExtensible(<span class="number">1</span>)     <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="12-Reflect-preventExtensions-target"><a href="#12-Reflect-preventExtensions-target" class="headerlink" title="12. Reflect.preventExtensions(target)"></a>12. Reflect.preventExtensions(target)</h4><p><code>Reflect.preventExtensions</code>对应<code>Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(myObject)      <span class="comment">// Object &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.preventExtensions(myObject)     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数不是对象，<code>Object.preventExtensions</code>在ES5环境报错，在ES6环境返回传入的参数，而<code>Reflect.preventExtensions</code>会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5环境</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(<span class="number">1</span>)     <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6环境</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(<span class="number">1</span>)     <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.preventExtensions(<span class="number">1</span>)    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="13-Reflect-ownKeys-target"><a href="#13-Reflect-ownKeys-target" class="headerlink" title="13. Reflect.ownKeys(target)"></a>13. Reflect.ownKeys(target)</h4><p><code>Reflect.ownKeys</code>方法用于返回对象的所有属性，基本等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.for(<span class="string">'baz'</span>)]: <span class="number">3</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.for(<span class="string">'bing'</span>)]: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(myObject)</span><br><span class="line"><span class="comment">// ['foo', 'bar']</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(myObject)</span><br><span class="line"><span class="comment">// [Symbol(baz), Symbol(bing)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(myObject)</span><br><span class="line"><span class="comment">// ['foo', 'bar', Symbol(baz), Symbol(bing)]</span></span><br></pre></td></tr></table></figure><hr><h3 id="三、实例：使用Proxy实现观察者模式"><a href="#三、实例：使用Proxy实现观察者模式" class="headerlink" title="三、实例：使用Proxy实现观察者模式"></a>三、实例：使用Proxy实现观察者模式</h3><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = observable(&#123;</span><br><span class="line">    name: <span class="string">'张三'</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observe(print);</span><br><span class="line">person.name = <span class="string">'李四'</span>;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 李四, 20</span></span><br></pre></td></tr></table></figure><p>上面代码中，数据对象<code>person</code>是观察对象，函数<code>print</code>是观察者。一旦数据对象发生变化，<code>print</code>就会自动执行。</p><p>下面，使用Proxy写一个观察者模式的最简单实现，即实现<code>observable</code>和<code>observe</code>这两个函数。思路是<code>observable</code>函数返回一个原始对象的Proxy代理，拦截赋值操作，触发充当观察者的各个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> queuedObservers.add(fn);</span><br><span class="line"><span class="keyword">const</span> observable = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;set&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">    queuedObservers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，先定义了一个<code>Set</code>集合，所有观察者函数都放进这个集合。然后，<code>Observable</code>函数返回原始对象的代理，拦截赋值操作。拦截函数<code>set</code>之中，会自动执行所有观察者。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/reflect">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中添加的Reflect。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/reflect&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(8) Proxy</title>
    <link href="http://www.xiaoleon.cn/2018/06/01/es6-8/"/>
    <id>http://www.xiaoleon.cn/2018/06/01/es6-8/</id>
    <published>2018-06-01T05:19:40.000Z</published>
    <updated>2018-06-10T12:48:52.521Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中添加的Proxy。节选自<a href="(http://es6.ruanyifeng.com/#docs/proxy">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所有属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>Proxy可以理解成，在目标对象之前假设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)；</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj.count = <span class="number">1</span></span><br><span class="line"><span class="comment">// setting count!</span></span><br><span class="line">++obj.count</span><br><span class="line"><span class="comment">// getting count!</span></span><br><span class="line"><span class="comment">// setting count!</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码说明，Proxy实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p><p>ES6原生提供了Proxy构造函数，用来生成Proxy实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>Proxy对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p><p>下面时另一个拦截读取属性行为的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p><p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p><p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.a = <span class="string">'b'</span>;</span><br><span class="line">target.a             <span class="comment">// 'b'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>。</p><p>一个技巧是将Proxy对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;<span class="attr">proxy</span>: <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)&#125;;</span><br></pre></td></tr></table></figure><p>Proxy实例也可以作为其他对象的原型对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.time            <span class="comment">// 35</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p><p>同一个拦截器，可以设置拦截多个操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name === <span class="string">'prototype'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.prototype;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello, '</span> + name;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    apply: <span class="function"><span class="keyword">function</span>(<span class="params">target, thisBinding, args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args[<span class="number">0</span>];</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>: args[<span class="number">1</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line">fproxy(<span class="number">1</span>, <span class="number">2</span>);                           <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> fproxy(<span class="number">1</span>, <span class="number">2</span>);                       <span class="comment">// &#123;value: 2&#125;</span></span><br><span class="line">fproxy.prototype === <span class="built_in">Object</span>.prototype   <span class="comment">// true</span></span><br><span class="line">fproxy.foo === <span class="string">'Hello, foo'</span>;            <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p><p>下面是Proxy支持的拦截操作一览，一共13种。</p><ul><li><p><code>get(target, propKey, receiver)</code>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</p></li><li><p><code>set(target, propKey, value, receiver)</code>：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</p></li><li><p><code>has(target, propKey)</code>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</p></li><li><p><code>deleteProperty(target, propKey)</code>：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</p></li><li><p><code>ownKeys(target)</code>：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</p></li><li><p><code>getOwnPropertyDescriptor(target, propKey)</code>：拦截<code>Object.getOwnPropertyDescriptor(target, propKey)</code>，返回属性的描述对象。</p></li><li><p><code>defineProperty(target, propKey, propDesc)</code>：拦截<code>Object.defineProperty(proxy, propKey, propDesc)</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</p></li><li><p><code>preventExtensions(target)</code>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</p></li><li><p><code>getPrototypeOf(target)</code>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</p></li><li><p><code>isExtensible(target)</code>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</p></li><li><p><code>setPrototypeOf(target, proto)</code>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</p></li><li><p><code>apply(target, object, args)</code>：拦截Proxy实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</p></li><li><p><code>constructor</code>：拦截Proxy实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</p></li></ul><hr><h3 id="二、Proxy实例的方法"><a href="#二、Proxy实例的方法" class="headerlink" title="二、Proxy实例的方法"></a>二、Proxy实例的方法</h3><p>下面是上面这些拦截方法的详细介绍。</p><h4 id="1-get"><a href="#1-get" class="headerlink" title="1. get()"></a>1. get()</h4><p><code>get</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和proxy实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p><p><code>get</code>方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'张三'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">return</span> target[property];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">'Property "'</span> + property + <span class="string">'" does not exist.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name          <span class="comment">// '张三'</span></span><br><span class="line">proxy.age           <span class="comment">// 抛出一个错误</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>。</p><p><code>get</code>方法可以继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    get(target, propertyKey, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'GET '</span> + propertyKey);</span><br><span class="line">        <span class="keyword">return</span> target[propertyKey];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proto);</span><br><span class="line">obj.foo             <span class="comment">// 'GET foo'</span></span><br></pre></td></tr></table></figure><p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p><p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">...elements</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> handler = &#123;</span><br><span class="line">        get(target, propKey, receiver) &#123;</span><br><span class="line">            <span class="keyword">let</span> index = <span class="built_in">Number</span>(propKey);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                propKey = <span class="built_in">String</span>(target.length + index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> target = [];</span><br><span class="line">    target.push(...elements);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = createArray(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line">arr[<span class="number">-1</span>]         <span class="comment">// 'c'</span></span><br></pre></td></tr></table></figure><p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数第一个成员。</p><p>利用Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pipe = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> funcStack = [];</span><br><span class="line">        <span class="keyword">var</span> oproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">            get: <span class="function"><span class="keyword">function</span>(<span class="params">pipeObject, fnName</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (fnName === <span class="string">'get'</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> funcStack.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">val, fn</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> fn(val);</span><br><span class="line">                    &#125;, value);</span><br><span class="line">                &#125;</span><br><span class="line">                funcStack.push(<span class="built_in">window</span>[fnName]);</span><br><span class="line">                <span class="keyword">return</span> oproxy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oproxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> pow = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br><span class="line"><span class="keyword">var</span> reverseInt = <span class="function"><span class="params">n</span> =&gt;</span> n.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) | <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pipe(<span class="number">3</span>).double.pow.reverseInt.get;      <span class="comment">// 63</span></span><br></pre></td></tr></table></figure><p>上面代码设置Proxy以后，达到了将函数名链式使用的效果。</p><p>下面的例子则是利用<code>get</code>拦截，实现一个生成各种DOM节点的通用函数<code>dom</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dom = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    get(target, property) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">attrs = &#123;&#125;, ...children</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(property);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">of</span> <span class="built_in">Object</span>.keys(attrs)) &#123;</span><br><span class="line">                el.setAttribute(prop, attrs[prop]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> children) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">'string'</span>) &#123;</span><br><span class="line">                    child = <span class="built_in">document</span>.createTextNode(child);</span><br><span class="line">                &#125;</span><br><span class="line">                el.appendChild(child);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> el;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> el = dom.div(&#123;&#125;,</span><br><span class="line">    <span class="string">'Hello, my name is '</span>,</span><br><span class="line">    dom.a(&#123;<span class="attr">href</span>: <span class="string">`//example.com`</span>&#125;, <span class="string">'Mark'</span>),</span><br><span class="line">    <span class="string">', I like:'</span>,</span><br><span class="line">    dom.ul(&#123;&#125;,</span><br><span class="line">        dom.li(&#123;&#125;, <span class="string">'The web'</span>),</span><br><span class="line">        dom.li(&#123;&#125;, <span class="string">'Food'</span>),</span><br><span class="line">        dom.li(&#123;&#125;, <span class="string">'...actually that\'s it'</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(el);</span><br></pre></td></tr></table></figure><p>下面是一个<code>get</code>方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是Proxy实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, property, receiver</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.getReceiver === proxy     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>proxy</code>对象的<code>getReceiver</code>属性是由<code>proxy</code>对象提供的，所以<code>receiver</code>指向<code>proxy</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, property, receiver</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">d.a === d;          <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>d</code>对象本身没有<code>a</code>属性，所以读取<code>d.a</code>的时候，会去<code>d</code>的原型<code>proxy</code>对象找。这时，<code>receiver</code>就指向<code>d</code>，代表原始的读操作所在的那个对象。</p><p>如果一个属性不可配置（configurable）和不可写（writable），则该属性不能被代理，通过Proxy对象访问该属性会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">        value: <span class="number">123</span>,</span><br><span class="line">        writable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    get(target, propKey) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'abc'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo           <span class="comment">// TypeError: Invariant check failed</span></span><br></pre></td></tr></table></figure><h4 id="2-set"><a href="#2-set" class="headerlink" title="2. set()"></a>2. set()</h4><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和Proxy实例本身，其中最后一个参数可选。</p><p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该时一个不大于200的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prop === <span class="string">'age'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The age is not an integer'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">                thrwo <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'The age seems invalid'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于满足条件的age属性以及其他属性，直接保存</span></span><br><span class="line">        obj[prop] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">100</span>;</span><br><span class="line">person.age      <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">person.age = <span class="string">'young'</span>        <span class="comment">// 报错</span></span><br><span class="line">person.age = <span class="number">300</span>            <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于设置了存值函数<code>set</code>，任何不符合要求的<code>age</code>属性赋值，都会抛出一个错误，这时数据验证的一种实现方法。利用<code>set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新DOM。</p><p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法，就可以做到防止这些内部属性被外部读写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    get(target, key) &#123;</span><br><span class="line">        invariant(key, <span class="string">'get'</span>);</span><br><span class="line">        <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, key, value) &#123;</span><br><span class="line">        invariant(key, <span class="string">'set'</span>);</span><br><span class="line">        target[key] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invariant</span>(<span class="params">key, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private "<span class="subst">$&#123;key&#125;</span>" property`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy._prop     </span><br><span class="line"><span class="comment">// Error: Invalid attemp to get private "_prop" property</span></span><br><span class="line">proxy._prop = <span class="string">'c'</span></span><br><span class="line"><span class="comment">// Error: Invalid attemp to set private "_prop" property</span></span><br></pre></td></tr></table></figure><p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p><p>下面是<code>set</code>方法第四个参数的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) </span>&#123;</span><br><span class="line">        obj[prop] = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">proxy.foo = <span class="string">'bar'</span>;</span><br><span class="line">proxy.foo === proxy;        <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>set</code>方法的第四个参数<code>receiver</code>，指的是原始的操作行为所在的那个对象，一般情况下是<code>proxy</code>实例本身，请看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) </span>&#123;</span><br><span class="line">        obj[prop] = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(myObj, proxy);</span><br><span class="line"></span><br><span class="line">myObj.foo = <span class="string">'bar'</span>;</span><br><span class="line">myObj.foo === myObj;        <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，设置<code>myObj.foo</code>属性的值时，<code>myObj</code>并没有<code>foo</code>属性，因此引擎会到<code>myObj</code>的原型链去找<code>foo</code>属性。<code>myObj</code>的原型对象<code>proxy</code>是一个Proxy实例，设置它的<code>foo</code>属性会触发<code>set</code>方法。这时，第四个参数<code>receiver</code>就指向原型赋值行为所在的对象<code>myObj</code>。</p><p>注意，如果目标对象自身的某个属性，不可写或不可配置，那么<code>set</code>方法将不起作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'foo'</span>, &#123;</span><br><span class="line">    value: <span class="string">'bar'</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) </span>&#123;</span><br><span class="line">        obj[prop] = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br><span class="line">proxy.foo = <span class="string">'baz'</span>;</span><br><span class="line">proxy.foo           <span class="comment">// 'bar'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj.foo</code>属性不可写，Proxy对这个属性的<code>set</code>代理将不会生效。</p><h4 id="3-apply"><a href="#3-apply" class="headerlink" title="3. apply()"></a>3. apply()</h4><p><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</p><p><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    apply(target, ctx, args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'I am the target'</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    apply: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'I am the proxy'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">p()     <span class="comment">// 'I am the proxy'</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>p</code>是Proxy的实例，当它作为函数调用时（<code>p()</code>），就会被<code>apply</code>方法拦截，返回一个字符串。</p><p>下面是另外一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twice = &#123;</span><br><span class="line">    apply(target, ctx, args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum, twice);</span><br><span class="line">proxy(<span class="number">1</span>, <span class="number">2</span>)                 <span class="comment">// 6</span></span><br><span class="line">proxy.call(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">6</span>)      <span class="comment">// 22</span></span><br><span class="line">proxy.apply(<span class="literal">null</span>, [<span class="number">7</span>, <span class="number">8</span>])   <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截。</p><p>另外，直接调用<code>Reflect.apply</code>方法，也会被拦截。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.apply(proxy, <span class="literal">null</span>, [<span class="number">9</span>, <span class="number">10</span>])     <span class="comment">// 38</span></span><br></pre></td></tr></table></figure><h4 id="4-has"><a href="#4-has" class="headerlink" title="4. has()"></a>4. has()</h4><p><code>has</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p><p><code>has</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</p><p>下面的例子使用<code>has</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    has(target, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">'foo'</span>, <span class="attr">prop</span>: <span class="string">'foo'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="string">'_prop'</span> <span class="keyword">in</span> proxy        <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has</code>就会返回false，从而不会被<code>in</code>运算符发现。</p><p>如果源对象不可配置或者禁止扩展，这时<code>has</code>拦截会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    has: <span class="function"><span class="keyword">function</span>(<span class="params">target, prop</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> p        <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象禁止扩展，结果使用<code>has</code>拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则<code>has</code>方法就不得“隐藏”（即返回false）目标对象的该属性。</p><p>值得注意的是，<code>has</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p><p>另外，虽然<code>for...in</code>循环也用到了<code>in</code>运算符，但是<code>has</code>拦截对<code>for...in</code>循环不生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stu1 = &#123;<span class="attr">name</span>: <span class="string">'张三'</span>, <span class="attr">score</span>: <span class="number">59</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> stu2 = &#123;<span class="attr">name</span>: <span class="string">'李四'</span>, <span class="attr">score</span>: <span class="number">99</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    has(target, prop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prop === <span class="string">'score'</span> &amp;&amp; target[prop] &lt; <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;target.name&#125;</span> 不及格`</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prop <span class="keyword">in</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy1 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(stu1, handler);</span><br><span class="line"><span class="keyword">let</span> proxy2 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(stu2, handler);</span><br><span class="line"></span><br><span class="line"><span class="string">'score'</span> <span class="keyword">in</span> proxy1       <span class="comment">// 张三 不及格 false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'score'</span> <span class="keyword">in</span> proxy2       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> proxy1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(proxy1[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 59</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> b <span class="keyword">in</span> proxy2) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(proxy2[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 李四</span></span><br><span class="line"><span class="comment">// 99</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>has</code>拦截只对<code>in</code>运算符生效，对<code>for...in</code>循环不生效，导致不符合要求的属性没有被<code>for...in</code>循环所排除。</p><h4 id="5-construct"><a href="#5-construct" class="headerlink" title="5. construct()"></a>5. construct()</h4><p><code>construct</code>方法用于拦截<code>new</code>命令，下面是拦截对象的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    construct(target, args, newTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> target(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>construct</code>方法可以接受两个参数。</p><ul><li><p><code>target</code>：目标对象</p></li><li><p><code>args</code>：构造函数的参数对象</p></li><li><p><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的<code>p</code>）</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">    construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'called: '</span> + args.join(<span class="string">', '</span>));</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>: args[<span class="number">0</span>] * <span class="number">10</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> p(<span class="number">1</span>)).value</span><br><span class="line"><span class="comment">// 'called: 1'</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p><code>construct</code>方法返回的必须是一个对象，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">    construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, argumentsList</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> p()     <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="6-deleteProperty"><a href="#6-deleteProperty" class="headerlink" title="6. deleteProperty()"></a>6. deleteProperty()</h4><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    deleteProperty(target, key) &#123;</span><br><span class="line">        invariant(key, <span class="string">'delete'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invariant</span>(<span class="params">key, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private "<span class="subst">$&#123;key&#125;</span>" property`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">'foo'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> proxy._prop</span><br><span class="line"><span class="comment">// Error: Invalid attempt to delete private "_prop" property</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>deleteProperty</code>方法拦截了<code>delete</code>操作符，删除第一个字符为下划线的属性会报错。</p><p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错。</p><h4 id="7-defineProperty"><a href="#7-defineProperty" class="headerlink" title="7. defineProperty()"></a>7. defineProperty()</h4><p><code>defineProperty</code>方法拦截了<code>Object.defineProperty</code>操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    defineProperty(target, key, descriptor) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.foo = <span class="string">'bar'</span>       <span class="comment">// 不会生效</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果目标对象不可扩展（extensible），则<code>defineProperty</code>不能增加目标对象上不存在的属性，否则会报错。另外，如果目标的某个属性不可写（writable）或者不可配置（configurable），则<code>defineProperty</code>方法不得改变这两个设置。</p><h4 id="8-getOwnPropertyDescriptor"><a href="#8-getOwnPropertyDescriptor" class="headerlink" title="8. getOwnPropertyDescriptor()"></a>8. getOwnPropertyDescriptor()</h4><p><code>getOwnPropertyDescriptor</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    getOwnPropertyDescriptor(target, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="string">'tar'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'wat'</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'_foo'</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'baz'</span>)</span><br><span class="line"><span class="comment">// &#123;value: 'tar', writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>handler.getOwnPropertyDescriptor</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p><h4 id="9-getPrototypeOf"><a href="#9-getPrototypeOf" class="headerlink" title="9. getPrototypeOf()"></a>9. getPrototypeOf()</h4><p><code>getPrototypeOf</code>方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p><ul><li><p><code>Object.prototype.__proto__</code></p></li><li><p><code>Object.prototype.isPrototypeOf()</code></p></li><li><p><code>Object.getPrototypeOf()</code></p></li><li><p><code>Reflect.getPrototypeOf()</code></p></li><li><p><code>instanceof</code></p></li></ul><p>下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    getPrototypeOf(target) &#123;</span><br><span class="line">        <span class="keyword">return</span> proto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(p) === proto      <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>getPrototypeOf</code>方法拦截<code>Object.getPrototypeOf()</code>，返回<code>proto</code>对象。</p><p>注意，<code>getPrototypeOf</code>方法的返回值必须是对象或者<code>null</code>，否则报错。另外，如果目标对象不可扩展（extensible），<code>getPrototypeOf</code>方法必须返回目标对象的原型对象。</p><h4 id="10-isExtensible"><a href="#10-isExtensible" class="headerlink" title="10. isExtensible()"></a>10. isExtensible()</h4><p><code>isExtensible</code>方法拦截<code>Object.isExtensible</code>操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    isExtensible: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'called'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(p)</span><br><span class="line"><span class="comment">// 'called'</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码设置了<code>isExtensible</code>方法，在调用<code>Object.isExtensible</code>时会输出<code>called</code>。</p><p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p><p>这个方法有一个强限制，它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则就会抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.isExtensible(proxy) === <span class="built_in">Object</span>.isExtensible(target)</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    isExtensible: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(p)      <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="11-ownKeys"><a href="#11-ownKeys" class="headerlink" title="11. ownKeys()"></a>11. ownKeys()</h4><p><code>ownKeys</code>方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p><ul><li><p><code>Object.getOwnPropertyNames()</code></p></li><li><p><code>Object.getOwnPropertySymbols()</code></p></li><li><p><code>Object.keys()</code></p></li><li><p><code>for...in</code>循环</p></li></ul><p>下面是拦截<code>Object.keys()</code>的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    ownKeys(target) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(proxy);</span><br><span class="line"><span class="comment">// ['a']</span></span><br></pre></td></tr></table></figure><p>上面代码拦截了对于<code>target</code>对象的<code>Object.keys()</code>操作，只返回<code>a</code>、<code>b</code>、<code>c</code>属性之中的<code>a</code>属性。</p><p>下面的例子是拦截第一个字符为下划线的属性名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    _bar: <span class="string">'foo'</span>,</span><br><span class="line">    _prop: <span class="string">'bar'</span>,</span><br><span class="line">    prop: <span class="string">'baz'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    ownKeys(target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(target).filter(<span class="function"><span class="params">key</span> =&gt;</span> key[<span class="number">0</span>] !== <span class="string">'_'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，使用<code>Object.keys</code>方法时，有三类属性会被<code>ownKeys</code>方法自动过滤，不会返回。</p><ul><li><p>目标对象上不存在的属性</p></li><li><p>属性名为Symbol值</p></li><li><p>不可遍历（enumerable）的属性</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.for(<span class="string">'secret'</span>)]: <span class="string">'4'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">'key'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">'static'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    ownKeys(target) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'a'</span>, <span class="string">'d'</span>, <span class="built_in">Symbol</span>.for(<span class="string">'secret'</span>), <span class="string">'key'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(proxy)</span><br><span class="line"><span class="comment">// ['a']</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>ownKeys</code>方法之中，显式返回不存在的属性<code>d</code>、Symbol值（<code>Symbol.for(&#39;secret&#39;)</code>）、不可遍历属性（<code>key</code>），结果都被自动过滤掉。</p><p><code>ownKeys</code>方法还可以拦截<code>Object.getOwnPropertyNames()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    ownKeys: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(p);</span><br><span class="line"><span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure><p><code>for...in</code>循环也受到<code>ownKeys</code>方法的拦截。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">hello</span>: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    ownKeys: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> proxy) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>ownKeys</code>指定只返回<code>a</code>和<code>b</code>属性，由于<code>obj</code>没有这两个属性，因此<code>for...in</code>循环不会有任何输出。</p><p><code>ownKeys</code>方法返回的是数组成员，只能是字符串或Symbol值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    values: <span class="number">10</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    ownKeys: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'b'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(p);</span><br><span class="line"><span class="comment">// Uncaught TypeError: 'ownKeys' on proxy: trap result did not include 'a'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象的<code>a</code>属性是不可配置的，这时<code>ownKeys</code>方法返回的数组之中，必须包含<code>a</code>，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    ownKeys: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(p);</span><br><span class="line"><span class="comment">// Uncaught TypeError: 'ownKeys' on proxy: trap returned extra keys but proxy target is non-extensible</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象是不可扩展的，这时<code>ownKeys</code>方法返回的数组之中，包含了<code>obj</code>对象的多余属性<code>b</code>，所以导致了报错。</p><h4 id="12-preventExtensions"><a href="#12-preventExtensions" class="headerlink" title="12. preventExtensions()"></a>12. preventExtensions()</h4><p><code>preventExtensions</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会自动转为布尔值。</p><p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>才能返回<code>true</code>，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    preventExtensions: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(p)     <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>proxy.preventExtensions</code>方法返回<code>true</code>，但这时<code>Object.isExtensible(proxy)</code>会返回<code>true</code>，因此报错。</p><p>为了防止出现这个问题，通常要在<code>proxy.preventExtensions</code>方法里面，调用一次<code>Object.preventExtensions</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    preventExtensions: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'called'</span>);</span><br><span class="line">        <span class="built_in">Object</span>.preventExtensions(target);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(p)</span><br><span class="line"><span class="comment">// 'called'</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="13-setPrototypeOf"><a href="#13-setPrototypeOf" class="headerlink" title="13. setPrototypeOf()"></a>13. setPrototypeOf()</h4><p><code>setPrototypeOf</code>方法主要用来拦截<code>Object.setPrototypeOf</code>方法。</p><p>下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    setPrototypeOf(target, proto) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Changing the prototype if forbidden'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, proto);</span><br><span class="line"><span class="comment">// Error: Change the prototype is forbidden</span></span><br></pre></td></tr></table></figure><p>上面代码中，只要修改<code>target</code>的原型对象，就会报错。</p><p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（extensible），<code>setPrototypeOf</code>方法不得改变目标对象的原型。</p><hr><h3 id="三、Proxy-revocable"><a href="#三、Proxy-revocable" class="headerlink" title="三、Proxy.revocable()"></a>三、Proxy.revocable()</h3><p><code>Proxy.revocable</code>方法返回一个可取消的Proxy实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo = <span class="number">123</span>;</span><br><span class="line">proxy.foo       <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo       <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure><p><code>Proxy.revocable</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p><p><code>Proxy.revocable</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><hr><h3 id="四、this问题"><a href="#四、this问题" class="headerlink" title="四、this问题"></a>四、this问题</h3><p>虽然Proxy可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在Proxy代理的情况下，目标对象内部的<code>this</code>关键字会指向Proxy代理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.m()      <span class="comment">// false</span></span><br><span class="line">proxy.m()       <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，一旦<code>proxy</code>代理<code>target.m</code>，后者内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p><p>下面是一个例子，由于<code>this</code>指向的变化，导致Proxy无法代理目标对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        _name.set(<span class="keyword">this</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get name() &#123;</span><br><span class="line">        <span class="keyword">return</span> _name.get(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jane = <span class="keyword">new</span> Person(<span class="string">'Jane'</span>);</span><br><span class="line">jane.name       <span class="comment">// 'Jane'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(jane, &#123;&#125;);</span><br><span class="line">proxy.name      <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实时保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p><p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以Proxy也无法代理这些原生对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate();</span><br><span class="line"><span class="comment">// TypeError: this is not a Date Object</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>getDate</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2015-01-01'</span>);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    get(target, prop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target.getDate.bind(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate()     <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><hr><h3 id="五、Web服务的客户端"><a href="#五、Web服务的客户端" class="headerlink" title="五、Web服务的客户端"></a>五、Web服务的客户端</h3><p>Proxy对象可以拦截目标对象的任意属性，这使得它很适合用来写Web服务的客户端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> service = createWebService(<span class="string">'http://example.com/data'</span>);</span><br><span class="line"></span><br><span class="line">service.employees().then(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> employees = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码新建了一个Web服务的接口，这个接口返回各种数据。Proxy可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个Proxy拦截就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWebService</span>(<span class="params">baseUrl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">        get(target, propKey, receiver) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> httpGet(baseUrl + <span class="string">'/'</span> + propKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，Proxy也可以用来实现数据库的ORM层。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/proxy">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中添加的Proxy。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/proxy&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(7) Generator函数的语法</title>
    <link href="http://www.xiaoleon.cn/2018/05/24/es6-7/"/>
    <id>http://www.xiaoleon.cn/2018/05/24/es6-7/</id>
    <published>2018-05-24T13:44:57.000Z</published>
    <updated>2018-06-10T12:47:59.171Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中<code>Generator</code>函数的使用方法。节选自<a href="(http://es6.ruanyifeng.com/#docs/generator">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍Generator函数的语法和API，它的异步编程应用请看后面的《Generator函数的异步应用》一章。</p><p>Generator函数有多种理解角度。语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</p><p>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p><p>形式上，Generator函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure><p>上面代码定义了一个Generator函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello、world和return语句（结束执行）。</p><p>然后，Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p><p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇见下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123;value: 'hello', done: false&#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123;value: 'world', done: false&#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123;value: 'ending', done: true&#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面的代码一共调用了四次<code>next</code>方法。</p><p>第一次调用，Generator函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第二次调用，Generator函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第三次调用，Generator函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值为<code>true</code>，表示遍历已经结束。</p><p>总结一下，调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><p>ES6没有规定，<code>function</code>关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>由于Generator函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在<code>function</code>关键字后面。</p><h4 id="2-yield表达式"><a href="#2-yield表达式" class="headerlink" title="2. yield表达式"></a>2. yield表达式</h4><p>由于Generator函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。</p><p>遍历器对象的<code>next</code>方法的运行逻辑如下。</p><p>(1) 遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</p><p>(2) 下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</p><p>(3) 如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</p><p>(4) 如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</p><p>需要注意的是，<code>yield</code>表达式后面的表达式，只有当调用了<code>next</code>方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>yield</code>后面的表达式<code>123 + 456</code>，不会立即求值，只会在<code>next</code>方法将指针移到这一句时，才会求值。</p><p><code>yield</code>表达式与<code>return</code>语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）<code>return</code>语句，但是可以执行多次（或者说多个）<code>yield</code>表达式。正常函数只能返回一个值，因为只能执行一次<code>return</code>；Generator函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。从另一个角度看，也可以说Generator生成了一系列的值，这也就是它的名称的来历。</p><p>Generator函数可以不用<code>yield</code>表达式，这时就变成了一个单纯的暂缓执行函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行了！'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> generator = f();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  generator.next();</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>如果是普通函数，在为变量<code>generator</code>赋值时就会执行。但是，函数<code>f</code>是一个Generator函数，就变成只有调用<code>next</code>方法时，函数<code>f</code>才会执行。</p><p>另外需要注意，<code>yield</code>表达式只能用在Generator函数里面，用在其他地方都会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected number</span></span><br></pre></td></tr></table></figure><p>上面代码在一个普通函数中使用<code>yield</code>表达式，结果产生一个句法错误。</p><p>下面是另一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* flat(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> f <span class="keyword">of</span> flat(arr)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码也会产生句法错误，因为<code>forEach</code>方法的参数是一个普通函数，但是在里面使用了<code>yield</code>表达式（这个函数里面还使用了<code>yield*</code>表达式，详细介绍见后文）。一种修改方法是改用<code>for</code>循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = a.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = a[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* flat(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> flat(arr)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br></pre></td></tr></table></figure><p>另外，<code>yield</code>表达式如果用在另一个表达式之中，必须放在圆括号里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span>);         <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span> <span class="number">123</span>);     <span class="comment">// SyntaxError</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span>));       <span class="comment">// ok</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span> <span class="number">123</span>));   <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>yield</code>表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo(<span class="keyword">yield</span> <span class="string">'a'</span>, <span class="keyword">yield</span> <span class="string">'b'</span>);    <span class="comment">// ok</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="keyword">yield</span>;            <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-与Iterator接口的关系"><a href="#3-与Iterator接口的关系" class="headerlink" title="3. 与Iterator接口的关系"></a>3. 与Iterator接口的关系</h4><p>任意一个对象的<code>Symbol.iterator</code>方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p><p>由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有Iterator接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable]   <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator函数赋值给<code>Symbol.iterator</code>属性，从而使得<code>myIterable</code>对象具有了Iterator接口，可以被<code>...</code>运算符遍历了。</p><p>Generator函数执行后，返回一个遍历器对象。该对象本身也具有<code>Symbol.iterator</code>属性，执行后返回自身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g[<span class="built_in">Symbol</span>.iterator]() === g</span><br></pre></td></tr></table></figure><p>上面代码中，<code>gen</code>是一个Generator函数，调用它会生成一个遍历器对象<code>g</code>。它的<code>Symbol.iterator</code>属性，也是一个遍历器对象生成函数，执行后返回自己。</p><hr><h3 id="二、next方法的参数"><a href="#二、next方法的参数" class="headerlink" title="二、next方法的参数"></a>二、next方法的参数</h3><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当做上一个<code>yield</code>表达式的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">if</span> (reset) &#123; i = <span class="number">-1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line"></span><br><span class="line">g.next()    <span class="comment">// &#123;next: 1, done: false&#125;</span></span><br><span class="line">g.next()    <span class="comment">// &#123;next: 2, done: false&#125;</span></span><br><span class="line">g.next(<span class="literal">true</span>)    <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码先定义了一个可以无限运行的Generator函数<code>f</code>，如果<code>next</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数（即<code>true</code>），因此<code>i</code>会等于<code>-1</code>，下一轮循环就会从<code>-1</code>开始递增。</p><p>这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过<code>next</code>方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p><p>再看一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next()      <span class="comment">// &#123;value: 6, done: false&#125;</span></span><br><span class="line">a.next()      <span class="comment">// &#123;value: NaN, done: false&#125;</span></span><br><span class="line">a.next()      <span class="comment">// &#123;value: NaN, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>)</span><br><span class="line">b.next()      <span class="comment">// &#123;value: 6, done: false&#125;</span></span><br><span class="line">b.next(<span class="number">12</span>)    <span class="comment">// &#123;value: 8, done: false&#125;</span></span><br><span class="line">b.next(<span class="number">13</span>)    <span class="comment">// &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二次运行<code>next</code>方法的时候不带参数，导致<code>y</code>的值等于<code>2 * undefined</code>（即<code>NaN</code>），除以3以后还是<code>NaN</code>，因此返回对象的<code>value</code>属性也等于<code>NaN</code>。第三次运行<code>next</code>方法的时候不带参数，所以<code>z</code>等于<code>undefined</code>，返回对象的<code>value</code>属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。</p><p>如果向<code>next</code>方法提供参数，返回结果就完全不一样了。上面代码第一次调用<code>b</code>的<code>next</code>方法时，返回<code>x + 1</code>的值<code>6</code>；第二次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；第三次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>13</code>，因此<code>z</code>等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以<code>return</code>语句的值等于<code>42</code>。</p><p>注意，由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的。V8引擎直接忽略第一次使用<code>next</code>方法时的参数，只有从第二次使用<code>next</code>方法开始，参数才是有效的。从语义上讲，第一个<code>next</code>方法用来启动遍历器对象，所以不用带有参数。</p><p>再看一个通过<code>next</code>方法的参数，向Generator函数内部输入值的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">dataConsumer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Started'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`1. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`2. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'result'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> genObj = dataConsumer();</span><br><span class="line">genObj.next();</span><br><span class="line"><span class="comment">// Started</span></span><br><span class="line">genObj.next(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">// 1. a</span></span><br><span class="line">genObj.next(<span class="string">'b'</span>);</span><br><span class="line"><span class="comment">// 2. b</span></span><br></pre></td></tr></table></figure><p>上面代码是一个很直观的例子，每次通过<code>next</code>方法向Generator函数输入值，然后打印出来。</p><p>如果想要第一次调用<code>next</code>方法时，就能够输入值，可以在Generator函数外面再包一层。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapper</span>(<span class="params">generatorFunction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> generatorObject = generatorFunction(...args);</span><br><span class="line">    generatorObject.next();</span><br><span class="line">    <span class="keyword">return</span> generatorObject;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapped = wrapper(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`First input: <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'DONE'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">wrapped().next(<span class="string">'hello!'</span>)</span><br><span class="line"><span class="comment">// First input: hello!</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator函数如果不用<code>wrapper</code>先包一层，是无法第一次调用<code>next</code>方法，就输入参数的。</p><hr><h3 id="三、for…of循环"><a href="#三、for…of循环" class="headerlink" title="三、for…of循环"></a>三、for…of循环</h3><p><code>for...of</code>循环可以自动遍历Generator函数生成时的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><p>上面代码使用<code>for...of</code>循环，依次显示5个<code>yield</code>表达式的值。这里需要注意，一旦<code>next</code>方法的返回对象的<code>done</code>属性为<code>true</code>，<code>for...of</code>循环就会中止，且不包含该返回对象，所以上面代码的<code>return</code>语句返回的<code>6</code>，不包括在<code>for...of</code>循环之中。</p><p>下面是一个利用Generator函数和<code>for...of</code>循环，实现斐波那契数列的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    <span class="keyword">yield</span> curr;</span><br><span class="line">    [prev, curr] = [curr, prev + curr];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> fibonacci()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可见，使用<code>for...of</code>语句时不需要使用<code>next</code>方法。</p><p>利用<code>for...of</code>循环，可以写出遍历任意对象（object）的方法。原生的JavaScript对象没有遍历接口，无法使用<code>for...of</code>循环，通过Generator函数为它加上这个接口，就可以用了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="built_in">Reflect</span>.ownKeys(obj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, obj[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">'Jane'</span>, <span class="attr">last</span>: <span class="string">'Doe'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> objectEntries(jane)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>jane</code>原生不具备Iterator接口，无法用<code>for...of</code>遍历。这时，我们通过Generator函数<code>objectEntries</code>为它加上遍历器接口，就可以用<code>for...of</code>遍历了。加上遍历器接口的另一种写法是，将Generator函数加到对象的<code>Symbol.iterator</code>属性上面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, <span class="keyword">this</span>[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123;<span class="attr">first</span>: <span class="string">'Jane'</span>, <span class="attr">last</span>: <span class="string">'Doe'</span>&#125;;</span><br><span class="line"></span><br><span class="line">jane[<span class="built_in">Symbol</span>.iterator] = objectEntries;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> jane) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure><p>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将Generator函数返回的Iterator对象，作为参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...numbers()]    <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from方法</span></span><br><span class="line"><span class="built_in">Array</span>.from(numbers())   <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = numbers();</span><br><span class="line">x   <span class="comment">// 1</span></span><br><span class="line">y   <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> numbers()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、Generator-prototype-throw"><a href="#四、Generator-prototype-throw" class="headerlink" title="四、Generator.prototype.throw()"></a>四、Generator.prototype.throw()</h3><p>Generator函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">'a'</span>);</span><br><span class="line">  i.throw(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象<code>i</code>连续抛出两个错误。第一个错误被Generator函数体内的<code>catch</code>语句捕获。<code>i</code>第二次抛出错误，由于Generator函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了Generator函数体，被函数体外的<code>catch</code>语句捕获。</p><p><code>throw</code>方法可以接受一个参数，该参数会被<code>catch</code>语句接收，建议抛出<code>Error</code>对象的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line">i.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了！'</span>));</span><br><span class="line"><span class="comment">// Error: 出错了！</span></span><br></pre></td></tr></table></figure><p>注意，不要混淆遍历器对象的<code>throw</code>方法和全局的<code>throw</code>命令。上面代码的错误，是用遍历器对象的<code>throw</code>方法抛出的，而不是用<code>throw</code>命令抛出的。后者只能被函数体外的<code>catch</code>语句捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="string">'a'</span>) <span class="keyword">throw</span> e;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'a'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 [Error: a]</span></span><br></pre></td></tr></table></figure><p>上面代码之所以只捕获了<code>a</code>，是因为函数体外的<code>catch</code>语句块，不活了抛出的<code>a</code>错误以后，就不会再继续<code>try</code>代码块里面剩余的语句了。</p><p>如果Generator函数内部没有部署<code>try...catch</code>代码块，那么<code>throw</code>方法抛出的错误，将被外部<code>try...catch</code>代码块捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">'a'</span>);</span><br><span class="line">  i.throw(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 a</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator函数<code>g</code>内部没有部署<code>try...catch</code>代码块，所以抛出的错误直接被外部<code>catch</code>代码块捕获。</p><p>如果Generator函数内部和外部，都没有部署<code>try...catch</code>代码块，那么程序将报错，直接中断执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.next();</span><br><span class="line">g.throw();</span><br><span class="line"><span class="comment">// hello </span></span><br><span class="line"><span class="comment">// Uncaught undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g.throw</code>抛出错误以后，没有任何<code>try...catch</code>代码块可以捕获这个错误，导致程序报错，中断执行。</p><p><code>throw</code>方法抛出的错误要被内部捕获，前提是必须至少执行过一次<code>next</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.throw(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Uncaught 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g.throw(1)</code>执行时，<code>next</code>方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行<code>next</code>方法，等同于启动执行Generator函数的内部代码，否则Generator函数还没有开始执行，这时<code>throw</code>方法抛出只可能抛出在函数外部。</p><p><code>throw</code>方法被捕获以后，会附带执行下一条<code>yield</code>表达式。也就是说，会附带执行一次<code>next</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.next()    <span class="comment">// a</span></span><br><span class="line">g.throw()   <span class="comment">// b</span></span><br><span class="line">g.next()    <span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g.throw</code>方法被捕获以后，自动执行了一次<code>next</code>方法，所以会打印<code>b</code>。另外，也可以看到，只要Generator函数内部部署了<code>try...catch</code>代码块，那么遍历器的<code>throw</code>方法抛出的错误，不影响下一次遍历。</p><p>另外，<code>throw</code>命令与<code>g.throw</code>方法是无关的，两者互不影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  g.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>throw</code>命令抛出的错误不会影响到遍历器的状态，所以两次执行<code>next</code>方法，都进行了正确的操作。</p><p>这种函数体内捕获错误的机制，大大方便了对错误的处理。多个<code>yield</code>表达式，可以只用一个<code>try...catch</code>代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在Generator函数内部写一次<code>catch</code>语句就可以了。</p><p>Generator函数体外抛出的错误，可以在函数体内捕获；反过来，Generator函数体内抛出的错误，也可以被函数体外的<code>catch</code>捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> y = x.toUpperCase();</span><br><span class="line">  <span class="keyword">yield</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line">it.next();    <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  it.next(<span class="number">42</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>next</code>方法向函数体内传入一个参数42，数值是没有<code>toUpperCase</code>方法的，所以会抛出一个TypeError错误，被函数体外的<code>catch</code>捕获。</p><p>一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用<code>next</code>方法，将返回一个<code>value</code>属性等于<code>undefined</code>、<code>done</code>属性等于<code>true</code>的对象，即JavaScript引擎认为这个Generator已经运行结束了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'throwing an exception'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'generator broke!'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'starting generator'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第一次运行next方法'</span>, v);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕捉错误'</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第二次运行next方法'</span>, v);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕捉错误'</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第三次运行next方法'</span>, v);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕捉错误'</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'caller done'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(g());</span><br><span class="line"><span class="comment">// starting generator</span></span><br><span class="line"><span class="comment">// 第一次运行next方法 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// throwing an exception</span></span><br><span class="line"><span class="comment">// 捕捉错误 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// 第三次运行next方法 &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">// caller done</span></span><br></pre></td></tr></table></figure><p>上面代码一共三次运行<code>next</code>方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator函数就已经结束了，不再执行下去了。</p><hr><h3 id="五、Generator-prototype-return"><a href="#五、Generator-prototype-return" class="headerlink" title="五、Generator.prototype.return()"></a>五、Generator.prototype.return()</h3><p>Generator函数返回的遍历器对象，还有一个<code>return</code>方法，可以返回给定的值，并且终结Generator函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.next()          <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return(<span class="string">'foo'</span>)   <span class="comment">// &#123; value: 'foo', done: true &#125;</span></span><br><span class="line">g.next()          <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象<code>g</code>调用<code>return</code>方法后，返回值的<code>value</code>属性就是<code>return</code>方法的参数<code>foo</code>。并且，Generator函数的遍历就终止了，返回值的<code>done</code>属性为<code>true</code>，以后再调用<code>next</code>方法，<code>done</code>属性总是返回<code>true</code>。</p><p>如果<code>return</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next()      <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return()    <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>如果Generator函数内部有<code>try...finally</code>代码块，那么<code>return</code>方法会推迟到<code>finally</code>代码块执行完再执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = numbers();</span><br><span class="line">g.next()      <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next()      <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.return(<span class="number">7</span>)   <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.next()      <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.next()      <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>return</code>方法后，就开始执行<code>finally</code>代码块，然后等到<code>finally</code>代码块执行完，再执行<code>return</code>方法。</p><hr><h3 id="六、next-、throw-、return-的共同点"><a href="#六、next-、throw-、return-的共同点" class="headerlink" title="六、next()、throw()、return()的共同点"></a>六、next()、throw()、return()的共同点</h3><p><code>next()</code>、<code>throw()</code>、<code>return()</code>这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让Generator函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。</p><p><code>next</code>是将<code>yield</code>表达式替换成一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> x + y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = g(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gen.next();   <span class="comment">// Object &#123; value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">gen.next(<span class="number">1</span>);    <span class="comment">// Object &#123; value: 1, done: true &#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>next(1)</code>方法就相当于将<code>yield</code>表达式替换成一个值<code>1</code>。如果<code>next</code>方法没有参数，就相当于替换成<code>undefined</code>。</p><p><code>throw</code>是将<code>yield</code>表达式替换成一个<code>throw</code>语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>));   <span class="comment">// Uncaught Error：出错了</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = throw(new Error('出错了'));</span></span><br></pre></td></tr></table></figure><p><code>return</code>是将<code>yield</code>表达式替换成一个<code>return</code>语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen.return(<span class="number">2</span>);    <span class="comment">// Object &#123; value: 2, done: true &#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = return 2;</span></span><br></pre></td></tr></table></figure><hr><h3 id="七、yield-表达式"><a href="#七、yield-表达式" class="headerlink" title="七、yield* 表达式"></a>七、yield* 表达式</h3><p>如果在Generator函数内部，调用另一个Generator函数，默认情况下是没有效果的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  foo();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="keyword">var</span>()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'x'</span></span><br><span class="line"><span class="comment">// 'y'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>foo</code>和<code>bar</code>都是Generator函数，在<code>bar</code>里面调用<code>foo</code>，是不会有效果的。</p><p>这个就需要用到<code>yield*</code>表达式，用来在一个Generator函数里面执行另一个Generator函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* foo();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="keyword">yield</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'x'</span></span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"><span class="comment">// 'y'</span></span><br></pre></td></tr></table></figure><p>再来看一个对比的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'open'</span>;</span><br><span class="line">  <span class="keyword">yield</span> inner();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'close'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = outer1()</span><br><span class="line">gen.next().value    <span class="comment">// 'open'</span></span><br><span class="line">gen.next().value    <span class="comment">// 返回一个遍历器对象</span></span><br><span class="line">gen.next().value    <span class="comment">// 'close'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'open'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* inner();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'close'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = outer2();</span><br><span class="line">gen.next().value    <span class="comment">// 'open'</span></span><br><span class="line">gen.next().value    <span class="comment">// 'hello!'</span></span><br><span class="line">gen.next().value    <span class="comment">// 'close'</span></span><br></pre></td></tr></table></figure><p>上面例子中，<code>outer2</code>使用了<code>yield*</code>，<code>outer1</code>没使用。结果就是，<code>outer1</code>返回一个遍历器对象，<code>outer2</code>返回该遍历器对象的内部值。</p><p>从语法角度看，如果<code>yield</code>表达式后面跟的是一个遍历器对象，需要在<code>yield</code>表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为<code>yield*</code>表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> delegateIterator = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Hello!'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Bye!'</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> delegatingIterator = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Greetings!'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* delegateIterator;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Ok, bye.'</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> delegatingIterator) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'Greetings!'</span></span><br><span class="line"><span class="comment">// 'Hello!'</span></span><br><span class="line"><span class="comment">// 'Bye!'</span></span><br><span class="line"><span class="comment">// 'Ok, bye.'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>delegatingIterator</code>是代理者，<code>delegatedIterator</code>是被代理者。由于<code>yield* delegatedIterator</code>语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。</p><p><code>yield*</code>后面的Generator函数（没有<code>return</code>语句时），等同于在Generator函数内部，部署一个<code>for...of</code>循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1;</span><br><span class="line">  <span class="keyword">yield</span>* iter2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter2) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码说明，<code>yield*</code>后面的Generator函数（没有<code>return</code>语句时），不过是<code>for...of</code>的一种简写形式，完全可以用后者替代前者。反之，在有<code>return</code>语句时，则需要用<code>var value = yield* iterator</code>的形式获取<code>return</code>语句的值。</p><p>如果<code>yield*</code>后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gen().next();   <span class="comment">// &#123; value: 'a', done: false &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>yield</code>命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。</p><p>实际上，任何数据结构只要有Iterator接口，就可以被<code>yield*</code>遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> read = (<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* <span class="string">'hello'</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">read.next().value     <span class="comment">// 'hello'</span></span><br><span class="line">read.next().value     <span class="comment">// 'h'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>yield</code>表达式返回整个字符串，<code>yield*</code>语句返回单个字符。因为字符串具有Iterator接口，所以被<code>yield*</code>遍历。</p><p>如果被代理的Generator函数有<code>return</code>语句，那么就可以向代理它的Generator函数返回数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="keyword">yield</span>* foo();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'v: '</span> + v);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line">it.next()     <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">it.next()     <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">it.next()     <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">it.next()     </span><br><span class="line"><span class="comment">// 'v: foo'</span></span><br><span class="line"><span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">it.next()     <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码在第四次调用<code>next</code>方法的时候，屏幕上会有输出，这是因为函数<code>foo</code>的<code>return</code>语句，向函数<code>bar</code>提供了返回值。</p><p>再看一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genFuncWithReturn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'The Result'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">logReturned</span>(<span class="params">genObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span>* genObj;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...logReturned(genFuncWithReturned())]</span><br><span class="line"><span class="comment">// The Result</span></span><br><span class="line"><span class="comment">// 值为['a', 'b']</span></span><br></pre></td></tr></table></figure><p>上面代码中，存在两次遍历。第一次是扩展运算符遍历函数<code>logReturned</code>返回的遍历器对象，第二次是<code>yield*</code>语句遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。所以，最后的数据表达式得到的值等于<code>[&#39;a&#39;, &#39;b&#39;]</code>。但是，函数<code>genFuncWithReturn</code>的<code>return</code>语句的返回值<code>The Result</code>，会返回给函数<code>logReturned</code>内部的<code>result</code>变量，因此会有终端输出。</p><p><code>yield*</code>命令可以很方便地取出嵌套数组的所有成员。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterTree</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(tree)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* iterTree(tree[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> tree;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree = [<span class="string">'a'</span>, [<span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="string">'d'</span>, <span class="string">'e'</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> iterTree(tree)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// e</span></span><br></pre></td></tr></table></figure><p>下面是一个稍微复杂的例子，使用<code>yield*</code>语句遍历完全二叉树。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是二叉树的构造函数，三个参数分别是左树、当前节点和右树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params">left, label, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.left = left;</span><br><span class="line">  <span class="keyword">this</span>.label = label;</span><br><span class="line">  <span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是中序（inorder）遍历函数</span></span><br><span class="line"><span class="comment">// 由于返回的是一个遍历器，所以要用generator函数。</span></span><br><span class="line"><span class="comment">// 函数体内采用递归算法，所以左树和右树要用yield*遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inorder</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t) &#123;</span><br><span class="line">    <span class="keyword">yield</span>* inorder(t.left);</span><br><span class="line">    <span class="keyword">yield</span> t.label;</span><br><span class="line">    <span class="keyword">yield</span>* inorder(t.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面生成二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否为叶节点</span></span><br><span class="line">  <span class="keyword">if</span> (array.length == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tree(<span class="literal">null</span>, array[<span class="number">0</span>], <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Tree(make(array[<span class="number">0</span>]), array[<span class="number">1</span>], make(array[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tree = make([[[<span class="string">'a'</span>], <span class="string">'b'</span>, [<span class="string">'c'</span>]], <span class="string">'d'</span>, [[<span class="string">'e'</span>], <span class="string">'f'</span>, [<span class="string">'g'</span>]]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二叉树</span></span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> node <span class="keyword">of</span> inorder(tree)) &#123;</span><br><span class="line">  result.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd', 'e', 'f', 'g']</span></span><br></pre></td></tr></table></figure><hr><h3 id="八、作为对象属性的Generator函数"><a href="#八、作为对象属性的Generator函数" class="headerlink" title="八、作为对象属性的Generator函数"></a>八、作为对象属性的Generator函数</h3><p>如果一个对象的属性是Generator函数，可以简写成下面的形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * myGeneratorMethod() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>myGeneratorMethod</code>属性前面有一个星号，表示这个属性是一个Generator函数。</p><p>它的完整形式如下，与上面的写法是等价的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  myGeneratorMethod: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="九、Generator函数的this"><a href="#九、Generator函数的this" class="headerlink" title="九、Generator函数的this"></a>九、Generator函数的this</h3><p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的<code>prototype</code>对象上的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">g.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hi!'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = g();</span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> g    <span class="comment">// true</span></span><br><span class="line">obj.hello()         <span class="comment">// 'hi!'</span></span><br></pre></td></tr></table></figure><p>上面代码表明，Generator函数<code>g</code>返回的遍历器<code>obj</code>，是<code>g</code>的实例，而且继承了<code>g.prototype</code>。但是，如果把<code>g</code>当作普通的构造函数，并不会生效，因为<code>g</code>返回的总是遍历器对象，而不是<code>this</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = g();</span><br><span class="line">obj.next();</span><br><span class="line">obj.a     <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator函数<code>g</code>在<code>this</code>对象上面添加了一个属性<code>a</code>，但是<code>obj</code>对象拿不到这个属性。</p><p>Generator函数也不能跟<code>new</code>命令一起用，会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.y = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> F()</span><br><span class="line"><span class="comment">// TypeError: F is not a constructor</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>new</code>命令跟构造函数<code>F</code>一起使用，结果报错，因为<code>F</code>不是构造函数。</p><p>那么，有没有办法让Generator函数返回一个正常的对象实例，既可以用<code>next</code>方法，又可以获得正常的<code>this</code>？</p><p>下面是一个变通方法。首先，生成一个空对象，使用<code>call</code>方法绑定Generator函数内部的<code>this</code>。这样，构造函数调用以后，这个空对象就是Generator函数的实例对象了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.b = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = F.call(obj);</span><br><span class="line"></span><br><span class="line">f.next();     <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next();     <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next();     <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">obj.a         <span class="comment">// 1</span></span><br><span class="line">obj.b         <span class="comment">// 2</span></span><br><span class="line">obj.c         <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，首先是<code>F</code>内部的<code>this</code>对象绑定<code>obj</code>对象，然后调用它，返回一个Iterator对象。这个对象执行三次<code>next</code>方法（因为<code>F</code>内部有两个<code>yield</code>表达式），完成<code>F</code>内部所有代码的运行。这时，所有内部属性都绑定在<code>obj</code>对象上了，因此<code>obj</code>对象也就成了<code>F</code>的实例。</p><p>上面代码中，执行的是遍历器对象<code>f</code>，但是生成的对象实例是<code>obj</code>，有没有办法将这两个对象统一呢？</p><p>一个方法就是将<code>obj</code>换成<code>F.prototype</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = F.call(F.prototype);</span><br><span class="line"></span><br><span class="line">f.next()      <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next()      <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next()      <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.a           <span class="comment">// 1</span></span><br><span class="line">f.b           <span class="comment">// 2</span></span><br><span class="line">f.c           <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>再将<code>F</code>改成构造函数，就可以对他执行<code>new</code>命令了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gen.call(gen.prototype);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line">f.next();     <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next();     <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next();     <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.a           <span class="comment">// 1</span></span><br><span class="line">f.b           <span class="comment">// 2</span></span><br><span class="line">f.c           <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><hr><h3 id="十、含义"><a href="#十、含义" class="headerlink" title="十、含义"></a>十、含义</h3><h4 id="1-Generator与状态机"><a href="#1-Generator与状态机" class="headerlink" title="1. Generator与状态机"></a>1. Generator与状态机</h4><p>Generator是实现状态机的最佳结构。比如，下面的<code>clock</code>函数就是一个状态机。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ticking = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> clock = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ticking) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Tick!'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Tock!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ticking = !tocking;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<code>clock</code>函数一共有两种状态（<code>Tick</code>和<code>Tock</code>），每运行一次，就改变一次状态。这个函数如果用Generator实现，就是下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clock = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Tick!'</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Tock!'</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的Generator实现与ES5实现对比，可以看到少了用来保存状态的外部变量<code>ticking</code>，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator之所以可以不用外部变量保存状态，是因为它本身就包含一个状态信息，即目前是否处于暂停态。</p><h4 id="2-Generator与协程"><a href="#2-Generator与协程" class="headerlink" title="2. Generator与协程"></a>2. Generator与协程</h4><p>协程（coroutine）是一种程序运行的方法，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p><ul><li>1) 协程与子例程的差异</li></ul><p>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行福函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p><p>从是线上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p><ul><li>2) 协程与普通线程的差异</li></ul><p>不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p><p>由于JavaScript是单线程语言，只能保持一个调用栈。引入协程以后，每个人物可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像一步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p><p>Generator函数是ES6对协程的实现，但属于不完全实现。Generator函数被称为“半协程（semi-coroutine）”，意思是只有Generator函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p><p>如果将Generator函数当作协程，完全可以将多个需要互相协作的任务协程Generator函数，它们之间使用<code>yield</code>表达式交换控制权。</p><h4 id="3-Generator与上下文"><a href="#3-Generator与上下文" class="headerlink" title="3. Generator与上下文"></a>3. Generator与上下文</h4><p>JavaScript代码运行时，会产生一个全局的上下文环境（context，又称为运行环境），包含了当前所有的变量与对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。</p><p>这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直到所有代码执行完成，堆栈清空。</p><p>Generator函数不是这样，它执行产生的上下文环境，一旦遇到<code>yield</code>命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行<code>next</code>命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  g.next().value,</span><br><span class="line">  g.next().value,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面代码中，第一次执行<code>g.next()</code>时，Generator函数<code>gen</code>的上下文会加入堆栈，即开始运行<code>gen</code>内部的代码。等遇到<code>yield 1</code>时，<code>gen</code>上下文退出堆栈，内部状态冻结。第二次执行<code>g.next()</code>时，<code>gen</code>上下文重新加入堆栈，变成当前的上下文，重新恢复执行。</p><hr><h3 id="十一、应用"><a href="#十一、应用" class="headerlink" title="十一、应用"></a>十一、应用</h3><p>Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。</p><h4 id="1-异步操作的同步化表达"><a href="#1-异步操作的同步化表达" class="headerlink" title="1. 异步操作的同步化表达"></a>1. 异步操作的同步化表达</h4><p>Generator函数的暂停执行的效果，意味着可以把异步操作写在<code>yield</code>表达式里面，等到调用<code>next</code>方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在<code>yield</code>表达式下面，反正要等到调用<code>next</code>方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loadUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  showLoadingScreen();</span><br><span class="line">  <span class="keyword">yield</span> loadUIDataAsynchronously();</span><br><span class="line">  hideLoadingScreen();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loader = loadUI();</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.next();</span><br></pre></td></tr></table></figure><p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面（<code>showLoadingScreen</code>），并且异步加载数据（<code>loadingDataAsynchronously</code>）。等到数据加载完成，再一次使用<code>next</code>方法，则会隐藏<code>Loading</code>界面。可以看到，这种写法的好处是所有<code>Loading</code>界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p><p>Ajax是典型的异步操作，通过Generator函数部署Ajax操作，可用同步的方式表达。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> request(<span class="string">'http://some.url'</span>);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">  <span class="built_in">console</span>.log()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  makeAjaxCall(url, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    it.next(response);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure><p>上面代码的<code>main</code>函数，就是通过Ajax操作获取数据。可以看到，除了多了一个<code>yield</code>，它几乎与同步操作的写法完全一致。注意，<code>makeAjaxCall</code>函数中的<code>next</code>方法，必须加上参数<code>response</code>，因为<code>yield</code>表达式，本身是没有值的，总是等于<code>undefined</code>。</p><p>下面是另一个例子，通过Generator函数逐行读取文本文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> file = <span class="keyword">new</span> FileReader(<span class="string">'numbers.txt'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!file.eof) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="built_in">parseInt</span>(file.readLine(), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    file.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码打开文本文件，使用<code>yield</code>表达式可以手动逐行读取文件。</p><h4 id="2-控制流管理"><a href="#2-控制流管理" class="headerlink" title="2. 控制流管理"></a>2. 控制流管理</h4><p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">step1(<span class="function"><span class="keyword">function</span>(<span class="params">value1</span>) </span>&#123;</span><br><span class="line">  step2(value1, <span class="function"><span class="keyword">function</span>(<span class="params">value2</span>) </span>&#123;</span><br><span class="line">    step3(value2, <span class="function"><span class="keyword">function</span>(<span class="params">value3</span>) </span>&#123;</span><br><span class="line">      step4(value3, <span class="function"><span class="keyword">function</span>(<span class="params">value4</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Do something with value4</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>采用Promise改写上面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(step1)</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(step4)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value4 &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">//</span> Do something with value4</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;, function(error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure><p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量Promise的语法。Generator函数可以进一步改善代码运行流程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">longRunningTask</span>(<span class="params">value1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value2 = <span class="keyword">yield</span> step1(value1);</span><br><span class="line">    <span class="keyword">var</span> value3 = <span class="keyword">yield</span> step1(value2);</span><br><span class="line">    <span class="keyword">var</span> value4 = <span class="keyword">yield</span> step1(value3);</span><br><span class="line">    <span class="keyword">var</span> value5 = <span class="keyword">yield</span> step1(value4);</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，使用一个函数，按次序自动执行所有步骤。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scheduler(longRunningTask(initialValue));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduler</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> taskObj = task.next(task.value)</span><br><span class="line">  <span class="comment">// 如果Generator函数未结束，就继续调用</span></span><br><span class="line">  <span class="keyword">if</span> (!taskObj.done) &#123;</span><br><span class="line">    task.value = taskObj.value;</span><br><span class="line">    scheduler(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面这种做法，只适合同步操作，即所有的<code>task</code>都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。</p><p>下面，利用<code>for...of</code>循环会自动依次执行<code>yield</code>命令的特性，提供一种更一般的控制流管理的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> steps = [step1Func, step2Func, step3Func];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterateSteps</span>(<span class="params">steps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; steps.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> step = steps[i];</span><br><span class="line">    <span class="keyword">yield</span> step();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>steps</code>封装了一个任务的多个步骤，Generator函数<code>iterateSteps</code>则是依次为这些步骤加上<code>yield</code>命令。</p><p>将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jobs = [job1, job2, job3];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterateJobs</span>(<span class="params">jobs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; jobs.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> job = jobs[i];</span><br><span class="line">    <span class="keyword">yield</span>* iterateSteps(job.steps);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>jobs</code>封装了一个项目的多个任务，Generator函数<code>iterableJobs</code>则是依次为这些任务加上<code>yield*</code>命令。</p><p>最后，就可以用<code>for...of</code>循环一次性执行所有任务的所有步骤。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> step <span class="keyword">of</span> iterableJobs(jobs)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(step.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步操作，必须使用后面《异步操作》一章介绍的方法。</p><p><code>for...of</code>本质上是一个<code>while</code>循环，所以上面的代码实质上执行的是下面的逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = iterableJobs(jobs);</span><br><span class="line"><span class="keyword">var</span> res = it.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!res.done) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = res.value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  res = it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-部署Iterator接口"><a href="#3-部署Iterator接口" class="headerlink" title="3. 部署Iterator接口"></a>3. 部署Iterator接口</h4><p>利用Generator函数，可以在任意对象上部署Iterator接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i];</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">bar</span>: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 3</span></span><br><span class="line"><span class="comment">// bar 7</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>myObj</code>是一个普通对象，通过<code>iterEntries</code>函数，就有了Iterator接口。也就是说，可以在任意对象上部署<code>next</code>方法。</p><p>下面是一个对数组部署Iterator接口的例子，尽管数组原生具有这个接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">makeSimpleGenerator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(nextIndex &lt; arrary.length) &#123;</span><br><span class="line">    <span class="keyword">yield</span> array[nextIndex++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = makeSimpleGenerator([<span class="string">'yo'</span>, <span class="string">'ya'</span>]);</span><br><span class="line"></span><br><span class="line">gen.next().value    <span class="comment">// 'yo'</span></span><br><span class="line">gen.next().value    <span class="comment">// 'ya'</span></span><br><span class="line">gen.next().done     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="4-作为数据结构"><a href="#4-作为数据结构" class="headerlink" title="4. 作为数据结构"></a>4. 作为数据结构</h4><p>Generator可以看作是数据结构，更确切地说，可以看作是一个数组结构。因为Generator函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'hello.txt'</span>);</span><br><span class="line">  <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'world.txt'</span>);</span><br><span class="line">  <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'and-such.txt'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是依次返回三个函数，但是由于使用了Generator函数，导致可以像处理数组那样，处理这三个返回的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(task <span class="keyword">of</span> doStuff) &#123;</span><br><span class="line">  <span class="comment">// task是一个函数，可以像回调函数那样使用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，如果用ES5表达，完全可以用数组模拟Generator的这种用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    fs.readFile.bind(<span class="literal">null</span>, <span class="string">'hello.txt'</span>);</span><br><span class="line">    fs.readFile.bind(<span class="literal">null</span>, <span class="string">'world.txt'</span>);</span><br><span class="line">    fs.readFile.bind(<span class="literal">null</span>, <span class="string">'and-such.txt'</span>);</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数，可以用一模一样的<code>for...of</code>循环处理！两相一比较，就不难看出Generator使得数据或者操作，具备了类似数组的接口。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/generator">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中&lt;code&gt;Generator&lt;/code&gt;函数的使用方法。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/generator&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(6) Symbol</title>
    <link href="http://www.xiaoleon.cn/2018/05/21/es6-6/"/>
    <id>http://www.xiaoleon.cn/2018/05/21/es6-6/</id>
    <published>2018-05-21T09:07:10.000Z</published>
    <updated>2018-05-22T15:05:18.475Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中<code>Symbol</code>的语法及使用方法。节选自<a href="(http://es6.ruanyifeng.com/#docs/symbol">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。比如，你是用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本是防止属性名的冲突。这就是ES6引入<code>Symbol</code>的原因。</p><p>ES6引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是JavaScript的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><p>Symbol值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s                <span class="comment">// 'symbol'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是Symbol数据类型，而不是字符串之类的其它类型。</p><p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1                      <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2                      <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.toString()           <span class="comment">// 'Symbol(foo)'</span></span><br><span class="line">s2.toString()           <span class="comment">// 'Symbol(bar)'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>是两个Symbol值。如果不加上参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分，有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><p>如果Symbol的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转换为字符串，然后才生成一个Symbol值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'obj'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</span><br><span class="line">sym             <span class="comment">// Symbol(abc)</span></span><br></pre></td></tr></table></figure><p>注意，<code>Symbol</code>函数的参数只是表示对当前Symbol值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2           <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2           <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。</p><p>Symbol值不能与其他类型的值进行运算，会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'my symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">'your symbol is'</span> + sym      <span class="comment">// TypeError: can't convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span>     <span class="comment">// TypeError: can't convert symbol to string</span></span><br></pre></td></tr></table></figure><p>但是，Symbol值可以显示转为字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'my symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(sym)                 <span class="comment">// 'Symbol(my symbol)'</span></span><br><span class="line">sym.toString()              <span class="comment">// 'Symbol(my symbol)'</span></span><br></pre></td></tr></table></figure><p>另外，Symbol值也可以转为布尔值，但是不能转为数值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">Boolean</span>(sym)                <span class="comment">// true</span></span><br><span class="line">!sym                        <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(sym)                 <span class="comment">// TypeError</span></span><br><span class="line">sym + <span class="number">2</span>                     <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><hr><h3 id="二、作为属性名的Symbol"><a href="#二、作为属性名的Symbol" class="headerlink" title="二、作为属性名的Symbol"></a>二、作为属性名的Symbol</h3><p>由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    [mySymbol]: <span class="string">'Hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123;<span class="attr">value</span>: <span class="string">'Hello'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol]                 <span class="comment">// 'Hello'</span></span><br></pre></td></tr></table></figure><p>上面代码通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个Symbol值。</p><p>注意，Symbol值作为对象属性名时，不能用点运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">'Hello'</span>;</span><br><span class="line">a[mySymbol]                 <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">'mySymbol'</span>]               <span class="comment">// 'Hello'</span></span><br></pre></td></tr></table></figure><p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个Symbol值。</p><p>同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [s]: <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[s](<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个Symbol值。</p><p>采用增强的对象写法，上面代码的<code>obj</code>对象可以写得更简洁一些。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [s](arg) &#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log.levels = &#123;</span><br><span class="line">    DEBUG: <span class="built_in">Symbol</span>(<span class="string">'debug'</span>),</span><br><span class="line">    INFO: <span class="built_in">Symbol</span>(<span class="string">'info'</span>),</span><br><span class="line">    WARN: <span class="built_in">Symbol</span>(<span class="string">'warn'</span>)</span><br><span class="line">&#125;;</span><br><span class="line">log(log.levels.DEBUG, <span class="string">'debug message'</span>);</span><br><span class="line">log(log.levels.INFO, <span class="string">'info message'</span>);</span><br></pre></td></tr></table></figure><p>下面是另外一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> COLOR_RED = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> COLOR_GREEN = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComplement</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(color) &#123;</span><br><span class="line">        <span class="keyword">case</span> COLOR_RED:</span><br><span class="line">            <span class="keyword">return</span> COLOR_GREEN;</span><br><span class="line">        <span class="keyword">case</span> COLOR_GREEN;</span><br><span class="line">            RETURN COLOR_RED;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Undefined color'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量使用Symbol值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按照设计的方式工作。</p><p>还有一点需要注意，Symbol值作为属性名时，该属性还是公开属性，不是私有属性。</p><hr><h3 id="三、实例：消除魔术字符串"><a href="#三、实例：消除魔术字符串" class="headerlink" title="三、实例：消除魔术字符串"></a>三、实例：消除魔术字符串</h3><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(shape) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'Triangle'</span>:        <span class="comment">// 魔术字符串</span></span><br><span class="line">            area = <span class="number">.5</span> * options.width * options.height;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(<span class="string">'Triangle'</span>, &#123;<span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;);     <span class="comment">// 魔术字符串</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p><p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">    triangle: <span class="string">'Triangle'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(shape) &#123;</span><br><span class="line">        <span class="keyword">case</span> shapeType.triangle:</span><br><span class="line">            area = <span class="number">.5</span> * options.width * options.height;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(shapeType.triangle, &#123;<span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，我们把<code>Triangle</code>写成<code>shapeType</code>对象的<code>triangle</code>属性，这样就消除了强耦合。</p><p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会根其他的<code>shapeType</code>属性的值冲突即可。因此，这里就很适合改用Symbol值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">    triangle: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，除了将<code>shapeType.triangle</code>的值设为一个Symbol，其他地方都不用修改。</p><hr><h3 id="四、属性名的遍历"><a href="#四、属性名的遍历" class="headerlink" title="四、属性名的遍历"></a>四、属性名的遍历</h3><p>Symbol作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有Symbol属性名。</p><p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的Symbol值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols               <span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure><p>下面是另一个例子，<code>Object.getOwnPropertySymbols</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, foo, &#123;</span><br><span class="line">    value: <span class="string">'foobar'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);         <span class="comment">// 无输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)     <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj)   <span class="comment">// [Symbol(foo)]</span></span><br></pre></td></tr></table></figure><p>上面代码中，使用<code>Object.getOwnPropertyNames</code>方法得不到<code>Symbol</code>属性名，需要使用<code>Object.getOwnPropertySymbols</code>方法。</p><p>另一个新的API，<code>Reflect.ownKeys</code>方法可以返回所有类型的键名，包括常规键名和Symbol键名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">    enum: <span class="number">2</span>,</span><br><span class="line">    nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)        <span class="comment">// ['enum', 'nonEnum', Symbol(my_key)]</span></span><br></pre></td></tr></table></figure><p>由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sie = <span class="built_in">Symbol</span>(<span class="string">'size'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>[size] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>[<span class="keyword">this</span>[size]] = item;</span><br><span class="line">        <span class="keyword">this</span>[size]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> sizeOf(instance) &#123;</span><br><span class="line">        <span class="keyword">return</span> instance[size]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> Collection();</span><br><span class="line">Collection.sizeOf(x);           <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">x.add(<span class="string">'foo'</span>);</span><br><span class="line">Collection.sizeOf(x);           <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(x)                  <span class="comment">// ['0']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(x)   <span class="comment">// ['0']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(x) <span class="comment">// [Symbol(size)]</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个Symbol值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它，这就造成了一种非私有的内部方法的效果。</p><hr><h3 id="五、Symbol-for-，Symbol-keyFor"><a href="#五、Symbol-for-，Symbol-keyFor" class="headerlink" title="五、Symbol.for()，Symbol.keyFor()"></a>五、Symbol.for()，Symbol.keyFor()</h3><p>有时候，我们希望重新使用同一个Symbol值，<code>Symbol.for</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2;                      <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>都是Symbol值，但是它们都是同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中提供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的Symbol类型的值，而是会检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果调用<code>Symbol.for(&quot;cat&quot;)</code>30次，每次都会返回同一个Symbol值，但是调用<code>Symbol(&#39;cat&#39;)</code>30次，会返回30个不同的Symbol值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'bar'</span>) === <span class="built_in">Symbol</span>(<span class="string">'bar'</span>)             <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p><p><code>Symbol.keyFor</code>方法返回一个已登记的Symbol类型值的<code>key</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1);              <span class="comment">// 'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2);              <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s2</code>属于未登记的Symbol值，所以返回<code>undefined</code>。</p><p>需要注意的是，<code>Symbol.for</code>为Symbol值登记的名字，是全局环境的，可以在不同的<code>iframe</code>或<code>service worker</code>中取到同一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = <span class="built_in">String</span>(<span class="built_in">window</span>.location);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">iframe.contentWindow.Symbol.for(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，iframe窗口生成的Symbol值，可以在主页面得到。</p><hr><h3 id="六、实例：模块的Singleton模式"><a href="#六、实例：模块的Singleton模式" class="headerlink" title="六、实例：模块的Singleton模式"></a>六、实例：模块的Singleton模式</h3><p>Singleton模式指的是调用一个类，任何时候返回的都是同一个实例。</p><p>对于Node来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p><p>很容易想到，可以把实例放到顶层对象<code>global</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!global._foo) &#123;</span><br><span class="line">    global._foo = <span class="keyword">new</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modules.exports = global._foo;</span><br></pre></td></tr></table></figure><p>然后，加载上面的<code>mod.js</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./mod.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.foo);</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例。</p><p>但是，这里有一个问题，全局变量<code>global._foo</code>是可写的，任何文件都可以修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">global._foo = &#123;<span class="attr">foo</span>: <span class="string">'world'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./mod.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.foo);</span><br></pre></td></tr></table></figure><p>上面的代码，会使得加载<code>mod.js</code>的脚本都失真。</p><p>为了防止这种情况出现，我们就可以使用Symbol。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">const</span> FOO_KEY = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!global[FOO_KEY]) &#123;</span><br><span class="line">    global[FOO_KEY] = <span class="keyword">new</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = global[FOO_KEY];</span><br></pre></td></tr></table></figure><p>上面代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">global[<span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)] = &#123;<span class="attr">foo</span>: <span class="string">'world'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./mod.js'</span>);</span><br></pre></td></tr></table></figure><p>如果键名使用<code>Symbol</code>方法生成，那么外部将无法引用这个值，当然也就无法改写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">const</span> FOO_KEY = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure><p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的<code>FOO_KEY</code>都是不一样的。虽然Node会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。</p><hr><h3 id="七、内置的Symbol值"><a href="#七、内置的Symbol值" class="headerlink" title="七、内置的Symbol值"></a>七、内置的Symbol值</h3><p>除了定义自己使用的Symbol值以外，ES6还提供了11各内置的Symbol值，指向语言内部使用的方法。</p><h4 id="1-Symbol-hasInstance"><a href="#1-Symbol-hasInstance" class="headerlink" title="1. Symbol.hasInstance"></a>1. Symbol.hasInstance</h4><p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.hasInstance](foo) &#123;</span><br><span class="line">        <span class="keyword">return</span> foo <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> MyClass();     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p><p>下面是另一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Even</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> Even = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> Even           <span class="comment">// false</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">instanceof</span> Even           <span class="comment">// true</span></span><br><span class="line"><span class="number">12345</span> <span class="keyword">instanceof</span> Even       <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="2-Symbol-isConcatSpreadable"><a href="#2-Symbol-isConcatSpreadable" class="headerlink" title="2. Symbol.isConcatSpreadable"></a>2. Symbol.isConcatSpreadable</h4><p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr1, <span class="string">'e'</span>)        <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br><span class="line">arr1[<span class="built_in">Symbol</span>.isConcatSpreadable]     <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr2, <span class="string">'e'</span>)        <span class="comment">// ['a', 'b', ['c', 'd'], 'e']</span></span><br></pre></td></tr></table></figure><p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p><p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'c'</span>, <span class="number">1</span>: <span class="string">'d'</span>&#125;;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>);        <span class="comment">// ['a', 'b', obj, 'e']</span></span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>);        <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure><p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">        <span class="keyword">super</span>(args);</span><br><span class="line">        <span class="keyword">this</span>[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">        <span class="keyword">super</span>(args);</span><br><span class="line">    &#125;</span><br><span class="line">    get [<span class="built_in">Symbol</span>.isConcatSpreadable]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> A1();</span><br><span class="line">a1[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">a1[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> A2();</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(a1).concat(a2)    <span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br></pre></td></tr></table></figure><p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p><p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p><h4 id="3-Symbol-species"><a href="#3-Symbol-species" class="headerlink" title="3. Symbol.species"></a>3. Symbol.species</h4><p>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> b = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x);</span><br><span class="line"><span class="keyword">const</span> c = a.filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">b.instanceof MyArray;           <span class="comment">// true</span></span><br><span class="line">c <span class="keyword">instanceof</span> MyArray;           <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，<code>a</code>是<code>MyArray</code>的实例，<code>b</code>和<code>c</code>是<code>a</code>的衍生对象。你可能会认为，<code>b</code>和<code>c</code>都是调用数组方法生成的，所以应该是数组(<code>Array</code>的实例)，但实际上它们也是<code>MyArray</code>的实例。</p><p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。现在，我们可以为<code>MyArray</code>设置<code>Symbol.species</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="title">extens</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，由于定义了<code>Symbol.species</code>属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>取值器。默认的<code>Symbol.species</code>属性等同于下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，再来看前面的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> MyArray();</span><br><span class="line"><span class="keyword">const</span> b = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x);</span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> MyArray        <span class="comment">// false</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Array</span>          <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a.map(x =&gt; x)</code>生成的衍生对象，就不是<code>MyArray</code>的实例，而直接就是<code>Array</code>的实例。</p><p>再看一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T2</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> T1(<span class="function"><span class="params">r</span> =&gt;</span> r()).then(<span class="function"><span class="params">v</span> =&gt;</span> v) <span class="keyword">instanceof</span> T1     <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> T2(<span class="function"><span class="params">r</span> =&gt;</span> r()).then(<span class="function"><span class="params">v</span> =&gt;</span> v) <span class="keyword">instanceof</span> T2     <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>T2</code>定义了<code>Symbol.species</code>属性，<code>T1</code>没有。结果就导致了创建衍生对象时（<code>then</code>方法），<code>T1</code>调用的是自身的构造方法，而<code>T2</code>调用的是<code>Promise</code>的构造方法。</p><p>总之，<code>Symbol.species</code>的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的作用是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p><h4 id="4-Symbol-match"><a href="#4-Symbol-match" class="headerlink" title="4. Symbol.match"></a>4. Symbol.match</h4><p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.match(regexp)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">regexp[<span class="built_in">Symbol</span>.match](<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMatcher</span> </span>&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.match](string) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span>.indexOf(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'e'</span>.match(<span class="keyword">new</span> MyMatcher())      <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="5-Symbol-replace"><a href="#5-Symbol-replace" class="headerlink" title="5. Symbol.replace"></a>5. Symbol.replace</h4><p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.replace(searchValue, replaceValue)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">searchValue[<span class="built_in">Symbol</span>.replace](<span class="keyword">this</span>, replaceValue)</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123;&#125;;</span><br><span class="line">x[<span class="built_in">Symbol</span>.replace] = <span class="function">(<span class="params">...s</span>) =&gt;</span> <span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="string">'Hello'</span>.replace(x, <span class="string">'World'</span>)     <span class="comment">// ['Hello', 'World']</span></span><br></pre></td></tr></table></figure><p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p><h4 id="6-Symbol-search"><a href="#6-Symbol-search" class="headerlink" title="6. Symbol.search"></a>6. Symbol.search</h4><p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.search(regexp)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">regexp[<span class="built_in">Symbol</span>.search](<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.search](string) &#123;</span><br><span class="line">        <span class="keyword">return</span> string.indexOf(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'foobar'</span>.search(<span class="keyword">new</span> MySearch(<span class="string">'foo'</span>))    <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h4 id="7-Symbol-split"><a href="#7-Symbol-split" class="headerlink" title="7. Symbol.split"></a>7. Symbol.split</h4><p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.split(separator, limit)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">separator[<span class="built_in">Symbol</span>.split](<span class="keyword">this</span>, limit)</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySpliter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.split](string) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = string.indexOf(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> string;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            string.substr(<span class="number">0</span>, index),</span><br><span class="line">            string.substr(index + <span class="keyword">this</span>.value.length)</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySeperator(<span class="string">'foo'</span>))      <span class="comment">// ['', 'bar']</span></span><br><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySeperator(<span class="string">'bar'</span>))      <span class="comment">// ['foo', '']</span></span><br><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySeperator(<span class="string">'baz'</span>))      <span class="comment">// 'foobar'</span></span><br></pre></td></tr></table></figure><p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为。</p><h4 id="8-Symbol-iterator"><a href="#8-Symbol-iterator" class="headerlink" title="8. Symbol.iterator"></a>8. Symbol.iterator</h4><p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable]     <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>[i] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">this</span>[i];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myCollection = <span class="keyword">new</span> Collection();</span><br><span class="line">myCollection[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">myCollection[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myCollection) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="9-Symbol-toPrimitive"><a href="#9-Symbol-toPrimitive" class="headerlink" title="9. Symbol.toPrimitive"></a>9. Symbol.toPrimitive</h4><p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p><p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p><ul><li><p>Number：该场合需要转成数值</p></li><li><p>String：该场合需要转成字符串</p></li><li><p>Default：该场合可以转成数值，也可以转成字符串</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(hint) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'str'</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'default'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'default'</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> * obj             <span class="comment">// 246，Number模式</span></span><br><span class="line"><span class="number">3</span> + obj             <span class="comment">// '3default'，Default模式</span></span><br><span class="line">obj == <span class="string">'default'</span>    <span class="comment">// true，Default模式</span></span><br><span class="line"><span class="built_in">String</span>(obj)         <span class="comment">// 'str'，String模式</span></span><br></pre></td></tr></table></figure><h4 id="10-Symbol-toStringTag"><a href="#10-Symbol-toStringTag" class="headerlink" title="10. Symbol.toStringTag"></a>10. Symbol.toStringTag</h4><p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法，在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line">(&#123;[<span class="built_in">Symbol</span>.toStringTag]: <span class="string">'Foo'</span>&#125;.toString())  <span class="comment">// "[object Foo]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    get [<span class="built_in">Symbol</span>.toStringTag]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'xxx'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> Collection();</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(x)           <span class="comment">// "[object xxx]"</span></span><br></pre></td></tr></table></figure><p>ES6新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p><ul><li><p><code>JSON[Symbol.toStringTag]</code>: ‘JSON’</p></li><li><p><code>Math[Symbol.toStringTag]</code>: ‘Math’</p></li><li><p>Module对象<code>M[Symbol.toStringTag]</code>: ‘Module’</p></li><li><p><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>: ‘ArrayBuffer’</p></li><li><p><code>DataView.prototype[Symbol.toStringTag]</code>: ‘DataView’</p></li><li><p><code>Map.prototype[Symbol.toStringTag]</code>: ‘Map’</p></li><li><p><code>Promise.prototype[Symbol.toStringTag]</code>: ‘Promise’</p></li><li><p><code>Set.prototype[Symbol.toStringTag]</code>: ‘Set’</p></li><li><p><code>%TypedArray%.prototype[Symbol.toStringTag]</code>: ‘Uint8Array’等</p></li><li><p><code>WeakMap.prototype[Symbol.toStringTag]</code>: ‘WeakMap’</p></li><li><p><code>WeakSet.prototype[Symbol.toStringTag]</code>: ‘WeakSet’</p></li><li><p><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>: ‘Map Iterator’</p></li><li><p><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>: ‘Set Iterator’</p></li><li><p><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>: ‘String Iterator’</p></li><li><p><code>Symbol.prototype[Symbol.toStringTag]</code>: ‘Symbol’</p></li><li><p><code>Generator.prototype[Symbol.toStringTag]</code>: ‘Generator’</p></li><li><p><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>: ‘GeneratorFunction’</p></li></ul><h4 id="11-Symbol-unscopables"><a href="#11-Symbol-unscopables" class="headerlink" title="11. Symbol.unscopables"></a>11. Symbol.unscopables</h4><p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables]</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//      copeWithin: true,</span></span><br><span class="line"><span class="comment">//      entries: true,</span></span><br><span class="line"><span class="comment">//      fill: true,</span></span><br><span class="line"><span class="comment">//      find: true,</span></span><br><span class="line"><span class="comment">//      findIndex: true,</span></span><br><span class="line"><span class="comment">//      includes: true,</span></span><br><span class="line"><span class="comment">//      keys: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(<span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables])</span><br><span class="line"><span class="comment">// ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'includes', 'keys']</span></span><br></pre></td></tr></table></figure><p>上面代码说明，数组有7个属性，会被<code>with</code>命令排除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有unscopables时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    foo() &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (MyClass.prototype) &#123;</span><br><span class="line">    foo();          <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有unscopables时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    foo() &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    get [<span class="built_in">Symbol</span>.unscopables]() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">foo</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (Myclass.prototype) &#123;</span><br><span class="line">    foo();          <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/symbol">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中&lt;code&gt;Symbol&lt;/code&gt;的语法及使用方法。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/symbol&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(5) Module的加载实现</title>
    <link href="http://www.xiaoleon.cn/2018/05/19/es6-5/"/>
    <id>http://www.xiaoleon.cn/2018/05/19/es6-5/</id>
    <published>2018-05-19T15:13:05.000Z</published>
    <updated>2018-06-10T22:13:14.060Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中<code>Module</code>的加载实现。节选自<a href="(http://es6.ruanyifeng.com/#docs/module-loader">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、浏览器加载"><a href="#一、浏览器加载" class="headerlink" title="一、浏览器加载"></a>一、浏览器加载</h3><h4 id="1-传统方法"><a href="#1-传统方法" class="headerlink" title="1. 传统方法"></a>1. 传统方法</h4><p>HTML网页中，浏览器通过<code>&lt;script&gt;</code>标签加载JavaScript脚本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面内嵌的脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// module code</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于浏览器脚本的默认语言是JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。</p><p>默认情况下，浏览器是同步加载JavaScript脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/myModule.js"</span> defer&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"path/to/myModule.js"</span> <span class="keyword">async</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>和<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p><p><code>defer</code>与<code>async</code>的区别是：<code>defer</code>要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行；<code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</p><h4 id="2-加载规则"><a href="#2-加载规则" class="headerlink" title="2. 加载规则"></a>2. 加载规则</h4><p>浏览器加载ES6模块，也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个ES6模块。</p><p>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面中出现的顺序依次执行。</p><p><code>&lt;script&gt;</code>标签的<code>async</code>属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一旦使用了<code>async</code>属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</p><p>ES6模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'./utils.js'</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// other code</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p><ul><li><p>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</p></li><li><p>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</p></li><li><p>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对URL或者相对URL），也可以使用<code>export</code>命令输出对外接口。</p></li><li><p>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</p></li><li><p>同一个模块如果加载多次，将只执行一次。</p></li></ul><p>下面是一个示例模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'https://example.com/js/utils.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="built_in">window</span>.x);        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="literal">undefined</span>);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在ES6模块之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotModuleScript = <span class="keyword">this</span> !== <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="二、ES6模块与CommonJS模块的差异"><a href="#二、ES6模块与CommonJS模块的差异" class="headerlink" title="二、ES6模块与CommonJS模块的差异"></a>二、ES6模块与CommonJS模块的差异</h3><p>讨论Node加载ES6之前，必须了解ES6模块与CommonJS模块完全不同。</p><p>它们有两个重大差异。</p><ul><li><p>CommonJS模块输出的是一个拷贝，ES6模块输出的是值的引用。</p></li><li><p>CommonJS模块是运行时加载，ES6模块是编译时输出接口。</p></li></ul><p>第二个差异是因为CommonJS加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本完全运行完才会生成。而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>下面重点解释第一个差异。</p><p>CommonJS模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件<code>lib.js</code>的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码输出内部变量<code>counter</code>和改写这个变量的内部方法<code>incCounter</code>。然后，在<code>main.js</code>里面加载这个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);     <span class="comment">// 3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  get counter() &#123;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;,</span><br><span class="line">  incCounter: incCounter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，输出的<code>counter</code>属性实际上是一个取值器函数。现在再执行<code>main.js</code>，就可以正确读取内部变量<code>counter</code>的变动了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node main.js</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>ES6模块的运行机制与CommonJS不一样。JS引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6的<code>import</code>有点像Unix系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p><p>还是举上面的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;counter, incCounter&#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter);       <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter);       <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>上面代码说明，ES6模块输入的<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p><p>再举一个出现在<code>export</code>一节中的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// m2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./m1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(foo), <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>m1.js</code>的变量<code>foo</code>，在刚加载的时候等于<code>bar</code>，过了500毫秒，又变为等于<code>baz</code>。</p><p>让我们看看，<code>m2.js</code>是否正确读取这个变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">babel-node m2.js</span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure><p>上面代码表明，ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p><p>由于ES6输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;obj&#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">123</span>;       <span class="comment">// ok</span></span><br><span class="line">obj = &#123;&#125;;             <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>main.js</code>从<code>lib.js</code>输入变量<code>obj</code>，可以对<code>obj</code>添加属性，但是重新赋值就会报错。因为变量<code>obj</code>指向的地址是只读的，不能重新赋值，这就好比<code>main.js</code>创造了一个名为<code>obj</code>的<code>const</code>变量。</p><p>最后，<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sum += <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.sum);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br></pre></td></tr></table></figure><p>上面的脚本<code>mod.js</code>，输出的是一个<code>c</code>的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">'./mod'</span>;</span><br><span class="line">c.add();</span><br><span class="line"></span><br><span class="line"><span class="comment">// y.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">'./mod'</span>;</span><br><span class="line">c.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./x'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./y'</span>;</span><br></pre></td></tr></table></figure><p>现在执行<code>main.js</code>，输出的是<code>1</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">babel-node main.js</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>这就证明了<code>x.js</code>和<code>y.js</code>加载的都是<code>c</code>的同一个实例。</p><hr><h3 id="三、Node加载"><a href="#三、Node加载" class="headerlink" title="三、Node加载"></a>三、Node加载</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>Node对ES6模块的处理比较麻烦，因为它有自己的CommonJS模块格式，与ES6模块格式是不兼容的。目前的解决方案是，将两者分开，ES6模块和CommonJS采用各自的加载方案。</p><p>Node要求ES6模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，那么就必须采用<code>.mjs</code>后缀名。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错。只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。</p><p>目前，这项功能还在试验阶段。安装Node V8.5.0或以上版本，要用<code>--experimental-modules</code>参数才能打开该功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --experimental-modules my-app.mjs</span><br></pre></td></tr></table></figure><p>为了与浏览器的<code>import</code>加载规则相同，Node的<code>.mjs</code>文件支持URL路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./foo?query=1'</span>;   <span class="comment">// 加载 ./foo 传入参数 ?query=1</span></span><br></pre></td></tr></table></figure><p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node会按URL规则来解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。</p><p>目前，Node的<code>import</code>命令只支持加载本地模块（<code>file:</code>协议），不支持加载远程模块。</p><p>如果模块名不含路径，那么<code>import</code>命令会去<code>node_modules</code>目录寻找这个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'baz'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'abc/123'</span>;</span><br></pre></td></tr></table></figure><p>如果模块包含路径，那么<code>import</code>命令会按照路径去寻找这个名字的脚本文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'file:///etc/config/app.json'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./foo'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./foo?search'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../bar'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'/baz'</span>;</span><br></pre></td></tr></table></figure><p>如果脚本文件省略了后缀名，比如<code>import &#39;./foo&#39;</code>，Node会依次尝试四个后缀名：<code>./foo.mjs</code>、<code>./foo.js</code>、<code>./foo.json</code>、<code>./foo.node</code>。如果这些脚本文件都不存在，Node就会去加载<code>./foo/package.json</code>的<code>main</code>字段指定的脚本。如果<code>./foo/package.json</code>不存在或者没有<code>main</code>字段，那么就会依次加载<code>./foo/index.mjs</code>、<code>./foo/index.js</code>、<code>./foo/index.json</code>、<code>./foo/index.node</code>。如果以上四个文件还是都不存在，就会抛出错误。</p><p>最后，Node的<code>import</code>命令是异步加载，这一点与浏览器的处理方法相同。</p><h4 id="2-内部变量"><a href="#2-内部变量" class="headerlink" title="2. 内部变量"></a>2. 内部变量</h4><p>ES6模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node规定ES6模块之中不能使用CommonJS模块的特有的一些内部变量。</p><p>首先，就是<code>this</code>关键字。ES6模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</p><p>其次，以下这些顶层变量在ES6模块之中都是不存在的。</p><ul><li><p><code>arguments</code></p></li><li><p><code>require</code></p></li><li><p><code>module</code></p></li><li><p><code>exports</code></p></li><li><p><code>__filename</code></p></li><li><p><code>__dirname</code></p></li></ul><p>如果一定要使用这些变量，有一个变通方法，就是写一个CommonJS模块输出这些变量，然后再用ES6模块加载这个CommonJS模块。但是这样一来，该ES6模块就不能直接用于浏览器环境了，所以不推荐这么做。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expose.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;__dirname&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use.mjs</span></span><br><span class="line"><span class="keyword">import</span> expose <span class="keyword">from</span> <span class="string">'./expose.js'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123;__dirname&#125; = expose;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>expose.js</code>是一个CommonJS模块，输出变量<code>__dirname</code>，该变量在ES6模块之中不存在。ES6模块加载<code>expose.js</code>，就可以得到<code>__dirname</code>。</p><h4 id="3-ES6模块加载CommonJS模块"><a href="#3-ES6模块加载CommonJS模块" class="headerlink" title="3. ES6模块加载CommonJS模块"></a>3. ES6模块加载CommonJS模块</h4><p>CommonJS模块的输出都定义在<code>module.exports</code>这个属性上面。Node的<code>import</code>命令加载CommonJS模块，Node会自动将<code>module.exports</code>属性，当作模块的默认输出，即等同于<code>export default xxx</code>。</p><p>下面是一个CommonJS模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span>,</span><br><span class="line">  bar: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span>,</span><br><span class="line">  bar: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>import</code>命令加载上面的模块，<code>module.exports</code>会被视为默认输出，即<code>import</code>命令实际上输入的是这样一个对象<code>{default: module.exports}</code>。</p><p>所以，一共有三种写法，可以拿到CommonJS模块的<code>module.exports</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">import</span> baz <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="comment">// baz = &#123;foo: 'hello', bar: 'world'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> baz&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="comment">// baz = &#123;foo: 'hello', bar: 'world'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> baz <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="comment">// baz = &#123;</span></span><br><span class="line"><span class="comment">//    get default() &#123;return module.exports&#125;,</span></span><br><span class="line"><span class="comment">//    get foo() &#123;return this.default.foo&#125;.bind(baz),</span></span><br><span class="line"><span class="comment">//    get bar() &#123;return this.default.bar&#125;.bind(baz)  </span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码的第三种写法，可以通过<code>baz.default</code>拿到<code>module.exports</code>。<code>foo</code>属性和<code>bar</code>属性就是可以通过这种方法拿到了<code>module.exports</code>。</p><p>下面是一些例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="comment">// foo = null;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bar <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="comment">// bar = &#123;default: null&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>es.js</code>采用第二种写法时，要通过<code>bar.default</code>这样的写法，才能拿到<code>module.exports</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'./c'</span>;</span><br><span class="line">foo();      <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bar <span class="keyword">from</span> <span class="string">'./c'</span>;</span><br><span class="line">bar.default();    <span class="comment">// 2</span></span><br><span class="line">bar();            <span class="comment">// throws, bar is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>bar</code>本身是一个对象，不能当做函数调用，只能通过<code>bar.default</code>调用。</p><p>CommonJS模块的输出缓存机制，在ES6加载方式下依然有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="number">123</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">module</span>.exports = <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，对于加载<code>foo.js</code>的脚本，<code>module.exports</code>将一直是<code>123</code>，而不会变成<code>null</code>。</p><p>由于ES6模块是编译时确定输出接口，CommonJS模块是运行时确定输出接口，所以采用<code>import</code>命令加载CommonJS模块时，不允许采用下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不正确</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure><p>上面的写法不正确，因为<code>fs</code>是CommonJS格式，只有在运行时才能确定<code>readFile</code>接口，而<code>import</code>命令要求编译时就确定这个接口。解决方法就是改为整体输入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法一</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">const</span> app = express.default();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确地写法二</span></span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br></pre></td></tr></table></figure><h4 id="4-CommonJS模块加载ES6模块"><a href="#4-CommonJS模块加载ES6模块" class="headerlink" title="4. CommonJS模块加载ES6模块"></a>4. CommonJS模块加载ES6模块</h4><p>CommonJS模块加载ES6模块，不能使用<code>require</code>命令，而要用<code>import()</code>函数。ES6模块的所有输出接口，会成为输入对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es.mjs</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123;<span class="attr">bar</span>: <span class="string">'my-default'</span>&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="keyword">const</span> es_namespace = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./es.mjs'</span>);</span><br><span class="line"><span class="comment">// es_namespace = &#123;</span></span><br><span class="line"><span class="comment">//    get default() &#123;</span></span><br><span class="line"><span class="comment">//      ...</span></span><br><span class="line"><span class="comment">//    &#125; </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(es_namespace.default);</span><br><span class="line"><span class="comment">// &#123;bar: 'my-default'&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>default</code>接口变成了<code>es_namespace.default</code>属性。</p><p>下面是另一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = &#123;<span class="attr">bar</span>: <span class="string">'my-default'</span>&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123;foo <span class="keyword">as</span> bar&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">c</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="keyword">const</span> es_namespace = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./es'</span>);</span><br><span class="line"><span class="comment">// es_namespace = &#123;</span></span><br><span class="line"><span class="comment">//   get foo() &#123;return foo;&#125;</span></span><br><span class="line"><span class="comment">//   get bar() &#123;return foo;&#125;</span></span><br><span class="line"><span class="comment">//   get f() &#123;return f;&#125;</span></span><br><span class="line"><span class="comment">//   get c() &#123;return c;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、循环加载"><a href="#四、循环加载" class="headerlink" title="四、循环加载"></a>四、循环加载</h3><p>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p><p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</p><p>对于JavaScript语言来说，目前最常见的两种模块格式CommonJS和ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p><h4 id="1-CommonJS模块的加载原理"><a href="#1-CommonJS模块的加载原理" class="headerlink" title="1. CommonJS模块的加载原理"></a>1. CommonJS模块的加载原理</h4><p>介绍ES6如何处理“循环加载”之前，先介绍目前最流行的CommonJS模块格式的加载原理。</p><p>CommonJS的一个模块，就是一个脚本。<code>require</code>命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: <span class="string">'...'</span>,</span><br><span class="line">  exports: &#123;...&#125;,</span><br><span class="line">  loaded: <span class="literal">true</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是Node内部加载模块后生成的一个对象。该对象的<code>id</code>属性是模块名，<code>exports</code>属性是模块输出的各个接口，<code>loaded</code>属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p><p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。即使再次执行<code>require</code>命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p><h4 id="2-CommonJS模块的循环加载"><a href="#2-CommonJS模块的循环加载" class="headerlink" title="2. CommonJS模块的循环加载"></a>2. CommonJS模块的循环加载</h4><p>CommonJS模块的重要特性是加载时执行，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p><p>让我们来看，Node官方文档里面的例子。脚本文件<code>a.js</code>代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在a.js之中，b.done = %j'</span>, b.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.js执行完毕'</span>);</span><br></pre></td></tr></table></figure><p>上面代码之中，<code>a.js</code>脚本先输出一个<code>done</code>变量，然后加载另一个脚本文件<code>b.js</code>。注意，此时<code>a.js</code>代码就停在这里，等待<code>b.js</code>执行完毕，再往下执行。</p><p>再看<code>b.js</code>的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在b.js之中，a.done = %j'</span>, a.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.js执行完毕'</span>);</span><br></pre></td></tr></table></figure><p>上面代码之中，<code>b.js</code>执行到第二行，就会去加载<code>a.js</code>，这时，就发生了“循环加载”。系统会去<code>a.js</code>模块对应对象的<code>exports</code>属性取值，可是因为<code>a.js</code>还没有执行完，从<code>exports</code>属性只能取回已经执行的部分，而不是最后的值。</p><p><code>a.js</code>已经执行的部分，只有一行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports.done = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>因此，对于<code>b.js</code>来说，它从<code>a.js</code>只输入一个变量<code>done</code>，值为<code>false</code>。</p><p>然后，<code>b.js</code>接着往下执行，等到全部执行完毕，再把执行权交还给<code>a.js</code>。于是，<code>a.js</code>接着往下执行，直到执行完毕。我们写一个脚本<code>main.js</code>，验证这个过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在main.js之中，a.done=%j，b.done=%j'</span>, a.done, b.done);</span><br></pre></td></tr></table></figure><p>执行<code>main.js</code>，运行结果如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node main.js</span><br><span class="line"></span><br><span class="line">在b.js之中，a.done = <span class="literal">false</span></span><br><span class="line">b.js执行完毕</span><br><span class="line">在a.js之中，b.done = <span class="literal">true</span></span><br><span class="line">a.js执行完毕</span><br><span class="line">在main.js之中，a.done=<span class="literal">true</span>, b.done=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面的代码证明了两件事。一是，在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。二是，<code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，二是输出缓存的<code>b.js</code>的执行结果，即它的第四行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports.done = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>总之，CommonJS输入的是被输出值的拷贝，不是引用。</p><p>另外，由于CommonJS模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>);           <span class="comment">// 安全的写法</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">'a'</span>).foo;     <span class="comment">// 危险的写法</span></span><br><span class="line"></span><br><span class="line">exports.good = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.foo(<span class="string">'good'</span>, arg);    <span class="comment">// 使用的是a.foo的最新值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.bad = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo(<span class="string">'bad'</span>, arg);       <span class="comment">// 使用的是一个部分加载时的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点。</p><h4 id="3-ES6模块的循环加载"><a href="#3-ES6模块的循环加载" class="headerlink" title="3. ES6模块的循环加载"></a>3. ES6模块的循环加载</h4><p>ES6处理“循环加载”与CommonJS有本质的不同。ES6模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from &#39;foo&#39;</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">'bar'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node --experimental-modules a.mjs</span><br><span class="line"></span><br><span class="line">b.mjs</span><br><span class="line"><span class="built_in">ReferenceError</span>: foo is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？</p><p>让我们一行行来看，ES6循环加载是怎么处理的。首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。</p><p>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">'foo'</span>;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">'bar'</span>;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;bar&#125;;</span><br></pre></td></tr></table></figure><p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node --experimental-modules a.mjs</span><br><span class="line"></span><br><span class="line">b.mjs</span><br><span class="line">foo</span><br><span class="line">a.mjs</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>这是因为函数具有提升作用，在执行<code>import {bar} from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。这也意味着，如果把函数<code>foo</code>改写成函数表达式，也会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar());</span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。</p><p>我们再看看ES6模块加载器SystemJS给出的一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;odd&#125; <span class="keyword">from</span> <span class="string">'./odd'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n === <span class="number">0</span> || odd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;even&#125; <span class="keyword">from</span> <span class="string">'./even'</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">odd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n !== <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于0，就会减去1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p><p>运行上面这段代码，结果如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">node</span><br><span class="line">&gt; <span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">'./even.js'</span>;</span><br><span class="line">&gt; m.even(<span class="number">10</span>);</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.counter;</span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt; m.even(<span class="number">20</span>);</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">m.counter</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>n</code>从10变为0的过程中，<code>even()</code>一共会执行6次，所以变量<code>counter</code>等于6。第二次调用<code>even()</code>时，参数<code>n</code>从20变为0，<code>even()</code>一共会执行11次，加上前面的6次，所以变量<code>counter</code>等于17。</p><p>这个例子要是改写成CommonJS，就根本无法执行，会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">'./odd'</span>);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">exports.counter = counter;</span><br><span class="line">exports.even = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">'./even'</span>).even;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n !== <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分（不存在任何结果），所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node</span><br><span class="line">&gt; <span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">'./even'</span>);</span><br><span class="line">&gt; m.even(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">TypeError</span>: even is not a <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="五、ES6模块的转码"><a href="#五、ES6模块的转码" class="headerlink" title="五、ES6模块的转码"></a>五、ES6模块的转码</h3><p>浏览器目前还不支持ES6模块，为了现在就能使用，可以将其转为ES5的写法。除了Babel可以用来转码之外，还有以下两个方法，也可以用来转码。</p><h4 id="1-ES6-module-transpiler"><a href="#1-ES6-module-transpiler" class="headerlink" title="1. ES6 module transpiler"></a>1. ES6 module transpiler</h4><p>ES6 module transpiler是square公司开源的一个转码器，可以将ES6模块转为CommonJS模块或AMD模块的写法，从而在浏览器中使用。</p><p>首先，安装这个转码器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g es6-<span class="built_in">module</span>-transpiler</span><br></pre></td></tr></table></figure><p>然后，使用<code>compile-modules convert</code>命令，将ES6模块文件转码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile modules convert file1.js file2.js</span><br></pre></td></tr></table></figure><p><code>-o</code>参数可以指定转码后的文件名。</p><h4 id="2-SystemJS"><a href="#2-SystemJS" class="headerlink" title="2. SystemJS"></a>2. SystemJS</h4><p>另一种解决方法是使用SystemJS。它是一个垫片库（polyfill），可以在浏览器内加载ES6模块、AMD模块和CommonJS模块，将其转为ES5格式。它在后台调用的是Google和Traceur转码器。</p><p>使用时，先在网页内载入<code>system.js</code>文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"system.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，使用<code>System.import</code>方法加载模块文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  System.import(<span class="string">'./app.js'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中的<code>./app</code>，指的是当前目录下的app.js文件。它可以是ES6模块文件，<code>System.import</code>会自动将其转码。</p><p>需要注意的是，<code>System.import</code>使用异步加载，返回一个Promise对象，可以针对这个对象编程。下面是一个模块文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/es6-file.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">q</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.es6 = <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在网页内加载这个模块文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  System.import(<span class="string">'app/es6-file'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">new</span> m.q().es6);     <span class="comment">// hello</span></span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>System.import</code>方法返回的是一个Promise对象，所以可以用<code>then</code>方法指定回调函数。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/module-loader">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中&lt;code&gt;Module&lt;/code&gt;的加载实现。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/module-loader&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(4) Module的语法</title>
    <link href="http://www.xiaoleon.cn/2018/05/18/es6-4/"/>
    <id>http://www.xiaoleon.cn/2018/05/18/es6-4/</id>
    <published>2018-05-18T13:59:58.000Z</published>
    <updated>2018-05-19T06:29:45.313Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中<code>Module</code>的语法及使用方法。节选自<a href="(http://es6.ruanyifeng.com/#docs/module">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>历史上，JavaScript一直没有模块（module）体系，无法讲一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的<code>require</code>、Python的<code>import</code>，甚至就连CSS都有<code>@import</code>，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123;stat, exists, readfile&#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取3个方法。这种加载成为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p><p>ES6模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;stat, exists, readfile&#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure><p>上面代码的实质是从<code>fs</code>模块加载了3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即ES6可以再编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。</p><p>由于ES6模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽JavaScript的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p><p>除了静态加载带来的各种好处，ES6模块还有以下好处。</p><ul><li><p>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这一点。</p></li><li><p>将来浏览器的新API就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</p></li><li><p>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</p></li></ul><hr><h3 id="二、严格模式"><a href="#二、严格模式" class="headerlink" title="二、严格模式"></a>二、严格模式</h3><p>ES6的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p><p>严格模式主要有以下限制：</p><ul><li><p>变量必须声明后再使用</p></li><li><p>函数的参数不能有同名属性，否则报错</p></li><li><p>不能使用<code>with</code>语句</p></li><li><p>不能对只读属性赋值，否则报错</p></li><li><p>不能使用前缀<code>0</code>表示八进制数，否则报错</p></li><li><p>不能删除不可删除的属性，否则报错</p></li><li><p>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></p></li><li><p><code>eval</code>不会在它的外层作用域引入变量</p></li><li><p><code>eval</code>和<code>arguments</code>不能被重新赋值</p></li><li><p><code>arguments</code>不会自动反映函数参数的变化</p></li><li><p>不能使用<code>arguments.callee</code></p></li><li><p>不能使用<code>arguments.caller</code></p></li><li><p>禁止<code>this</code>指向全局对象</p></li><li><p>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</p></li><li><p>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</p></li></ul><p>上面这些限制，模块都必须遵守。由于严格模式是ES5引入的，不属于ES6，所以请参阅相关ES5书籍。</p><p>其中，尤其需要注意<code>this</code>的限制。ES6模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code>。</p><hr><h3 id="三、export命令"><a href="#三、export命令" class="headerlink" title="三、export命令"></a>三、export命令</h3><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个JS文件，里面使用<code>export</code>命令输出变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br></pre></td></tr></table></figure><p>上面的代码是<code>profile.js</code>文件，保存了用户信息。ES6将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p><p><code>export</code>的写法，除了像上面这样，还有另外一种。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在<code>var</code>语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p><p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码对外输出一个函数<code>multiply</code>。</p><p>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p><p>需要特别注意的是，<code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> m;</span><br></pre></td></tr></table></figure><p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量<code>m</code>，还是直接输出1。<code>1</code>只是一个值，不是接口。正确地写法是下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br></pre></td></tr></table></figure><p>上面三种写法都是正确的，规定了对外的接口<code>m</code>。其他脚本可以通过这个接口，取到值<code>1</code>。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p><p>同样的，<code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;f&#125;;</span><br></pre></td></tr></table></figure><p>另外，<code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500毫秒之后变成<code>baz</code>。</p><p>这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新。</p><p>最后，<code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'bar'</span>      <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>上面代码中，<code>export</code>语法放在函数之中，结果报错。</p><hr><h3 id="四、import命令"><a href="#四、import命令" class="headerlink" title="四、import命令"></a>四、import命令</h3><p>使用<code>export</code>命令定义了模块的对外接口以后，其他JS文件就可以通过<code>import</code>命令加载这个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  element.textContent = firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<code>import</code>命令，用于加载<code>profile.js</code>文件，并从中输入变量。<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p><p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;lastName <span class="keyword">as</span> surname&#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br></pre></td></tr></table></figure><p><code>import</code>命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在家在模块的脚本里面，改写接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./xxx.js'</span>;</span><br><span class="line"></span><br><span class="line">a = &#123;&#125;;           <span class="comment">// Syntax Error: 'a' is read-only</span></span><br></pre></td></tr></table></figure><p>上面代码中，脚本加载了变量<code>a</code>，对其重新赋值就会报错，因为<code>a</code>是一个只读的接口。但是，如果<code>a</code>是一个对象，改写<code>a</code>的属性是允许的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./xxx.js'</span>;</span><br><span class="line"></span><br><span class="line">a.foo = <span class="string">'hello'</span>;      <span class="comment">// 合法操作</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a</code>的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当做完全只读，轻易不要改变它的属性。</p><p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径，<code>.js</code>后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉JavaScript引擎该模块的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;myMethod&#125; <span class="keyword">from</span> <span class="string">'util'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>util</code>是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p><p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure><p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</p><p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="string">'f'</span> + <span class="string">'oo'</span>&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'module1'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'module2'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种写法都会报错，因为它们用到了表达式、变量和<code>if</code>结构。在静态分析阶段，这些语法都是没法得到值的。</p><p>最后，<code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure><p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p><p>如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure><p>上面代码加载了两次<code>lodash</code>，但是只会执行一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，虽然<code>foo</code>和<code>bar</code>在两个语句中加载，但是它们对应的是同一个<code>my_module</code>实例。也就是说，<code>import</code>语句是Singleton模式。</p><p>目前阶段，通过Babel转码，CommonJS模块的<code>require</code>命令和ES6模块的<code>import</code>命令，可以写在同一个模块里面，但是最好不要这么做。因为<code>import</code>在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/modules/es6.symbol'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/modules/es6.promise'</span>);</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'React'</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="五、模块的整体加载"><a href="#五、模块的整体加载" class="headerlink" title="五、模块的整体加载"></a>五、模块的整体加载</h3><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p><p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，加载这个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;area, circumference&#125; <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure><p>上面写法是逐一指定要加载的方法，整体加载的写法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + circle.area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circle.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure><p>注意，模块整体加载所在的那个对象（上例是<code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两行都是不允许的</span></span><br><span class="line">circle.foo = <span class="string">'hello'</span>;</span><br><span class="line">circle.area = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="六、export-default命令"><a href="#六、export-default命令" class="headerlink" title="六、export default命令"></a>六、export default命令</h3><p>从前面的例子可以看出，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p><p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p><p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line">customName();     <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p><p><code>export default</code>命令用在非匿名函数前，也是可以的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者写成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>foo</code>函数的函数名<code>foo</code>，在模块外部是无效的。加载的时候，视同匿名函数加载。</p><p>下面比较一下默认输出和正常输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一组</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">'crc32'</span>;          <span class="comment">// 输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二组</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123;           <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;crc32&#125; <span class="keyword">from</span> <span class="string">'crc32'</span>;        <span class="comment">// 输入</span></span><br></pre></td></tr></table></figure><p>上面代码的两组写法，第一组是使用<code>export default</code>的，对应的<code>import</code>语句不需要使用大括号；第二组是不使用<code>export default</code>的，对应的<code>import</code>语句需要使用大括号。</p><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，<code>import</code>命令后面不用加大括号，因为只可能唯一对应<code>export default</code>命令。</p><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> foo&#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// import foo from 'modules';</span></span><br></pre></td></tr></table></figure><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>export default a</code>的含义是将变量<code>a</code>的值赋给变量<code>default</code>。所以，最后一种写法会报错。</p><p>同样的，因为<code>export default</code>命令的本质是将后面的值，赋给<code>default</code>变量，所以可以直接将一个值写在<code>export default</code>之后。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为<code>default</code>。</p><p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入<code>lodash</code>模块为例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure><p>如果想在一条<code>import</code>语句中，同时输入默认方法和其他接口，可以写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _, &#123;each, each <span class="keyword">as</span> forEach&#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure><p>对应上面代码的<code>export</code>语句如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;each <span class="keyword">as</span> forEach&#125;;</span><br></pre></td></tr></table></figure><p>上面代码和最后一行的意思是，暴露出<code>forEach</code>接口，默认指向<code>each</code>接口，即<code>forEach</code>和<code>each</code>指向同一个方法。</p><p><code>export default</code>也可以用来输出类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'MyClass'</span>;</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> MyClass();</span><br></pre></td></tr></table></figure><hr><h3 id="七、export与import的复合写法"><a href="#七、export与import的复合写法" class="headerlink" title="七、export与import的复合写法"></a>七、export与import的复合写法</h3><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;foo, bar&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>export</code>和<code>import</code>语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，<code>foo</code>和<code>bar</code>实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用<code>foo</code>和<code>bar</code>。</p><p>模块的接口改名和整体输出，也可以采用这种写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口改名</span></span><br><span class="line"><span class="keyword">export</span> &#123;foo <span class="keyword">as</span> myFoo&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体输出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure><p>默认接口的写法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span>&#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br></pre></td></tr></table></figure><p>具名接口改为默认接口的写法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;es6 <span class="keyword">as</span> <span class="keyword">default</span>&#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123;es6&#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br></pre></td></tr></table></figure><p>同样的，默认接口也可以改名为具名接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> es6&#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br></pre></td></tr></table></figure><p>下面三种<code>import</code>语句，没有对应的复合写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">from</span> someIdentifier <span class="keyword">from</span> <span class="string">'someModule'</span>;</span><br><span class="line"><span class="keyword">import</span> someIdentifier <span class="keyword">from</span> <span class="string">'someModule'</span>;</span><br><span class="line"><span class="keyword">import</span> someIdentifier, &#123;namedIdentifier&#125; <span class="keyword">from</span> <span class="string">'someModule'</span>;</span><br></pre></td></tr></table></figure><p>为了做到形式的对称，现在有提案，提出补上这三种复合写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> someIdentifier <span class="keyword">from</span> <span class="string">'someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> someIdentifier <span class="keyword">from</span> <span class="string">'someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> someIdentifier, &#123;namedIdentifier&#125; <span class="keyword">from</span> <span class="string">'someModule'</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="八、模块的继承"><a href="#八、模块的继承" class="headerlink" title="八、模块的继承"></a>八、模块的继承</h3><p>模块之间也可以继承。</p><p>假设有一个<code>circleplus</code>模块，继承了<code>circle</code>模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71827182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>export *</code>，表示再输出<code>circle</code>模块的所有属性和方法。注意，<code>export *</code>命令会忽略<code>circle</code>模块的<code>default</code>方法。然后，上面代码又输出了自定义的<code>e</code>变量和默认方法。</p><p>这时，也可以将<code>circle</code>的属性或方法，改名后再输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line"><span class="keyword">export</span> &#123;area <span class="keyword">as</span> circleArea&#125; <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br></pre></td></tr></table></figure><p>上面代码表示，只输出<code>circle</code>模块的<code>area</code>方法，且将其改名为<code>circleArea</code>。</p><p>加载上面模块的写法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">'circleplus'</span>;</span><br><span class="line"><span class="keyword">import</span> exp <span class="keyword">from</span> <span class="string">'circleplus'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exp(math.e));</span><br></pre></td></tr></table></figure><p>上面代码中的<code>import exp</code>表示，将<code>circleplus</code>模块的默认方法加载为<code>exp</code>方法。</p><hr><h3 id="九、跨模块常量"><a href="#九、跨模块常量" class="headerlink" title="九、跨模块常量"></a>九、跨模块常量</h3><p><code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.js 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> C = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.js 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(constants.A);       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(constants.B);       <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.js 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(A);                 <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(B);                 <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/db.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = &#123;</span><br><span class="line">  url: <span class="string">'http://my.couchdbserver.local:5984'</span>,</span><br><span class="line">  admin_username: <span class="string">'admin'</span>,</span><br><span class="line">  admin_password: <span class="string">'admin password'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constants/user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> users = [<span class="string">'root'</span>, <span class="string">'admin'</span>, <span class="string">'staff'</span>, <span class="string">'ceo'</span>, <span class="string">'chief'</span>, <span class="string">'moderator'</span>];</span><br></pre></td></tr></table></figure><p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/index.js</span></span><br><span class="line"><span class="keyword">export</span> &#123;db&#125; <span class="keyword">from</span> <span class="string">'./db'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;users&#125; <span class="keyword">from</span> <span class="string">'./users'</span>;</span><br></pre></td></tr></table></figure><p>使用的时候，直接加载<code>index.js</code>就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;db, users&#125; <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="十、import"><a href="#十、import" class="headerlink" title="十、import()"></a>十、import()</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p>前面介绍过，<code>import</code>命令会被JavaScript引擎静态分析，先于模块内的其他与句执行（<code>import</code>命令叫做“连接”）。所以，下面的代码会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> MyModule <span class="keyword">from</span> <span class="string">'./myModule'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报语法错误，而不是执行时错误。也就是说，<code>import</code>和<code>export</code>命令只能在模块的顶层，不能在代码块之中（比如，在<code>if</code>代码块之中，或在函数之中）。</p><p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代Node的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">'./'</span> + fileName;</span><br><span class="line"><span class="keyword">const</span> myModule = <span class="built_in">require</span>(path);</span><br></pre></td></tr></table></figure><p>上面的语句就是动态加载，<code>require</code>到底加载哪一个模块，只有运行时才知道。</p><p><code>import</code>命令做不到这一点。因此，有一个提案，建议引入<code>import()</code>函数，完成动态加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(specifier);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p><p><code>import()</code>返回一个Promise对象。下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">'main'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">`./section-modules/<span class="subst">$&#123;someVariable&#125;</span>.js`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.loadPageInfo(main);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    main.textContent = err.message;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于Node的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</p><h4 id="2-适用场合"><a href="#2-适用场合" class="headerlink" title="2. 适用场合"></a>2. 适用场合</h4><p>下面是<code>import()</code>的一些适用场合。</p><ul><li>1) 按需加载</li></ul><p><code>import()</code>可以在需要的时候，再加载某个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./dialogBox.js'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">dialogBox</span> =&gt;</span> &#123;</span><br><span class="line">      dialogBox.open();</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>import()</code>方法放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p><ul><li>2) 条件加载</li></ul><p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'moduleA'</span>).then(...);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'moduleB'</span>).then(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，如果满足条件，就加载模块A，否则加载模块B。</p><ul><li>3) 动态的模块路径</li></ul><p><code>import()</code>允许模块路径动态生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(f())</span><br><span class="line">  .then(...);</span><br></pre></td></tr></table></figure><p>上面代码中，根据函数<code>f()</code>的返回结果，加载不同的模块。</p><h4 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3. 注意点"></a>3. 注意点</h4><p><code>import()</code>加载模块成功以后，这个模块会作为一个对象，当作<code>then</code>方法的参数。因此，可以使用对象解构赋值的语句，获取输出接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./myModule.js'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123;export1, export2&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>export1</code>和<code>export2</code>都是<code>myModule.js</code>的输出接口，可以解构获得。</p><p>如果模块有<code>default</code>输出接口，可以用参数直接获得。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./myModule.js'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">myModule</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myModule.default);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面的代码也可以使用具名输入的形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./myModule.js'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>: theDefault&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(theDefault);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>如果想同时加载多个模块，可以采用下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./module1.js'</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./module2.js'</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./module3.js'</span>),</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[module1, module2, module3]</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>import()</code>也可以用在<code>async</code>函数之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> myModule = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./myModule.js'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;export1, export2&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./myModule.js'</span>);</span><br><span class="line">  <span class="keyword">const</span> [module1, module2, module3] = </span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">'./module1.js'</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">'./module2.js'</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">'./module3.js'</span>)</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/module">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中&lt;code&gt;Module&lt;/code&gt;的语法及使用方法。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/module&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(3) Iterator和for...of循环</title>
    <link href="http://www.xiaoleon.cn/2018/05/16/es6-3/"/>
    <id>http://www.xiaoleon.cn/2018/05/16/es6-3/</id>
    <published>2018-05-16T13:23:17.000Z</published>
    <updated>2018-06-10T14:38:43.324Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中<code>Iterator</code>遍历器和<code>for...of</code>循环方法。节选自<a href="(http://es6.ruanyifeng.com/#docs/iterator">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、Iterator（遍历器）的概念"><a href="#一、Iterator（遍历器）的概念" class="headerlink" title="一、Iterator（遍历器）的概念"></a>一、Iterator（遍历器）的概念</h3><p>JavaScript原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p><p>遍历器（<code>Iterator</code>）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署<code>Iterator</code>接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><p><code>Iterator</code>的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令<code>for...of</code>循环，<code>Iterator</code>接口主要供<code>for...of</code>消费。</p><p><code>Iterator</code>的遍历过程是这样的。</p><ul><li><p>1) 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p></li><li><p>2) 第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p></li><li><p>3) 第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p></li><li><p>4) 不断调用指针对象的<code>next</code>方法，知道它指向数据结构的结束位置。</p></li></ul><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p><p>下面是一个模拟<code>next</code>方法返回值的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"></span><br><span class="line">it.next()         <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line">it.next()         <span class="comment">// &#123;value: 'b', done: false&#125;</span></span><br><span class="line">it.next()         <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: arr[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个<code>makeIterator</code>函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组<code>[&#39;a&#39;, &#39;b&#39;]</code>执行这个函数，就会返回该数组的遍历器对象（即指针对象）<code>it</code>。</p><p>指针对象的<code>next</code>方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用<code>next</code>方法，指针就会指向数组的下一个成员。第一次调用，指向<code>a</code>；第二次调用，指向<code>b</code>。</p><p><code>next</code>方法返回一个对象，表示当前数据成员的信息。这个对象具有<code>value</code>和<code>done</code>两个属性，<code>value</code>属性返回当前位置的成员，<code>done</code>属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用<code>next</code>方法。</p><p>总之，调用指针对象的<code>next</code>方法，就可以遍历事先给定的数据结构。</p><p>对于遍历器对象来说，<code>done: false</code>和<code>value: undefined</code>属性都是可以省略的，因此上面的<code>makeIterator</code>函数可以简写成下面的形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++]&#125; :</span><br><span class="line">        &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>Iterator</code>只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = idMaker();</span><br><span class="line"></span><br><span class="line">it.next().value       <span class="comment">// 1</span></span><br><span class="line">it.next().value       <span class="comment">// 2</span></span><br><span class="line">it.next().value       <span class="comment">// 3</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">idMaker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>: index++, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，遍历器生成函数<code>idMaker</code>，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。</p><p>如果使用TypeScript的写法，遍历器接口（<code>Iterable</code>）、指针对象（<code>Iterator</code>）和<code>next</code>方法返回值的规格可以描述如下。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Iterable &#123;</span><br><span class="line">  [Symbol.iterator](): Iterator,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Iterator &#123;</span><br><span class="line">  next(value?: <span class="built_in">any</span>): IterationResult,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IterationResult &#123;</span><br><span class="line">  value: <span class="built_in">any</span>, done: <span class="built_in">boolean</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、默认Iterator接口"><a href="#二、默认Iterator接口" class="headerlink" title="二、默认Iterator接口"></a>二、默认Iterator接口</h3><p><code>Iterator</code>接口的目的，就是为所有的数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找<code>Iterator</code>接口。</p><p>一种数据结构只要部署了<code>Iterator</code>接口，我们就称这种数据结构是“可遍历的”（<code>iterable</code>）。</p><p>ES6规定，默认的<code>Iterator</code>接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（<code>iterable</code>）。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为<code>Symbol</code>的特殊值，所以要放在方括号内。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: <span class="number">1</span>,</span><br><span class="line">          done: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>是可遍历的（<code>iterable</code>），因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。</p><p>ES6的有些数据结构原生具备Iterator接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性，另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p><p>原生具备Iterator接口的数据结构如下：</p><ul><li><p>Array</p></li><li><p>Map</p></li><li><p>Set</p></li><li><p>String</p></li><li><p>TypedArray</p></li><li><p>函数的arguments对象</p></li><li><p>NodeList对象</p></li></ul><p>下面的例子是数组的<code>Symbol.iterator</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next()         <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line">iter.next()         <span class="comment">// &#123;value: 'b', done: false&#125;</span></span><br><span class="line">iter.next()         <span class="comment">// &#123;value: 'c', done: false&#125;</span></span><br><span class="line">iter.next()         <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>arr</code>是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以，调用这个属性，就得到遍历器对象。</p><p>对于原生部署Iterator接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的Iterator接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历。</p><p>对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当做Map接口使用，ES5没有Map结构，而ES6原生提供了。</p><p>一个对象如果要具备可被<code>for...of</code>循环调用的Iterator接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可以）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(start, stop) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = start;</span><br><span class="line">    <span class="keyword">this</span>.stop = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.stop) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value++;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, stop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> range(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);       <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个类部署Iterator接口的写法。<code>Symbol.iterator</code>属性对应一个函数，执行后返回当前对象的遍历器对象。</p><p>下面是通过遍历器实现指针结构的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Obj.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> iterator = &#123;<span class="attr">next</span>: next&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> current = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = current.value;</span><br><span class="line">      current = current.next;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> iterator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> one = <span class="keyword">new</span> Obj(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> two = <span class="keyword">new</span> Obj(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> three = <span class="keyword">new</span> Obj(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">one.next = two;</span><br><span class="line">two.next = three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> one) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);       <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码首先在构造函数的原型链上部署<code>Symbol.iterator</code>方法，调用该方法会返回遍历器对象<code>iterator</code>，调用该对象的<code>next</code>方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p><p>下面是为另一个对象添加Iterator接口的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  data: [<span class="string">'hello'</span>, <span class="string">'world'</span>],</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; self.data.length) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            value: self.data[index++],</span><br><span class="line">            done: <span class="literal">false</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于类似数组的对象（存在数值键名和<code>length</code>属性），部署Iterator接口，有一个简便方法，就是<code>Symbol.iterator</code>方法直接引用数组的Iterator接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = [][<span class="built_in">Symbol</span>.iterator];</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)] <span class="comment">// 可以执行了</span></span><br></pre></td></tr></table></figure><p>NodeList对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的<code>Symbol.iterator</code>属性，可以看到没有任何影响。</p><p>下面是另一个类似数组的对象调用数组的<code>Symbol.iterator</code>方法的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);      <span class="comment">// 'a', 'b', 'c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，普通对象部署数组的<code>Symbol.iterator</code>方法，并无效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  a: <span class="string">'a'</span>,</span><br><span class="line">  b: <span class="string">'b'</span>,</span><br><span class="line">  c: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);      <span class="comment">// undefined, undefined, undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="params">()</span> =&gt;</span> i;</span><br><span class="line"></span><br><span class="line">[...obj]        <span class="comment">// TypeError: [] is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>obj</code>的<code>Symbol.iterator</code>方法对应的不是遍历器生成函数，因此报错。</p><p>有了遍历器接口，数据结构就可以用<code>for...of</code>循环遍历，也可以使用<code>while</code>循环遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $iterator = ITERABLE[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">var</span> $result = $iterator.next();</span><br><span class="line"><span class="keyword">while</span>(!$result.done) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = $result.value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  $result = $iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>ITERABLE</code>代表某种可遍历的数据结构，<code>$iterator</code>是它的遍历器对象。遍历器对象每次移动指针（<code>next</code>方法），都检查一下返回值的<code>done</code>属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（<code>next</code>方法），不断循环。</p><hr><h3 id="三、调用Iterator接口的场合"><a href="#三、调用Iterator接口的场合" class="headerlink" title="三、调用Iterator接口的场合"></a>三、调用Iterator接口的场合</h3><p>有一些场合会默认调用Iterator接口（即<code>Symbol.iterator</code>方法），除了下文介绍的<code>for...of</code>循环，还有几个别的场合。</p><ul><li>1) 解构赋值</li></ul><p>对数组和Set结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">'a'</span>).add(<span class="string">'b'</span>).add(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y] = set;</span><br><span class="line"><span class="comment">// x='a'; y='b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, ...rest] = set;</span><br><span class="line"><span class="comment">// first='a'; rest=['b', 'c'];</span></span><br></pre></td></tr></table></figure><ul><li>2) 扩展运算符</li></ul><p>扩展运算符（<code>...</code>）也会调用默认的Iterator接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line">[...str]            <span class="comment">// ['h', 'e', 'l', 'l', 'o']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>]  <span class="comment">// ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure><p>上面代码的扩展运算符内部就调用Iterator接口。</p><p>实际上，这提供了一种简便机制，可以将任何部署了Iterator接口的数据结构，转为数组。也就是说，只要某个数据结构部署了Iterator接口，就可以对它使用扩展运算符，将其转为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure><ul><li>3) yield*</li></ul><p><code>yield*</code>后面跟的是一个可遍历的解构，它会调用该结构的遍历器接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next();            <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">iterator.next();            <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">iterator.next();            <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">iterator.next();            <span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line">iterator.next();            <span class="comment">// &#123;value: 5, done: false&#125;</span></span><br><span class="line">iterator.next();            <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><ul><li>4) 其他场合</li></ul><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p><ul><li><p><code>for...of</code></p></li><li><p><code>Array.from()</code></p></li><li><p><code>Map()</code>, <code>Set()</code>, <code>WeakMap()</code>, <code>WeakSet</code></p></li><li><p><code>Promise.all()</code></p></li><li><p><code>Promise.race()</code></p></li></ul><hr><h3 id="四、字符串的Iterator接口"><a href="#四、字符串的Iterator接口" class="headerlink" title="四、字符串的Iterator接口"></a>四、字符串的Iterator接口</h3><p>字符串是一个类似数组的对象，也原生具有Iterator接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">'hi'</span>;</span><br><span class="line"><span class="keyword">typeof</span> someString[<span class="built_in">Symbol</span>.iterator];</span><br><span class="line"><span class="comment">// 'function'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iterator.next()             <span class="comment">// &#123;value: 'h', done: false&#125;</span></span><br><span class="line">iterator.next()             <span class="comment">// &#123;value: 'i', done: false&#125;</span></span><br><span class="line">iterator.next()             <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>Symbol.iterator</code>方法返回一个遍历器对象，在这个遍历器上可以调用<code>next</code>方法，实现对于字符串的遍历。</p><p>可以覆盖原生的<code>Symbol.iterator</code>方法，达到修改遍历器行为的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hi'</span>);</span><br><span class="line"></span><br><span class="line">[...str]            <span class="comment">// ['h', 'i']</span></span><br><span class="line"></span><br><span class="line">str[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._first) &#123;</span><br><span class="line">                <span class="keyword">this</span>._first = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="string">'bye'</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        _first: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...str]            <span class="comment">// ['bye']</span></span><br><span class="line">str                 <span class="comment">// 'hi'</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串str的<code>Symbol.iterator</code>方法被修改了，所以扩展运算符（<code>...</code>）返回的值变成了<code>bye</code>，而字符串本身还是<code>hi</code>。</p><hr><h3 id="五、Iterator接口和Generator函数"><a href="#五、Iterator接口和Generator函数" class="headerlink" title="五、Iterator接口和Generator函数"></a>五、Iterator接口和Generator函数</h3><p><code>Symbol.iterator</code>方法的最简单实现，还是使用后面要介绍的Generator函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[...myIterable]             <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'hello'</span></span><br><span class="line"><span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Symbol.iterator</code>方法几乎不用部署任何代码，只要yield命令给出每一步的返回值即可。</p><hr><h3 id="六、遍历器对象的return-，throw"><a href="#六、遍历器对象的return-，throw" class="headerlink" title="六、遍历器对象的return()，throw()"></a>六、遍历器对象的return()，throw()</h3><p>遍历器对象除了具有<code>next</code>方法，还可以具有<code>return</code>方法和<code>throw</code>方法。如果我们自己写遍历器对象生成函数，那么<code>next</code>方法是必须部署的，<code>return</code>方法和<code>throw</code>方法是否部署是可选的。</p><p><code>return</code>方法的使用场合是，如果<code>for...of</code>循环提前退出（通常是因为报错，或者有<code>break</code>语句或<code>continue</code>语句），就会调用<code>return</code>方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLinesSync</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                next() () &#123;</span><br><span class="line">                    <span class="keyword">return</span>  &#123;<span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">return</span>() &#123;</span><br><span class="line">                    file.close();</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>readLinesSync</code>接受一个文件对象作为参数，返回一个遍历器对象，其中除了<code>next</code>方法，还部署了<code>return</code>方法。下面三种情况，都会触发执行<code>return</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(line);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(line);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(line);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，情况一输出文件的第一行后，就会执行<code>return</code>方法，关闭这个文件；情况二输出所有行以后，执行<code>return</code>方法，关闭该文件；情况三在执行<code>return</code>方法关闭文件之后，再抛出错误。</p><p>注意，<code>return</code>方法必须返回一个对象，这是Generator规格决定的。</p><p><code>throw</code>方法主要是配合Generator函数使用的，一般的遍历器对象用不到这个方法。</p><hr><h3 id="七、for…of循环"><a href="#七、for…of循环" class="headerlink" title="七、for…of循环"></a>七、for…of循环</h3><p>ES6借鉴C++、Java、C#和Python语言，引入了<code>for...of</code>循环，作为遍历所有数据结构的统一的方法。</p><p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有iterator接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p><p><code>for...of</code>循环可以使用的范围包括数组、Set和Map解构、某些类似数组的对象（比如<code>arguments</code>对象、Dom NodeList对象）、Generator对象，以及字符串。</p><h4 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h4><p>数组原生具备iterator接口（即默认部署了<code>Symbol.iterator</code>属性），<code>for...of</code>循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);         <span class="comment">// 'red', 'green', 'blue'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = arr[<span class="built_in">Symbol</span>.iterator].bind(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);         <span class="comment">// 'red', 'green', 'blue'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，空对象obj部署了数组arr的<code>Symbol.iterator</code>属性，结果obj的<code>for...of</code>循环，产生了与arr完全一样的结果。</p><p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element, index</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);       <span class="comment">// red green blue</span></span><br><span class="line">    <span class="built_in">console</span>.log(index);         <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>JavaScript原有的<code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。ES6提供<code>for...of</code>循环，允许遍历获得键值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);             <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);             <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法（参见ES6数组扩展）。</p><p><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);             <span class="comment">// '0', '1', '2', 'foo'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);             <span class="comment">// '3', '5', '7'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>for...of</code>循环不会返回数组arr的foo属性。</p><h4 id="2-Set和Map结构"><a href="#2-Set和Map结构" class="headerlink" title="2. Set和Map结构"></a>2. Set和Map结构</h4><p>Set和Map结构也原生具有Iterator接口，可以直接使用<code>for...of</code>循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'Gecko'</span>, <span class="string">'Trident'</span>, <span class="string">'Webkit'</span>, <span class="string">'Webkit'</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> engines) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Gecko</span></span><br><span class="line"><span class="comment">// Trident</span></span><br><span class="line"><span class="comment">// Webkit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> es6 = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">es6.set(<span class="string">'edition'</span>, <span class="number">6</span>);</span><br><span class="line">es6.set(<span class="string">'committee'</span>, <span class="string">'TC39'</span>);</span><br><span class="line">es6.set(<span class="string">'standard'</span>, <span class="string">'ECMA-262'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, value] <span class="keyword">of</span> es6) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name + <span class="string">': '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br></pre></td></tr></table></figure><p>上面代码演示了如何遍历Set结构和Map结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加仅数据结构的顺序。其次，Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别是当前Map成员的键名和键值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'a'</span>, <span class="number">1</span>).set(<span class="string">'b'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ['a', 1]</span></span><br><span class="line"><span class="comment">// ['b', 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">': '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a: 1</span></span><br><span class="line"><span class="comment">// b: 2</span></span><br></pre></td></tr></table></figure><h4 id="3-计算生成的数据结构"><a href="#3-计算生成的数据结构" class="headerlink" title="3. 计算生成的数据结构"></a>3. 计算生成的数据结构</h4><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6的数组、Set、Map都部署了以下三个方法，调用后都返回遍历器对象。</p><ul><li><p><code>entries()</code> 返回一个遍历器对象，用来遍历<code>[键名, 键值]</code>组成的数组。对于数组，键名就是索引值；对于Set，键名与键值相同。Map结构的Iterator接口，默认就是调用<code>entries</code>方法。</p></li><li><p><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</p></li><li><p><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</p></li></ul><p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure><h4 id="4-类似数组的对象"><a href="#4-类似数组的对象" class="headerlink" title="4. 类似数组的对象"></a>4. 类似数组的对象</h4><p>类似数组的对象包括好几类。下面是<code>for...of</code>循环用于字符串、DOM NodeList对象、<code>arguments</code>对象的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s);         <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList</span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">    p.classList.add(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printArgs(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br></pre></td></tr></table></figure><p>对于字符串来说，<code>for...of</code>循环还有一个特点，就是会正确识别32位UTF-16字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="string">'a\uD83D\uDC0A'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// '\uD83D\uDC0A'</span></span><br></pre></td></tr></table></figure><p>并不是所有类似数组的对象都具有Iterator接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">3</span>, <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">Array</span>.from(arrayLike)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-对象"><a href="#5-对象" class="headerlink" title="5. 对象"></a>5. 对象</h4><p>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了Iterator接口后才能使用。但是，这样情况下，<code>for...in</code>循环依然可以用来遍历键名，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> es6 = &#123;</span><br><span class="line">    edition: <span class="number">6</span>,</span><br><span class="line">    committee: <span class="string">'TC39'</span>,</span><br><span class="line">    standard: <span class="string">'ECMA-262'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">in</span> es6) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition</span></span><br><span class="line"><span class="comment">// committee</span></span><br><span class="line"><span class="comment">// standard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> es6) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TypeError: es6[Symbol.iterator] is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码表示，对于普通的对象，<code>for...in</code>循环可以遍历键名，<code>for...of</code>循环会报错。</p><p>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(someObject)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">': '</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种解决方法是，使用Generator函数将对象重新包装一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, <span class="string">'-&gt;'</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure><h4 id="6-与其他遍历语法的比较"><a href="#6-与其他遍历语法的比较" class="headerlink" title="6. 与其他遍历语法的比较"></a>6. 与其他遍历语法的比较</h4><p>以数组为例，JavaScript提供多种遍历语法，最原始的写法就是<code>for</code>循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; array.length; index++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(array[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法比较麻烦，因此数组提供内置的<code>forEach</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种写法的问题在于，无法中途跳出<code>forEach</code>循环，<code>break</code>命令或<code>return</code>命令都不能奏效。</p><p><code>for...in</code>循环可以遍历数组的键名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for...in</code>循环有几个缺点：</p><ul><li><p>数组的键名是数字，但是<code>for...in</code>循环是以字符串作为键名，“0”、“1”、“2”等等。</p></li><li><p><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</p></li><li><p>某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</p></li></ul><p>总之，<code>for...in</code>循环主要是为遍历对象而设计的，不适用于遍历数组。</p><p><code>for...of</code>循环相比上面几种做法，有一些显著的优点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点。</p></li><li><p>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用。</p></li><li><p>提供了遍历所有数据结构的统一操作接口。</p></li></ul><p>下面是一个使用<code>break</code>语句，跳出<code>for...of</code>循环的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子，会输出斐波那契数列小于等于1000的项。如果当前项大于1000，就会使用<code>break</code>语句跳出<code>for...of</code>循环。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="(http://es6.ruanyifeng.com/#docs/iterator">《ESMAScript 6 入门 —— 阮一峰》</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中&lt;code&gt;Iterator&lt;/code&gt;遍历器和&lt;code&gt;for...of&lt;/code&gt;循环方法。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/iterator&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(2) 解构赋值</title>
    <link href="http://www.xiaoleon.cn/2018/05/16/es6-2/"/>
    <id>http://www.xiaoleon.cn/2018/05/16/es6-2/</id>
    <published>2018-05-15T23:58:11.000Z</published>
    <updated>2018-05-16T13:22:30.227Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中添加的解构赋值。节选自<a href="(http://es6.ruanyifeng.com/#docs/destructuring">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、数组的解构赋值"><a href="#一、数组的解构赋值" class="headerlink" title="一、数组的解构赋值"></a>一、数组的解构赋值</h3><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>以前，为变量赋值，只能直接指定值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>ES6允许写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo                 <span class="comment">// 1</span></span><br><span class="line">bar                 <span class="comment">// 2</span></span><br><span class="line">baz                 <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>];</span><br><span class="line">third               <span class="comment">// 'baz'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x                   <span class="comment">// 1</span></span><br><span class="line">y                   <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head                <span class="comment">// 1</span></span><br><span class="line">tail                <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x                   <span class="comment">// 'a'</span></span><br><span class="line">y                   <span class="comment">// undefined</span></span><br><span class="line">z                   <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果结构不成功，变量的值就等于<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = [];</span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [];</span><br></pre></td></tr></table></figure><p>以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code>。</p><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x                   <span class="comment">// 1</span></span><br><span class="line">y                   <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a                   <span class="comment">// 1</span></span><br><span class="line">b                   <span class="comment">// 2</span></span><br><span class="line">d                   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>上面两个例子，都属于不完全解构，但是可以成功。</p><p>如果等号的右边不是数组（或者严格地说，不是可遍历的解构），那么将会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备<code>Iterator</code>接口（前五个表达式），要么本身就不具备<code>Iterator</code>接口（最后一个表达式）。</p><p>对于<code>Set</code>解构，也可以使用数组的解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">x                   <span class="comment">// 'a'</span></span><br></pre></td></tr></table></figure><p>事实上，只要某种数据结构具有<code>Iterator</code>接口，都可以采用数组形式的解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth               <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>fibs</code>是一个<code>Generator</code>函数，原生具有<code>Iterator</code>接口。解构赋值会依次从这个接口获取值。</p><h4 id="2-默认值"><a href="#2-默认值" class="headerlink" title="2. 默认值"></a>2. 默认值</h4><p>解构赋值允许指定默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo                 <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>];       <span class="comment">// x='a', y='b'</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>];        <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure><p>注意，ES6内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x                   <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x                   <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>上面代码中，因为<code>x</code>能取到值，所以函数<code>f</code>根本不会执行。上面代码其实等价于下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x = [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值可以引用解构赋值的其他变量，但是该变量必须已经声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];            <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];           <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>];        <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];            <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure><p>上面最后一个表达式之所以会报错，是因为<code>x</code>用<code>y</code>做默认值时，<code>y</code>还没有声明。</p><hr><h3 id="二、对象的解构赋值"><a href="#二、对象的解构赋值" class="headerlink" title="二、对象的解构赋值"></a>二、对象的解构赋值</h3><p>解构不仅可以用于数组，还可以用于对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">foo             <span class="comment">// 'aaa'</span></span><br><span class="line">bar             <span class="comment">// 'bbb'</span></span><br></pre></td></tr></table></figure><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">foo             <span class="comment">// 'aaa'</span></span><br><span class="line">bar             <span class="comment">// 'bbb'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz             <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。</p><p>如果变量名与属性名不一致，必须写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz             <span class="comment">// aaa</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">'hello'</span>, <span class="attr">last</span>: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l&#125; = obj;</span><br><span class="line">f               <span class="comment">// 'hello'</span></span><br><span class="line">l               <span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure><p>这实际上说明，对象的解构赋值是下面形式的简写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar&#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span>&#125;</span><br></pre></td></tr></table></figure><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz             <span class="comment">// 'aaa'</span></span><br><span class="line">foo             <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p><p>与数组一样，解构也可以用于嵌套结构的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    p: [</span><br><span class="line">        <span class="string">'Hello'</span>,</span><br><span class="line">        &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x               <span class="comment">// 'Hello'</span></span><br><span class="line">y               <span class="comment">// 'World'</span></span><br></pre></td></tr></table></figure><p>注意，这时<code>p</code>是模式，不是变量，因此不会被赋值。如果<code>p</code>也要作为变量赋值，可以写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    p: [</span><br><span class="line">        <span class="string">'Hello'</span>,</span><br><span class="line">        &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x               <span class="comment">// 'Hello'</span></span><br><span class="line">y               <span class="comment">// 'World'</span></span><br><span class="line">p               <span class="comment">// ["Hello", &#123;y: 'World'&#125;]</span></span><br></pre></td></tr></table></figure><p>下面是另一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cosnt node = &#123;</span><br><span class="line">    loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">            line: <span class="number">1</span>,</span><br><span class="line">            column: <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125;&#125; = node;</span><br><span class="line">line            <span class="comment">// 1</span></span><br><span class="line">loc             <span class="comment">// Object &#123;start: Object&#125;</span></span><br><span class="line">start           <span class="comment">// Object &#123;line: 1, column: 5&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码有三次解构赋值，分别是对<code>loc</code>、<code>start</code>、<code>line</code>三个属性的解构赋值。注意，最后一次对<code>line</code>属性的解构赋值之中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不是变量。</p><p>下面是嵌套赋值的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; <span class="attr">foo</span>: obj.prop, <span class="attr">bar</span>: arr[<span class="number">0</span>] &#125;) = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">obj             <span class="comment">// &#123;prop: 123&#125;</span></span><br><span class="line">arr             <span class="comment">// [true]</span></span><br></pre></td></tr></table></figure><p>对象的解构也可以指定默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; x = <span class="number">3</span> &#125; = &#123;&#125;;</span><br><span class="line">x               <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; x, y = <span class="number">5</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>&#125;</span><br><span class="line">x               <span class="comment">// 1</span></span><br><span class="line">y               <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y               <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123; <span class="attr">x</span>: <span class="number">5</span> &#125;</span><br><span class="line">y               <span class="comment">// 5 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;</span><br><span class="line">msg             <span class="comment">// 'Something went wrong'</span></span><br></pre></td></tr></table></figure><p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  &#123; x = <span class="number">3</span> &#125; = &#123; <span class="attr">x</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">x               <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  &#123; x = <span class="number">3</span> &#125; = &#123; <span class="attr">x</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">x               <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码中，属性<code>x</code>等于<code>null</code>，因为<code>null</code>与<code>undefined</code>不严格相等，所以是个有效的赋值，导致默认值<code>3</code>不生效。</p><p>如果结构失败，变量的值等于<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;foo&#125; = &#123; <span class="attr">bar</span>: <span class="string">'baz'</span> &#125;;</span><br><span class="line">foo             <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: &#123; bar &#125; &#125; = &#123; <span class="attr">bar</span>: <span class="string">'baz'</span> &#125; ;</span><br></pre></td></tr></table></figure><p>上面代码中，等号左边对象的<code>foo</code>属性，对应一个子对象。该子对象的<code>bar</code>属性，解构时会报错。原因很简单，因为<code>foo</code>这时等于<code>undefined</code>，再取子属性就会报错，请看下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  _tmp = &#123; <span class="attr">baz</span>: <span class="string">'baz'</span> &#125;;</span><br><span class="line">_tmp.foo.bar        <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>上面代码的写法会报错，因为JavaScript引擎会将<code>{x}</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p><p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;log, sin, cos&#125; = <span class="built_in">Math</span>;</span><br></pre></td></tr></table></figure><p>上面代码将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span>: first, [arr.length - <span class="number">1</span>]: last&#125; = arr;</span><br><span class="line">first               <span class="comment">// 1</span></span><br><span class="line">last                <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码对数组进行对象解构。数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>键，对应的值是`3``。方括号这种写法，属于“属性名表达式”。</p><hr><h3 id="三、字符串的解构赋值"><a href="#三、字符串的解构赋值" class="headerlink" title="三、字符串的解构赋值"></a>三、字符串的解构赋值</h3><p>字符串也可以解构赋值，这是因为此时，字符串被转换成了一个类似数组的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a               <span class="comment">// 'h'</span></span><br><span class="line">b               <span class="comment">// 'e'</span></span><br><span class="line">c               <span class="comment">// 'l'</span></span><br><span class="line">d               <span class="comment">// 'l'</span></span><br><span class="line">e               <span class="comment">// 'o'</span></span><br></pre></td></tr></table></figure><p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span>: len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len             <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、数值和布尔值的解构赋值"><a href="#四、数值和布尔值的解构赋值" class="headerlink" title="四、数值和布尔值的解构赋值"></a>四、数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值或布尔值，则会先转为对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString;    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString;   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p><p>解构赋值的意思是，只要等号右边的值不是对象或数组，就先将其转换为对象。由于<code>undefined</code>和<code>null</code>无法转换为对象，所以对它们进行解构赋值，都会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">prop</span>: x&#125; = <span class="literal">undefined</span>;          <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">prop</span>: y&#125; = <span class="literal">null</span>;               <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><hr><h3 id="五、函数参数的解构赋值"><a href="#五、函数参数的解构赋值" class="headerlink" title="五、函数参数的解构赋值"></a>五、函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]);            <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);        <span class="comment">// [3, 7]</span></span><br></pre></td></tr></table></figure><p>函数参数的解构也可以使用默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);         <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);               <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;);                   <span class="comment">// [0, 0]</span></span><br><span class="line">move();                     <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>move</code>的参数是一个对象，通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。</p><p>注意，下面的写法会得到不一样的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);         <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);               <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;);                   <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move();                     <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值，所以会得到与前一种写法不同的结果。</p><p><code>undefined</code>就会触发函数参数的默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">'yes'</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [1, 'yes', 3]</span></span><br></pre></td></tr></table></figure><hr><h3 id="六、圆括号问题"><a href="#六、圆括号问题" class="headerlink" title="六、圆括号问题"></a>六、圆括号问题</h3><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p><p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解析的歧义，就不得使用圆括号。</p><p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p><h4 id="1-不能使用圆括号的情况"><a href="#1-不能使用圆括号的情况" class="headerlink" title="1. 不能使用圆括号的情况"></a>1. 不能使用圆括号的情况</h4><p>以下三种解构赋值不得使用圆括号。</p><ul><li>1) 变量声明语句</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">o</span>: (&#123;<span class="attr">p</span>: p&#125;)&#125; = &#123;<span class="attr">o</span>: &#123;<span class="attr">p</span>: <span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>上面六个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p><ul><li>2) 函数参数</li></ul><p>函数参数也属于变量声明，因此不能带有圆括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z, (x</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br></pre></td></tr></table></figure><ul><li>3) 赋值语句的模式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123;<span class="attr">p</span>: a&#125;) = &#123;<span class="attr">p</span>: <span class="number">42</span>&#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>上面代码将整个模式放在圆括号之中，导致报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">[(&#123;<span class="attr">p</span>: a&#125;, &#123;<span class="attr">x</span>: c&#125;)] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><p>上面代码将一部分模式放在圆括号之中，导致报错。</p><h4 id="2-可以使用圆括号的情况"><a href="#2-可以使用圆括号的情况" class="headerlink" title="2. 可以使用圆括号的情况"></a>2. 可以使用圆括号的情况</h4><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>];</span><br><span class="line">(&#123;<span class="attr">p</span>: (d)&#125; = &#123;&#125;);</span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是<code>p</code>，而不是<code>d</code>；第三行语句与第一行语句的性质一致。</p><hr><h3 id="七、用途"><a href="#七、用途" class="headerlink" title="七、用途"></a>七、用途</h3><p>变量的解构赋值用途很多。</p><h4 id="1-交换变量的值"><a href="#1-交换变量的值" class="headerlink" title="1. 交换变量的值"></a>1. 交换变量的值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简介，而且易读，语义非常清晰。</p><h4 id="2-从函数返回多个值"><a href="#2-从函数返回多个值" class="headerlink" title="2. 从函数返回多个值"></a>2. 从函数返回多个值</h4><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        foo: <span class="number">1</span>,</span><br><span class="line">        bar: <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;foo, bar&#125; = example();</span><br></pre></td></tr></table></figure><h4 id="3-函数参数定义"><a href="#3-函数参数定义" class="headerlink" title="3. 函数参数定义"></a>3. 函数参数定义</h4><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123;...&#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123;...&#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-提取JSON数据"><a href="#4-提取JSON数据" class="headerlink" title="4. 提取JSON数据"></a>4. 提取JSON数据</h4><p>解构赋值对提取JSON对象中的数据，尤其有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">    id: <span class="number">42</span>,</span><br><span class="line">    status: <span class="string">'OK'</span>,</span><br><span class="line">    data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;id, status, <span class="attr">data</span>: number&#125; = jsonData;</span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);        <span class="comment">// 42, 'OK', [867, 5309]</span></span><br></pre></td></tr></table></figure><h4 id="5-函数参数的默认值"><a href="#5-函数参数的默认值" class="headerlink" title="5. 函数参数的默认值"></a>5. 函数参数的默认值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">    beforeSend = function(</span>) </span>&#123;&#125;,</span><br><span class="line">    cache = <span class="literal">true</span>,</span><br><span class="line">    complete = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    crossDomain = <span class="literal">false</span>,</span><br><span class="line">    global = <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;</code>这样的语句。</p><h4 id="6-遍历Map结构"><a href="#6-遍历Map结构" class="headerlink" title="6. 遍历Map结构"></a>6. 遍历Map结构</h4><p>任何部署了<code>Iterator</code>接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持<code>Iterator</code>接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">' is '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-输入模块的指定方法"><a href="#7-输入模块的指定方法" class="headerlink" title="7. 输入模块的指定方法"></a>7. 输入模块的指定方法</h4><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">'source-map'</span>);</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">《ESMAScript 6 入门 —— 阮一峰》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中添加的解构赋值。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/destructuring&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(1) let和const命令</title>
    <link href="http://www.xiaoleon.cn/2018/05/15/es6-1/"/>
    <id>http://www.xiaoleon.cn/2018/05/15/es6-1/</id>
    <published>2018-05-15T13:31:08.000Z</published>
    <updated>2018-05-16T13:22:30.217Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中添加的<code>let</code>和<code>const</code>指令。节选自<a href="(http://es6.ruanyifeng.com/#docs/let">《ESMAScript 6 入门 —— 阮一峰》</a>)</p><a id="more"></a><h3 id="一、let命令"><a href="#一、let命令" class="headerlink" title="一、let命令"></a>一、let命令</h3><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><p><code>let</code>命令用来声明变量，它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a       <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">b       <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量，然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p><p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);     <span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>];     <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面的代码中，使用<code>var</code>声明的变量<code>i</code>，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是10。</p><p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是6。</p><p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>上面代码运行正确，输出了3次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p><h4 id="2-不存在变量提升"><a href="#2-不存在变量提升" class="headerlink" title="2. 不存在变量提升"></a>2. 不存在变量提升</h4><p><code>var</code>命令会发生“变量提升”现象，即变量可以再声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p><p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明之后使用，否则报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);     <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar);     <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表明在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p><h4 id="3-暂时性死区"><a href="#3-暂时性死区" class="headerlink" title="3. 暂时性死区"></a>3. 暂时性死区</h4><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就绑定（binding）这个区域，不再受外部的影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>;      <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p><p>ES6明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，被称为“暂时性死区”（temporal dead zone, TDZ）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ start</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>;          <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp);     <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp;              <span class="comment">// TDZ end</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp);     <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);     <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p><p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x;         <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>x</code>使用<code>let</code>命令声明，所以在声明之前，都属于<code>x</code>的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个<code>ReferenceError</code>。</p><p>作为比较，如果一个变量根本没有声明，使用<code>typeof</code>反而不会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable;   <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><p>有些“死区”比较隐蔽，不太容易发现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();        <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>bar</code>函数之所以报错，是因为参数<code>x</code>默认值等于另一个参数<code>y</code>，而此时<code>y</code>还没有声明，属于“死区”。如果<code>y</code>的默认值是<code>x</code>，就不会报错，因为此时<code>x</code>已经声明了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = <span class="number">2</span>, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();        <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure><p>另外，下面的代码也会报错，与<code>var</code>的行为不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> x = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> x = x;</span><br></pre></td></tr></table></figure><p>上面代码报错，也是因为暂时性死区。使用<code>let</code>声明变量时，只要变量在还没有声明完成之前使用，就会报错。</p><p>ES6规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><h4 id="4-不允许重复声明"><a href="#4-不允许重复声明" class="headerlink" title="4. 不允许重复声明"></a>4. 不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，不能在函数内部重新声明参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg;    <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg;    <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、块级作用域"><a href="#二、块级作用域" class="headerlink" title="二、块级作用域"></a>二、块级作用域</h3><h4 id="1-为什么需要块级作用域"><a href="#1-为什么需要块级作用域" class="headerlink" title="1. 为什么需要块级作用域"></a>1. 为什么需要块级作用域</h4><p>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p><p>第一种场景，内层变量可能会覆盖外层变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">"hello world"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();        <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);       <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>只能用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><h4 id="2-ES6的块级作用域"><a href="#2-ES6的块级作用域" class="headerlink" title="2. ES6的块级作用域"></a>2. ES6的块级作用域</h4><p><code>let</code>实际上为JavaScript新增了块级作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n);     <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是10。</p><p>ES6允许块级作用域的任意嵌套。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;&#123;<span class="keyword">let</span> insane = <span class="string">'hello world'</span>&#125;&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>外层作用域无法读取内层作用域的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'hello world'</span>&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(insane);        <span class="comment">// 报错</span></span><br><span class="line">&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>内层作用域可以定义外层作用域的同名变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  <span class="keyword">let</span> insane = <span class="string">'hello world'</span>;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'hello world'</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-块级作用域与函数声明"><a href="#3-块级作用域与函数声明" class="headerlink" title="3. 块级作用域与函数声明"></a>3. 块级作用域与函数声明</h4><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p><p>ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种函数声明，根据ES5的规定都是非法的。</p><p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p><p>ES6引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>);&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>上面代码在ES5中运行，会得到<code>I am inside!</code>，因为<code>if</code>内声明的函数<code>f</code>会被提升到函数头部，实际运行的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>);&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>);&#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>ES6就完全不一样了，理论上会得到<code>I am outside!</code>。因为块级作用域内声明的函数类似于<code>let</code>，对作用域之外没有影响。但是，如果真的在ES6浏览器中运行，会报错。</p><p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p><ul><li><p>允许在块级作用域内声明函数</p></li><li><p>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部</p></li><li><p>同时，函数声明还会提升到所在的块级作用域的头部。</p></li></ul><p>注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作<code>let</code>处理。</p><p>根据这三条规则，在浏览器的ES6环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的ES6环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>);&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;())</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>上面的代码在ES6的浏览器中，都会报错，因为实际运行的是下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的ES6环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;consoel.log(<span class="string">'I am outside!'</span>);&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;())</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明语句</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、const命令"><a href="#三、const命令" class="headerlink" title="三、const命令"></a>三、const命令</h3><h4 id="1-基本用法-1"><a href="#1-基本用法-1" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">PI            <span class="comment">// 3.1415</span></span><br><span class="line"></span><br><span class="line">PI = <span class="number">3</span>;       <span class="comment">// TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo;      <span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(MAX);   <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">const</span> MAX = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两行都会报错</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">'Goodbye'</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h4 id="2-本质"><a href="#2-本质" class="headerlink" title="2. 本质"></a>2. 本质</h4><p><code>const</code>实际上保证的，并不是变量的值不得改变，而是变量指向的那个内存地址不得改变。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于符合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，<code>const</code>只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，讲一个对象声明为常量必须非常小心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为foo添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop            <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将foo指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;;           <span class="comment">// TypeError: "foo" is read-only</span></span><br></pre></td></tr></table></figure><p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>);      <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;         <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];         <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p><p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通模式下，下面一行不起作用</span></span><br><span class="line"><span class="comment">// 严格模式下，下面一行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">      constanize(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-ES6声明变量的六种方法"><a href="#3-ES6声明变量的六种方法" class="headerlink" title="3. ES6声明变量的六种方法"></a>3. ES6声明变量的六种方法</h4><p>ES5只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6除了添加<code>let</code>和<code>const</code>命令，还增加了两种方法：<code>import</code>和<code>class</code>。所以，ES6一共有6种声明变量的方法。</p><hr><h3 id="四、顶层对象的属性"><a href="#四、顶层对象的属性" class="headerlink" title="四、顶层对象的属性"></a>四、顶层对象的属性</h3><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在Node指的是<code>global</code>对象。ES5之中，顶层对象的属性与全局变量是等价的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a                 <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a          <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p><p>顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序猿很容易不知不觉就创建了全局变量；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在node的repl环境，可以写成global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成this.a</span></span><br><span class="line"><span class="built_in">window</span>.a      <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b      <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p><hr><h3 id="五、global对象"><a href="#五、global对象" class="headerlink" title="五、global对象"></a>五、global对象</h3><p>ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p><ul><li><p>浏览器里面，顶层对象是<code>window</code>，但Node和Web Worker没有<code>window</code></p></li><li><p>浏览器和Web Worker里面，<code>self</code>也指向顶层对象，但是Node没有<code>self</code></p></li><li><p>Node里面，顶层对象是<code>global</code>，但其他环境都不支持</p></li></ul><p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>变量，但是有局限性。</p><ul><li><p>全局环境中，<code>this</code>会返回顶层对象。但是，Node模块和ES6模块中，<code>this</code>返回的是当前模块</p></li><li><p>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code></p></li><li><p>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器使用了CSP（Content Security Policy，内容安全政策），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</p></li></ul><p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line">  ? <span class="built_in">window</span></span><br><span class="line">  : (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">     <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">     <span class="keyword">typeof</span> global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有一个提案，在语言标准的层面，引入<code>global</code>作为顶层对象。也就是说，在所有环境下，<code>global</code>都是存在的，都可以从它拿到顶层对象。</p><p>垫片库<code>system.global</code>模拟了这个提案，可以再所有环境拿到<code>global</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS的写法</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'system.global/shim'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6模块的写法</span></span><br><span class="line"><span class="keyword">import</span> shim <span class="keyword">from</span> <span class="string">'system.global'</span>;</span><br><span class="line">shim();</span><br></pre></td></tr></table></figure><p>上面代码可以保证各种环境里面，<code>global</code>对象都是存在的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS写法</span></span><br><span class="line"><span class="keyword">var</span> global = <span class="built_in">require</span>(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6模块写法</span></span><br><span class="line"><span class="keyword">import</span> getGlobal <span class="keyword">from</span> <span class="string">'system.global'</span>;</span><br><span class="line"><span class="keyword">const</span> global = getGlobal();</span><br></pre></td></tr></table></figure><p>上面代码将顶层对象放入变量<code>global</code>。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">《ESMAScript 6 入门 —— 阮一峰》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中添加的&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;指令。节选自&lt;a href=&quot;(http://es6.ruanyifeng.com/#docs/let&quot;&gt;《ESMAScript 6 入门 —— 阮一峰》&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>React(4) 模块化React和Redux应用</title>
    <link href="http://www.xiaoleon.cn/2018/03/13/react-4/"/>
    <id>http://www.xiaoleon.cn/2018/03/13/react-4/</id>
    <published>2018-03-13T15:02:05.000Z</published>
    <updated>2018-03-19T13:15:53.831Z</updated>
    
    <content type="html"><![CDATA[<p>在第一部分中，我们已经了解了React的基本工作方式，也知道了Redux在组合React组件中的作用，但是更多的只是了解其基本原理和使用方法，上手练习的也是一个简单的例子。</p><a id="more"></a><p>实际工作中我们要创建的应用无论结构和大小都要复杂得多，在这一章中，我们要介绍创建一个复杂一点的应用应该如何做，包含以下内容：</p><ul><li><p>模块化应用的要点</p></li><li><p>代码文件的组织方式</p></li><li><p>状态树的设计</p></li><li><p>开发辅助工具</p></li></ul><h3 id="一、模块化应用要点"><a href="#一、模块化应用要点" class="headerlink" title="一、模块化应用要点"></a>一、模块化应用要点</h3><p>在本书中，我们探讨的是如何用React和Redux来构建前端网页应用，这两者都奉行这样一个公式<code>UI=render(state)</code>来产生用户界面。React适合于视图层面的东西，但是不能指望靠React来管理应用的状态，Redux才适合担当应用状态的管理工作。</p><p>从架构出发，当我们开始一个新的应用的时候，有几件事情是一定要考虑清楚的：</p><ul><li><p>代码文件的组织结构</p></li><li><p>确定模块的边界</p></li><li><p>Store的状态树设计</p></li></ul><p>这三件事情，是构建一个应用的基础。如果我们在一开始深入思考这三件事，并做出合乎需要的判断，可以在后面的路上省去很多麻烦。</p><p>从本章开始，我们将构造一个“待办事项”（Todo）应用，逐步完善这个应用，增加新的功能，在这个Todo应用的进化过程中来学习各个层次的知识。</p><p>在这个各种JavaScript框架层出不穷的时代，Todo应用几乎就代替了传统Hello World应用的作用，每个框架问世的时候都会用一个Todo应用来展示自己的不同，不要小看了这样一个Todo应用，它非常适合用于做技术展示，首先，这个应用的复杂度刚刚好，没有复杂到可能要很多篇幅才能解释清楚做什么，也没有简单到只需要几行代码就能够搞定；其次，这样的功能非常利于理解，恰好能够考验一个JavaScript框架的表达能力。</p><p>确定了我们的应用要做什么之后，不要上来就开始写代码，磨刀不误砍柴工，先要思考上面提到的三个问题。让我们从第一个问题开始。</p><hr><h3 id="二、代码文件的组织方式"><a href="#二、代码文件的组织方式" class="headerlink" title="二、代码文件的组织方式"></a>二、代码文件的组织方式</h3><h4 id="1-按角色组织"><a href="#1-按角色组织" class="headerlink" title="1. 按角色组织"></a>1. 按角色组织</h4><p>如果读者之前曾用MVC框架开发过应用程序，应该知道MVC框架之下，通常有这样一种代码的组织方式，文件目录列表如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">controllers/</span><br><span class="line">  todoController.js</span><br><span class="line">  filterController.js</span><br><span class="line">models/</span><br><span class="line">  todoModel.js</span><br><span class="line">  filterModel.js</span><br><span class="line">views/</span><br><span class="line">  todo.js</span><br><span class="line">  todoItem.js</span><br><span class="line">  filter.js</span><br></pre></td></tr></table></figure><p>在MVC中，应用代码分为Controller、Model和View，分别代表三种模块角色，就是把所有的Controller代码放在controllers目录下，把所有的Model代码方法在models目录下，把View代码放在views目录下。这种组织代码的方式，叫做“按角色组织”（Organized by Roles）。</p><p>我们当然不会使用MVC，在上一章中我们介绍过MVC框架的缺点。和众多前端开发者一样，我们选择Flux和Redux就是为了克服这些缺点的，但是因为MVC框架的影响非常深远，一些风格依然影响了前端开发人员的思维方式。</p><p>因为MVC这种“按角色组织”代码文件的影响，在Redux应用的构建中，就有这样一种代码组织方法，文件目录列表如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">reducers/</span><br><span class="line">  todoReducer.js</span><br><span class="line">  filterReducer.js</span><br><span class="line">actions/</span><br><span class="line">  todoActions.js</span><br><span class="line">  filterActions.js</span><br><span class="line">components/</span><br><span class="line">  todoList.js</span><br><span class="line">  todoItem.js</span><br><span class="line">  filter.js</span><br><span class="line">containers/</span><br><span class="line">  todoListContainer.js</span><br><span class="line">  todoItemContainer.js</span><br><span class="line">  filterContainer.js</span><br></pre></td></tr></table></figure><p>和MVC的代码组织方式不同，只不过是把controller、models和views目录换成了reducers、actions、components和containers，各个目录下代码文件的角色如下：</p><ul><li><p>reducer目录包含所有Redux的reducer</p></li><li><p>actions目录包含所有action构造函数</p></li><li><p>components目录包含所有的傻瓜组件</p></li><li><p>containers目录包含所有的容器组件</p></li></ul><p>这种组织方式看起来还不错，把一个类型的代码文件放在了一个目录下，至少比把所有代码全放在一个目录下要有道理。</p><p>实际上，在前面章节的所有ControlPanel例子中，我们采用的也是类似的方法，当我们发现代码文件变多，全都直接放在一个src目录下不合理时，首先想到的就是建一个views目录，把所有视图相关的目录移到views目录里面去。我们没有移动action相关和reducer相关的文件，只因为ControlPanel应用实在太简单，因为只有一个组件Counter可能发出动作，所以只有一个Action文件，也只有一个对应的Reducer文件，所以到最后我们都没有觉得有必要把它们移动到代表各自角色的目录里面去。</p><p>有过MVC框架开发经历的朋友可以回忆一下，当你需要对一个功能进行修改，虽然这个功能只是针对某一个具体的应用模块，但是却牵扯到MVC中的三个角色Controller、Model和View，不管你用的是什么样的编辑器，你都得费点劲才能在这三个目录之间跳转，或者需要滚动文件列表跳过无关的分发器文件才能找到你想要修改的那一个分发器文件。</p><p>如果说MVC框架下，因为三个角色之间的交叉关系，也只能默默接受，那么在Redux框架下，我们已经有机会实现严格模块化的思想，就应该想一想更好的组织文件的方式。</p><h4 id="2-按功能组织"><a href="#2-按功能组织" class="headerlink" title="2. 按功能组织"></a>2. 按功能组织</h4><p>Redux应用适合于“按功能组织”（Organzied by Feature），也就是完成同一应用功能的代码放在一个目录下，一个应用功能包含多个角色的代码。在Redux中，不同的角色就是reducer、actions和视图，而应用功能对应的就是用户界面上的交互模块。</p><p>拿Todo应用为例子，这个应用的两个基本功能就是TodoList和Filter，所以代码就这样组织，文件目录列表如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">todoList/</span><br><span class="line">  actions.js</span><br><span class="line">  actionTypes.js</span><br><span class="line">  index.js</span><br><span class="line">  reducer.js</span><br><span class="line">  views/</span><br><span class="line">    component.js</span><br><span class="line">    container.js</span><br><span class="line">filter/</span><br><span class="line">  actions.js</span><br><span class="line">  actionTypes.js</span><br><span class="line">  index.js</span><br><span class="line">  reducer.js</span><br><span class="line">  views/</span><br><span class="line">    component.js</span><br><span class="line">    container.js</span><br></pre></td></tr></table></figure><p>每个基本功能对应的其实就是一个模块，每个功能模块对应一个目录，这个例子中分别是todoList和filter，每个目录下包含同样名字的角色文件：</p><ul><li><p>actionTypes.js 定义action类型</p></li><li><p>actions.js 定义action构造函数，决定了这个功能模块可以接受的动作</p></li><li><p>reducer.js 定义这个功能模块如何响应actions.js中定义的动作</p></li><li><p>views目录，包含这个功能模块中所有的React组件，包括傻瓜组件和容器组件</p></li><li><p>index.js 这个文件把所有的角色导入，然后统一导出</p></li></ul><p>在这种组织方式下，当我们要修改某个功能模块的代码的时候，只要关注对应的目录就行了，所有需要修改的代码文件都能在这个目录下找到。</p><p>表面上看，“按照角色组织”还是“按照功能组织”只是一个审美的问题，也许你觉得自己已经习惯了MVC世界的“按照角色组织”方式，也许你已经有一套很厉害的代码编辑器可以完美解决在不同目录下寻找代码文件困难的问题。但是，开发Redux应用你依然应该用“按照功能组织”的方式，为什么呢？我们看看下一条“确定模块的边界”就明白了。</p><hr><h3 id="三、模块接口"><a href="#三、模块接口" class="headerlink" title="三、模块接口"></a>三、模块接口</h3><p>不同功能模块之间的依赖关系应该简单而且清晰，也就是所谓的保持模块之间低耦合性；一个模块应该把自己的功能封装得很好，让外界不要太依赖与自己内部的结构，这样不会因为内部变化而影响外部模块的功能，这就是所谓高内聚性。</p><p>React组件本身应该具有低耦合性和高内聚性的特点，不过在Redux的游乐场中，React组件扮演的就是一个视图的角色，还有reducer、actions这些角色参与这个游戏。对于整个Redux应用而言，整体由模块构成，但是模块不再是React组件，而是由React组件加上关于reducer和actions构成的小整体。</p><p>以我们将要实现的Todo应用为例，功能模块就是todoList和filter，这两个功能模块分别用各自的React组件、reducer和action定义。</p><p>可以预期每个模块之间会有依赖关系，比如filter模块想要使用todoList的action构造函数和视图，那么我们希望对方如何导入呢？一种写法是像下面的代码这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'../todoList/actions'</span>;</span><br><span class="line"><span class="keyword">import</span> container <span class="keyword">as</span> TodoList <span class="keyword">from</span> <span class="string">'../todoList/views/container'</span>;</span><br></pre></td></tr></table></figure><p>这种写法当然能够完成功能，但是却非常不合理，因为这让filter模块依赖于todoList模块的内部结构，而且直接伸手到todoList内部去导入想要的部分。</p><p>虽然我们在上面的例子中，todoList和filter中的文件名几乎一样，但是这毕竟是模块内部的事情，不应该硬性要求，更不应该假设所有的模块都应该按照这样的文件命名。在我们的例子中，存储视图代码文件的目录叫做views，但是有的开发者习惯把这个目录叫做components；我们把包含容器组件的文件名叫做container.js，根据开发者个人习惯也可能叫做TodoList，这些都没有必要而且也不应该有硬性规定。</p><p>现在既然我们把一个目录看作一个模块，那么我们要做的是明确这个模块对外的接口，而这个接口应该实现把内部封装起来。</p><p>请注意我们的todoList和filter模块目录下，都有一个index.js文件，这个文件就是我们的模块接口。</p><p>比如，在todoList/index.js中，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions.js'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer.js'</span>;</span><br><span class="line"><span class="keyword">import</span> view <span class="keyword">from</span> <span class="string">'./views/container.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;actions, reducer, view&#125;;</span><br></pre></td></tr></table></figure><p>如果filter中的组件想要使用todoList中的功能，应该导入todoList这个目录，因为导入一个目录的时候，默认导入的就是这个目录下的index.js文件，index.js文件中导出的内容，就是这个模块想要公开出来的接口。</p><blockquote><p>注意：虽然每个模块目录下都会有一个actionTypes.js文件定义action类型，但是通常不会把actionTypes中内容作为模块的接口之一导出，因为action类型只有两个部分依赖，一个是reducer，一个是action构造函数，而且只有当前模块的reducer和action构造函数才会直接使用action类型。模块之外，不会关心这个模块的action类型，如果模块之外要使用这个模块的动作，也只需要直接使用action构造函数就行。</p></blockquote><p>下面就是对应的导入todoList的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;actions, reducer, view <span class="keyword">as</span> TodoList&#125; <span class="keyword">from</span>  <span class="string">'../todoList'</span>;</span><br></pre></td></tr></table></figure><p>当我们想要修改todoList的内部代码结构，比如把views目录改名为components目录，或者把container.js改名为TodoListView.js时，所要做的只是修改todoList目录下的index.js内容，而这个文件export出来的内容不会有任何改变，也就是说对导入todoList的代码不用任何改变。这就是我们确定模块边界想要达到的目的。</p><p>还有一种导出模块接口的方式，是不以命名式export的方式导出模块接口，而是以export default的方式默认导出，就像这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions.js'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer.js'</span>;</span><br><span class="line"><span class="keyword">import</span> view <span class="keyword">from</span> <span class="string">'./views/container.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;actions, reducer, view&#125;</span><br></pre></td></tr></table></figure><p>如果像上面这样导出，那么导入时的代码会有一点区别，因为ES6语法中，export default和export两种导出方式的导入方式也会不同，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TodoListComponent <span class="keyword">from</span> <span class="string">'./actions.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = TodoListComponent.reducer;</span><br><span class="line"><span class="keyword">const</span> actions = TodoListComponent.actions;</span><br><span class="line"><span class="keyword">const</span> TodoList = TodoListComponent.view;</span><br></pre></td></tr></table></figure><p>无论使用哪种导出方式，都请在整个应用中只用一中模块导出方式，保持一致，避免混乱。</p><p>在本书中，全部使用export的方式，因为从上面的代码看得出来，如果使用export default的方式，在导入的时候不可避免要使用多行代码才能得到actions、reducer和view，而用导入命名式export只用一行就可以搞定，相对而言要更加简洁。</p><p>读者可能注意到了，上面接口代码中导入actions的语句和导入view和reducer不一样，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions.js'</span>;</span><br></pre></td></tr></table></figure><p>我们预期actions.js中是按照命名式export，原因和上面陈述的一样，actions.js可能会导出很多action构造函数，命名式导出是为了导入actions方便。对于view和reducer，一个功能模块绝对只有一个根视图模块，一个功能模块也只应该有一个导出的reducer，所以它们两个在各自代码文件中是以默认方式导出的。</p><hr><h3 id="四、状态树的设计"><a href="#四、状态树的设计" class="headerlink" title="四、状态树的设计"></a>四、状态树的设计</h3><p>上面说的“代码文件组织结构”和“确定模块的边界”更多的只是确定规矩，然后在每个应用中我们只要都遵循这个规矩就足够了，而要注意的第三点“Store上状态树的设计”，更像是一门技术，需要我们动一动脑子。</p><p>因为所有的状态都存在Store上，Store的状态树设计，直接决定了要写哪些reducer，还有action怎么写，所以是程序逻辑的源头。</p><p>我们认为状态树设计要遵循如下几个原则：</p><ul><li><p>一个模块控制一个状态节点</p></li><li><p>避免冗余数据</p></li><li><p>树形结构扁平</p></li></ul><h4 id="1-一个状态节点只属于一个模块"><a href="#1-一个状态节点只属于一个模块" class="headerlink" title="1. 一个状态节点只属于一个模块"></a>1. 一个状态节点只属于一个模块</h4><p>这个规则与其说是规则，不如说是Redux中模块必须遵守的限制，完全无法无视这个限制。</p><p>在Redux应用中，Store上的每个state都只能通过reducer来更改，而我们每个模块都有机会导出自己的reducer，这个导出的reducer只能最多更改Redux的状态树上一个节点下的数据，因为reducer之间对状态树上的修改权是互斥的，不可能让两个reducer都可以修改同一个状态树上的节点。</p><p>比如，如果A模块的reducer负责修改状态树上a字段下的数据，那么另一个模块B的reducer就不可能有机会修改a字段下的数据。</p><p>这里所说的“拥有权”指的是“修改权”，而不是“读取权”，实际上，Redux Store上的全部状态，在任何时候，对任何模块都是开放的，通过store.getState()总能够读取当前整个状态树的数据，但是只能更新自己相关那一部分模块的数据。</p><h4 id="2-避免冗余数据"><a href="#2-避免冗余数据" class="headerlink" title="2. 避免冗余数据"></a>2. 避免冗余数据</h4><p>冗余数据是一致性的大敌，如果在Store上存储冗余数据，那么维持不同部分数据一致就是一个大问题。</p><p>传统的关系型数据库中，对数据结构的各种“范式化”，其实就是在去除数据的冗余。而近年风生水起的NoSQL运动，提倡的就是在数据存储中“去范式化”，对数据结构的处理和关系型数据库正好相反，利用数据冗余来减少读取数据库时的数据关联工作。</p><p>面向用户的应用处于性能的考虑，倾向于直接使用“去范式化”的应用。但是带来的问题就是维持数据一致性就会困难。</p><p>不同的应用当然应该从自己的需要出发，在选择数据库的问题上，选择SQL关系型数据库或者NoSQL类型的数据库要根据应用特点，这个问题不是我们要在本书中讨论的。但是要强调的是，不管服务器端数据库用的是“范式化”还是“去范式化”的数据存储方式，在前段Redux的Store中，一定要避免数据冗余的出现。</p><p>并不是说Redux应用不需要考虑性能，而是相对于性能问题，数据一致性的问题才更加重要。</p><p>在后面的章节中我们会介绍，即使使用“范式化”的无冗余数据结构，我们借助reselector等工具一样可以获得很高的性能。</p><h4 id="3-树形结构扁平"><a href="#3-树形结构扁平" class="headerlink" title="3. 树形结构扁平"></a>3. 树形结构扁平</h4><p>理论上，一个树形结构可以有很深的层次，但是我们在设计Redux Store的状态树时，要尽量保持树形结构的扁平。</p><p>如果树形结构层次很深，往往意味着树形很复杂，一个很复杂的状态树是难以管理的，如果你曾不幸开发过Windows操作系统中依赖于“注册表”的应用，就一定深有体会，Windows中的注册表就是一个庞大而且层次很深的属性结果，看起来很灵活，实际上总让软件开发陷入麻烦的泥沼。</p><p>从代码的角度出发，深层次树形状态结构会让代码冗长。</p><p>假设，一个树形从上往下依次有A、B、C、D四个节点，为了访问节点D，就只能通过上面三层逐级访问，不过，谁也不敢保证A、B、C三个节点真的存在，为了防止运行时出错，代码就要考虑到所有的可能，最后为了访问D，代码不得不写成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> d = state.A &amp;&amp; state.A.B &amp;&amp; state.A.B.C &amp;&amp;&amp; state.A.B.C.D</span><br></pre></td></tr></table></figure><p>相信没有开发者会愿意写很多类似上面这样的代码。</p><hr><h3 id="五、Todo应用实例"><a href="#五、Todo应用实例" class="headerlink" title="五、Todo应用实例"></a>五、Todo应用实例</h3><p>了解上述创建应用的原则之后，我们现在终于可以开始构建Todo应用了。</p><p>Todo应用从界面上看应该由三部分组成：</p><ul><li><p>待办事项的列表</p></li><li><p>增加新待办事项的输入框和按钮</p></li><li><p>待办事项过滤器，可以选择过滤不同状态的待办事项</p></li></ul><p>看起来需要三个功能模块，但是第一部分和第二部分的关系密切，可以放在一个模块中，所以最后我们确定有两个功能模块todos和filter，其中todos包含第一部分和第二部分的功能。</p><p>我们遵循“按照功能组织”的原则来设计代码，创建三个目录来容纳各自的代码文件，每个目录下都有一个index.js文件，这是模块的边界。各个模块之间只能假设其他模块包含index.js文件，要引用模块只能导入index.js，不能够直接去导入其他文件，文件目录如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">todos/</span><br><span class="line">  index.js</span><br><span class="line">filter/</span><br><span class="line">  index.js</span><br></pre></td></tr></table></figure><h4 id="1-Todo状态设计"><a href="#1-Todo状态设计" class="headerlink" title="1. Todo状态设计"></a>1. Todo状态设计</h4><p>至于Todo应用状态，从界面上看，应用中可以有很多待办事项，并有先后顺序的关系，明显用一个数组很合适。所以，我们的状态树上应该有一个表示待办事项的数组。</p><p>至于每个待办事项，应该用一个对象代表，这个对象肯定要包含文字，记录待办事项的内容，因为我们可以把一个待办事项标记为“已完成”，所以还要有一个布尔字段记录是否完成的状态，当我们把一个待办事项标记位“已完成”或者“未完成”时，必须要能唯一确定一个待办事项对象，没有规则说一个待办事项的文字必须唯一，所以我们需要一个字段来唯一标识一个待办事项，所以一个待办事项的对象格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: //唯一标识</span><br><span class="line">  text: //待办事项内容</span><br><span class="line">  completed: //布尔值，标识待办事项是否已完成</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器选项设定界面上显示什么样状态的代表事项，我们已知过滤器有三种选择：</p><ul><li><p>全部待办事项</p></li><li><p>已完成待办事项</p></li><li><p>未完成待办事项</p></li></ul><p>看起来就是一个列举类型的结构，不过JavaScript里面并没有原生的enum类型支持，所以我们只能用类似常量标识符的方式来定义三种状态。在代码中，可以分别用体现语义的ALL、COMPLETED和UNCOMPLETED代表这三种状态，但是这三个标识符的实际值的选择，也值得商榷。</p><p>最简单的方式，就是让这三个状态标识符的值是整型，比如这样的代码形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ALL = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> COMPLETED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> UNCOMPLETED = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>但是，考虑到将来无论是debug还是产生log，一个数字在开发人员眼里不容易看出来代表什么意思，最后还需要对照代码才知道0代表ALL、1代表COMPLETED，这样很不方便。所以，开发中一个惯常的方法，就是把这些枚举型的常量定义为字符串，比如这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ALL = <span class="string">'all'</span>;</span><br><span class="line"><span class="keyword">const</span> COMPLETED = <span class="string">'completed'</span>;</span><br><span class="line"><span class="keyword">const</span> UNCOMPLETED = <span class="string">'uncompleted'</span>;</span><br></pre></td></tr></table></figure><p>综合起来看，我们知道Todo应用的Store状态树大概是这样一个样子，JavaScript对象的表示形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  todos: [</span><br><span class="line">    &#123;</span><br><span class="line">      text: <span class="string">'First todo'</span>,</span><br><span class="line">      completed: <span class="literal">false</span>,</span><br><span class="line">      id: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      text: <span class="string">'Second todo'</span>,</span><br><span class="line">      completed: <span class="literal">false</span>,</span><br><span class="line">      id: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  filter: <span class="string">'all'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当增加一个待办事项，就在数组类型的todos中增加一个元素，当药标记一个待办事项为“已完成”或者“未完成”，就更新对应待办事项的complete字段值，而哪些待办事项应该显示出来，则要根据todos和filter共同决定。</p><p>在应用的入口文件src/index.js中，我们和ControlPanel一样，用Provider包住最顶层的TodoApp模块，这样让store可以被所有组件访问到，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;TodoApp /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>而在顶层模块src/TodoApp.js中，所要做的只是把两个关键视图显示出来，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;view <span class="keyword">as</span> Todos&#125; <span class="keyword">from</span> <span class="string">'./todos/'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;view <span class="keyword">as</span> Filter&#125; <span class="keyword">from</span> <span class="string">'./filter/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Todos /&gt;</span><br><span class="line">      &lt;Filter /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default TodoApp;</span></span><br></pre></td></tr></table></figure><h4 id="2-action构造函数"><a href="#2-action构造函数" class="headerlink" title="2. action构造函数"></a>2. action构造函数</h4><p>确定好状态树的结构之后，接下来就可以写action构造函数了。</p><p>在todos和filter目录下，我们都要分别创造actionTypes.js和actions.js文件，这两个文件几乎每个功能模块都需要，文件如此命名是大家普遍接受的习惯。</p><p>在src/todos/actionTypes.js中，我们定义的是todos支持的action类型。在Todo应用中，支持对待办事项的增加、反转和删除三种action类型，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO = <span class="string">'TODO/ADD'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TOGGLE_TODO = <span class="string">'TODO/TOGGLE'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REMOVE_TODO = <span class="string">'TODO/REMOVE'</span>;</span><br></pre></td></tr></table></figure><p>和index.js中使用命名式导出而不用默认导出一样，在actionTypes中我们也使用命名式导出，这样，使用actionTypes的文件可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ADD_TODO, TOGGLE_TODO, REMOVE_TODO&#125; <span class="keyword">from</span> <span class="string">'./actionTypes.js'</span>;</span><br></pre></td></tr></table></figure><p>也同样是为了便于debug和输出到log里面查看清晰，所有的action类型的值都是字符串，字符串还有一个好处就是可以直接通过===来比较是否相等，而其他对象用===则要求必须引用同一个对象。</p><blockquote><p>提示：严格来说，使用Symbol来代替字符串表示这样的枚举值更合适，但是有的浏览器并不支持Symbol，我们在这里不作深入探讨。</p></blockquote><p>考虑到应用可以无限扩展，每个组件也要避免明明冲突。所以，最好是每个组件的action类型字符串都有一个唯一的前缀。在我们的例子中，所有todos的action类型字符串都有共同前缀“TODO/”，所有filter的action类型字符串前缀“FILTER/”。</p><p>在src/todos/actions.js中，我们定义todos相关的action构造函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ADD_TODO, TOGGLE_TODO, REMOVE_TODO&#125; <span class="keyword">from</span> <span class="string">'./actionTypes.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextTodoId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addTodo = <span class="function">(<span class="params">text</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: ADD_TODO,</span><br><span class="line">  completed: <span class="literal">false</span>,</span><br><span class="line">  id: nextTodoId++,</span><br><span class="line">  text: text</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toggleTodo = <span class="function">(<span class="params">id</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: TOGGLE_TODO,</span><br><span class="line">  id: id</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeTodo = <span class="function">(<span class="params">id</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: REMOVE_TODO,</span><br><span class="line">  id: id</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上一章中我们已经知道，Redux的action构造函数就是创造action对象的函数，返回的action对象中必须有一个type字段代表action类型，还可能有其他字段代表这个动作承载的数据。</p><p>在src/todos/actions.js文件中定义了一个文件级别的变量nextTodoId，每调用一次addTodo action构造函数就加一，实现为每个产生的待办事项赋予一个唯一id的目的。当然，这种方法非常简陋，我们在后面的章节中会改进唯一id的生成方法。</p><p>读者可能会注意到我们用了一种新的写法，虽然action构造函数应该是一个返回action对象的方法，我们却看不见return的字样。对于只return一个对象的函数体，ES6允许简写为省去return，直接用圆括号把返回的对象包起来就行，比如上面的toggleTodo对象构造器，实际上是下面方法的简写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toggleTodo = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: TOGGLE_TODO,</span><br><span class="line">    id: id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-组合reducer"><a href="#3-组合reducer" class="headerlink" title="3. 组合reducer"></a>3. 组合reducer</h4><p>在todos和filter目录下，各有一个reducer.js文件定义的两个功能模块reducer。</p><p>对于reducer我们并不陌生，在前面的ControlPanel例子中我们就创建过reducer。但是在那个例子中，整个应用只有一个reducer。而在Todo应用中，两个功能模块都有自己的reducer，而Redux的createStore函数只能接受一个reducer，那么怎么办？</p><p>这是Redux最有意思的部分，虽然Redux的createStore只接受一个reducer，却可以把多个reducer组合起来，成为一体，然后就可以被createStore函数接受。</p><p>在src/Store.js文件中，我们完成了reducer的组合，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore, combineReducer&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;reducer <span class="keyword">as</span> todoReducer&#125; <span class="keyword">from</span> <span class="string">'./todos'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;reducer <span class="keyword">as</span> filterReducer&#125; <span class="keyword">from</span> <span class="string">'./filter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducer(&#123;</span><br><span class="line">  todos: todoReducer,</span><br><span class="line">  filter: filterReducer</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(reducer);</span><br></pre></td></tr></table></figure><p>我们使用了Redux提供的一个函数combineReducers来把多个reducer函数合成为一个reducer函数。</p><p>combineReducers函数接受一个对象作为参数，参数对象的每个字段名对应了state状态上的字段名（在上面的例子中分别是todoReducer和filterReducer），combineReducers函数返回一个新的reducer函数，当这个新的reducer函数被执行时，会把传入的state参数对象拆开处理，todo字段下的子状态交给todoReducer，filter字段下的子状态交给filterReducer，然后再把这两个调用的返回结果合并成一个新的state，作为整体reducer函数的返回结果。</p><p>假设，当前State上的状态可以用currentState代表，这时候给Store派发一个action对象，combineReducers产生的这个reducer函数就会被调用，调用参数state就是currentState。这个reducer函数会分别调用todoReducer和filterReducer，不过传递过去的state参数有些变化，调用todoReducer的参数state值是currentStore.todos，调用filterReducer的state是currentState.filter，当todoReducer和filterReducer这两个函数返回结果之后，combineReducers产生的reducer函数就用这两个结果分别去更新Store上的todos和filter字段。</p><p>所以，现在我们来看功能模块的reducer，会发现state的值不是Redux上那个完整的状态，而是状态上对应自己的那一部分。</p><p>在src/todos/reducer.js中可以看到，state参数对应的是Store上todos字段的值，默认值是一个数组，reducer函数往往就是一个以action.type为条件的switch语句构成，代表模式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ADD_TODO, TOGGLE_TODO, REMOVE_TODO&#125; <span class="keyword">from</span> <span class="string">'./actionTypes.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = [], action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="comment">// 针对action.type所有可能值的case语句</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先看对于ADD_TODO这种action类型的处理，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ADD_TODO: &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      id: action.id,</span><br><span class="line">      text: action.text,</span><br><span class="line">      completed: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...state</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们使用了ES6的扩展操作符来简化reducer的代码，扩展操作符可以用来扩展一个对象，也可以用来扩展一个数组。</p><p>现在state是一个数组，我们想要返回一个增加了一个对象的数组，就这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [newObject, ...state];</span><br></pre></td></tr></table></figure><p>为什么我们不直接使用熟悉的数组push或者unshift操作呢？</p><p>绝对不能，因为push和unshift会改变原来的那个数组，还记得吗？reducer必须是一个纯函数，纯函数不能有任何副作用，包括不能修改参数对象。</p><p>对于TOGGLE_TODO这种action累i系那个的处理，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TOGGLE_TODO: &#123;</span><br><span class="line">    <span class="keyword">return</span> state.map(<span class="function">(<span class="params">todoItem</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (todoItem.id === action.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;...todoItem, <span class="attr">complated</span>: !todoItem.completed&#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> todoItem;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展操作符可以在一对{}符号中把一个对象展开，这样，在{}中后面的部分的字段值，可以覆盖展开的部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;...todoItem, <span class="attr">completed</span>: !todoItem.completed&#125;;</span><br></pre></td></tr></table></figure><p>像上面的代码中，返回了一个新的对象，所有字段都和todoItem一样，只是completed字段和todoItem中的completed布尔类型值正好相反。</p><p>对于REMOVE_TODO这种action类型的处理，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> REMOVE_TODO: &#123;</span><br><span class="line">  <span class="keyword">return</span> state.filter(<span class="function">(<span class="params">todoItem</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> todoItem.id !== action.id;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于删除操作，我们使用数组的filter方法，将id匹配的待办事项过滤掉，产生了一个新的数组。</p><p>最后，reducer中的switch语句一定不要漏掉了default的条件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为reducer函数会接收到任意action，包括它根本不感兴趣的action，这样就会执行default中的语句，应该将state原样返回，表示不需要更改state。</p><p>在src/filter/reducer.js中定义了filter模块的reducer，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;SET_FILTER&#125; <span class="keyword">from</span> <span class="string">'./actionTypes.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;FilterTypes&#125; <span class="keyword">from</span> <span class="string">'../constants.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = FilterTypes.ALL, action) = &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SET_FILTER: &#123;</span><br><span class="line">      <span class="keyword">return</span> action.filter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个reducer更加简单，所做的就是把Redux Store上filter字段的值设为action对象上的filter值。</p><p>我们来总结一下Redux的组合reducer功能，利用combineReducers可以把多个只针对局部状态的“小的”reducer合并为一个操纵整个状态树的“大的”reducer，更妙的事，没有两个“小的”reducer会发生冲突，因为无论怎么组合，状态树上一个子状态都只会被一个reducer处理，Redux就是用这种方法隔绝了各个模块。</p><p>很明显，无论我们有多少“小的”reducer，也无论如何组合，都不用在乎它们被因为调用的顺序，因为调用顺序和结果没有关系。</p><h4 id="4-Todo视图"><a href="#4-Todo视图" class="headerlink" title="4. Todo视图"></a>4. Todo视图</h4><p>对于一个功能模块，定义action类型、action构造函数和reducer基本上各用一个文件就行，约定俗成地分别放在模块目录下（actionTypes.js、actions.js和reducer.js文件中）。但是，一个模块涉及的视图文件往往包含多个，因为对于充当视图的React组件，我们往往会让一个React组件的功能精良、小，导致视图分布在多个文件之中。</p><p>既然有多个文件，那么也就没有太大必要保持统一的文件名，反正模块导出的只是一个view字段，在模块内部只要文件名能够表达视图的含义就行。</p><ul><li>1) todos视图</li></ul><p>对于todos模块，在index.js中被导出的view存在src/todos/views/todos.js中，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> AddTodo <span class="keyword">from</span> <span class="string">'./addTodo.js'</span>;</span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'./todoList.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"todos"</span>&gt;</span><br><span class="line">      &lt;AddTodo /&gt;</span><br><span class="line">      &lt;TodoList /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>很简单，就是把AddTodo组件和TodoList两个组件摆放在一个div中，这样的简单组合自然不需要什么状态，所以用一个函数表示成无状态组件就可以了。</p><p>在Todos的顶层div上添加了className属性，值为字符串todos，最后产生的DOM元素上就会有CSS类todos。这个类是为了将来定制样式而使用的，并不影响功能。</p><p>对于AddTodo组件，涉及处理用户的输入。当用户点击“增加”按钮或者在输入栏input中直接回车键的时候，要让JavaScript读取到input这个DOM元素的value值，React为了支持这种方法，提供了一个叫ref的功能。</p><p>在src/todos/views/addTodo.js中有对AddTodo组件的定义，我们先来看其中render函数对ref的用法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"add-todo"</span>&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.onSubmit&#125;&gt;</span><br><span class="line">        &lt;input className=<span class="string">"new-todo"</span> ref=&#123;<span class="keyword">this</span>.refInput&#125; /&gt;</span><br><span class="line">        &lt;button className=<span class="string">"add-btn"</span> type=<span class="string">"submit"</span>&gt;</span><br><span class="line">        添加</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>当一个包含ref属性的组件完成装载（mount）过程的时候，会看一看ref属性是不是一个函数，如果是，就会调用这个函数，参数就是这个组件代表的DOM元素，注意，是DOM元素，不是Virtual DOM元素，通过这种方法，我们的代码可以访问到实际的DOM元素。</p><p>AddTodo的render渲染出来了一个form，通过onSubmit属性把form被提交的事件挂在AddTodo组件的onSubmit函数上。</p><p>在上面的例子中，input元素的ref属性是AddTodo组件的一个成员函数refInput，所以当这个input元素完成装载之后，refInput会被调用。</p><p>refInput的函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refInput(node) &#123;</span><br><span class="line">  <span class="keyword">this</span>.input = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当refInput被调用时，参数node就是那个input元素，refInput把这个node记录在成员变量input中。</p><p>于是，当组件完成mount之后，就可以通过this.input来访问那个input元素。这是一个DOM元素，可以使用任何DOM API访问元素内容，通过访问this.input.value就可以直接读取当前的用户输入。</p><p>使用this.input的onSubmit函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onSubmit(ev) &#123;</span><br><span class="line">  ev.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> input = <span class="keyword">this</span>.input;</span><br><span class="line">  <span class="keyword">if</span> (!input.value.trim()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.props.onAdd(input.value);</span><br><span class="line">  input.value = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HTML中，一个form表单被提交的默认行为会引发网页跳转，在React应用中当然不希望网页跳转发生，所以我们首先通过调用参数ev的preventDefault函数取消掉浏览器的默认提交行为。</p><p>通过this.input.value，可以判断出当前输入框里的文字内容。如果是空白，就应该忽略，因为创建一个空白的待办事项没有意义。否则，就调用通过属性onAdd传递进来的函数。最后，我们把input清空，让用户知道创建成功，而且方便创建下一条待办事项。</p><p>文件中的AddTodo组件是一个内部组件，按说应该是一个傻瓜组件，但是和我们之前例子中的傻瓜组件不一样，AddTodo不是一个只有一个render函数的组件，AddTodo甚至有一个逻辑比较复杂的onSubmit函数，为什么不把这部分逻辑提取到外面的容器组件呢？</p><p>其实我们可以把onSubmit的逻辑提取到mapDispatchToProps中。但是，让AddTodo组件外面的mapDispatchToProps访问到AddTodo组件里面的ref很困难，得不偿失。</p><p>使用ref实际上就是直接触及了DOM元素，与我们想远离DOM是非之地的想法相悖，虽然React提供了这个功能，但是还是要谨慎使用，如果要用，我们进尽量让ref不要跨越组件的边界。</p><p>所以，我们把通过ref访问input.value放在内部的AddTodo中，但是把调用dispatch派发action对象的逻辑放在mapDispatchToProps中，两者一个主内一个主外，各司其职，不要混淆。</p><blockquote><p>注意：并不是只有ref一种方法才能够访问input元素的value，我们在这里使用ref主要是展示一下React的这个功能，在后面的章节中我们会介绍更加可控的方法。</p></blockquote><p>注意，对于AddTodo，没有任何需要从Redux Store的状态衍生的属性，所以最后一行的connect函数第一个参数mapStateToProps是null，只是用了第二个参数mapDispatchToProps。</p><p>在src/todos/views/addTodo.js中表示AddTodo标识符代表的组件和src/todos/views/todos.js中AddTodo标识符代表的组件不一样，后者是前者用react-redux包裹之后的容器组件。</p><p>接下来看看待办事项列表组件，定义在src/todos/view/todoList.js中，在渲染TodoList时，我们的todos属性是一个数组，而数组元素的个数是不确定的，这就涉及如何渲染数量不确定子组件的问题，TodoList作为无状态组件代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TodoList = <span class="function">(<span class="params">&#123;todos, onToogleTodo, onRemoveTodo&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul className=<span class="string">"todo-list"</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      todos.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">        &lt;TodoItem</span><br><span class="line">          key=&#123;item.id&#125;</span><br><span class="line">          text=&#123;item.text&#125;</span><br><span class="line">          completed=&#123;item.completed&#125;</span><br><span class="line">          onToggle=&#123;() =&gt; onToggleTodo(item.id)&#125;</span><br><span class="line">          onRemove=&#123;() =&gt; onRemoveTodo(item.id)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这段代码中的TodoList真的就只是一个无状态的傻瓜组件了，对于传递进来的todos属性，预期是一个数组，通过一个数组的map函数转化为一个TodoItem组件的数组，这是我们第一次在JSX代码片段中创建动态数量的元素。</p><p>因为todos这个数组的元素数量并不确定，所以很自然想到要用一个循环来产生同样数量的TodoItem组件实例。但是，并不能在JSX中使用for或者while这样的循环语句。因为，JSX中可以使用任何形式的JavaScript表达式，只要JavaScript表达式出现在符号{}之间，但是也只能是JavaScript“表达式”，for或者while产生的是“语句”而不是“表达式”，所以不能出现for或者while。</p><p>归根到底，JSX最终会被babel转译成一个嵌套的函数调用，在这个函数调用中自然无法插入一个语句进去，所以，当我们想要在JSX中根据数组产生动态数量的组件实例，就应该用数组的map方法。</p><p>还有一点很重要，对于动态数量的子组件，每个子组件都必须要带上一个key属性，而且这个key属性的值一定要是能够唯一标示这个子组件的值。</p><p>当我们完成Todo应用之后，会回过头来再解释key值的作用。</p><p>TodoList的mapStateToProps方法需要根据Store上的filter状态决定todos状态上取哪些元素来显示，这个过程涉及对filter的switch判断。为了防止mapStateToProps方法过长，我们将这个逻辑提取到selectVisibleTodos函数中，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectVisibleTodos = <span class="function">(<span class="params">todos, filter</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (filter) &#123;</span><br><span class="line">    <span class="keyword">case</span> FilterTypes.ALL:</span><br><span class="line">      <span class="keyword">return</span> todos;</span><br><span class="line">    <span class="keyword">case</span> FilterTypes.COMPLETED:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.completed);</span><br><span class="line">    <span class="keyword">case</span> FilterTypes.UNCOMPLETED:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">item</span> =&gt;</span> !item.completed);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unsupported filter'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    todos: selectVisibleTodos(state.todos, state.filter)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们看TodoList的mapDispatchToProps方法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onToggleTodo: <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">      dispatch(toggleTodo(id));</span><br><span class="line">    &#125;,</span><br><span class="line">    onRemoveTodo: <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">      dispatch(removeTodo(id));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在TodoList空间中，看mapDispatchToProps函数产生的练个新属性onToggleTodo和onRemoveTodo的代码遵循一样的模式，都是把接收到的参数作为参数传递给一个action构造函数，然后用dispatch方法把产生的action对象派发出去，这看起来是重复代码。</p><p>实际上，Redux已经提供了一个bindActionCreators方法来消除这样的重复代码，显而易见很多mapDispatchToProps要做的事情只是把action构造函数和prop关联起来，所以直接以prop名为字段名，以action构造函数为对应字段值，把这样的对象传递给bindActionCreators就可以了，上面的mapDispatchToProps可以简写为这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;bindActionCreators&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> bindActionCreators(&#123;</span><br><span class="line">  onToggleTodo: toggleTodo,</span><br><span class="line">  onRemoveTodo: removeTodo</span><br><span class="line">&#125;, dispatch);</span><br></pre></td></tr></table></figure><p>更进一步，可以直接让mapDispatchToProps是一个prop到action构造函数的映射，这样连bindActionCreators函数都不用，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  onToggleTodo: toggleTodo,</span><br><span class="line">  onRemoveTodo: removeTodo</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面定义的mapDispatchToProps传给connect函数，产生的效果和之前的写法完全一样。</p><p>我们再看定义了TodoItem的src/todos/views/todoItem.js文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TodoItem = <span class="function">(<span class="params">&#123;onToggle, onRemove, completed, text&#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;li </span><br><span class="line">    className=<span class="string">"todo-item"</span> </span><br><span class="line">    style=&#123;&#123;</span><br><span class="line">      textDecoration: completed ? <span class="string">'line-through'</span>: <span class="string">'none'</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;input </span><br><span class="line">      className=<span class="string">"toggle"</span></span><br><span class="line">      type=<span class="string">"checkbox"</span></span><br><span class="line">      checked=&#123;completed ? <span class="string">"checked"</span>: <span class="string">""</span>&#125;</span><br><span class="line">      readOnly</span><br><span class="line">      onClick=&#123;onToggle&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;label className=<span class="string">"text"</span>&gt;&#123;text&#125;&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button className="remove" onClick=&#123;onRemove&#125;&gt;X&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>这里的TodoItem就是一个无状态的组件，把onToggle属性挂到checkbox的点击事件上，把onRemove属性挂到删除按钮的点击事件上。</p><p>每个待办事项都包含一个checkbox元素和一段文字内容，checkbox是否勾选并不依赖用户输入，而是根据completed属性来判断。同时，对于completed状态的待办事项，文字内容中间用横线代表完成。</p><ul><li>2) filter视图</li></ul><p>对于过滤器，我们有三个功能类似的链接，很自然就会想到把链接相关的功能提取出来，放在一个叫Link的组件中。</p><p>在src/filter/views/filter.js中，我们定义被导出的filter主视图，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Filter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;p className=<span class="string">"filters"</span>&gt;</span><br><span class="line">      &lt;Link filter=&#123;FilterTypes.ALL&#125;&gt;&#123;FilterTypes.ALL&#125;&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Link filter=&#123;FilterTypes.COMPLETED&#125;&gt;&#123;FilterTypes.COMPLETED&#125;&lt;/</span>Link&gt;</span><br><span class="line">      &lt;Link filter=&#123;FilterTypes.UNCOMPLETED&#125;&gt;&#123;FilterTypes.UNCOMPLETED&#125;&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>p&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个filter主视图很简单，是一个无状态的函数，列出了三个过滤器，把实际工作都交给了Link组件。</p><p>我们在src/filter/views/link.js中添加Link组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Link = <span class="function">(<span class="params">&#123;active, children, onClick&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (active) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;b className=<span class="string">"filter selected"</span>&gt;&#123;children&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">  &#125; else (</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;a href="#" className="filter no-selected" onClick=&#123;(ev) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        ev.preventDefault();</span></span><br><span class="line"><span class="regexp">        onClick();</span></span><br><span class="line"><span class="regexp">      &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &#123;children&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>a&gt;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为傻瓜组件的Link，当传入属性active为true时表示当前实例就是被选中的过滤器，不该被再次选择，所以不应该渲染超链接标签a。若否，则渲染一个超链接标签。</p><p>一个超链接标签的默认行为是跳转，即href属性是#，所以超链接标签的onClick事件处理器第一件事就是用preventDefault函数取消默认行为。实际上，我们把href设为“#”唯一的目的就是让浏览器给超链接显示出下划线，代表这是一个链接。</p><p>我们使用了一个特殊的属性children，对于任何一个React组件都可以访问这样一个属性，代表的是被包裹住的子组件，比如，对于下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Foo&gt;</span><br><span class="line">  &lt;Bar&gt;WhatEver&lt;<span class="regexp">/Bar&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Foo&gt;</span><br></pre></td></tr></table></figure><p>Foo组件实例的children就是<code>&lt;Bar&gt;WhatEver&lt;/Bar&gt;</code>，而Bar组件实例的children就是<code>WhatEver</code>。在render函数中把children属性渲染出来，是惯常的组合React组件的方法。</p><p>Link的mapStateToProps和mapDispatchToProps函数都很简单，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, ownProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    active: state.filter === ownProps.filter</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch, ownProps</span>) =&gt;</span> &#123;</span><br><span class="line">  onClick: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch(setFilter(ownProps.filter));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-样式"><a href="#5-样式" class="headerlink" title="5. 样式"></a>5. 样式</h4><p>我们终于完成了Todo应用，在浏览器中可以看到最终效果。</p><p><img src="/images/react-4/1.png" alt="无定制样式的Todo应用界面"></p><p>这个Todo应用功能已经完成，但是并没有定制样式，还是需要通过CSS来添加样式。我们在定义视图部分代码时，一些元素上通过className属性添加了CSS类，现在我们就利用这些类来定义CSS规则。</p><p>在src/todos/views/style.css中，我们定义了Todo空间中所有的样式，为了让定义的样式产生效果，在Todos组件的最顶层视图文件src/todos/views/todos.js中添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span>;</span><br></pre></td></tr></table></figure><p>在React应用中，通常使用webpack来完成对JavaScript的打包，create-react-app产生的应用也不例外，不过webpack不知能够处理JavaScript文件，它还能够处理css、scss甚至图片文件，因为在webpack眼里，一切文件都是“模块”，通过文件中的import语句或者require函数调用就可以找到文件之间的使用关系，只要被import就会被纳入最终打包的文件中，即使被import的是一个css文件。</p><p>如下图所示，Todo应用拥有样式了。</p><p><img src="/images/react-4/2.png" alt="完成定制样式的Todo应用界面"></p><p>把css文件用import语句导入，webpack默认的处理方式是将css文件的内容嵌入最终的打包文件bundle.js中，这毫无疑问会让打包文件变得更大，但是应用所有的逻辑都被包含在一个文件中了，便于部署。</p><p>当然，如果不希望将css和JavaScript混在一起，也可以在webpack中通过配置完成，在webpack的loader中使用extract-text-webpack-plugin，就可以让css文件在build时被放在独立的css文件中。</p><p>有意思的是，选择css和JavaScript打包在一起还是分开打包，和代码怎么写没有任何关系，这就是React的妙处。代码中只需要描述“想要什么”，至于最终“怎么做”，可以通过配置webpack获得多重选择。</p><p>如果使用scss语法，可以简化上面的样式代码，但是create-react-app产生的应用默认不支持scss，有兴趣的话可以通过eject方法直接编辑webpack配置，应用上scss加载器。</p><h4 id="6-不使用ref"><a href="#6-不使用ref" class="headerlink" title="6. 不使用ref"></a>6. 不使用ref</h4><p>在前面的例子中，代码通过React的ref功能来访问DOM元素，这种功能的需求往往来自于提交表单的操作，在提交表单的时候，需要读取当前表单中input元素的值。</p><p>毫无疑问，ref的用法非常脆弱，因为React的产生就是为了避免直接操作DOM元素，因为直接访问DOM元素很容易产生失控的情况，现在为了读取某个DOM元素的值，通过ref取得对元素的直接引用，不得不说，干的并不漂亮。</p><p>有没有更好的方法呢？</p><p>有，可以利用组件状态来同步记录DOM元素的值，这种方法可以控制住组件不使用ref。</p><p>Todo应用中的addTodo.js文件可以这样修改，首先是render函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"add-todo"</span>&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.onSubmit&#125;&gt;</span><br><span class="line">        &lt;input </span><br><span class="line">          className=<span class="string">"new-todo"</span> </span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.onInputChange&#125; </span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.value&#125; /&gt;</span><br><span class="line">        &lt;button className=<span class="string">"add-btn"</span> type=<span class="string">"submit"</span>&gt;</span><br><span class="line">          添加</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在这里我们不再使用ref来获取对input元素的直接访问，而是利用input元素上的onChange属性挂上一个事件处理函数onInputChange，这样每当input的值发生变化时，onInputChange函数就会被调用，这样我们总有机会记录下最新的input元素内容。</p><p>onInputChange函数的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onInputChange(event) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    value: event.target.value</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onInputChange函数中，通过传入的事件参数event可以访问事件发生的目标，读取到当前值，并把内容存在组件状态的value字段上。这样，组件状态上总能够获取最新的input元素内容。</p><p>然后看onSubmit函数的改变，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onSubmit(ev) &#123;</span><br><span class="line">  ev.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> inputValue = <span class="keyword">this</span>.state.value;</span><br><span class="line">  <span class="keyword">if</span> (!inputValue.trim()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.props.onAdd(inputValue);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="string">''</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要提交表单的时候，onSubmit函数被调用，只需要直接从组件状态上读取value字段的值就够了。</p><p>在产品开发中，应该尽量避免ref的使用，而换用这种状态绑定的方法来获取元素的值。</p><hr><h3 id="六、开发辅助工具"><a href="#六、开发辅助工具" class="headerlink" title="六、开发辅助工具"></a>六、开发辅助工具</h3><p>我们已经写了一个比较复杂的基于React和Redux的应用，将来还会遇到更复杂的应用，是时候引入一些开发辅助工具了，毕竟没有人能够一次把复杂代码写对，必要的工具能够大大提高我们的工作效率。</p><h4 id="1-Chrome扩展包"><a href="#1-Chrome扩展包" class="headerlink" title="1. Chrome扩展包"></a>1. Chrome扩展包</h4><p>Chrome是网页应用开发者群体最喜爱的浏览器，因为Chrome浏览器有丰富的扩展库来帮助网页开发，这里我们介绍三款Chrome扩展包，可以说是React和Redux应用开发必备之物。</p><ul><li><p>React Devtools，可以检视React组件的树形结构</p></li><li><p>Redux Devtools，可以检视Redux数据流，可以将Store状态跳跃到任何一个历史状态，也就是所谓的“时间旅行”功能</p></li><li><p>React Perf，可以发现React组件渲染的性能问题</p></li></ul><h4 id="2-redux-immutable-state-invariant辅助包"><a href="#2-redux-immutable-state-invariant辅助包" class="headerlink" title="2. redux-immutable-state-invariant辅助包"></a>2. redux-immutable-state-invariant辅助包</h4><p>我们曾经反复强调过，每一个reducer函数都必须是一个纯函数，不能修改传入的参数state和action，否则会让应用重新陷入状态不可预料的境地。</p><p>禁止reducer函数修改参数，这是一个规则，规则总是会被无心违反的，但是怎么避免开发者不小心违反这个规则呢？</p><p>有一个redux-immutable-state-invariant包，提供了一个Redux的中间件，能够让Redux在每次派发动作之后做一个检查。如果发现某个reducer违反了作为一个纯函数的规定擅自修改了参数state，就会给一个大大的错误警告，从而让开发者意识到自己犯了一个错误，必须要修正。</p><p>什么是Redux的中间件？我们在后面的章节会详细介绍，在这里我们只要理解中间件是可以增强Redux的Store实例功能的一种方法就可以。</p><p>很明显，对于redux-immutable-state-invariant的这种检查，在开发环境下很有用。但是在产品环境下，这样的出错提示意义不大，只是徒耗计算资源和增大JavaScript代码提及，所以我们通常在产品环境中不启用redux-immutable-state-invariant。</p><h4 id="3-工具应用"><a href="#3-工具应用" class="headerlink" title="3. 工具应用"></a>3. 工具应用</h4><p>上面我们介绍了辅助开发的Chrome扩展包和redux-immutable-state-variant库，对于React Devtools来说，启用只是安装一个Chrome扩展包的事，但是对于其余几个工具，我们的代码需要做一些修改才能配合浏览器使用。</p><p>因为Store是Redux应用的核心，所以所有的代码修改都集中在src/Store.js中。</p><p>首先需要从Redux引入多个函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore, combineReducers, applyMiddleware, compose&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br></pre></td></tr></table></figure><p>为了使用React Perf插件，需要添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Perf <span class="keyword">from</span> <span class="string">'react-addons-perf'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> win = <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">win.Perf - Perf;</span><br></pre></td></tr></table></figure><p>在这里把window赋值给模块级别变量win，是为了帮助代码缩小器（minifer），在webpack中缩小代码的插件叫UglifyJsPlugin，能够将局部变量名改成很短的变量名，这样功能不受影响但是代码的大小大大缩减。</p><p>不过，和所有的代码缩小器一样，UglifyJsPlugin不敢去改变全局变量名，因为改了就会影响程序的功能。所以当多次引用window这样的全局变量时，最好在模块开始将window赋值给一个变量，比如win，然后在代码其它部分只使用win，这样最终经过UglifyJsPlugin产生的缩小代码就只包含一个无法缩小的window变量。</p><p>我们给win上的Perf赋值了从react-addons-perf上导入的内容，这是为了帮助React Perf扩展包的使用，做了这个代码修改之后，React Perf上的Start按钮和Stop按钮才会起作用。</p><p>为了应用redux-immutable-state-invariant中间件和Redux Devtools，需要使用Redux的Store Enhancer功能，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  todos: todoReducer,</span><br><span class="line">  filter: filterReducer</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewares = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  middlewares.push(<span class="built_in">require</span>(<span class="string">'redux-immutable-state-invariant'</span>)());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storeEnhancers = compose(</span><br><span class="line">  applyMiddleware(...middlewares),</span><br><span class="line">  (win &amp;&amp; win.devToolsExtension) ? win.devToolExtension() : <span class="function">(<span class="params">f</span>) =&gt;</span> f</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(reducer, &#123;&#125;, storeEnhancers);</span><br></pre></td></tr></table></figure><p>代码修改的关键在于给createStore函数增加了第三个参数storeEnhancers，这个参数代表Store Enhancer的意思，能够让createStore函数产生的Store对象具有更多更强的功能。</p><p>因为Store Enhancer可能有多个，在我们的例子中就有两个，所以Redux提供了一个compose函数，用于把多个Store Enhancer组合在一起，我们分别来看这两个Store Enhancer是什么。</p><p>第一个Store Enhancer是一个函数applyMiddleware的执行结果，这个函数接受一个数组作为参数，每个元素都是一个Redux的中间件。虽然目前我们只应用了一个中间件，但是考虑到将来会扩展更多，所以我们用数组变量middlewares来存储所有的中间件，将来要扩展新的中间件只需要往这个数组中push新的元素就可以了。</p><p>目前，往middlewares中push的唯一一个中间件就是redux-immutable-state-invariant。如同上面解释过的，redux-immutable-state-invariant只有在开发环境下使用才有意义，所以只有当process.env.NODE_ENV不等于production时才加入这个中间件。</p><p>我们一直按照ES6的语法导入模块，也就是用import关键字导入模块，但是在这里却用了Node传统风格require，是因为import语句不能够存在于条件语句之中，只能出现在模块语句的顶层位置。</p><p>第二个Store Enhancer就是Redux Devtools，因为Redux Devtools的工作原理是截获所有应用中Redux Store的动作和状态变化，所以必须通过Store Enhancer在Redux Store中加入钩子。</p><p>如果浏览器中安装了Redux Devtools，在全局window对象上就有一个devToolsExtension代表Redux Devtools。但是，我们也要让没有安装这个扩展包的浏览器也能正常使用我们的应用，所以要根据window.devToolsExtension是否存在做一个判断，如果有就用，如果没有就插入一个什么都不做的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(win &amp;&amp; win.devToolsExtension) ? win.devToolsExtension() : <span class="function">(<span class="params">f</span>) =&gt;</span> f</span><br></pre></td></tr></table></figure><p>当所有的代码修改完毕，重新启动Todo应用，在浏览器的开发者工具中就可以使用所有关于React和Redux的工具了。</p><hr><h3 id="七、本章小结"><a href="#七、本章小结" class="headerlink" title="七、本章小结"></a>七、本章小结</h3><p>在这一章，我们学习了构建一个完整Redux应用的步骤和需要考虑的方面。</p><p>首先，要考虑代码文件的组织方式，对于可以高度模块化的Redux应用，使用“按功能组织”的方式要优于传统MVC框架下“按角色组织”的方式。</p><p>之后，要考虑Store上状态树的设计，因为状态树的结构直接决定了模块的划分，以及action类型、action构造函数和reducer的设计。可以说，开始写Redux应用第一行代码之前，首先要想好Store的状态树长得什么样子。</p><p>然后，我们实际构建了一个Todo应用，这个应用要比之前的ControlPanel应用复杂，利用划分模块的方法解决才是正道，从中我们也学习了React的ref功能，以及动态数量的子空间必须要包含key属性。</p><p>最后，我们了解了开发React和Redux应用必备的几样辅助工具，有了这几样工具，开发React和Redux应用就会如虎添翼。</p><p>这只是个起点，在接下来的章节中，我们会进一步深入了解React和Redux的精髓。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="/resources/深入浅出React和Redux.pdf">《深入浅出React和Redux —— 程墨》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在第一部分中，我们已经了解了React的基本工作方式，也知道了Redux在组合React组件中的作用，但是更多的只是了解其基本原理和使用方法，上手练习的也是一个简单的例子。&lt;/p&gt;
    
    </summary>
    
      <category term="React抄书笔记" scheme="http://www.xiaoleon.cn/categories/React%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.xiaoleon.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Web(7) 前端路由实现方法</title>
    <link href="http://www.xiaoleon.cn/2018/03/13/web-7/"/>
    <id>http://www.xiaoleon.cn/2018/03/13/web-7/</id>
    <published>2018-03-13T07:45:47.000Z</published>
    <updated>2018-03-13T14:27:42.743Z</updated>
    
    <content type="html"><![CDATA[<p>什么是路由？简单的来说，路由是 <strong><em>URL –&gt; 函数</em></strong> 的映射关系。</p><p>大部分复杂的网站，都会把业务解耦为模块进行处理。这些网站中又有很多的网站会把适合的部分应用Ajax进行数据交互，展现给用户，很明显处理这样的数据通信交互，不可避免的会涉及到跟URL打交道，让数据交互的变化反映到URL的变化上，进而可以给用户机会去通过保存的URL链接，还原刚才的页面内容板块的布局，这其中包括Ajax局部刷新的变化。</p><a id="more"></a><h3 id="一、router和route的区别"><a href="#一、router和route的区别" class="headerlink" title="一、router和route的区别"></a>一、<code>router</code>和<code>route</code>的区别</h3><p><code>route</code>是一条路由，它将一个 <strong><em>URL</em></strong> 路径和一个 <strong><em>函数</em></strong> 进行映射，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/users          --&gt;     getAllUsers()  </span><br><span class="line">/users/count    --&gt;     getUsersCount()</span><br></pre></td></tr></table></figure><p><code>router</code>可以理解为一个容器，或者一种机制，它管理了一组<code>route</code>。</p><p><code>router</code>是<code>route</code>的一组Map映射表，接收到一个URL后，由<code>router</code>来从映射表中查找相应的函数。</p><hr><h3 id="二、服务端路由"><a href="#二、服务端路由" class="headerlink" title="二、服务端路由"></a>二、服务端路由</h3><p>对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。</p><ul><li><p>静态资源，可以认为，URL的映射函数就是一个文件的读取操作。 </p></li><li><p>动态资源，映射函数可能是一个数据库的读取操作，也可能是一些数据处理等等。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.sendFile(<span class="string">'index'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/users'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = db.queryAllUsers();</span><br><span class="line">    res.send(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>router</code>匹配<code>route</code>的过程中，不仅会根据URL来匹配，还会根据请求的方法来匹配，如<code>POST</code>、<code>GET</code>、<code>PUT</code>、<code>DELETE</code>等等。</p><hr><h3 id="三、客户端路由"><a href="#三、客户端路由" class="headerlink" title="三、客户端路由"></a>三、客户端路由</h3><p>对于客户端来说，路由的映射函数通常是进行一些DOM元素的<strong>显示和隐藏</strong>操作。这样，当访问不同的路径的时候，会显示不同的页面组件。</p><p>客户端路由最常见的是下面两种实现方案：</p><h4 id="1-基于Hash（锚点）"><a href="#1-基于Hash（锚点）" class="headerlink" title="1. 基于Hash（锚点）"></a>1. 基于Hash（锚点）</h4><p>URL中 <code>#</code> 或者 <code>#!</code> 及其后面的部分为hash，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"><span class="keyword">var</span> a = url.parse(<span class="string">'http://example.com/a/b/#/foo/bar'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.has)</span><br><span class="line"><span class="comment">// =&gt; #/foo/bar</span></span><br></pre></td></tr></table></figure><p>H5中对has有一个<code>hashchange</code>事件，当页面的<code>hash</code>变化时，即会出发<code>hashchange</code>。</p><p>锚点<code>Hash</code>起到引导浏览器将这次记录推入<strong>历史记录栈顶</strong>的作用，<code>window.location</code>对象处理 <code>#</code> 的改变并不会重新加载页面，而是将之当成新页面，放入历史栈里。</p><p>当<code>前进(-&gt;)</code>或者<code>后退(&lt;-)</code>或者触发<code>hashchange</code>事件时，我们可以在对应的事件处理函数里注册ajax等操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash = <span class="built_in">window</span>.location.hash;</span><br><span class="line">    <span class="keyword">var</span> path = hash.substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (path) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            showHome();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/users'</span>:</span><br><span class="line">            showUsersList();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            show404NotFound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是hashchange这个事件并不是每个浏览器都有，地基浏览器需要用轮询检测URL是否在变化，来检测锚点的变化。  </p><p>当锚点内容 <code>location.hash</code> 被操作时，如果锚点内容发生改变浏览器才会将其放入历史栈中；否则历史栈并不会增加，并且也不会触发<code>hashchange</code>事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果浏览器不支持原生实现的事件，则开始模拟，否则退出。</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="string">"onhashchange"</span> <span class="keyword">in</span> <span class="built_in">window</span>.document.body ) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> location = <span class="built_in">window</span>.location,</span><br><span class="line">    oldURL = location.href,</span><br><span class="line">    oldHash = location.hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每隔100ms检查hash是否发生变化</span></span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newURL = location.href,</span><br><span class="line">        newHash = location.hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash发生变化且全局注册有onhashchange方法（这个名字是为了和模拟的事件名保持统一）；</span></span><br><span class="line">        <span class="keyword">if</span> ( newHash != oldHash &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span>.onhashchange === <span class="string">"function"</span>  ) &#123;</span><br><span class="line">            <span class="comment">// 执行方法</span></span><br><span class="line">            <span class="built_in">window</span>.onhashchange(&#123;</span><br><span class="line">                type: <span class="string">"hashchange"</span>,</span><br><span class="line">                oldURL: oldURL,</span><br><span class="line">                newURL: newURL</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            oldURL = newURL;</span><br><span class="line">            oldHash = newHash;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><h4 id="2-基于History"><a href="#2-基于History" class="headerlink" title="2. 基于History"></a>2. 基于History</h4><p>我们首先熟悉几个H5的 <code>History Api</code>，下面是<code>Mozilla</code>在H5中实现的<code>History Api</code>的官方文档描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Returns the number of entries in the joint session history.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.length</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Returns the current state object.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.state</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Goes back or forward the specified number of steps in the joint session history.A zero delta will reload the current page.If the delta is out of range, does nothing.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.go([delta])</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Goes back one step in the joint session history.If there is no previous page, does nothing.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.back()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Goes forward one step in the joint session history.If there is no next page, does nothing.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.forward()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Pushes the given data onto the session history, with the given title, and, if provided and not null, the given URL.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.pushState(data, title[url])</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Updates the current entry in the session history to have the given data, title, and,if provided and not null, URL.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.replaceState(data, title[url])</span><br></pre></td></tr></table></figure><p>其中最后的两个方法<code>history.pushState</code>和<code>history.replaceState</code>，为前端操控浏览器历史栈提供了可能性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*parameters</span></span><br><span class="line"><span class="comment">*@data &#123;object&#125; state对象，这是一个javascript对象，一般是JSON格式的对象</span></span><br><span class="line"><span class="comment">*字面量。</span></span><br><span class="line"><span class="comment">*@title &#123;string&#125; 可以理解为document.title，在这里是作为新页面传入参数的。</span></span><br><span class="line"><span class="comment">*@url &#123;string&#125; 增加或改变的记录，对应的url，可以是相对路径或者绝对路径，</span></span><br><span class="line"><span class="comment">*url的具体格式可以自定。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">history.pushState(data, title, url) <span class="comment">//向浏览器历史栈中增加一条记录。</span></span><br><span class="line">history.replaceState(data, title, url) <span class="comment">//替换历史栈中的当前记录。</span></span><br></pre></td></tr></table></figure><p>这两个Api都会操作浏览器的历史栈，而不会引起页面的刷新。不同的是，<code>pushState</code>会增加一条新的历史记录，而<code>replaceState</code>则会替换当前的历史记录。</p><p>在将新的历史记录存入栈后，会把传入的<code>data(即state对象)</code>同时存入，方便以后调用，存在用户的本地硬盘上，最大支持到640k。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentState = history.state; <span class="comment">//如果没有则为null</span></span><br></pre></td></tr></table></figure><p>同时，这俩api都会更新或者覆盖当前浏览器的title和url为对应传入的参数。</p><p>URL参数可以为绝对路径，也可以为相对路径，但是不能跨域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设当前网页URL为：http://tonylee.pw</span></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"http://tonylee.pw?name=tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw?name=tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"http://tonylee.pw/name/tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"?name=tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw?name=tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"name=tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name=tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"/name/tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"name/tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的用法：</span></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"http://www.tonylee.pw?name=tonylee"</span>);</span><br><span class="line"><span class="comment">//error: 由于跨域将产生错误</span></span><br></pre></td></tr></table></figure><p>可以看到，URL作为一个改变当前浏览器地址的参数，用法是非常灵活的。传入的URL默认以“<code>/</code>”相隔，也可以自己指定为“<code>?</code>”等。</p><p><strong><em>根据URL的变化 –&gt; 页面板块变化 –&gt; 页面发出XHR请求 –&gt; 页面没有reload</em></strong></p><p>这里我们可以看一下<code>mozilla</code>提供的一个<code>pushState</code>和<code>replaceState</code>的小demo，已经接近一个前端路由的雏形。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;!-- <span class="keyword">this</span> starts off <span class="keyword">as</span> http:<span class="comment">//example.com/line?x=5 --&gt;</span></span><br><span class="line">&lt;title&gt;Line Game - <span class="number">5</span>&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;You are at coordinate &lt;span id="coord"&gt;5&lt;/</span>span&gt; on the line.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;</span></span><br><span class="line"><span class="regexp">&lt;a href="?x=6" onclick="go(1); return false;"&gt;Advance to 6&lt;/</span>a&gt; or</span><br><span class="line">&lt;a href=<span class="string">"?x=4"</span> onclick=<span class="string">"go(-1); return false;"</span>&gt;retreat to <span class="number">4</span>&lt;<span class="regexp">/a&gt;?</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> currentPage = <span class="number">5</span>; <span class="comment">// prefilled by server！！！！</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    setupPage(currentPage + d);</span><br><span class="line">    history.pushState(currentPage, <span class="built_in">document</span>.title, <span class="string">'?x='</span> + currentPage);</span><br><span class="line">&#125;</span><br><span class="line">onpopstate = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    setupPage(event.state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupPage</span>(<span class="params">page</span>) </span>&#123;</span><br><span class="line">    currentPage = page;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">'Line Game - '</span> + currentPage;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'coord'</span>).textContent = currentPage;</span><br><span class="line">    <span class="built_in">document</span>.links[<span class="number">0</span>].href = <span class="string">'?x='</span> + (currentPage+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">document</span>.links[<span class="number">0</span>].textContent = <span class="string">'Advance to '</span> + (currentPage+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">document</span>.links[<span class="number">1</span>].href = <span class="string">'?x='</span> + (currentPage<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">document</span>.links[<span class="number">1</span>].textContent = <span class="string">'retreat to '</span> + (currentPage<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>从例子中我们看到一个<code>popstate</code>的事件，这里也看看<code>mozalla</code>官方文档</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">An event handler <span class="keyword">for</span> the popstate event on the window.</span><br><span class="line"></span><br><span class="line">A popstate event is dispatched to the window every <span class="built_in">time</span> the active history entry changes between two history entries <span class="keyword">for</span> the same document. <span class="keyword">If</span> the history entry being activated was created by a <span class="keyword">call</span> to history.pushState() or was affected by a <span class="keyword">call</span> to history.replaceState(), the popstateevent's state property contains a <span class="built_in">copy</span> of the history entry's state object.</span><br><span class="line"></span><br><span class="line">Note that just calling history.pushState() or history.replaceState() won't trigger apopstate event. The popstate event is only triggered by doing a browser action such as clicking on the back button (or calling history.back() <span class="keyword">in</span> JavaScript). And the event is only triggered when the user navigates between two history entries <span class="keyword">for</span> the same document.</span><br><span class="line"></span><br><span class="line">Browsers tend to handle the popstate event differently on page load. Chrome (prior to v34) and Safari always emit a popstate event on page load, but Firefox doesn't.</span><br><span class="line"></span><br><span class="line">Syntax</span><br><span class="line">    window.onpopstate = funcRef;</span><br><span class="line">    //funcRef is a handler function.</span><br></pre></td></tr></table></figure><p>简单来说，当同一个页面在历史记录间切换时，就会派发<code>popstate</code>事件。</p><p>正常情况下，用户点击后退按钮或者调用<code>history.back() or history.go()</code>，页面根本没有处理事件的机会，因为这些操作会使得页面<code>reload</code>，所以<code>popstate</code>只在不会让浏览器页面刷新的历史记录之间切换才能触发，这些历史记录一般由<code>pushState/replaceState</code>或者是由<code>hash</code>锚点等操作产生，并且在事件的句柄中可以访问state对象的引用副本！</p><p>单纯的调用<code>pushState/replaceState</code>并不会触发<code>popstate</code>事件。</p><p>页面初次加载时，是否会主动触发<code>popstate</code>事件，不同的浏览器实现不一样。下面是一个官方demo。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"location: "</span> + <span class="built_in">document</span>.location + <span class="string">", state: "</span> +   <span class="built_in">JSON</span>.stringify(event.state));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">1</span>&#125;, <span class="string">"title 1"</span>, <span class="string">"?page=1"</span>);</span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">2</span>&#125;, <span class="string">"title 2"</span>, <span class="string">"?page=2"</span>);</span><br><span class="line">history.replaceState(&#123;<span class="attr">page</span>: <span class="number">3</span>&#125;, <span class="string">"title 3"</span>, <span class="string">"?page=3"</span>);</span><br><span class="line">history.back(); <span class="comment">// alerts "location: http://example.com/example.html?page=1, state: &#123;"page":1&#125;"</span></span><br><span class="line">history.back(); <span class="comment">// alerts "location: http://example.com/example.html, state: null</span></span><br><span class="line">history.go(<span class="number">2</span>); <span class="comment">// alerts "location: http://example.com/example.html?page=3, state: &#123;"page":3&#125;</span></span><br></pre></td></tr></table></figure><p>兼容性测试脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"node_modules/jquery/dist/jquery.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(history &amp;&amp; history.pushState) &#123;</span><br><span class="line">        alert(<span class="string">"true"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">"false"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    $(<span class="built_in">window</span>).on(<span class="string">"hashchange"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"hashchange"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>兼容性概览：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">history &amp;&amp; history.pushState兼容如下：</span><br><span class="line">    chrome true；</span><br><span class="line">    Firefox true；</span><br><span class="line">    IE10 true;</span><br><span class="line">    IE &lt;= <span class="number">9</span> false;  </span><br><span class="line"><span class="function">    PS:<span class="title">IE</span> &lt;= 9既然不支持这些<span class="title">api</span>那就只能采用<span class="title">hash</span>方案，来实现路由系统的兼容了。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">hashchange</span>兼容如下：</span></span><br><span class="line"><span class="function">    <span class="title">IE9</span> <span class="title">true</span>;</span></span><br><span class="line"><span class="function">    <span class="title">IE8</span> <span class="title">true</span>;</span></span><br><span class="line"><span class="function">    <span class="title">IE7</span> <span class="title">false</span>;</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">页面<span class="title">load</span>时，<span class="title">onhashchange</span>默认触发情况：</span></span><br><span class="line"><span class="function">    <span class="title">chrome</span> 需主动<span class="title">trigger</span>才能触发</span></span><br><span class="line"><span class="function">    <span class="title">FF</span> 需主动<span class="title">trigger</span>才能触发</span></span><br><span class="line"><span class="function">    <span class="title">IE</span> 需主动<span class="title">trigger</span>才能触发</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">页面<span class="title">load</span>时，<span class="title">onpopstate</span>默认触发情况：</span></span><br><span class="line"><span class="function">    <span class="title">chrome</span> &lt; 34版本之前的默认触发 </span></span><br><span class="line"><span class="function">    <span class="title">FF</span> 默认不触发</span></span><br><span class="line"><span class="function">    <span class="title">IE</span> 默认不触发</span></span><br></pre></td></tr></table></figure><p>只有webkit内核浏览器才会默认触发<code>popstate</code>。</p><h4 id="3-两种实现的比较"><a href="#3-两种实现的比较" class="headerlink" title="3. 两种实现的比较"></a>3. 两种实现的比较</h4><ul><li><p>基于<code>Hash</code>的路由，兼容性更好</p></li><li><p>基于<code>History API</code>的路由，更加直观和正式</p></li></ul><p>有一点很大的区别是，基于<code>Hash</code>的路由不需要对服务器做改动，基于<code>History API</code>的路由需要对服务器做一些改造。</p><p>浏览器第一次打开某个链接时，首先会定向到<code>server</code>端进行路由解析。上边所说的前端路由系统，都是建立在页面已经打开的前提下，前端才可以通过<code>History API</code>进行URL拦截，确保这些URL变化不会发送给<code>server</code>端返回新页面。</p><p>但是需要考虑这种情况，链接时在一个新的浏览器tab中打开的，那么这个时候就无法拦截下这个URL，所以，这就要求server和前端制定好一个规则，区分URL中<strong><em>前端解析的部分</em></strong>和<strong><em>后端解析的部分</em></strong>，<code>server</code>端判断出这个URL的某个部分不属于自己的范围时，就应该把这部分URL定向到前端路由页面的<code>javascript</code>代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodejs</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req.path.indexOf(<span class="string">'/routeForServer'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        res.send(<span class="string">'这里返回的都是server端处理的路由'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.sendfile(<span class="string">'这里返回配置好路由的页面'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>正常情况下，URL中的“/”一般是server端路由采用的标记，而“?”或者“#”再或者“#!”，则一般是前端路由采用的开始标记，我们可以在这些符号后边，通过键值对的形式，描述一个页面具有哪些板块配置信息。也不乏有的网站为了美观，前后端共用“/”进行路由索引。</p><p>URL中采用“#”或者“#!”进行前后端的区分，是为了照顾到更多浏览器，因为利用hash方案，IE对这套路由系统有很好的支持性。</p><hr><h3 id="四、动态路由"><a href="#四、动态路由" class="headerlink" title="四、动态路由"></a>四、动态路由</h3><p>上面提到的例子都是静态路由，即路径都是固定的。但是我们经常会需要在路径中传入参数，例如或者某个用户的信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodejs</span></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">百度：</span><br><span class="line"><span class="function">    https://<span class="title">wenku.baidu.com</span>/<span class="title">album</span>/<span class="title">list</span>?<span class="title">cid</span>=197</span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">zhidao.baidu.com</span>/<span class="title">daily</span>/<span class="title">view</span>?<span class="title">id</span>=47009</span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新浪：</span><br><span class="line"><span class="function">    http://<span class="title">sz.sina.com.cn</span>/<span class="title">news</span>/<span class="title">yz</span>/2016-09-02/<span class="title">detail</span>-<span class="title">ifxvqcts9207231.shtml</span>?<span class="title">from</span>=<span class="title">sz_tttj</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">京东：</span><br><span class="line"><span class="function">    https://<span class="title">item.jd.com</span>/3995645.<span class="title">html</span>#<span class="title">crumb</span>-<span class="title">wrap</span></span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">list.jd.com</span>/<span class="title">list.html</span>?<span class="title">cat</span>=9987,653,655&amp;<span class="title">ev</span>=%40<span class="title">exbrand_14026</span>&amp;<span class="title">go</span>=0</span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Google Gmail</span><br><span class="line"><span class="function">    https://<span class="title">mail.google.com</span>/<span class="title">mail</span>/<span class="title">u</span>/1/#<span class="title">inbox</span></span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">mail.google.com</span>/<span class="title">mail</span>/<span class="title">u</span>/1/#<span class="title">starred</span></span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">mail.google.com</span>/<span class="title">mail</span>/<span class="title">u</span>/1/#<span class="title">sent</span></span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">mail.google.com</span>/<span class="title">mail</span>/<span class="title">u</span>/1/#<span class="title">drafts</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate" target="_blank" rel="noopener">MDN官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是路由？简单的来说，路由是 &lt;strong&gt;&lt;em&gt;URL –&amp;gt; 函数&lt;/em&gt;&lt;/strong&gt; 的映射关系。&lt;/p&gt;
&lt;p&gt;大部分复杂的网站，都会把业务解耦为模块进行处理。这些网站中又有很多的网站会把适合的部分应用Ajax进行数据交互，展现给用户，很明显处理这样的数据通信交互，不可避免的会涉及到跟URL打交道，让数据交互的变化反映到URL的变化上，进而可以给用户机会去通过保存的URL链接，还原刚才的页面内容板块的布局，这其中包括Ajax局部刷新的变化。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="前端路由" scheme="http://www.xiaoleon.cn/tags/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
    
      <category term="Hash" scheme="http://www.xiaoleon.cn/tags/Hash/"/>
    
      <category term="History" scheme="http://www.xiaoleon.cn/tags/History/"/>
    
  </entry>
  
  <entry>
    <title>Web(6) 浏览器页面的渲染过程</title>
    <link href="http://www.xiaoleon.cn/2018/03/12/web-6/"/>
    <id>http://www.xiaoleon.cn/2018/03/12/web-6/</id>
    <published>2018-03-12T02:52:44.000Z</published>
    <updated>2018-03-12T14:01:55.037Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器在下载好HTML、CSS、JS等文件后，是如何将这些内容组装成绚丽的页面呈现给用户呢？不同的浏览器渲染过程实际上并不相同，但是依旧存在相一致的部分。</p><a id="more"></a><h3 id="一、浏览器渲染页面"><a href="#一、浏览器渲染页面" class="headerlink" title="一、浏览器渲染页面"></a>一、浏览器渲染页面</h3><p>从浏览器地址栏的请求链接开始，浏览器通过DNS解析查到域名映射的IP地址，成功之后浏览器端向此IP地址取得连接。成功连接之后，浏览器端将请求头信息通过HTTP协议向此IP地址所在服务器发起请求。服务器接收到请求之后等待处理，最后向浏览器端发回响应，此时在HTTP协议下，浏览器从服务器接收到text/html类型的代码，浏览器开始显示此HTML，并获取其中内嵌资源文件，然后浏览器再发起请求来获取这些资源，并在浏览器的html中显示。</p><p>浏览器解析的大概的工作流程可以分为以下几个步骤：</p><ul><li><p>1) 用户输入网址（假设是HTML页面，第一次访问，无缓存情况），浏览器向服务器发出HTTP请求，服务器返回HTML文件</p><p>  优化方案：善用缓存，减少HTTP请求，减轻服务器压力</p></li><li><p>2) 浏览器载入HTML代码，发现head内有一个link引用外部css文件，则浏览器立即发送css文件请求，获取浏览器返回的css文件</p><p>  优化方案：css文件合并，减少HTTP请求</p></li><li><p>3) 浏览器继续载入HTML中body部分的代码，并且css文件已经拿到手了，可以开始渲染页面了</p><p>  优化方案：css文件要放在最上面，避免网页重新渲染</p></li><li><p>4) 浏览器在代码中发现一个img标签引用了一张图片，向服务器发出请求，此时浏览器不会等到图片下载完，而是继续渲染后面的代码</p><p>  优化方案：图片文件合并，减少HTTP请求</p></li><li><p>5) 服务器返回图片文件，由于占用了一定面积，影响后面段落的布局，因此浏览器需要回过头来重新渲染这部分代码</p><p>  优化方案：最好图片都设置尺寸，避免重新渲染</p></li><li><p>6) 浏览器发现一个包含一行JavaScript的script标签，会立即运行该js代码</p><p>  优化方案：script最好放在页面最下面</p></li><li><p>7) js脚本执行了语句，它令浏览器隐藏掉代码中的某个div，突然就少了一个元素，浏览器不得不重新渲染这部分代码</p><p>  优化方案：页面初始化样式不要使用js控制</p></li><li><p>8) 浏览器完成渲染，展示HTML页面</p></li></ul><hr><h3 id="二、重绘和回流"><a href="#二、重绘和回流" class="headerlink" title="二、重绘和回流"></a>二、重绘和回流</h3><h4 id="1-什么是重绘和回流"><a href="#1-什么是重绘和回流" class="headerlink" title="1. 什么是重绘和回流"></a>1. 什么是重绘和回流</h4><p>为什么页面会慢？那是因为浏览器需要花时间去渲染，尤其是当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，该过程称为回流（<code>reflow</code>）。</p><p><code>reflow</code>几乎是无法避免的，现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的<code>reflow</code>。鼠标滑过、点击等等，只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会<code>reflow</code>哪一部分的代码，它们都彼此相互影响着。</p><p>如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器的重绘（<code>repaint</code>）。</p><p><code>repaint</code>的速度明显快于<code>reflow</code>（在IE下需要换一下说法，<code>reflow</code>要比<code>repaint</code>更缓慢）。</p><p><code>repaint操</code>作触发时，元素的外观被改变，且在没有改变布局的情况下发生，如改变<code>outline</code>、<code>visibility</code>、<code>background-color</code>，不会影响到dom结构渲染。</p><p><code>reflow</code>与<code>repaint</code>区别就是它会影响到dom的结构渲染，同时它会触发<code>repaint</code>，它会改变它本身与所有父辈元素，这种开销是非常昂贵的，导致性能下降是必然的，页面元素越多效果越明显。</p><p>注意：回流必将引起重绘，重绘不一定引起回流。</p><h4 id="2-如何减少重绘和回流"><a href="#2-如何减少重绘和回流" class="headerlink" title="2. 如何减少重绘和回流"></a>2. 如何减少重绘和回流</h4><p><code>reflow</code>是不可避免的，只能将<code>reflow</code>对性能的影响减少到最小</p><ul><li><p>1) 不要一条一条地修改DOM样式，通过设置<code>style</code>属性改变节点样式的话，每设置一次都会导致一次<code>reflow</code>。所以最好通过设置<code>class</code>的方式，这样可以将多次改变样式属性的操作合并成一次操作</p></li><li><p>2) 让要操作的元素进行“离线处理”，处理完后一起更新</p><ul><li><p>使用<code>DocumentFragment</code>进行缓存操作，引发一次重绘与回流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">fragment.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Hello Zhang Xiao!'</span>));</span><br><span class="line"></span><br><span class="line">fragment.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'br'</span>));</span><br><span class="line"></span><br><span class="line">fragment.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Hello Leon!'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(fragment);</span><br></pre></td></tr></table></figure></li><li><p>使用<code>display: none</code>技术，只引发两次重绘与回流</p><p>原理：由于<code>display</code>属性为<code>none</code>的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样在隐藏和显示时触发2次重排。</p></li></ul></li><li><p>3) 设置元素的<code>position</code>为<code>absolute</code>或<code>fixed</code></p></li></ul><p>元素脱离标准文档流，也从DOM树结构中脱离出来，在需要<code>reflow</code>时只需要<code>reflow</code>自身与下级元素。</p><ul><li>4) 不要使用table布局</li></ul><p>table中某个元素一旦触发<code>reflow</code>就会导致table里所有的其他元素<code>reflow</code>。在适合用table的场合，可以设置<code>table-layout</code>为<code>auto</code>或<code>fixed</code>，这样可以让table一行一行的渲染，这种做法也是为了限制<code>reflow</code>的影响范围。</p><ul><li>5) 避免使用css的JavaScript表达式，如果css里有<code>expression</code>，每次都会重新计算一次。</li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://www.jianshu.com/p/7fbd239ca0e2?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">浏览器如何渲染页面</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器在下载好HTML、CSS、JS等文件后，是如何将这些内容组装成绚丽的页面呈现给用户呢？不同的浏览器渲染过程实际上并不相同，但是依旧存在相一致的部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="页面渲染" scheme="http://www.xiaoleon.cn/tags/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/"/>
    
      <category term="重绘" scheme="http://www.xiaoleon.cn/tags/%E9%87%8D%E7%BB%98/"/>
    
      <category term="回流" scheme="http://www.xiaoleon.cn/tags/%E5%9B%9E%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>React(3) 从Flux到Redux</title>
    <link href="http://www.xiaoleon.cn/2018/03/06/react-3/"/>
    <id>http://www.xiaoleon.cn/2018/03/06/react-3/</id>
    <published>2018-03-06T15:05:43.000Z</published>
    <updated>2018-03-19T13:15:53.841Z</updated>
    
    <content type="html"><![CDATA[<p>在前一章中我们已经感受到完全用React来管理应用数据的麻烦，在这一章中，我们将介绍Redux这种管理应用状态的框架</p><a id="more"></a><p>本章包含以下内容：</p><ul><li><p>单向数据流框架的始祖Flux</p></li><li><p>Flux理念的一个更强实现Redux</p></li><li><p>结合React和Redux</p></li></ul><h3 id="一、Flux"><a href="#一、Flux" class="headerlink" title="一、Flux"></a>一、Flux</h3><p>要了解Redux，首先要从Flux说起，可以认为Redux是Flux思想的另一种实现方式，通过了解Flux，我们可以知道Flux一族框架（其中就包括Redux）贯彻的最重要的观点——单向数据流，更重要的是，我们可以发现Flux框架的缺点，从而深刻地认识到Redux相对于Flux的改进之处。</p><p>让我们来看看Flux的历史，实际上，Flux是和React同时面世的，在2013年，Facebook公司让React亮相的同时，也推出了Flux框架，React和Flux相辅相成，Facebook认为两者结合在一起才能构建大型的JavaScript应用。</p><p>做一个容易理解的对比，React是用来替换jQuery的，那么Flux就是以替换Backbone.js、Ember.js等MVC一族框架为目的。</p><p>在MVC（Model-View-Controller）的世界里，React相当于V（View）的部分，只涉及页面的渲染，一旦涉及应用的数据管理部分，还是交给Model和Controller，不过，Flux并不是一个MVC框架，事实上，Flux认为MVC框架存在很大问题，它推翻了MVC框架，并用一个新的思维来管理数据流转。</p><h4 id="1-MVC框架的缺陷"><a href="#1-MVC框架的缺陷" class="headerlink" title="1. MVC框架的缺陷"></a>1. MVC框架的缺陷</h4><p>MVC框架是业界广泛接受的一种前端应用框架类型，这种框架把应用分成三个部分：</p><ul><li><p>Model（模型）：负责管理数据，大部分业务逻辑也应该放在Model中</p></li><li><p>View（视图）：负责渲染用户界面，应该避免在View中涉及业务逻辑</p></li><li><p>Controller（控制器）：负责接受用户输入，根据用户输入调用对应的Model部分逻辑，把产生的数据结果交给View部分，让View渲染出必要的输出。</p></li></ul><p>MVC框架的几个组成部分和请求的关系如图所示</p><p><img src="/images/react-3/1.png" alt="MVC框架"></p><p>这样的逻辑划分，实质上与把以一个应用划分为多个组件一样，就是“分而治之”。毫无疑问，相比把业务逻辑和界面渲染逻辑混在一起，MVC框架要先进得多。这种方式得到了广泛的认可，连Facebook最初也是用这种框架。</p><p>但是，Facebook的工程部门逐渐发现，对于非常巨大的代码库和庞大的组织，按照他们的原话说就是“MVC真的很快就变得非常复杂”。每当工程师想要增加一个新的功能时，对代码的修改很容易引入新的bug，因为不同模块之间的依赖关系让系统变得“脆弱而且不可预测”。对于刚刚加入团队的新手，更是举步维艰，因为不知道修改代码会造成什么样的后果。如果要保险，就会发现寸步难移；如果放手去干，就可能引发很多bug。</p><p>一句话，MVC根本不适合Facebook的需求。</p><p>为何被业界普遍认可的MVC框架在Facebook眼里却沦落到如此地步呢？</p><p>下图是Facebook描述的MVC框架，在图中我们可以看到，Model和View之间缠绕着蜘蛛网一样复杂的依赖关系，根据箭头的方向，我们知道有的是Model调用了View，有的是View调用了Model，很乱。</p><p><img src="/images/react-3/2.png" alt="MVC的缺点"></p><p>MVC框架提出的数据流很理想，用户请求先到达Controller，由Controller调用Model获得数据，然后把数据交给View，但是，在实际框架实现中，总是允许View和Model可以直接通信，从而出现上图的情况。越来越多的同行发现，在MVC中让View和Model直接对话就是灾难。</p><p>当我向以前没接触过Flux的朋友介绍Flux的时候，发现了一个有意思的现象。凡是只在服务器端使用过MVC框架的朋友，就很容易理解和接受Flux。而对于已经有很多浏览器端MVC框架经验的朋友，往往还要费一点劲才能明白MVC和Flux的差异。</p><p>造成这种认知差别的主要原因，就是服务器端MVC框架往往就是每个请求就只在Controller-Model-View三者之间走一圈，结果就返回给浏览器去渲染或者其他处理了，然后这个请求生命周期的Controller-Model-View就可以回收销毁了，这是一个严格意义的单向数据流；对于浏览器端MVC框架，存在用户的交互处理，界面渲染出来之后，Model和View依然处在于浏览器中，这时候就会诱惑开发者为了简便，让现存的Model和View直接对话。</p><p>对于MVC框架，为了让数据流可控，Controller应该是中心，当View要传递消息给Model时，应该调用Controller的方法，同样，当Model要更新View时，也应该通过Controller引发新的渲染。</p><p>当Facebook推出Flux时，招致了很多质疑。很多人都说，Flux只不过是一个对数据流管理更加严格的MVC框架而已。这种说法不完全准确，但是一定意义上也说明了Flux的一个特点：更严格的数据流控制。</p><p>Facebook无心在MVC框架上纠缠，他们用Flux框架来代替原有的MVC框架，他们提出的Flux框架大致结构如图所示</p><p><img src="/images/react-3/3.png" alt="Flux的单向数据流"></p><p>一个Flux应用包含四个部分，我们先粗略了解一下：</p><ul><li><p>Dispatcher：处理动作分发，维持Store之间的依赖关系</p></li><li><p>Store：负责存储数据和处理数据相关逻辑</p></li><li><p>Action：驱动Dispatcher的JavaScript对象</p></li><li><p>View：视图部分，负责显示用户界面</p></li></ul><p>如果非要把Flux和MVC做一个结构对比，那么，Flux的Dispatcher相当于MVC的Controller，Flux的Store相当于MVC的Model，Flux的View当然就对应MVC的View，至于多出来的这个Action，可以理解为对应MVC框架的用户请求。</p><p>在MVC框架中，系统能够提供什么样的服务，通过Controller暴露函数来实现。每增加一个功能，Controller往往就要增加一个函数；在Flux的世界里，新增加功能并不需要Dispatcher增加新的函数，实际上，Dispatcher自始至终只需要暴露一个函数Dispatch，当需要增加新的功能时，要做的是增加一种新的Action类型，Dispatcher的对外接口并不用改变。</p><p>当需要扩充应用所能处理的“请求”时，MVC方法就需要增加新的Controller，而对于Flux则只是增加新的Action。</p><p>下面我们看看怎么用Flux改进我们的React应用。</p><p><em>**</em> 2. Flux应用</p><p>让我们改进一下前面创造的ControlPanel应用，Flux提供了一些辅助工具类和函数，能够帮助创建Flux应用，但是需要一些学习曲线。在这里，我们只用Facebook官方的基本功能，目的是为了更清晰地看一看Flux的工作原理。</p><p>首先通过命令行在项目目录下安装Flux。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save flux</span><br></pre></td></tr></table></figure><p>利用Flux实现ControlPanel应用后的界面效果与前面创造的应用完全一样，通过同一界面不同实现方式的比对，我们可以体会每个方式的优劣。</p><ul><li>1) Dispatcher</li></ul><p>首先，我们要创造一个Dispatcher，几乎所有应用都只需要拥有一个Dispatcher，对于我们这个简单的应用更不例外。在src/AppDispatcher.js中，我们创造这个唯一的Dispatcher对象，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Dispatcher&#125; <span class="keyword">from</span> <span class="string">'flux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Dispatcher();</span><br></pre></td></tr></table></figure><p>非常简单，我们引入flux库中的Dispatcher类，然后创造一个新的对象作为这个文件的默认输出就足够了。在其他代码中，将会引用这个全局唯一的Dispatcher对象。</p><p>Dispatcher存在的作用，就是用来派发action，接下来我们就来定义应用中涉及的action。</p><ul><li>2) action</li></ul><p>action顾名思义代表一个“动作”，不过这个动作只是一个普通的JavaScript对象，代表一个动作的纯数据，类似于DOM API中的事件（event）。甚至，和事件相比，action其实还是更加纯粹的数据对象，因为事件往往还包含一些方法，比如点击事件就有preventDefault方法，但是action对象不自带方法，就是纯粹的数据。</p><p>作为管理，action对象必须有一个名为type的字段，代表这个action对象的类型，为了记录日志和debug方便，这个type应该是字符串类型。</p><p>定义action通常需要两个文件，一个定义action的类型，一个定义action的构造函数（也称为action creator）。分成两个文件的主要原因是Store中会根据action类型做不同操作，也就有单独导入action类型的需要。</p><p>在src/ActionTypes.js中，我们定义action的类型，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">'increment'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT = <span class="string">'decrement'</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，用户只能做两个动作，一个是点击“<code>+</code>”按钮，一个是点击“<code>-</code>”按钮，所以我们只有两个action类型INCREMENT和DECREMENT。</p><p>现在我们在src/Actions.js文件中定义action构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ActionTypes <span class="keyword">from</span> <span class="string">'./ActionTypes.js'</span>;</span><br><span class="line"><span class="keyword">import</span> AppDispatcher <span class="keyword">from</span> <span class="string">'./AppDispatcher.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function">(<span class="params">counterCaption</span>) =&gt;</span> &#123;</span><br><span class="line">  AppDispatcher.dispatch(&#123;</span><br><span class="line">    type: ActionTypes.INCREMENT,</span><br><span class="line">    counterCaption: counterCaption</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function">(<span class="params">counterCaption</span>) =&gt;</span> &#123;</span><br><span class="line">  AppDispatcher.dispatch(&#123;</span><br><span class="line">    type: ActionTypes.DECREMENT,</span><br><span class="line">    counterCaption: counterCaption</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然出于业界习惯，这个文件被命名为Actions.js，但是要注意里面定义的并不是action对象本身，而是能够产生并派发action对象的函数。</p><p>在Actions.js文件中，引入了ActionTypes和AppDispatcher，看得出来是要直接使用Dispatcher。</p><p>这个Actions.js导出了两个action构造函数increment和decrement，当这两个函数被调用的时候，创造了对应的action对象，并立即通过AppDispatcher.dispatch函数派发出去。</p><p>派发出去的action对象最后怎么样了呢？下面关于Store的部分可以看到。</p><ul><li>3) Store</li></ul><p>一个Store也是一个对象，这个对象存储应用状态，同时还要接受Dispatcher派发的动作，根据动作来决定是否要更新应用状态。</p><p>接下来我们创造Store相关的代码，因为使用Flux之后代码文件数量会增多，再把所有源代码文件都放在src目录下就不容易管理了。所以我们在src下创建一个子目录stores，在这个子目录里放置所有的Store代码。</p><p>在前面章节的ControlPanel应用例子里，有三个Counter组件，还有一个统计三个Counter计数值之和的功能，我们遇到的麻烦就是这两者之间的状态如何同步的问题，现在，我们创造两个Store，一个是为Counter组件服务的CounterStore，另一个就是为总数服务的SummaryStore。</p><p>我们首先添加CounterStore，放在src/stores/CounterStore.js文件中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterValues = &#123;</span><br><span class="line">  <span class="string">'First'</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">'Second'</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="string">'Third'</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CounterStore = <span class="built_in">Object</span>.assign(&#123;&#125;, EventEmitter.prototype, &#123;</span><br><span class="line">  getCounterValues: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> counterValues;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  emitChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.emit(CHANGE_EVENT);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addChangeListener: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.on(CHANGE_EVENT, callback);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  removeChangeListener: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.removeListener(CHANGE_EVENT, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当Store的状态发生变化的时候，需要通知应用的其它部分做必要的响应。在我们的应用中，做出响应的部分当然就是View部分，但是我们不应该硬编码这种联系，应该用消息的方式建立Store和View的联系。这就是为什么我们让CounterStore扩展了EventEmitter.prototype，等于让CounterStore成了EventEmitter对象，一个EventEmitter实例对象支持下列相关函数。</p><ul><li><p>emit函数，可以广播一个特定事件，第一个参数是字符串类型的事件名称</p></li><li><p>on函数，可以增加一个挂在这个EventEmitter对象特定事件上的处理函数，第一个参数是字符串类型的事件名称，第二个参数是处理函数</p></li><li><p>removeListener函数，和on函数做的事情相反，删除挂在这个EventEmitter对象特定事件上的处理函数，和on函数一样，第一个参数是事件名称，第二个参数是处理函数。要注意，如果要调用removeListener函数，就一定要保留对处理函数的引用</p></li></ul><p>对于CounterStore对象，emitChange、addChangeListener和removeChangeListener函数就是利用EventEmitter上述的三个函数完成对CounterStore状态更新的广播、添加监听函数和删除监听函数等操作。</p><p>CounterStore函数还提供一个getCounterValues函数，用于让应用中其他模块可以读取当前的计数值，当前的计数值存储在文件模块级的变量counterValues中。</p><p>上面实现的Store只有注册到Dispatcher实例上才能真正发挥作用，所以还需要增加下列代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AppDispatcher <span class="keyword">from</span> <span class="string">'../AppDispatcher.js'</span>;</span><br><span class="line"></span><br><span class="line">CounterStore.dispatchToken = AppDispatcher.register(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ActionTypes.INCREMENT) &#123;</span><br><span class="line">    counterValues[action.counterCaption]++;</span><br><span class="line">    CounterStore.emitChange();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === ActionTypes.DECREMENT) &#123;</span><br><span class="line">    counterValues[action.counterCaption]--;</span><br><span class="line">    CounterStore.emitChange();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是最重要的一个步骤，要把CounterStore注册到全局唯一的Dispatcher上去。Dispatcher有一个函数叫做register，接受一个回调函数作为参数。返回值是一个token，这个token可以用于Store之间的同步，我们在CounterStore中还用不上这个返回值，在稍后的SummaryStore中会用到，现在我们只是把register函数的返回值保存在CounterStore对象的dispatchToken字段上，待会就会用得到。</p><p>现在我们来仔细看看register接受的这个回调函数参数，这是Flux流程中最核心的部分，当通过register函数把一个回调函数注册到Dispatcher之后，所有派发给Dispatcher的action对象，都会传递到这个回调函数中来。</p><p>比如通过Dispatcher派发一个动作，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AppDispatcher.dispatch(&#123;</span><br><span class="line">  type: ActionTypes.INCREMENT,</span><br><span class="line">  counterCaption: <span class="string">'First'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那在CounterStore注册的回调函数就会被调用，唯一的一个参数就是那个action对象，回调函数要做的，就是根据action对象来决定如何更新自己的状态。</p><p>作为一个普遍接受的传统，action对象中必须要有一个type字段，类型是字符串，用于表示这个action对象是什么类型，比如上面派发的action对象，type为“increment”，表示是一个计数器“加一”的动作；如果有必要，一个action对象还可以包含其他的字段。上面的action对象中还有一个counterCaption字段值为“First”，标识名字为“First”的计数器。</p><p>在我们的例子中，action对象的type和counterCaption字段结合在一起，可以确定是哪个计数器应该做加一或者减一的动作，上面例子中的动作含义就是：“名字为First的计数器要做加一动作。”</p><p>根据不同的type，会有不同的操作，所以注册的回调函数很自然有一个模式，就是函数体是一串if-else条件语句或者switch条件语句，而条件语句的跳转条件，都是针对参数action对象的type字段:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CounterStore.dispatchToken = AppDispatcher.register(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ActionTypes.INCREMENT) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === ActionTypes.DECREMENT) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>无论是加一还是减一，最后都要调用counterStore.emitChange函数，假如有调用者通过Counter.addChangeListener关注了CounterStore的状态变化，这个emitChange函数调用就会引发监听函数的执行。</p><p>目前，CounterStore只关注INCREMENT和DECREMENT动作，所以if-else判断也只关注了这两种类型的动作，除此之外，其他action对象一律忽略。</p><p>接下来，我们再来看看另一个Store，也就是代表所有计数器计数值综合的Store，在src/stores/SummaryStore.js中。</p><p>SummaryStore也有emitChange、addChangeListener还有removeChangeListener函数，功能一样也是用于通知监听者状态变化，这几个函数的代码和CounterStore中完全重复，不同点是对获取状态函数的定义，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeSummary</span>(<span class="params">counterValues</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> summary = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> counterValues) &#123;</span><br><span class="line">    <span class="keyword">if</span> (counterValues.hasOwnProperty(key)) &#123;</span><br><span class="line">      summary += counterValues[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> summary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SummaryStore = <span class="built_in">Object</span>.assign(&#123;&#125;, EventEmitter.prototype, &#123;</span><br><span class="line">  getSummary: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> computeSummary(CounterStore.getCounterValues());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以注意到，SummaryStore并没有存储自己的状态，当getSummary被调用时，它是直接从CounterStore里获取状态计算的。</p><p>CounterStore提供了getCounterValues函数让其他模块能够获得所有计数器的值，SummaryStore也提供了getSummary让其他模块可以获得所有计数器当前的总和。不过，既然总可以通过CounterStore.getCounterValues函数获取最新鲜的数据，SummaryStore似乎也就没有必要把计数器总和存储到某个变量里。事实上，可以看到SummaryStore并不像CounterStore一样用一个变量counterValues存储数据，SummaryStore不存储数据，而是每次对getSummary的调用，都实时读取CounterStore.getCounterValues，然后实时计算总和返回给调用者。</p><p>可见，虽然名为Store，但并不表示一个Store必须要存储什么东西，Store只是提供获取数据的方法，而Store提供的数据完全可以另一个Store计算得来。</p><p>SummaryStore在Dispatcher上注册的回调函数也和CounterStore很不一样，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SummaryStore.dispatchToken = AppDispatcher.register(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((action.type === ActionTypes.INCREMENT) ||</span><br><span class="line">      (action.type === ActionTypes.DECREMENT)) &#123;</span><br><span class="line">        AppDispatcher.waitFor([CounterStore.dispatchToken]);</span><br><span class="line">        SummaryStore.emitChange();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>SummaryStore同样也通过AppDispatcher.register函数注册了一个回调函数，用于接受派发的action对象。在回调函数中，也只关注了INCREMENT和DECREMENT类型的action对象，并通过emitChange通知监听者，注意在这里使用了waitFor函数，这个函数解决的是下面描述的问题。</p><p>既然一个action对象会被派发给所有回调函数，这就产生了一个问题，到底是按照什么顺序调用各个回调函数呢？</p><p>即使Flux按照register调用的顺序去调用各个回调函数，我们也完全无法把握各个Store哪个先装载从而调用register函数。所以，可以认为Dispatcher调用回调函数的顺序完全是无法预期的，不要假设它会按照我们期望的顺序逐个调用。</p><p>怎么解决这个问题呢？这就要靠Dispatcher的waitFor函数了。在SummaryStore的回调函数中，之前在CounterStore中注册回调函数时保存下来的dispatchToken终于派上用场了。</p><p>Dispatcher的waitFor可以接受一个数组作为参数，数组中的每个元素都是一个Dispatcher.register函数的返回结果，也就是所谓的dispatchToken。这个waitFor函数告诉Dispatcher，当前的处理必须要暂停，直到dispatchToken代表的那些已注册回调函数执行结束才能继续。</p><p>我们知道，JavaScript是单线程语言，不可能有线程之间的等待这回事，这个waitFor函数当然不是用多线程实现的，只是在调用waitFor的时候，把控制权交给Dispatcher，让Dispatcher检查一下dispatchToken代表的回调函数有没有被执行，如果已经执行，那就直接继续，如果还没有执行，那就调用dispatchToken代表的回调函数之后waitFor才返回。</p><p>回到我们上面的例子，即使SummaryStore比CounterStore提前接收到了action对象，在emitChange中调用waitFor，也就能够保证emitChange函数被调用的时候，CounterStore也已经处理过这个action对象。</p><p>这里要注意一个事实，Dispatcher的register函数，只提供了一个回调函数的功能，但却不能让调用者在register时选择只监听某些action，换句话说，每个register的调用者只能这样请求：“当有任何动作被派发时，请调用我。”但不能够这么请求：“当这种类型还有那种类型的动作被派发的时候，请调用我。”</p><p>当一个动作被派发的时候，Dispatcher就是简单地把所有注册的回调函数全都调用一遍，至于这个动作是不是对方关心的，Flux的Dispatcher不关心，要求每个回调函数去鉴别。</p><p>看起来，这似乎是一种浪费，但是这个设计让Flux的Dispatcher逻辑最简单化，Dispatcher的责任越简单，就越不会出现问题。毕竟，由回调函数全权决定如何处理action对象，也是非常合理的。</p><ul><li>4) View</li></ul><p>首先要说明，Flux框架下，View并不是说必须要使用React，View本身是一个独立的部分，可以用任何一种UI库来实现。</p><p>不过，话说回来，既然我们都使用上Flux了，除非项目有大量历史遗留代码，否则实在没有理由不用React来实现View。</p><p>存在于Flux框架中的React组件需要实现以下几个功能：</p><ul><li><p>创建时要读取Store上状态来初始化组件内部状态</p></li><li><p>当Store上状态发生变化时，组件要立刻同步更新内部状态保持一致</p></li><li><p>View如果要改变Store状态，必须且只能派发action</p></li></ul><p>最后让我们来看看例子中的View部分，为了方便管理，所有View文件都放在src/views目录里。</p><p>先看src/views/ControlPanel.js中的ControlPanel组件，其中render函数的实现和上一章很不一样，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;style&#125;&gt;</span><br><span class="line">      &lt;Counter caption=<span class="string">'First'</span> /&gt;</span><br><span class="line">      &lt;Counter caption=<span class="string">'Second'</span> /&gt;</span><br><span class="line">      &lt;Counter caption=<span class="string">'Third'</span> /&gt;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &lt;Summary /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>可以注意到，和前面章节中的ControlPanel不同，Counter组件实例只有caption属性，没有initValue属性。因为我们把计数值包括初始值全都放到CounterStore中去了，所以在创造Counter组件实例的时候就没必要指定initValue了。</p><p>接着看src/views/Counter.js中定义的Counter组件，构造函数中初始化this.state的方式有了变化，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.onChange = <span class="keyword">this</span>.onChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.onClickIncrementButton = <span class="keyword">this</span>.onClickIncrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.onClickDecrementButton = <span class="keyword">this</span>.onClickDecrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    count: CounterStore.getCounterValues()[props.cpation]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中，CounterStore.getCounterValues函数获得了所有计数器的当前值，然后把this.state初始化为对应caption字段的值，也就是说Counter组件的store来源不再是prop，而是Flux的Store。</p><p>Counter组件中的state应该成为Flux Store上状态的一个同步镜像，为了保持两者一致，除了在构造函数中的初始化之外，在之后当CounterStore上状态变化时，Counter组件也要对应变化，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  CounterStore.addChangeListener(<span class="keyword">this</span>.onChange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  CounterStore.removeChangeListener(<span class="keyword">this</span>.onChange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onChange() &#123;</span><br><span class="line">  <span class="keyword">const</span> newCount = CounterStore.getCounterValues()[<span class="keyword">this</span>.props.caption];</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: newCount &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码所示，在componentDidMount函数中通过CounterStore.addChangeListener函数监听了CounterStore的变化之后，只要CounterStore发生变化，Counter组件的onChange函数就会被调用。与componentDidMount函数中监听事件对应，在componentWillUnmount函数中删除了这个监听。</p><p>接下来，要看React组件如何派发action，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">onClickIncrementButton() &#123;</span><br><span class="line">  Actions.increment(<span class="keyword">this</span>.props.action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onClickDecrementButton() &#123;</span><br><span class="line">  Actions.decrement(<span class="keyword">this</span>.props.action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;caption&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onClickIncrementButton&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onClickDecrementButton&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;caption&#125; count: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，在Counter组件中有两处用到CounterStore的getCounterValues函数的地方，第一处在构造函数中初始化this.state的时候，第二处是在响应CounterStore状态变化的onChange函数中，同样一个Store的状态，为了转换为React组件的状态，有两次重复的调用，这看起来似乎不是很好。但是，React组件的状态就是这样，在构造函数中要对this.state初始化，要更新它就要调用this.setState函数。</p><p>有没有更简洁的办法？比如说只使用CounterStore.getCounterValues一次？可惜，只要我们想用组件的状态来驱动组件的渲染，就不可避免要有这两步。那么如果我们不利用组件的状态呢？</p><p>如果不使用组件的状态，那么我们就可以逃出这个必须在代码中使用Store两次的宿命，在接下来的章节里，我们会遇到这种“无状态”组件。</p><p>Summary组件，存在于src/views/Summary.js中，和Counter类似，在constructor中初始化组件状态，通过在componentDidMount中添加对SummaryStore的监听来同步状态，因为这个View不会有任何交互功能，所以没有派发出任何action。</p><h4 id="3-Flux的优势"><a href="#3-Flux的优势" class="headerlink" title="3. Flux的优势"></a>3. Flux的优势</h4><p>本章的例子和上一章我们只用React的实现效果一样，但是工作方式有了大变化。</p><p>回顾一下完全只用React实现的版本，应用的状态数据只存在于React组件之中，每个组件都要维护驱动自己渲染的状态数据，单个组件的状态还好维护，但是如果多个组件之间的状态有关联，但就麻烦了。比如Counter组件和Summary组件，Summary组件就需要维护所有Counter组件计数值的总和，Counter组件和Summary组件分别维护自己的状态，如何同步Summary和Counter状态就成了问题，React只提供了props方法让组件之间通信，组件之间关系稍微复杂一点，这种方式就显得非常笨拙。</p><p>Flux架构下，应用的状态被放在了Store中，React组件只是扮演View的作用，被动根据Store的状态来渲染。在上面的例子中，React组件依然有自己的状态，但是已经完全沦为Store组件的一个映射，而不是主动变化的数据。</p><p>在完全只用React实现的版本里，用户的交互操作，比如点击“<code>+</code>”按钮，引发的事件处理函数直接通过this.setState改变组件的状态。在Flux的实现版本里，用户的操作引发的是一个“动作”的派发，这个派发的动作会发送给所有的Store对象，引起Store对象的状态改变，而不是直接引发组件的状态改变。因为组件的状态是Store状态的映射，所以改变了Store对象也就触发了React组件对象的状态改变，从而引发了界面的重新渲染。</p><p>Flux带来了哪些好处呢？最重要的就是“单向数据流”的管理方式。</p><p>在Flux的理念里，如果要改变界面，必须改变Store中的状态，如果要改变Store中的状态，就必须派发一个action对象，这就是规矩。在这个规矩之下，想要追溯一个应用的逻辑就变得非常容易。</p><p>我们已经讨论过MVC框架的缺点，MVC最大的问题就是无法禁绝View与Model之间的直接对话，对应于MVC中的View就是Flux中的View，对应于MVC中Model的就是Flux中的Store。在Flux中，Store只有get方法，没有set方法，根本不可能直接去修改其内部状态，View只能通过get方法获取Store的状态，无法直接去修改状态，如果View想要修改Store状态的话，只有派发一个action给Dispatcher。</p><p>这看起来是一个“限制”，但却是一个很好地“限制”，禁绝了数据流混乱的可能。</p><p>简单来说，Flux的体系下，驱动界面改变始于一个动作的派发，别无他法。</p><h4 id="4-Flux的不足"><a href="#4-Flux的不足" class="headerlink" title="4. Flux的不足"></a>4. Flux的不足</h4><p>任何工具不可能只有优点没有缺点，接下来让我们看看Flux的不足之处，只有了解了Flux的不足之处，才能理解为什么会出现Flux的改进框架Redux。</p><ul><li>1) Store之间的依赖关系</li></ul><p>在Flux的体系中，如果两个Store之间有逻辑依赖关系，就必须用上Dispatcher的waitFor函数。在上面的例子中我们已经使用过waitFor函数，SummaryStore对action的处理，依赖于CounterStore已经处理过了。所以，必须要通过waitFor函数告诉Dispatcher，先让CounterStore处理这些action对象，只有CounterStore搞定之后SummaryStore才继续。</p><p>那么，SummaryStore如何标识CounterStore呢？靠的是register函数的返回值dispatchToken，而dispatchToken的产生，当然是CounterStore控制的，换句话说，要这样设计：</p><ul><li><p>CounterStore必须要把注册回调函数时产生的dispatchToken公之于众</p></li><li><p>SummaryStore必须要在代码里建立对CounterStore的dispatchToken的依赖</p></li></ul><p>虽然Flux这个设计的确解决了Store之间的依赖关系，但是，这样明显的模块之间的一来，看着还是让人感觉不太舒服，毕竟最好的依赖管理是根本不让依赖产生。</p><ul><li>2) 难以进行服务器端渲染</li></ul><p>关于服务器端渲染，我们在后面会详细介绍，在这里，我们只需要知道，如果要在服务器端渲染，输出不是一个DOM树，而是一个字符串，准确来说就是一个全是HTML的字符串。</p><p>在Flux的体系中，有一个全局的Dispatcher，然后每一个Store都是一个全局唯一的对象，这对于浏览器端应用完全没有问题，但是如果放在服务器端，就会有大问题。</p><p>和一个浏览器网页只服务于一个用户不同，在服务器端要同时接受很多用户的请求，如果每个Store都是全局唯一对象，那不同请求的状态肯定就乱套了。</p><p>并不是说Flux不能做服务器端渲染，只是说让Flux做服务器端渲染很困难，实际上，Facebook也说得很清楚，Flux不是设计用作服务器端渲染的，他们也从来没有尝试过把Flux应用于服务器端。</p><ul><li>3) Store混杂了逻辑和状态</li></ul><p>Store封装了数据和处理数据的逻辑，用面向对象的思维来看，这是一件好事，毕竟对象就是这样定义的。但是，当我们需要动态替换一个Store的逻辑时，只能把这个Store整体替换掉，那也就无法保持Store中存储的状态。</p><p>在开发模式下，开发人员要不停地对代码进行修改，如果Store在某个状态下引发了bug，如果能在不毁掉状态的情况下替换Store的逻辑，那就最好了，开发人员就可以不断地改进逻辑来验证这个状态下bug是否被修复了。</p><p>还有一些应用，在生产环节下就要根据用户属性来动态加载不同的模块，而且动态加载模块还希望不要网页重新加载，这时候也希望能够在不修改应用状态的前提下重新加载应用逻辑，这就是热加载，后面章节会介绍如何实现热加载。</p><hr><h3 id="二、Redux"><a href="#二、Redux" class="headerlink" title="二、Redux"></a>二、Redux</h3><p>我们把Flux看作一个框架理念的话，Redux是Flux的一种实现，除了Redux之外，还有很多实现Flux的框架，比如Reflux、Fluxible等，毫无疑问Redux获得的关注最多，这不是偶然的，因为Redux有很多其他框架无法比拟的优势。</p><h4 id="1-Redux的基本原则"><a href="#1-Redux的基本原则" class="headerlink" title="1. Redux的基本原则"></a>1. Redux的基本原则</h4><p>2013年问世的Flux饱受争议，而2015年Dan Abramov提出了在Flux基础上的改进框架Redux，则是一鸣惊人，在所有Flux的变体中算是最受关注的框架，没有之一。</p><p>Flux的基本原则是“单向数据流”，Redux在此基础上强调三个原则：</p><ul><li><p>唯一数据源（Single Source of Truth）</p></li><li><p>保持状态只读（State is read-only）</p></li><li><p>数据改变只能通过纯函数完成（Changes are made with pure functions）</p></li></ul><p>让我们逐一解释这三条基本原则</p><ul><li>1) 唯一数据源</li></ul><p>唯一数据源指的是应用的状态数据应该只存储在唯一的一个Store上。</p><p>我们已经知道，在Flux中，应用可以拥有多个Store，往往根据功能把应用的状态数据划分给若干个Store分别存储管理。比如，在上面的ControlPanel中，我们创造了CounterStore和SummaryStore。</p><p>如果状态数据分散在多个Store中，容易造成数据冗余，这样数据一致性方面就会出问题。虽然利用Dispatcher的waitFor方法可以保证多个Store之间的更新顺序，但是这又产生了不同Store之间的显示依赖关系，这种依赖关系的存在增加了应用的复杂度，容易带来新的问题。</p><p>Redux对这个问题的解决方法就是，整个应用只保持一个Store，所有组件的数据源就是这个Store上的状态。</p><p>这个唯一Store上的状态，是一个树形的结构，每个组件往往只是用树形对象上一部分的数据，而如何设计Store上状态的结构，就是Redux应用的核心问题，我们接下来会描述细节。</p><ul><li>2) 保持状态只读</li></ul><p>保持状态只读，就是说不能去直接修改状态，要修改Store的状态，必须要通过派发一个action对象完成，这一点，和Flux的要求并没有什么区别。</p><p>如果只看这个原则的字面意思，可能会让我们有些费解，还记得那个公式吗？<code>UI=render(state)</code>，我们已经能够说过驱动用户界面更改的是状态，如果状态都是只读的不能修改，怎么可能引起用户界面的变化呢？</p><p>当然，要驱动用户界面渲染，就要改变应用的状态，但是改变状态的方法不是去修改状态的值，而是创建一个新的状态对象返回给Redux，由Redux完成新的状态的组装。</p><p>这就引出了下面的第三条原则。</p><ul><li>3) 数据改变只能通过纯函数完成</li></ul><p>这里所说的纯函数就是Reducer，Redux这个名字的前三个字母Red代表的就是Reducer。按照创作者Dan Abramov的说法，Redux名字的含义是Reducer+Flux。</p><p>Reducer不是一个Redux特定的术语，而是一个计算机科学中的通用概念，很多语言和框架都有对Reducer函数的支持。以JavaScript为例，数组类型就有reduce函数，接受的参数就是一个reducer，reduce做的事情就是把数组所有元素依次做“规约”，对每个元素都调用一次reducer，通过reducer函数完成规约所有元素的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">accumulation, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulation + item;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>上面的代码中，reducer函数接受两个参数，第一个参数是上一次规约的结果，第二个参数是这一次规约的元素，函数体是返回两者之和，所以这个规约的结果就是所有元素之和。</p><p>在Redux中，每个reducer的函数签名如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reducer(state, action)</span><br></pre></td></tr></table></figure><p>第一个参数state是当前的状态，第二个参数是接收到的action对象，而reducer函数要做的事情，就是根据state和action的值产生一个新的对象返回，注意reducer必须是纯函数，也就是说函数的返回结果必须完全由参数state和action决定，而且不产生任何副作用，也不能修改参数state和action对象。</p><p>让我们回顾一下Flux中的Store是如何处理函数的，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CounterStore.dispatchToken = AppDispatcher.register(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ActionTypes.INCREMENT) &#123;</span><br><span class="line">    counterValues[action.counterCaption]++;</span><br><span class="line">    CounterStore.emitChange();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === ActionTypes.DECREMENT) &#123;</span><br><span class="line">    counterValues[action.counterCaption]--;</span><br><span class="line">    CounterStore.emitChange();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Flux更新状态的函数只有一个参数action，因为状态是由Store直接管理的，所以处理函数中会看到代码直接更新state；在Redux中，一个实现同样功能的reducer代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) =&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;counterCaption&#125; = action;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.INCREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.DECREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到reducer函数不光接受action为参数，还接受state为参数。也就是说，Redux的reducer只负责计算状态，却并不负责存储状态。</p><p>我们在后面的实例中会详细解释这个reducer的构造。</p><p>读到这里，读者可能会有一个疑问，从Redux的基本原则来看，Redux并没有赋予我们强大的功能，反而是给开发者增加了很多限制，开发者丧失了想怎么写就怎么写的灵活度。</p><blockquote><p>“如果你愿意限制做事方式的灵活度，你几乎总会发现可以做得更好。” —— John Carmark</p></blockquote><p>作为制作出《Doom》《Quake》这样游戏的杰出开发者，John Carmark这句话道出了软件开发中的一个真谛。</p><p>在计算机编程的世界里，完成任何一件任务，可能都有一百种以上的方法，但是无节制的灵活度反而让软件难以维护，增加限制是提高软件质量的法门。</p><h4 id="2-Redux实例"><a href="#2-Redux实例" class="headerlink" title="2. Redux实例"></a>2. Redux实例</h4><p>前面我们用Flux实现了一个ControlPanel的应用，接下来让我们用Redux来重新实现一遍同样的功能，通过对比就能看出二者的差异。</p><p>React和Redux事实上是两个独立的产品，一个应用可以使用React而不是用Redux，也可以使用Redux而不是用React，但是，如果两者结合使用，没有理由不使用一个名叫react-redux的库，这个库能够大大简化代码的书写。</p><p>不过，如果一开始就使用react-redux，可能对其设计思路完全一头雾水，所以，我们的实例先不采用react-redux库，从最简单的Redux使用方法开始，初步改进，循序渐进地过渡到使用react-redux。</p><p>最基本的Redux实现，存在与本书对应Github的chapter-03/redux_basic目录中，在这里我们只关注使用Redux实现和使用Flux不同的地方。</p><p>首先看关于action对象的定义，和Flux一样，Redux应用习惯上把action类型和action构造函数分成两个文件定义，其中定义action类型的src/ActionTypes.js和Flux版本没有任何差别，但是src/Actions.js文件就不大一样了，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ActionTypes <span class="keyword">from</span> <span class="string">'./ActionTypes.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function">(<span class="params">counterCaption</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ActionTypes.INCREMENT,</span><br><span class="line">    counterCaption: counterCaption</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function">(<span class="params">counterCaption</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ActionTypes.DECREMENT,</span><br><span class="line">    counterCaption: counterCaption</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和Flux的src/Actions.js文件对比就会发现，Redux中每个action构造函数都返回一个action对象，而Flux版本中action构造函数并不返回什么，而是把构造的动作函数立刻通过调用Dispatcher的dispatch函数派发出去。</p><p>这是一个习惯上的差别，接下来我们会发现，在Redux中，很多函数都是这样不做什么产生副作用的动作，而是返回一个对象，把如何处理这个对象的工作交给调用者。</p><p>在Flux中我们要用到一个Dispatcher对象，但是在Redux中，就没有Dispatcher这个对象了，Dispatcher存在的作用就是把一个action对象分发给了多个注册了的Store，既然Redux让全局只有一个Store，那么再创造一个Dispatcher也的确意义不大。所以，Redux中“分发”这个功能，从一个Dispatcher对象简化为Store对象上的一个函数dispatch，毕竟只有一个Store，要分发也是分发给这个Store，就调用Store上一个表示分发的函数，合情合理。</p><p>我们创造一个src/Store.js文件，这个文件输出全局唯一的那个Store，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./Reducer.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initValues = &#123;</span><br><span class="line">  <span class="string">'First'</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">'Second'</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">'Third'</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, initValues);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p>在这里，我们接触到了Redux库提供的createStore函数，这个函数第一个参数代表更新状态的reducer，第二个参数是状态的初始值，第三个参数可选，代表Store Enhancer，在这个例子中用不上，后面章节会详细介绍。</p><p>确定Store状态，是设计好Redux应用的关键。从Store状态的初始值看得出来，我们的状态是这样一个格式：状态上每个字段名代表Counter组件的名（caption），字段的值就是这个组件当前的计数值，根据这些状态字段，足够支撑三个Counter组件。</p><p>那么，为什么没有状态来支持Summary组件呢？因为Summary组件的状态，完全可以通过把Counter状态数值加在一起得到，没有必要制造冗余数据存储，这也符合Redux“唯一数据源”的基本原则。记住：Redux的Store状态设计的一个主要原则：避免冗余数据。</p><p>接下来看src/Reducer.js中定义的reducer函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ActionTypes <span class="keyword">from</span> <span class="string">'./ActionTypes.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;counterCaption&#125; = action;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.INCREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.DECREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和Flux应用中每个Store注册的回调函数一样，reducer函数中往往包含以action.type为判断条件的if-else或者switch语句。</p><p>和Flux不同的是，多了一个参数state。在Flux的回调函数中，没有这个参数，因为state是由Store管理的，而不是由Flux管理的。Redux中把存储state的工作抽取出来交给Redux框架本身，让reducer只用关心如何更新state，而不要管state怎么存。</p><p>代码中使用了三个句号组成的扩展操作符，表示把state中所有字段扩展开，而后面对counterCaption值对应的字段会赋上新值，像下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] + <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>逻辑上等同于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newState = <span class="built_in">Object</span>.assign(&#123;&#125;, state);</span><br><span class="line">newState[counterCaption]++;</span><br><span class="line"><span class="keyword">return</span> newState;</span><br></pre></td></tr></table></figure><p>和Flux很不一样的是，在reducer中，绝对不能去修改参数中的state，如果我们直接修改state并返回false，代码如下，注意这不是正确写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;counterCaption&#125; = action;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.INCREMENT:</span><br><span class="line">      state[counterCaption]++;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.DECREMENT:</span><br><span class="line">      state[counterCaption]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这样写，似乎更简单直接，但实际上犯了大错，因为reducer应该是一个纯函数，纯函数不应该产生任何副作用。</p><p>接下来，我们看View部分，View部分代码都在src/views目录下。看看src/views/ControlPanel.js，作为这个应用最顶层的组件ControlPanel，内容和Flux例子中没有任何区别。然后是Counter组件，存在于src/views/Counter.js中，这就和Flux不大一样了，首先是构造函数中初始化this.state的来源不同，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../Store.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">this</span>.getOwnState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getOwnState() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: store.getState()[<span class="keyword">this</span>.props.caption]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和Flux例子一样，在这个视图文件中我们要引入Store，只不过这次我们引入的Store不叫CounterStore，而是一个唯一的Redux Store，所以名字就叫store，通过store.getState()能够获得store上存储的所有状态，不过每个组件往往只需要使用返回状态的一部分数据。为了避免重复代码，我们把从store获得状态的逻辑放在getOwnState函数中，这样任何关联Store状态的地方都可以重用这个函数。</p><p>和Flux实现的例子一样，仅仅在构造函数时根据store来初始化this.state还不够，要保持store上状态和this.state的同步，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onChange() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="keyword">this</span>.getOwnState());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  store.subscribe(<span class="keyword">this</span>.onChange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  store.unsubscribe(<span class="keyword">this</span>.onChange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在componentDidMount函数中，我们通过Store的subscribe监听其变化，只要Store状态发生变化，就会调用这个组件的onChange方法；在componentWillUnmount函数中，我们把这个监听注销掉，这个清理动作和componentDidMount中的动作对应。</p><p>其实，这个增加监听函数的语句也可以写在构造函数里，但是为了让mount和unmount的对应看起来更清晰，在所有的例子中我们都把加载监听的函数放在componentDidMount中。</p><p>除了从store同步状态，视图中可能会想要改变store中的状态，和Flux一样，改变store中状态唯一的方法就是派发action，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onIncrement() &#123;</span><br><span class="line">  store.dispatch(Actions.increment(<span class="keyword">this</span>.props.caption));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onDecrement() &#123;</span><br><span class="line">  store.dispatch(Actions.decrement(<span class="keyword">this</span>.props.caption));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了onIncrement和onDecrement方法，在render函数中的JSX中需要使用这两种函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">this</span>.state.value;</span><br><span class="line">  <span class="keyword">const</span> &#123;caption&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onIncrement&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onDecrement&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;caption&#125; count: &#123;value&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在render函数中，对于点击“<code>+</code>”按钮和“<code>-</code>”按钮的onClick事件，被分别挂上了onIncrement函数和onDecrement函数，所做的事情就是派发对应的action对象出去。注意和Flux例子的区别，在Redux中，action构造函数只负责创建对象，要派发action就需要调用store.dispatch函数。</p><p>组件的render函数所显示的动态内容，要么来自于props，要么来自于自身状态。</p><p>然后再来看看src/views/Summary.js中的Summary组件，其中getOwnState函数的实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getOwnState() &#123;</span><br><span class="line">  <span class="keyword">const</span> state = store.getState();</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> state) &#123;</span><br><span class="line">    sum += state[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">sum</span>: sum &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Summary组件的套路和Counter组件差不多，唯一值得一提的就是getOwnState函数的实现。因为Store的状态中只记录了各个Counter组件的计数值，所以需要在getOwnState状态中自己计算出所有计数值总和出来。</p><h4 id="3-容器组件和傻瓜组件"><a href="#3-容器组件和傻瓜组件" class="headerlink" title="3. 容器组件和傻瓜组件"></a>3. 容器组件和傻瓜组件</h4><p>分析一下上面的Redux例子中的Counter组件和Summary组件部分，可以发现一个规律，在Redux框架下，一个React组件基本上就是要完成以下两个功能：</p><ul><li><p>和Redux Store打交道，读取Store的状态，用于初始化组件的状态，同时还要监听Store的状态改变；当Store状态发生变化时，需要更新组件状态，从而驱动组件重新渲染；当需要更新Store状态时，就要派发action对象</p></li><li><p>根据当前props和state，渲染出用户界面</p></li></ul><p>还记得那句话吗？让一个组件只专注做一件事，如果发现一个组件做的事情太多了，就可以把这个组件拆分成多个组件，让每个组件依然只专注于一件事。</p><p>如果React组件都是要包办上面说的两个任务，似乎做的事情也的确稍微多了一点。我们可以考虑拆分，拆分为两个组件，分别承担一个任务，然后把两个组件嵌套起来，完成原本一个组件完成的所有任务。</p><p>这样的关系里，两个组件是父子组件的关系。业界对于这样的拆分有多种叫法，承担第一个任务的组件，也就是负责和Redux Store打交道的组件，处于外层，所以被称为容器组件（Container Component）；对于承担第二个任务的组件，也就是只专心负责渲染界面的组件，处于内层，叫做展示组件（Presentational Component）。</p><p>外层的容器组件又叫聪明组件（Smart Component），内层的展示组件又叫傻瓜组件（Dumb Component），所谓“聪明”还是“傻瓜”只是相对而言，并没有褒贬的含义。</p><p><img src="/images/react-3/4.png" alt="容器组件和傻瓜组件的分工"></p><p>傻瓜组件就是一个纯函数，根据props产生结果。说是“傻瓜”，这种纯函数实现反而体现了计算机编程中的大智慧，大智若愚。</p><p>而容器组件，只是做的事情涉及一些状态转换，虽然名字里有“聪明”，其实做的事情都有套路，我们很容易就能抽取出共同之处，复用代码完成任务，并不需要开发者极其聪明才能掌握。</p><p>在我们把一个组件拆分为容器组件和傻瓜组件的时候，不只是功能分离，还有一个比较大的变化，那就是傻瓜组件不再需要有状态了。</p><p>实际上，让傻瓜组件无状态，是我们拆分的主要目的之一，傻瓜组件只需要根据props来渲染结果，不需要state。</p><p>那么，状态哪里去了呢？全都交给容器组件去打点，这是它的责任。容器组件如何把状态传递给傻瓜组件呢？通过props。</p><p>值得一提的是，拆分容器组件和傻瓜组件，是设计React组件的一种模式，和Redux没有直接关系。在Flux或者任何一种其他框架下都可以使用这种模式，只不过为了引出后面的react-redux，我们才在这里开始介绍罢了。</p><p>我们还是通过例子来感受一下容器组件和傻瓜组件如何协同工作，对应的代码在chapter-03/redux_smart_dumb目录下，是前面chapter-03/redux_basic的改进，只有视图部分代码有改变。</p><p>在视图代码src/views/Counter.js中定义了两个组件，一个是Counter，这是傻瓜组件，另一个是CounterContainer，这是容器组件。</p><p>傻瓜组件Counter代码的逻辑前所未有的简单，只有一个render函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;caption, onIncrement, onDecrement, value&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button style=&#123;buttonStyle&#125; onClick=&#123;onIncrement&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;button style=&#123;buttonStyle&#125; onClick=&#123;onDecrement&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;span&gt;&#123;caption&#125; count: &#123;value&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Counter组件完全没有state，只有一个render方法，所有的数据都来自于props，这种组件叫做“无状态”组件。</p><p>而CounterContainer组件承担了所有的和Store关联的工作，它的render函数所做的就是渲染傻瓜组件Counter而已，只负责传递必要的prop，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> <span class="attr">caption</span>=<span class="string">&#123;this.props.caption&#125;</span> </span></span></span><br><span class="line"><span class="xml">            onIncrement=&#123;this.onIncrement&#125;</span></span><br><span class="line"><span class="xml">            onDecrement=&#123;this.onDecrement&#125;</span></span><br><span class="line"><span class="xml">            value=&#123;this.state.value&#125; /&gt;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default CounterContainer;</span></span><br></pre></td></tr></table></figure><p>可以看到，这个文件export导出的不再是Counter组件，而是CounterContainer组件，也就是对于使用这个视图的模块来说，根本不会感受到傻瓜组件的存在，从外部看到的就只是容器组件。</p><p>对于无状态组件，其实我们可以进一步缩减代码，React支持只用一个函数代表的无状态组件，所以，Counter组件可以进一步简化，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;caption, onIncrement, onDecrement, value&#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;onIncrement&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;onDecrement&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;caption&#125; count: &#123;value&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为没有状态，不需要用对象表示，所以连类都不要了，对于一个只有render方法的组件，缩略为一个函数足矣。</p><p>注意，改为这种写法，获取props就不能用this.props，而是通过函数的参数props获得，无状态组件的props参数和有状态组件的this.props内容和结构完全一样。</p><p>还有一种惯常写法，就是把解构赋值直接放在参数部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;caption, onIncrement, onDecrement, value&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数体中可以直接使用caption、onIncrement等变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看src/views/Summary.js中，内容也被分解为了傻瓜组件Summary和SummaryContainer，方式和Counter差不多，不再赘述。</p><p>重新审阅代码，我们可以看到CounterContainer和SummaryContainer代码有很多相同之处，写两份实在是重复，既然都是套路，完全可以抽取出来，后面的章节会讲如何应用react-redux来减少重复代码。</p><h4 id="4-组件Context"><a href="#4-组件Context" class="headerlink" title="4. 组件Context"></a>4. 组件Context</h4><p>在介绍react-redux之前，我们重新看一看现在的Counter和Summary组件文件，发现它们都直接导入Redux Store。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./Store.js'</span>;</span><br></pre></td></tr></table></figure><p>虽然Redux应用全局就一个Store，这样的直接导入依然有问题。</p><p>在实际工作中，一个应用的规模会很大，不会所有的组件都放在一个代码库里，有时候还要通过npm方式引入第三方的组件。想想看，当开发一个独立的组件的时候，都不知道自己这个组件会存在于哪个应用中，当然不可能预先知道定义唯一Redux Store的文件位置了，所以，在组件中直接导入Store是非常不利于组件复用的。</p><p>一个应用中，最好只有一个地方需要直接导入Store，这个位置当然应该是在调用最顶层React组件的位置。在我们的ControlPanel例子中，就是应用的入口文件src/index.js中，其余组件应该避免直接导入Store。</p><p>不让组件直接导入Store，那就只能让组件的上层组件把Store传递下来了。首先想到的当然是用props，毕竟，React组件就是用props来传递父子组件之间的数据的。不过，这种方法有一个很大的缺陷，就是从上到下，所有的组件都要帮助传递这个props。</p><p>设想在一个嵌套多层的组件结构中，只有最里层的组件才需要使用Store，但是为了把Store从外层传递到最里层，就要求中间所有的组件都需要增加对这个store prop的支持，即使根本不使用它，这无疑很麻烦。</p><p>还是来看ControlPanel这个例子，最顶层的组件ControlPanel根本就不使用Store，如果仅仅为了让它传递一个prop给子组件Counter和Summary就要求它支持state prop，显然非常不合理。所以，用prop传递store不是一个好方法。</p><p>React提供了一个叫Context的功能，能够完美地解决这个问题。</p><p><img src="/images/react-3/5.png" alt="React的Context"></p><p>所谓Context，就是“上下文环境”，让一个树状组件上所有组件都能访问一个共同的对象，为了完成这个任务，需要上级组件和下级组件配合。</p><p>首先，上级组件要宣称自己支持context，并且提供一个函数来返回代表Context的对象。</p><p>然后，这个上级组件之下的所有下级组件，只要宣称自己需要这个Context，就可以通过this.context访问到这个共同的环境对象。</p><p>我们尝试给ControlPanel程序加上context功能来优化，相关代码在chapter-3/redux_with_context目录中，这个应用是对前面redux_smart_dumb的改进。</p><p>因为Redux应用中只有一个Store，因此所有组件如果要使用Store的话，只能访问这唯一的Store。很自然，希望顶层的组件来扮演这个Context提供者的角色，只要顶层组件提供包含store的context，那就覆盖了整个应用的所有组件，简单而且够用。</p><p>不过，每个应用的顶层组件不同，在我们的ControlPanel例子里顶层组件是ControlPanel，在另一个应用里会有另一个组件。而且，ControlPanel有它自己的职责，我们没有理由把它复杂化，没必要非要让它扮演context提供者的功能。</p><p>我们来创建一个特殊的React组件，它将是一个通用的context提供者，可以应用在任何一个应用中，我们把这个组件叫做Provider。在src/Provider.js中，首先定义一个名为Provider的React组件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;PropTypes, Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      store: <span class="keyword">this</span>.props.store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Provider也是一个React组件，不过它的render函数就是简单地把子组件渲染出来，在渲染上，Provider不做任何附加的事情。</p><p>每个React组件的props中都可以包含一个特殊属性children，代表的是子组件，比如这样的代码，在Provider的render函数中this.props.children就是两个Provider标签之间的<code>&lt;ControlPanel /&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider&gt;</span><br><span class="line">  &lt;ControlPanel /&gt;</span><br><span class="line">&lt;<span class="regexp">/Provider&gt;</span></span><br></pre></td></tr></table></figure><p>除了把渲染工作完全交给子组件，Provider还要提供一个函数getChildContext，这个函数返回的就是代表Context的对象。我们的Context中只有一个字段store，而且我们也希望Provider足够通用，所以并不在这个文件中导入store，而是要求Provider的使用者通过prop传递进来store。</p><p>为了让Provider能够被React认可为一个Context的提供者，还需要指定Provider的childContextTypes属性，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Provider.childContextTypes = &#123;</span><br><span class="line">  store: ProTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Provider还需要定义类的childContextTypes，必须和getChildContext对应，只有这两者都齐备，Provider的子组件才有可能访问到context。</p><p>有了Provider，我们就可以改进一下应用的入口src/index.js文件了，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./Store.js'</span>;</span><br><span class="line"><span class="keyword">import</span> Provider <span class="keyword">from</span> <span class="string">'./Provider.js'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;ControlPanel /&gt;</span><br><span class="line">  &lt;<span class="regexp">/provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>在前面所有的例子中，React.render的第一个参数就是顶层组件ControlPanel。现在，这个ControlPanel作为子组件被Provider包住了，Provider成为了顶层组件。当然，如同我们上面看到的，Provider只是把渲染工作完全交给子组件，它扮演的角色只是提供Context，包住了最顶层的ControlPanel，也就让context覆盖了整个应用中的所有组件。</p><p>至此，我们完成了提供Context的工作，接下来我们看底层组件如何使用Context。</p><p>我们可以顺便看一眼src/views/ControlPanel.js，这个文件和前面的例子没有任何变化，它做的工作只是搭建应用框架，把子组件Counter和Summary渲染出来，和Store一点关系都没有，这个文件既没有导入Store，也没有支持关于store的props。</p><p>在src/views/Counter.js中，我们可以看到对context的使用。作为傻瓜组件的Counter是一个无状态组件，它也不需要和Store牵扯什么关系，和之前的代码一模一样，有变化的是CounterContainer部分。</p><p>为了让CounterContainer能够访问context，必须给CounterContainer类的contextTypes赋值和Provider.childContextTypes一样的值，两者必须一致，不然就无法访问到context，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CounterContainer.contextTypes = &#123;</span><br><span class="line">  store: PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CounterContainer中，所有对store的访问，都是通过this.context.store完成的，因为this.context就是Provider提供的context对象，所以getOwnState函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getOwnState() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: <span class="keyword">this</span>.context.store.getState()[<span class="keyword">this</span>.props.caption]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一点，因为我们自己定义了构造函数，所以要用上第二个参数context，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props, context);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用super的时候，一定要带上context参数，这样才能让React组件初始化实例中的context，不然组件的其它部分就无法使用this.context。</p><p>要求constructor显式声明props和context两个参数然后又传递给super看起来很麻烦，我们的代码似乎只是一个参数的搬运工，而且将来可能有新的参数出现那样又要修改这部分代码，我们可以用下面的方法一劳永逸地解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">  <span class="keyword">super</span>(...arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不能直接使用arguments，因为在JavaScript中arguments表现得像是一个数组而不是分开的一个个参数，但是我们通过扩展标识符就能把arguments彻底变成传递给super的参数。</p><p>在结束之前，让我们重新审视一下Context这个功能，Context这个功能相当于提供了一个全局可以访问的对象，但是全局对象或者说全局变量肯定是我们应该避免的用法，只要有一个地方改变了全局对象的值，应用中其它部分就会受影响，那样整个程序的运行结果就完全不可预测了。</p><p>所以，单纯来看React的这个Context功能的话，必须强调这个功能要谨慎使用，只有对那些每个组件都可能使用，但是中间组件又可能不使用的对象才有必要使用Context，千万不要滥用。</p><p>对于Redux，因为Redux的Store封装得很好，没有提供直接修改状态的功能，就是说一个组件虽然能够访问全局唯一的Store，却不可能直接修改Store中的状态，这样部分克服了作为全局对象的缺点。而且，一个应用只有一个Store，这个Store是Context里唯一需要的东西，并不算滥用，所以，使用Context来传递Store是一个不错的选择。</p><h4 id="5-React-Redux"><a href="#5-React-Redux" class="headerlink" title="5. React-Redux"></a>5. React-Redux</h4><p>在上面两节中，我们了解了改进React应用的两个方法，第一是把一个组件拆分为容器组件和傻瓜组件，第二是使用React的Context来提供一个所有组件都可以直接访问的Context，也不难发现，这两种方法都有套路，完全可以把套路部分抽取出来复用，这样每个组件的开发只需要关注于不同的部分就可以了。</p><p>实际上，已经有这样的一个库来完成这些工作了，这个库就是react-redux。</p><p>在本书的chapter-03/react-redux目录下，可以看到利用react-redux实现的ControlPanel版本，因为使用了react-redux，所以它是所有实现方式中代码最精简的一个例子。</p><p>我们只看不同的部分，在src/index.js中，代码几乎和react_with_context一模一样，唯一的区别就是我们不再使用自己实现的Provider，而是从react-redux库导入Provider，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br></pre></td></tr></table></figure><p>有了react-redux，视图文件src/views/Counter.js和src/Summary.js中的代码可以变得相当简洁。</p><p>在前面的redux_smart_dumb和redux_with_context例子中，我们实际上分别实现了react-redux的两个最主要的功能：</p><ul><li><p>connect：连接容器组件和傻瓜组件</p></li><li><p>Provider：提供包含store的context</p></li></ul><p>现在我们直接使用react-redux提供的这两个功能了，让我们分别来详细介绍。</p><ul><li>1) connect</li></ul><p>以Counter组件为例，和redux_with_context中的代码不同，react-redux的例子中没有定义CounterContainer这样命名的容器组件，而是直接导出了这样一个语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Counter);</span><br></pre></td></tr></table></figure><p>第一眼看去，会让人觉得这不是正常的JavaScript语法。其实，connect是react-redux提供的一个方法，这个方法接收两个参数mapStateToProps和mapDispatchToProps，执行结果依然是一个函数，所以才可以在后面又加一个圆括号，把connect函数执行的结果立刻执行，这一次参数是Counter这个傻瓜组件。</p><p>这里有两次函数执行，第一次是connect函数的执行，第二次是把connect函数返回的函数再次执行，最后产生的就是容器组件，功能相当于redux_smart_dumb中的CounterContainer。</p><p>当然，我们也可以把connect的结果赋值给一个变量CounterContainer，然后再export这个CounterContainer，只是connect已经大大简化了代码，习惯上可以直接导出函数执行结果，也不用纠结如何命名这个变量。</p><p>这个connect函数具体做了什么工作呢？</p><p>作为容器组件，要做的工作无外乎两件事：</p><ul><li><p>把Store上的状态转化为内层傻瓜组件的props</p></li><li><p>把内层傻瓜组件中的用户动作转化为派送给store的动作</p></li></ul><p>这两个工作一个是内层傻瓜对象的输入，一个是内层傻瓜对象的输出。</p><p>这两个工作的套路也很明显，把Store上的状态转化为内层组件的props，其实就是一个映射关系，去掉框架，最后就是一个mapStateToProps函数该做的事情。这个函数命名是业界习惯，因为它只是一个模块内的函数，所以实际上叫什么函数都行，如果觉得mapStateToProps这个函数名太长，也可以叫mapState，也是业界惯常的做法。</p><p>Counter组件对应的mapStateToProps函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state, ownProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: state[ownProps.caption]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把内层傻瓜组件中用户动作转化为派送给Store的动作，也就是把内层傻瓜组件暴露出来的函数类型的prop关联上dispatch函数的调用，每个prop代表的回调函数的主要区别就是dispatch函数的参数不同，这就是mapDispatchToProps函数做的事情，和mapStateToProps一样，这么长的函数名只是习惯问题，mapDispatchToProps也可以叫作mapDispatch。</p><p>Counter组件对应的mapDispathToProps函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch, ownProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onIncrement: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(Actions.increment(ownProps.caption));</span><br><span class="line">    &#125;,</span><br><span class="line">    onDecrement: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(Actions.decrement(ownProps.caption));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapStateToProps和mapDispatchToProps都可以包含第二个参数，代表ownProps，也就是直接传递给外层容器组件的props，在ControlPanel的例子中没有用到，我们在后续章节中会有详细介绍。</p><ul><li>2) Provider</li></ul><p>我们在redux_with_context中已经完整实现了一个Provider，react-redux和我们例子中的Provider几乎一样，但是更加严谨，比如我们只要求store属性是一个object，而react-redux要求store不光是一个object，而且是必须包含三个函数的object，这三个函数分别是：</p><ul><li><p>subscribe</p></li><li><p>dispatch</p></li><li><p>getState</p></li></ul><p>拥有上述三个函数的对象，才能称之为一个Redux的store。</p><p>另外，react-redux定义了Provider的componentWillReceiveProps函数，在React组件的生命周期中，componentWillReceiveProps函数在每次重新渲染时都会调用到，react-redux在componentWillReceiveProps函数中会检查这一次渲染时代表store的prop和上一次的是否一样。如果不一样，就会给出警告，这样做是为了避免多次渲染用了不同的Redux Store。每个Redux应用只能有一个Redux Store，在整个Redux的生命周期中都应该保持Store的唯一性。</p><hr><h3 id="三、本章小结"><a href="#三、本章小结" class="headerlink" title="三、本章小结"></a>三、本章小结</h3><p>在这一章中，我们首先从Redux的鼻祖Flux框架出发，通过创造一个ControlPanel的例子，了解了Flux“单向数据流”的原则。如果只由React来管理数据流，就很难管理拥有很多组件的大型应用，传统的MVC框架也有其缺陷，很容易写乱套，所以Flux是应用架构的一个巨大改进，但是Flux也有其缺点。</p><p>Redux是Flux框架的一个巨大改进，Redux强调单一数据源、保持状态只读和数据改变只能通过纯函数完成的基本原则，和React的<code>UI=render(state)</code>思想完全契合。我们在这一章中用不同方法，循序渐进的改进了ControlPanel这个应用的例子，为的就是更清晰地理解每个改进背后的动因，最后，我们终于通过react-redux完成了React和Redux的融合。</p><p>但是，这只是一个开始。接下来，我们将看到更加深入的React和Redux实践知识。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="/resources/深入浅出React和Redux.pdf">《深入浅出React和Redux —— 程墨》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前一章中我们已经感受到完全用React来管理应用数据的麻烦，在这一章中，我们将介绍Redux这种管理应用状态的框架&lt;/p&gt;
    
    </summary>
    
      <category term="React抄书笔记" scheme="http://www.xiaoleon.cn/categories/React%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.xiaoleon.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(2) 设计高质量的React组件</title>
    <link href="http://www.xiaoleon.cn/2018/03/04/react-2/"/>
    <id>http://www.xiaoleon.cn/2018/03/04/react-2/</id>
    <published>2018-03-04T13:29:25.000Z</published>
    <updated>2018-03-19T13:15:53.841Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个合格的开发者，不能只满足于编写出可以运行的代码，而要了解代码背后的工作原理；不能只满足于自己编写的程序能够运行，还要让自己的代码可读而且易于维护。这样才能开发出高质量的软件。</p><a id="more"></a><p>本文中，我们将深入介绍构建高质量React组件的原则和方法，包括以下内容</p><ul><li><p>划分组件边界的原则</p></li><li><p>React组件的数据种类</p></li><li><p>React组件的生命周期</p></li></ul><h3 id="一、易于维护组件的设计要素"><a href="#一、易于维护组件的设计要素" class="headerlink" title="一、易于维护组件的设计要素"></a>一、易于维护组件的设计要素</h3><p>任何一个复杂的应用，都是由一个简单的应用发展而来的，当应用还很简单的时候，因为功能很少，可能只有一个组件就足够了，但是，随着功能的增加，把越来越多的功能放在一个组件里就会显得臃肿和难以管理。</p><p>就和一个人最好一次只专注做一件事一样，也应该尽量保持一个组件只做一件事。当开发者发现一个组件功能太多代码量太大的时候，就要考虑拆分这个组件，用多个小的组件来代替。每个小的组件只关注实现单个功能，但是这些功能组合起来，也能满足复杂的实际需求。</p><p>这就是“分而治之”的策略，把问题分解为多个小问题，这样极容易解决也方便维护，虽然“分而治之”是一个好策略，但是不要滥用，只有必要的时候才去拆分组件，不然可能得不偿失。</p><p>拆分组件最关键的就是确定组件的边界，每个组件都应该是可以独立存在的，如果两个组件逻辑太紧密，无法清晰定义各自的责任，那也许这两个组件本身就不该被拆开，作为同一个组件也许更合理。</p><p>虽然组件是应该独立存在的，但是并不是说组件就是孤岛一样的存在，不同组件之间总会有通信交流，这样才可能组合起来完成更大的功能。</p><p>作为软件设计的通则，组件的划分要满足<strong>高内聚（High Cohesion）</strong>和<strong>低耦合（Low Coupling）</strong>的原则。</p><p><strong>高内聚</strong>指的是把逻辑紧密相关的内容放在一个组件中。用户界面无外乎内容、交互行为和样式。传统上，内容由HTML表示，交互行为放在JavaScript代码文件中，样式放在CSS文件中定义。这虽然满足一个功能模块的需要，却要放在三个不同的文件中，这其实不满足高内聚的原则，React却不是这样，展示内容的JSX、定义行为的JavaScript，甚至定义样式的CSS，都可以放在一个JavaScript文件中，因为它们本来就是为了实现一个目的而存在的，所以说React天生具有高内聚的特点。</p><p><strong>低耦合</strong>指的是不同组件之间的依赖关系要尽量弱化，也就是每个组件要尽量独立。保持整个系统的低耦合度，需要对系统中的功能有充分的认识，然后根据功能点划分模块，让不同的组件去实现不同的功能，这个功夫还在开发者身上，不过，React组件的对外结构非常规范，方便开发者设计低耦合的系统。</p><hr><h3 id="二、React组件的数据"><a href="#二、React组件的数据" class="headerlink" title="二、React组件的数据"></a>二、React组件的数据</h3><p>毫无疑问，如何组织数据是程序的最重要问题。</p><p>React组件的数据分为两种，prop和state，无论prop或者state的改变，都可能引发组件的重新渲染，那么，设计一个组件的时候，什么时候选择用prop什么时候选择用state呢？其实原则很简单，prop是组件的对外接口，state是组件的内部状态，对外用prop，内部用state。</p><p>为了演示属性的使用，我们构造一个应用包含两个组件，Counter组件和ControlPanel组件，其中ControlPanel组件是父组件，包含若干个Counter组件。</p><p><img src="/images/react-2/1.png" alt="ControlPanel应用效果图"></p><p>可以看到三个Counter组件有了不同的初始计数值，点击网页中的“<code>+</code>”按钮可以看到对应一行的计数增加，点击“<code>-</code>”按钮可以看到对应一行的计数减少。</p><h4 id="1-React的prop"><a href="#1-React的prop" class="headerlink" title="1. React的prop"></a>1. React的prop</h4><p>在React中，prop（property的简写）是从外部传递给组件的数据，一个React组件通过定义自己能够接受的prop就定义了自己的对外公共接口。</p><p>每个React组件都是独立存在的模块，组件之外的一切都是外部世界，外部世界就是通过prop来和组件对话的。</p><ul><li>1) 给prop赋值</li></ul><p>我们先从外部世界来看，prop是如何使用的，在下面的JSX代码片段中，就使用了prop</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SampleButton id=<span class="string">"sample"</span> borderWidgh=&#123;<span class="number">2</span>&#125; onClick=&#123;onButtonClick&#125; style=&#123;&#123;<span class="attr">color</span>: <span class="string">"red"</span>&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>在上面的例子中，创建了名为SampleButton的组件实例，使用了名字分别为id、borderWidth、onClick和style的prop，看起来，React组件的prop很像是HTML元素的属性，不过，HTML组件属性的值都是字符串类型，即使是内嵌JavaScript，也依然是字符串形式表示代码。React组件的prop所能支持的类型则丰富得多，除了字符串，可以是任何一种JavaScript语言支持的数据类型。</p><p>比如在上面的SampleButton中，borderWidth就是数字类型，onClick是函数类型，style的值是一个包含color字段的对象，当prop的类型不是字符串类型时，在JSX中必须用花括号<code>{}</code>把prop值包住，所以style的值有两层花括号，外层花括号代表的是JSX的语法，内层的花括号代表这是一个对象常量。</p><p>当外部世界要传递一些数据给React组件，一个最直接的方式就是通过prop；同样，React组件要反馈数据给外部世界，也可以用prop，因为prop的类型不限于纯数据，也可以是函数，函数类型的prop等于让父组件交给了子组件一个回调函数，子组件在恰当的时机调用函数类型的prop，可以带上必要的参数，这样就可以反过来把信息传递给外部世界。</p><p>对于Counter组件，父组件的ControlPanel就是外部世界，我们看ControlPanel是如何用prop传递信息给Counter的，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ControlPanel</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Counter caption=<span class="string">"First"</span> initValue=&#123;<span class="number">0</span>&#125; /&gt;</span><br><span class="line">        &lt;Counter caption=<span class="string">"Second"</span> initValue=&#123;<span class="number">10</span>&#125; /&gt;</span><br><span class="line">        &lt;Counter caption=<span class="string">"Third"</span> initValue=&#123;<span class="number">20</span>&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>ControlPanel组件包含三个Counter组件实例，在ControlPanel的render函数中将这三个子组件实例用div包起来，因为React要求render函数只能返回一个元素。</p><p>在每个Counter组件实例中，都使用了caption和initValue这两个prop。通过名为caption的prop，ControlPanel传递给Counter组件实例说明文字。通过initValue的prop传递给Counter组件一个初始的计数值。</p><ul><li>2) 读取prop值</li></ul><p>我们再来看Counter组件内部是如何接收传入的prop的，首先是构造函数，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.onClickIncrementButton = <span class="keyword">this</span>.onClickIncrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.onClickDecrementButton = <span class="keyword">this</span>.onClickDecrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: props.initValue || <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个组件需要定义自己的构造函数，一定要记得在构造函数的第一行通过super调用父类也就是React.Component的构造函数。如果在构造函数中没有调用super(props)，那么组件实例被构造之后，类实例的所有成员函数就无法通过this.props访问到父组件传递过来的props值。很明显，给this.props赋值是React.Component构造函数的工作之一。</p><p>在Counter的构造函数中还给两个成员函数绑定了当前this的执行环境，因为ES6方法创造的React组建类并不自动给我们绑定this到当前实例对象。</p><p>在构造函数的最后，我们可以看到读取传入prop的方法，在构造函数中可以通过参数props获得传入的prop值，在其他函数中则可以通过this.props访问传入的prop的值，比如在Counter组件的render函数中，我们就是通过this.props获得传入的caption，render代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; caption &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onClickIncrementButton&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onClickDecrementButton&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;caption&#125; count: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用了ES6的解构赋值（destructuring assignment）语法从this.props中获得了名为caption的prop值。</p><ul><li>3) propTypes检查</li></ul><p>既然prop是组件的对外接口，那么就应该有某种方式让组件声明自己的接口规范。简单说，一个组件应该可以规范以下这些方面：</p><ul><li><p>这个组件支持哪些prop</p></li><li><p>每个prop应该是什么样的格式</p></li></ul><p>React通过propTypes来支持这些功能。</p><p>在ES6方法定义的组件类中，可以通过增加类的propTypes属性来定义prop规格，这不只是声明，而且是一种限制，在运行时和静态代码检查时，都可以根据propTypes判断外部世界是否正确地使用了组件的属性。</p><p>比如，对于Counter组件的propTypes定义代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Counter.propTypes = &#123;</span><br><span class="line">  caption: PropTypes.string.isRequired,</span><br><span class="line">  initValue: PropTypes.number</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中要求caption必须是string类型，initValue必须是number类型。可以看到，两者除了类型不同之外，还有一个区别：caption带上了isRequired，这表示使用Counter组件必须要指定caption；而initValue因为没有isRequired，则表示如果没有也没关系。</p><p>为了验证propTypes的作用，可以尝试故意违反propTypes的规定使用Counter实例，比如在ControlPanel的render函数中增加下列的代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Counter caption=&#123;<span class="number">123</span>&#125; initValue=&#123;<span class="number">20</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>我们在Chrome浏览器中，可以看到console中的红色警告</p><p><img src="/images/react-2/2.png" alt="错误prop类型的错误提示"></p><p>这段出错的含义是，caption属性预期是字符串类型，得到的却是一个数字类型。我们尝试删掉这个Counter实例的caption属性，代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Counter initValue=&#123;<span class="number">20</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>这是可以看到Console中依然有红色警告信息</p><p><img src="/images/react-2/3.png" alt="缺失必须存在prop的错误提示"></p><p>提示的含义是，caption是Counter必需的属性，但是却没有赋值。</p><p>很明显，有了propTypes的检查，可以很容易发现对prop的不正确使用方法，可尽早发现代码中的错误。</p><p>如果组件根本没有定义propTypes会怎么样呢？可以尝试在<code>src/Counter.js</code>文件中删除掉propTypes赋值的语句，在浏览器Console中红色警告不再出现。可见，没有propTypes定义，组件依然能够正常工作，而且，即使在上面propTypes检查出错的情况下，组件依旧能够工作。也就是说propTypes检查只是一个辅助开发的功能，并不会改变组件的行为。</p><p>propTypes虽然能够在开发阶段发现代码中的问题，但是放在产品环境中就不大合适了。</p><p>首先，定义类的propTypes属性，无疑是要占用一些代码空间，而且propTypes检查也是要消耗CPU计算资源的。其次，在产品环境下做propTypes检查没有什么帮助，毕竟，propTypes产生的这些错误信息只有开发者才能看得懂，放在产品环境下，在最终用户的浏览器Console中输出这些错误信息没什么意义。</p><p>所以，最好的方式是，开发者在代码中定义propTypes，在开发过程中避免犯错，但是在发布产品代码时，用一种自动的方式将propTypes去掉，这样最终部署到产品环境的代码就会更优。现有的babel-react-optimize就具有这个功能，可以通过npm安装，但是应该确保只在发布产品时使用它。</p><h4 id="2-React的state"><a href="#2-React的state" class="headerlink" title="2. React的state"></a>2. React的state</h4><p>驱动组件渲染过程的除了prop，还有state，state代表组件的内部状态。由于React组件不能修改传入的prop，所以需要记录自身数据变化，就要使用state。</p><p>在Counter组件中，最初显示初始计数，可以通过initValue这个prop来定制，在Counter已经被显示之后，用户会点击“<code>+</code>”和“<code>-</code>”按钮改变这个计数，这个变化的数据就要Counter组件自己通过state来存储了。</p><ul><li>1) 初始化state</li></ul><p>通常在组件类的构造函数结尾处初始化state，在Counter构造函数中，通过对this.state的赋值完成了对组件state的初始化，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    count: props.initValue || <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为initValue是一个可选的props，要考虑到父组件没有指定这个props值的情况，我们优先使用传入属性的initValue，如果没有，就是用默认值0。</p><p>组件的state必须是一个JavaScript对象，不能是string或者number这样的简单数据类型，即使我们需要存储的只是一个数字类型的数据，也只能把它存作state某个字段对应的值，Counter组件里，我们的唯一数据就存在count字段里。</p><p>由于在PropType声明中没有用isRequired要求必须有值的prop，例如上面的initValue，我们需要在代码中判断所给的prop值是否存在，如果不存在，就给一个默认的初始值。不过，让这样的判断逻辑充斥在我们组件的构造函数之中并不是一件美观的事情，而且容易有遗漏。我们可以用React的defaultProps功能，让代码更加容易读懂。</p><p>给Counter组件添加defaultProps代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Counter.defaultProps = &#123;</span><br><span class="line">  initValue: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了这样的设定，Counter构造函数中的this.state初始化中可以省去判断条件，可以认为代码执行到这里，必有initValue属性值，代码可以简化为这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  count: props.initValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，即使Counter的使用者没有指定initValue，在组件中就会收到一个默认的属性值0。</p><ul><li>2) 读取和更新state</li></ul><p>通过给button的onClick属性挂载点击事件处理函数，我们可以改变组件的state，以点击“<code>+</code>”按钮的响应函数为例，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onClickIncrementButton() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，通过this.state可以读取到组件的当前state。值得注意的是，我们改变组件state必须要使用this.setState函数，而不能直接去修改this.state。</p><p>直接修改this.state的值，虽然事实上改变了组件的内部状态，但只是野蛮地修改了state，却没有驱动组件进行重新渲染，既然组件没有重新渲染，当然不会反应this.state值的变化；而this.setState()函数所做的事情，首先是改变this.state的值，然后驱动组件经历更新过程，这样才有机会让this.state里新的值出现在界面上。</p><h4 id="3-prop和state的对比"><a href="#3-prop和state的对比" class="headerlink" title="3. prop和state的对比"></a>3. prop和state的对比</h4><p>总结一下prop和state的区别：</p><ul><li><p>prop用于定义外部接口，state用于记录内部状态</p></li><li><p>prop的赋值在外部世界使用组件时，state的赋值在组件内部</p></li><li><p>组件不应该改变prop的值，而state存在的目的就是让组件来改变的</p></li></ul><p>组件的state，就相当于组件的记忆，其存在意义就是被修改，每一次通过this.setState函数修改state就改变了组件的状态，然后通过渲染过程把这种变化体现出来。</p><p>但是，组件是绝不应该去修改传入的props值的，我们设想一下，假如父组件包含多个子组件，然后把一个JavaScript对象作为props值传给这几个子组件，而某个子组件居然改变了这个对象的内部值，那么，接下来其他子组件读取这个对象会得到什么值呢？当时读取了修改过的值，但是其他子组件是每次渲染都读取这个props的值呢？还是只读一次以后就用那个最初值呢？一切皆有可能，完全不可预料。也就是说，一个子组件去修改props中的值，可能让程序陷入一团混乱之中，这就完全违背了React设计的初衷。</p><p>严格来说，React并没有办法阻止我们去修改传入的props对象。所以，每个开发者就把这当做一个规矩，在编码中一定不要踩这道红线，不然最后可能遇到不可预料的bug。</p><hr><h3 id="三、组件的生命周期"><a href="#三、组件的生命周期" class="headerlink" title="三、组件的生命周期"></a>三、组件的生命周期</h3><p>为了理解React的工作过程，我们就必须要了解React组件的生命周期，如同人有生老病死，自然界有日月更替，每个组件在网页中也会被创建、更新和删除，如同有生命的机体一样。</p><p>React严格定义了组件的生命周期，会经理如下三个过程：</p><ul><li><p>装载过程（Mount），也就是把组件第一次在DOM树中渲染的过程</p></li><li><p>更新过程（Update），当组件被重新渲染的过程</p></li><li><p>卸载过程（Unmount），组件从DOM中删除的过程</p></li></ul><p>三种不同的过程，React库会依次调用组件的一些成员函数，这些函数称为生命周期函数。所以，要定制一个React组件，实际上就是定制这些生命周期函数。</p><h4 id="1-装载过程"><a href="#1-装载过程" class="headerlink" title="1. 装载过程"></a>1. 装载过程</h4><p>我们先来看装载过程，当组件第一次被渲染的时候，依次调用的函数是如下这些：</p><ul><li><p>constructor</p></li><li><p>getInitialState</p></li><li><p>getDefaultProps</p></li><li><p>componentWillMount</p></li><li><p>render</p></li><li><p>componentDidMount</p></li></ul><p>我们逐个详细解释这些函数的功能</p><ul><li>1) constructor</li></ul><p>我们先来看constructor，也就是ES6中每个类的构造函数，要创造一个组件类的实例，当然会调用对应的构造函数。</p><p>要注意，并不是每个组件都需要定义自己的构造函数。在后文中我们可以看到，无状态的React组件往往就不需要定义构造函数，一个React组件需要构造函数，往往是为了下面的目的：</p><ul><li><p>初始化state，因为组件生命周期中任何函数都可能要访问state，那么整个生命周期中第一个被调用的构造函数自然是初始化state最理想的地方</p></li><li><p>绑定成员函数的this环境</p></li></ul><p>在ES6语法下，类的每个成员函数在执行时的this并不是和类实例自动绑定的。而在构造函数中，this就是当前组件实例，所以，为了方便将来的调用，往往在构造函数中将这个实例的特定函数绑定this为当前实例。</p><p>以Counter组件为例，我们的构造函数有这样如下的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.onClickIncrementButton = <span class="keyword">this</span>.onClickIncrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.onClickDecrementButton = <span class="keyword">this</span>.onClickDecrementButton.bind(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这两句的作用，就是通过bind方法让当前实例中onClickIncrementButton和onClickDecrementButton函数被调用时，this始终是指向当前组件实例。</p><ul><li>2) getInitialState和getDefaultProps</li></ul><p>getInitialState这个函数的返回值用来初始化组件的this.state，但是，这个方法只有用React.createClass方法创造的组件类才会发生作用，本文中使用ES6语法，所以这个函数根本不会产生作用。</p><p>getDefaultProps函数的返回值可以作为props的初始值，和getInitialState一样，这个函数不会产生作用。</p><ul><li>3) render</li></ul><p>render函数无疑是React组件中最重要的函数，一个React组件可以忽略其他所有函数都不实现，但是一定要实现render函数，因为所有React组件的父类React.Component类对除render之外的生命周期函数都有默认实现。</p><p>通常一个组件要发挥作用，总是要渲染一些东西，render函数并不做实际的渲染动作，它只是返回一个JSX描述的结构，最终由React来操作渲染过程。</p><p>当然，某些特殊组件的作用不是渲染界面，或者，组件在某些情况下选择没有东西可画，那就让render函数返回一个null或者false，等于告诉React，这个组件这次不需要渲染任何DOM元素。</p><p>需要注意的时，render函数应该是一个纯函数，是完全根据this.state和this.props来决定返回的结果，而且不要产生任何副作用。在render函数中去调用this.setState毫无疑问是错误的，因为一个纯函数不应该引起状态的改变。</p><ul><li>4) componentWillMount和componentDidMount</li></ul><p>在装在过程中，componentWillMount会在调用render函数之前被调用，componentDidMount会在调用render函数之后被调用，这两个函数就像是render函数的前哨和后卫，一前一后，把render函数夹住，正好分别做render前后必要的工作。</p><p>不过，我们通常不用定义componentWillMount函数，顾名思义，componentWillMount发生在“将要装载”的时候，这个时候没有任何渲染出来的结果，即使调用this.setState修改状态也不会引发重新绘制，一切都迟了。换句话说，所有可以在这个componentWillMount中做的事情，都可以提前到constructor中去做，可以认为这个函数存在的主要目的就是为了和componentDidMount对称。</p><p>而componentDidMount作用就大了，需要注意的是，render函数被调用完之后，componentDidMount函数并不是会被立刻调用，componentDidMount被调用的时候，render函数返回的东西已经引发了渲染，组件已经被装载到了DOM树上。</p><p>我们还是以ControlPanel为例，在ControlPanel中有三个Counter组件，我们稍微修改Counter的代码，让装在过程中所有生命周期函数都用console.log输出函数名和caption的值，比如，componentWillMount函数的内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'enter componentWillMount '</span> + <span class="keyword">this</span>.props.caption);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器的console里我们能够看见：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enter constructor: First</span><br><span class="line">enter componentWillMount First</span><br><span class="line">enter render First</span><br><span class="line">enter constructor: Second</span><br><span class="line">enter componentWillMount Second</span><br><span class="line">enter render Second</span><br><span class="line">enter constructor: Third</span><br><span class="line">enter componentWillMount Third</span><br><span class="line">enter render Third</span><br><span class="line">enter componentDidMount First</span><br><span class="line">enter componentDidMount Second</span><br><span class="line">enter componentDidMount Third</span><br></pre></td></tr></table></figure><p>可以清楚的看到，虽然componentWillMount都是紧贴着自己组件的render函数之前被调用，componentDidMount可不是紧跟着render函数被调用，当所有三个组建的render函数都被调用之后，三个组件的componentDidMount才连在一起被调用。</p><p>之所以会有上面的现象，是因为render函数本身并不往DOM树上渲染或者装载内容，它只是返回一个JSX表示的对象，然后由React库来根据返回对象决定如何渲染。而React库肯定是要把所有的组件返回的结果综合起来，才能知道如何产生对应的DOM修改。所以，只有React库调用三个Counter组件的render函数之后，才有可能完成装载，这时候才会依次调用各个组件的componentDidMount函数作为装载过程的收尾。</p><p>componentWillMount和componentDidMount这对兄弟函数还有一个区别，就是componentWillMount可以在服务器端被调用，也可以在浏览器端被调用；而componentDidMount只能在浏览器端被调用，在服务器端使用React的时候不会被调用。</p><p>目前为止，我们构造的React应用例子都只是在浏览器端使用React，所以看不出区别，在后面关于“同构”应用的介绍时，我们会探讨在服务器端使用React的情况。</p><p>至于为什么只有componentDidMount仅在浏览器端执行，这是一个实现上的决定，而不是设计时刻有意而为之。不过，如果非要有个解释的话，可以这么说，既然“装载”是一个创建组件并放到DOM树上的过程，那么，真正的“装载”是不可能在服务器端完成的，因为服务器端渲染并不会产生DOM树，通过React组件产生的只是一个纯粹的字符串而已。</p><p>不管怎样，componentDidMount只在浏览器端执行，倒是给了我们开发者一个很好地位置去做只有浏览器端才做的逻辑，比如通过Ajax获取数据来填充组件的内容。</p><p>在componentDidMount被调用的时候，组件已经被装载到DOM树上了，可以放心获取渲染出来的任何DOM。</p><p>在实际开发过程中，可能会需要让React和其他UI库配合使用，比如，因为项目前期已经用jQuery开发了很多功能，需要继续使用这些基于jQuery的代码，有时候其他的UI库做某些功能比React更合适，比如d3.js已经支持了丰富的绘制图表的功能，在这些情况下，我们不得不考虑如何让React和其他UI库和平共处。</p><p>以和jQuery配合为例，我们知道，React是用来取代jQuery的，但如果真的要让React和jQuery配合，就需要利用componentDidMount函数，当componentDidMount被执行时，React组件对应的DOM已经存在，所有的事件处理函数也已经设置好，这时候就可以调用jQuery的代码，让jQuery在已经绘制的DOM基础上增强新的功能。</p><p>在componentDidMount中调用jQuery代码只处理了装载过程，要和jQuery完全结合，又要考虑React的更新过程，就需要使用下面要讲的componentDidUpdate函数。</p><h4 id="2-更新过程"><a href="#2-更新过程" class="headerlink" title="2. 更新过程"></a>2. 更新过程</h4><p>当组件被装载到DOM树上之后，用户在网页上可以看到组件的第一印象，但是要提供更好的交互体验，就要让该组件可以随着用户操作改变展现的内容，当props或者state修改的时候，就会引发组件的更新过程。</p><p>更新过程会依次调用下面的生命周期函数，其中render函数和装载过程一样，没有差别。</p><ul><li><p>componentWillReceiveProps</p></li><li><p>shouldComponentUpdate</p></li><li><p>componentWillUpdate</p></li><li><p>render</p></li><li><p>componentDidUpdate</p></li></ul><p>有意思的是，并不是所有的更新过程都会执行全部函数，下面会介绍到各种特例。</p><ul><li>1) componentWillReceiveProps(nextProps)</li></ul><p>关于这个componentWillReceiveProps存在一些误解。在网上有些教材声称这个函数只有当组件的props发生改变的时候才会被调用，其实是不正确的。实际上，只要是父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程，不管父组件传给子组件的props有没有改变，都会触发子组件的componentWillReceiveProps函数。</p><p>注意，通过this.setState方法触发的更新过程不会调用这个函数，这是因为这个函数适合根据新的props值（也就是参数nextProps）来计算出是不是要更新内部状态state。更新组件内部状态的方法就是this.setState，如果this.setState的调用导致componentWillReceiveProps再一次被调用，那就是一个死循环了。</p><p>让我们对ControlPanel做一些小的改进，来体会一下上面提到的规则。</p><p>我们首先在Counter组件类里增加函数定义，让这个函数componentWillReceiveProps在console上输出一些文字，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'enter componentWillReceiveProps '</span> + <span class="keyword">this</span>.props.caption);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ControlPanel组件的render函数中，我们也做如下修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'enter ControlPanel render'</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;style&#125;&gt;</span><br><span class="line">      ...</span><br><span class="line">      &lt;button onClick=&#123; () =&gt; <span class="keyword">this</span>.forceUpdate() &#125;&gt;</span><br><span class="line">        Click me to repaint!</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了在ControlPanel的render函数入口处增加console输出，我们还增加了一个按钮，这个按钮的onClick事件引发了一个匿名函数，当这个函数被点击的时候，调用this.forceUpdate，每个React组件都可以通过forceUpdate函数强行引发一次重新绘制。</p><p>在网页中，我们去点击那个新增加的按钮，可以看到浏览器的console中有如下输出：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enter ControlPanel render</span><br><span class="line">enter componentWillReceiveProps First</span><br><span class="line">enter render First</span><br><span class="line">enter componentWillReceiveProps Second</span><br><span class="line">enter render Second</span><br><span class="line">enter componentWillReceiveProps Third</span><br><span class="line">enter render Third</span><br></pre></td></tr></table></figure><p>可以看到，引发forceUpdate之后，首先是ControlPanel的render函数被调用，随后第一个Counter组件的componentWillReceiveProps函数被调用，然后Counter组件的render函数被调用，随后第二个第三个组件的这两个函数也依次被调用。</p><p>然而，ControlPanel在渲染三个子组件的时候，提供的props值一直就没有变化，可见componentWillReceiveProps并不是当props值变化的时候才被调用，所以，这个函数有必要把传入参数nextProps和this.props做必要对比。nextProps代表的是这一次渲染传入的props值，this.props代表的上一次渲染时的props值，只有两者有变化的时候才有必要调用this.setState更新内部状态。</p><p>在网页中，我们再次尝试点击第一个Counter组件的“<code>+</code>”按钮，可以看到浏览器的console输出如下：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enter render First</span><br></pre></td></tr></table></figure><p>明显，只有第一个组件的Counter的render函数被调用，函数componentWillReceiveProps没有被调用。因为点击“<code>+</code>”按钮引发的是第一个Counter组件的this.setState函数的调用，就像上面说过的一样，this.setState不会引发这个函数componentWillReceiveProps被调用。</p><p>从这个例子我们也会发现，在React的组件组合中，完全可以只渲染一个子组件，而其它组件完全不需要渲染，这是提高React性能的重要方式。</p><ul><li>2) shouldComponentUpdate(nextProps, nextState)</li></ul><p>除了render函数，shouldComponentUpdate可能是React组件生命周期中最重要的一个函数了。</p><p>说render函数重要，是因为render函数决定了该渲染什么，而说shouldComponentUpdate函数重要，是因为它决定了一个组件什么时候不需要渲染。</p><p>render和shouldComponentUpdate函数，也是React生命周期函数中唯二两个要求有返回结果的函数。render函数的返回结果将用于构造DOM对象，而shouldComponentUpdate函数返回一个布尔值，告诉React库这个组件在这次更新过程中是否要继续。</p><p>在更新过程中，React库首先调用shouldComponentUpdate函数，如果这个函数返回true，那就会继续更新过程，接下来调用render函数；反之，如果得到一个false，那就立刻停止更新过程，也就不会引发后续的渲染了。</p><p>说shouldComponentUpdate重要，就是因为只要使用恰当，它就能够大大提高React组件的性能，虽然React的渲染性能已经很不错了，但是，不管渲染有多快，如果发现没必要重新渲染，那就干脆不用渲染好了，速度会更快。</p><p>我们知道render函数应该是一个纯函数，这个纯函数的逻辑输入就是组件的props和state。所以，shouldComponentUpdate的参数就是接下来的props和state值。如果我们要定义shouldComponentUpdate，那就根据这两个参数，外加this.props和this.state来判断出返回true还是返回false。</p><p>如果我们给组件添加shouldComponentUpdate函数，那就沿用所有React组件父类React.Component中的默认实现方式，默认实现方式就是简单地返回true，也就是每次更新过程都要重新渲染。当然，这是最稳妥的方式，大不了浪费一点，但是绝对不会出错。不过若我们要追求更高的性能，就不能满足于默认实现，需要定制这个函数shouldComponentUpdate。</p><p>让我们尝试来给Counter组件增加一个shouldComponentUpdate函数。先来看看props，Counter组件支持两个props，一个叫caption，一个叫initValue。很明显，只有caption这个prop改变的时候，才有必要重新渲染。对于initValue，只是创建Counter组件实例时用于初始化计数值，在组件实例创建之后，无论怎么改，都不应该让Counter组件重新渲染。</p><p>再来看看state，Counter组件的state只有一个值count，如果count发生了变化，那肯定应该重新渲染，如果count没变化，那就没必要了。</p><p>现在，让我们给Counter组件类增加shouldComponentUpdate函数的定义，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="keyword">return</span> (nextProps.caption !== <span class="keyword">this</span>.props.caption) ||</span><br><span class="line">    (nextState.count !== <span class="keyword">this</span>.state.count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，只有当caption改变，或者state中的count值改变，shouldComponentUpdate才会返回true。</p><p>值得一提的是，通过this.setState函数引发更新过程，并不是立刻更新组件的state值，在执行到函数shouldComponentUpdate的时候，this.state依然是this.setState函数执行之前的值，所以我们要做的实际上就是在nextProps、nextState、this.props和this.state中互相比对。</p><p>我们在网页中引发一次ControlPanel的重新绘制，可以看到浏览器的console中输出这样：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enter ControlPanel render</span><br><span class="line">enter componentWillReceiveProps First</span><br><span class="line">enter componentWillReceiveProps Second</span><br><span class="line">enter componentWillReceiveProps Third</span><br></pre></td></tr></table></figure><p>可以看到，三个Counter组件的render函数都没有被调用，因为这个刷新没有改变caption的值，更没有引发组件内状态的改变，所以完全没有必要重新绘制counter。</p><p>对于Counter这个简单的组件，我们无法感觉到性能的提高，但是，实际开发中会遇到更复杂更庞大的组件，这种情况下避免没必要的重新渲染，就会大大提高性能。</p><ul><li>3) componentWillUpdate和componentDidUpdate</li></ul><p>如果组件的shouldComponentUpdate函数返回true，React接下来就会依次调用对应组件的componentWillUpdate、render和componentDidUpdate函数。</p><p>componentWillMount和componentDidMount，componentWillUpdate和componentDidUpdate，这两对函数一前一后地把render函数夹在中间。</p><p>和装载过程不同的是，当在服务器端使用React渲染时，这一对函数中的Did函数，也就是componentDidUpdate函数，并不是只在浏览器端才执行的，无论更新过程发生在服务器端还是浏览器端，该函数都会被调用。</p><p>在介绍componentDidMount函数时，我们说到可以利用componentDidMount函数执行其他UI库的代码，比如jQuery代码。当React组件被更新时，原有的内容被重新绘制，这时候就需要在componentDidUpdate函数再次调用jQuery代码。</p><p>那么，componentDidUpdate函数不是可能会在服务器端也被执行吗？在服务器端怎么能够使用jQuery呢？实际上，使用React做服务器端渲染时，基本不会经历更新过程，因为服务器端只需要产出HTML字符串，一个装载过程就足够产出HTML了，所以正常情况下服务器端不会调用componentDidUpdate函数，如果调用了，说明我们的程序有错误，需要改进。</p><h4 id="3-卸载过程"><a href="#3-卸载过程" class="headerlink" title="3. 卸载过程"></a>3. 卸载过程</h4><p>React组件的卸载过程只涉及一个函数componentWillUnmount，当React组件要从DOM树上删除掉之前，对应的componentWillUnmount函数会被调用，所以这个函数适合做一些清理性的工作。</p><p>和装载过程和更新过程不一样，这个函数没有配对的Did函数，就一个函数，因为卸载完就完了，没有“卸载完再做的事情”。</p><p>不过，componentWillUnmount中的工作往往和componentDidMount有关，比如，在componentDidMount中用非React的方法创造一些DOM元素，如果撒手不管可能会造成内存的泄漏，那就需要在componentWillUnmount中把这些创造的DOM元素清理掉。</p><hr><h3 id="四、组件向外传递数据"><a href="#四、组件向外传递数据" class="headerlink" title="四、组件向外传递数据"></a>四、组件向外传递数据</h3><p>通过构造ControlPanel和Counter，现在我们已经知道了如何通过props从父组件传递数据给子组件，但是，组件之间的交流是相互的，子组件某些情况下也需要把数据传递给父组件，我们接下来看看在React中如何实现这个功能。</p><p>在ControlPanel中，包含三个Control子组件实例，每个Counter都有一个可以动态改变的计数值，我们希望ControlPanel能够即时显示出这三个子组件当前计数值之和。</p><p>这个功能看起来很简单，但是要解决一个问题，就是要让ControlPanel“知道”三个子组件当前的计数值，而且是每次改变都要立刻知道，而Counter组件的当前值是组件的内部状态，如何让外部世界知道这个值呢？</p><p>解决这个问题的方法，依然是利用prop。组件的prop可以是任何JavaScript对象，而在JavaScript中，函数是一等公民，函数本身就可以被看作一种对象，既可以像其他对象一样作为prop的值从父组件传递给子组件，又可以被子组件作为函数调用，这样事情就好办了。</p><h4 id="1-应用实例"><a href="#1-应用实例" class="headerlink" title="1. 应用实例"></a>1. 应用实例</h4><p>我们看到修改后的功能图如图所示</p><p><img src="/images/react-2/5.png" alt="包含总数的ControlPanel应用效果图"></p><p>点击任何一个Counter的“<code>+</code>”按钮或者“<code>-</code>”按钮，可以看见除了所属Counter的计数变化，底部的总计数也会随之变化，这是因为Counter能够把自己状态改变的信息传递给外层的组件。</p><p>接下来看实现这个功能的关键代码。</p><p>在Counter组件中，对于点击“<code>+</code>”和“<code>-</code>”按钮的事件处理方法做了改动，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">onClickIncrementButton() &#123;</span><br><span class="line">  <span class="keyword">this</span>.updateCount(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onCLickDecrementButton() &#123;</span><br><span class="line">  <span class="keyword">this</span>.updateCount(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateCount(isIncrement) &#123;</span><br><span class="line">  <span class="keyword">const</span> previousValue = <span class="keyword">this</span>.state.count;</span><br><span class="line">  <span class="keyword">const</span> newValue = isIncrement ? previousValue + <span class="number">1</span> : previousValue - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: newValue &#125;);</span><br><span class="line">  <span class="keyword">this</span>.props.onUpdate(newValue, previousValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，onClickIncrementButton函数和onClickDecrementButton函数的任务除了调用this.setState改变内部状态，还要调用this.props.onUpdate这个函数，为了避免重复代码，我们对原有代码做一下重构，提取了共同部分到updateCount函数里。</p><p>对应的，Counter组件的propTypes和defaultProps就要增加onUpdate的定义，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Counter.propTypes = &#123;</span><br><span class="line">  caption: PropTypes.string.isRequires,</span><br><span class="line">  initValue: PropTypes.number,</span><br><span class="line">  onUpdate: PropTypes.func</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Counter.defaultProps = &#123;</span><br><span class="line">  initValue: <span class="number">0</span>,</span><br><span class="line">  onUpdate: <span class="function"><span class="params">f</span> =&gt;</span> f</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>新增加的prop叫做onUpdate，类型是一个函数，当Counter的状态改变的时候，就会调用这个给定的函数，从而达到通知父组件的作用。</p><p>这样，Counter的onUpdate就成了作为子组件的Counter向父组件ControlPanel传递数据的渠道，我们先约定这个函数的第一个参数是Counter更新之后的值，第二个参数是更新之前的值，至于如何使用这两个参数的值，是父组件ControlPanel的逻辑，Counter不用操心，而且根据两个参数的值足够推导出数值是增加还是减少。</p><p>从使用Counter组件的角度，在ControlPanel组件中也要做一些修改，现在ControlPanel需要包含自己的state，首先是构造函数部分，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.onCounterUpdate = <span class="keyword">this</span>.onCounterUpdate.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.initValues = [<span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line">  <span class="keyword">const</span> initSum = <span class="keyword">this</span>.initValues.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    sum: initSum</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ControlPanel组件被第一次渲染的时候，就需要显示三个计数器数值的综合，所以我们在构造函数中使用initValues数组记录所有的Counter的初始值，在初始化this.state之前，将initValues数组中所有值加在一起，作为this.state中sum字段的初始值。</p><p>ControlPanel传递给Counter组件的onUpdate这个prop的值是onCounterUpdate函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onCounterUpdate(newValue, previousValue) &#123;</span><br><span class="line">  <span class="keyword">const</span> valueChange = newValue - previousValue;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    sum: <span class="keyword">this</span>.state.sum + valueChange</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onCounterUpdate函数的参数和Counter中调用的onUpdate prop的参数规格一致，第一个参数为新值，第二个参数为之前的值，两者之差就是改变值，将这个改变作用到this.state.sum上就是sum的新状态。</p><p>遗憾的是，React虽然有PropType能够检查prop的类型，却没有任何机制来限制prop的参数规格，参数的一致性只能靠开发者来保证。</p><p>ControlPanel组件的render函数中需要增加对this.state.sum和onCountUpdate的使用，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;style&#125;&gt;</span><br><span class="line">      &lt;Counter onUpdate=&#123;<span class="keyword">this</span>.onCountUpdate&#125; caption=<span class="string">"First"</span> /&gt;</span><br><span class="line">      &lt;Count onUpdate=&#123;<span class="keyword">this</span>.onCountUpdate&#125; caption=<span class="string">"Second"</span> initValue=&#123;<span class="keyword">this</span>.initValues[<span class="number">1</span>]&#125; /&gt;</span><br><span class="line">      &lt;Count onUpdate=&#123;<span class="keyword">this</span>.onCountUpdate&#125; caption=<span class="string">"Third"</span> initValue=&#123;<span class="keyword">this</span>.initValues[<span class="number">2</span>]&#125; /&gt;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &lt;div&gt;Total Count: &#123;<span class="keyword">this</span>.state.sum&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="五、React组件state和prop的局限"><a href="#五、React组件state和prop的局限" class="headerlink" title="五、React组件state和prop的局限"></a>五、React组件state和prop的局限</h3><p>是时候重新思考一下多个组件之间的数据管理问题了。在上面修改的代码中，不难发现其实实现得并不精妙，每个Count组件有自己的状态记录当前计数，而父组件ControlPanel也有一个状态来存储所有Counter计数总和，也就是说，数据发生了重复。</p><p>数据如果出现重复，带来的一个问题就是如何保证重复的数据一致，如果数据存多份而且不一致，那就很难决定到底使用哪个数据作为正确结果了。</p><p>在上面的例子中，ControlPanel通过onUpdate回调函数传递的新值和旧值来计算新的计数总和，设想一下，由于某种bug的原因，某个按钮的点击更新没有通知到ControlPanel，就会让ControlPanel中的sum状态和所有子组件Counter的count状态之和不一致，这时候，是应该相信ControlPanel还是Count呢？</p><p>如图所示，逻辑上应该相同的状态，分别存放在不同组件中，就会导致这种困局。</p><p><img src="/images/react-2/6.png" alt="组件状态不一致的困惑"></p><p>对于上面所说的问题，一个直观的解决方法是以某一个组件的状态为准，这个组件是状态的“领头羊”，其余组件都保持和“领头羊”的状态同步，但是在实际情况下这种方法可能很难实施。比如上面的例子中，每个Counter记录自己的计数值是很自然的，但是有三个Counter组件，也就有三只“领头羊”，让ControlPanel跟着三只“领头羊”走，似乎不是一个好主意。</p><p>另一种思路，就是干脆不要让任何一个React组件扮演“领头羊”的角色，把数据源放在React组件之外形成全局状态，如下图所示，让各个组件保持和全局状态的一致，这样更容易控制。</p><p><img src="/images/react-2/7.png" alt="React中提取出来"></p><p>图中全局状态就是唯一可靠的数据源，下一章我们会介绍，这就是Flux和Redux中Store的概念。</p><p>除了state，利用prop在组件之间传递信息也会遇到问题。设想一下，在一个应用中，包含三级或者三级以上的组件结构，顶层的祖父级组件想要传递一个数据给最底层的子组件，用prop的方式，就只能通过父组件中转，而中间那一层父组件可能根本用不上这个prop，但是依然要支持这个prop，扮演好搬运工的角色，只因为子组件用得上，这明显违反了低耦合的设计要求。</p><p><img src="/images/react-2/8.png" alt="跨级传递prop的困局"></p><hr><h3 id="六、本章小结"><a href="#六、本章小结" class="headerlink" title="六、本章小结"></a>六、本章小结</h3><p>本章中，我们学习了构建高质量组件的原则，应用React一样要以构建高内聚低耦合的组件为目标，而保证组件高质量的一个重要工作就是保持组件对外接口清晰简洁。</p><p>React利用prop来定义组件的对外接口，用state来代表内部的状态，某个数据选择用prop还是用state表示，取决于这个数据是对内还是对外。</p><p>我们还介绍了React的生命周期，了解了装载过程、更新过程和卸载过程涉及的所有生命周期函数。</p><p>在本章中我们利用ControlPanel和Counter两个组件演示了组件之间的通信方式，包括子组件向父组件传递信息的方式，同时也看出了使用React的state来存储状态的一个缺点，那就是数据的冗余和重复，这就是我们接下来要解决的问题。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="/resources/深入浅出React和Redux.pdf">《深入浅出React和Redux —— 程墨》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个合格的开发者，不能只满足于编写出可以运行的代码，而要了解代码背后的工作原理；不能只满足于自己编写的程序能够运行，还要让自己的代码可读而且易于维护。这样才能开发出高质量的软件。&lt;/p&gt;
    
    </summary>
    
      <category term="React抄书笔记" scheme="http://www.xiaoleon.cn/categories/React%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.xiaoleon.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(1) 新的前端思维方式</title>
    <link href="http://www.xiaoleon.cn/2018/03/04/react-1/"/>
    <id>http://www.xiaoleon.cn/2018/03/04/react-1/</id>
    <published>2018-03-04T01:51:31.000Z</published>
    <updated>2018-03-19T13:15:53.821Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来只管认识React，对任何一种工具，只有使用才能够熟练掌握，React也不例外。通过对React快速上手，我们会解析React的工作原理，并通过与功能相同的jQuery程序对比，从而看出React的特点。</p><a id="more"></a><h3 id="一、初始化一个React项目"><a href="#一、初始化一个React项目" class="headerlink" title="一、初始化一个React项目"></a>一、初始化一个React项目</h3><p>React是一个JavaScript语言的工具库，我们需要安装Node.js，React本身并不依赖于Node.js，但是我们开发中用到的诸多工具需要Node.js的支持。</p><p>在Node.js的官网（<a href="https://nodejs.org" target="_blank" rel="noopener">https://nodejs.org</a>）可以找到合适的安装方式，安装Node.js的同时也就安装了npm，npm是Node.js的安装包管理工具，因为我们不可能自己开发所有功能，会大量使用现有的安装包，就需要npm的帮助。</p><h4 id="1-create-react-app工具"><a href="#1-create-react-app工具" class="headerlink" title="1. create-react-app工具"></a>1. create-react-app工具</h4><p>React技术依赖于一个很庞大的技术栈，比如，转译JavaScript代码需要使用Babel，模块打包工具又要使用Webpack，定制build过程需要grunt或者gulp，这些技术栈都需要各自的配置文件，还没有开始写一行React相关代码，我们就已经被各种技术名词淹没。</p><p>针对这种情况，React的创建者Facebook提供了一个快速开发React应用的工具，名叫<code>create-react-app</code>，这个工具的目的是将开发人员从配置工作中解脱出来，无需过早关注这些技术栈细节，通过创建一个已经完成基本配置的应用，让开发者快速开始React应用的开发。</p><p><code>create-react-app</code>是一个通过npm发布的安装包，在确认Node.js和npm安装好之后，命令行中执行下面的命令安装<code>create-react-app</code>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure><p>安装结束后，我们可以通过如下命令创建react项目：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app first_react_app</span><br></pre></td></tr></table></figure><p>这个命令会在当前目录创建一个名为first_react_app的目录，在这个目录中会自动添加一个应用的框架，随后我们只需要在这个框架的基础上修改文件就可以开发React应用，避免了大量的手工配置工作。</p><p>在<code>create-react-app</code>命令一大段文字输出之后，根据提示，输入下面的命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> first_react_app</span><br><span class="line">npm <span class="built_in">start</span></span><br></pre></td></tr></table></figure><p>这个命令会启动一个开发模式的服务器，同时也会让浏览器自动打开一个网页，指向本机地址<code>http://localhost:3000</code>。</p><p><img src="/images/react-1/1.png" alt="第一个React应用"></p><p>接下来，我们会用React开发一个简单的功能。</p><hr><h3 id="二、增加一个新的React组件"><a href="#二、增加一个新的React组件" class="headerlink" title="二、增加一个新的React组件"></a>二、增加一个新的React组件</h3><p>React的首要思想是通过组件（<code>Component</code>）来开发应用。所谓组件，简单说，指的是能完成某个特定功能的独立的、可重用的代码。</p><p>基于组件的应用开发是广泛使用的软件开发模式，用分而治之的方法，把一个大的应用分解成若干小的组件，每个组件只关注于某个小范围的特定功能，但是把组件组合起来，就能构成一个功能庞大的应用。如果分解功能的过程足够巧妙，那么每个组件可以在不同场景下重用，那么不光可以构建庞大的应用，还可以构建出灵活的应用。打个比方，每个组件是一块砖，而一个应用是一座楼，想要一次锻造就创建一座楼是不现实的。实际上，总是先锻造出很多砖，通过排列组合这些砖，才能构建伟大的建筑。</p><p>我们先看看<code>create-react-app</code>给我们自动产生的代码，在first_react_app目录下包含如下文件和目录。</p><p><img src="/images/react-1/2.png" alt="文件目录"></p><p>在开发过程中，我们主要关注src目录中的内容，这个目录中是所有的源代码。</p><p>create-react-app所创建的应用的入口是<code>src/index.js</code>文件，我们看看中间的内容，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个应用所做的事情，只是渲染一个名叫<code>App</code>的组件，<code>App</code>组件在同目录下的<code>App.js</code>文件中定义，渲染出来的效果就是在上图中看到的界面。</p><p>我们要定义一个新的能够计算点击数组件，名叫<code>ClickCounter</code>，所以我们修改<code>index.js</code>文件如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> ClickCounter <span class="keyword">from</span> <span class="string">'./ClickCounter'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ClickCounter /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>接下来我们会介绍代码的含义。现在我们先来看看如何添加一个新组件，在<code>src</code>目录下添加一个新的代码文件<code>ClickCounter.js</code>，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.onClickButton = <span class="keyword">this</span>.onClickButton.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onClickButton() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.onClickButton&#125;&gt;Click Me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          Click Count: &#123; this.state.count &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default ClickCounter;</span></span><br></pre></td></tr></table></figure><p>我们可以在网页中看到，其中内容已经发生改变，如下图所示</p><p><img src="/images/react-1/3.png" alt="ClickCounter组件界面效果"></p><p>点击“Click Me”按钮，可以看到“Click Count”后面的数字会随之增加，每点击一次加1.</p><p>现在让我们来逐步详细解释代码中各部分的要义。</p><p>在<code>index.js</code>文件中，使用<code>import</code>导入了<code>ClickCounter</code>组件，代替了之前的<code>App</code>组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ClickCounter <span class="keyword">from</span> <span class="string">'./ClickCounter'</span>;</span><br></pre></td></tr></table></figure><p><code>import</code>是ES6语法中导入文件模块的方式，ES6语法是一个大集合，大部分功能都被最新浏览器支持。不过这个<code>import</code>方法却不在广泛支持之列，这没有关系，ES6语法的JavaScript会被webpack和babel转译成所有浏览器支持的ES5语法，而这一切都无需开发人员配置，<code>create-react-app</code>已经替我们完成了这些工作。</p><p>在<code>ClickCounter.js</code>文件的第一行，我们从react库中引入了<code>React</code>和<code>Component</code>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br></pre></td></tr></table></figure><p><code>Component</code>作为所有组件的基类，提供了很多组建共有的功能，下面这行代码，使用的是ES6语法来创建一个叫<code>ClickCounter</code>的组建类，<code>ClickCounter</code>的父类就是<code>Component</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>在React出现之初，使用的是<code>React.createClass</code>方式来创造组件类，这种方法已经被废弃了。在本文中，我们只使用ES6的语法来构建组件类。</p><p>虽然我们导入的<code>Component</code>类在<code>ClickCounter</code>组件定义中使用了，可是导入的React却没有被使用，难道这里引入React没有必要吗？</p><p>事实上，引入React非常必要，我们可以尝试删掉第一行中的React，在网页中立刻会出现错误信息。</p><p><img src="/images/react-1/4.png" alt="缺失React的错误"></p><p>这个错误的含义是：“在使用JSX的范围内必须要有React。”</p><p>也就是说，在使用JSX的代码文件中，即使代码中并没有直接使用React，也一定要导入React，这是因为JSX最终会被转译成依赖于React的表达式。</p><h4 id="1-JSX"><a href="#1-JSX" class="headerlink" title="1. JSX"></a>1. JSX</h4><p>所谓JSX，是JavaScript的语法扩展（eXtension），让我们在JavaScript中可以编写像HTML一样的代码。在<code>ClickCounter.js</code>的<code>render</code>函数中，就出现了类似这样的HTML代码，在<code>index.js</code>中，<code>ReactDOM.render</code>的第一个参数<code>&lt;App /&gt;</code>也是一段JSX代码。</p><p>JSX中的这几段代码看起来和HTML几乎一模一样，都可以使用<code>&lt;div&gt;</code>、<code>&lt;button&gt;</code>之类的元素，所以只要熟悉HTML，学习JSX完全不成问题，但是，我们一定要明白两者的不同之处。</p><p>首先，在JSX中使用的“元素”不局限于HTML元素，可以是任何一个React组件，在App.js中可以看到，我们创建的<code>ClickCounter</code>组件被直接应用在JSX中，使用方法和其他元素一样，这一点是传统的HTML做不到的。</p><p>React判断一个元素是HTML元素还是React元素的原则就是看第一个字母是否大写，如果在JSX中我们不用<code>ClickCounter</code>而是用<code>clickCounter</code>，那就得不到我们想要的结果。</p><p>其次，在JSX中可以通过<code>onClick</code>的方式给一个元素添加一个事件处理函数，当然，在HTML中也可以使用<code>onclick</code>（注意和<code>onClick</code>拼写有区别），但在HTML中直接书写<code>onclick</code>一直就是为人诟病的写法，网页应用开发界一直倡导的是用jQuery的方法添加事件处理函数，直接写<code>onclick</code>会带来代码混乱的问题。</p><p>这就带来一个问题，既然长期以来一直不提倡在HTML中使用<code>onclick</code>，为什么在React的JSX中我们却要使用<code>onClick</code>这样的方式来添加事件处理函数呢？</p><h4 id="2-JSX是进步还是倒退"><a href="#2-JSX是进步还是倒退" class="headerlink" title="2. JSX是进步还是倒退"></a>2. JSX是进步还是倒退</h4><p>在React出现之初，很多人对React这样的设计非常反感，因为React把类似HTML的标记语言和JavaScript混在一起了，但是，随着时间的推移，业界逐渐认可了这种方式，因为大家都发现，以前用HTML来代表内容，CSS代笔样式，Javascript来定义交互行为，这三种语言分在三种不同的文件里面，实际上是把不同技术分开管理了，而不是逻辑上的“分而治之”。</p><p>根据做同一件事的代码应该有高耦合性的设计原则，既然我们要实现一个<code>ClickCounter</code>，那为什么不把实现这个功能的所有代码集中在一个文件里呢？</p><p>那么，在JSX中使用<code>onClick</code>添加事件处理函数，是否代表网页应用开发兜了一个大圈，最终回到了起点呢？</p><p>不是这样，JSX的<code>onClick</code>事件处理方式和HTML的<code>onclick</code>有很大不同。</p><p>即使现在，我们还是要说在HTML中直接使用<code>onclick</code>很不专业，原因如下：</p><ul><li><p><code>onclick</code>添加的事件处理函数是在全局环境下执行的，这污染了全局环境，很容易产生意料不到的后果</p></li><li><p>给很多Dom元素添加<code>click</code>事件，可能会影响网页的性能，毕竟，网页需要的事件处理函数越多，性能就会越低</p></li><li><p>对于使用<code>onclick</code>的Dom元素，如果要动态地从DOM树中删掉的话，需要把对应的事件处理器注销，假如忘了注销，就可能造成内存泄漏，这样的bug很难被发现</p></li></ul><p>上面说的这些问题，在JSX中都不存在。</p><p>首先，<code>onClick</code>挂载的每个函数，都可以控制在组建范围内，不会污染全局空间。</p><p>我们在JSX中看到一个组件使用了<code>onClick</code>，但并没有产生直接使用<code>onclick</code>的HTML，而是使用了事件委托（event delegation）的方式处理点击事件，无论有多少个<code>onClick</code>出现，其实最后都只在DOM树上添加了一个事件处理函数，挂在最顶层的DOM节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组建分配给特定函数，使用事件委托的性能当然要比为每个<code>onClick</code>都挂载一个事件处理函数要高。</p><p>因为React控制了组件的生命周期，在<code>unmount</code>的时候自然能够清除相关的所有事件处理函数，内存泄漏也不再是一个问题。</p><p>除了在组件中定义交互行为，我们还可以在React组件中定义样式，我们可以修改<code>ClickCounter.js</code>中的<code>render</code>函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> counterStyle = &#123;</span><br><span class="line">    margin: <span class="string">'16px'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;counterStyle&#125;&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.onClickButton&#125;&gt;Click Me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      Click Count: &lt;span id="clickCount"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在JavaScript代码中定义一个<code>counterStyle</code>对象，然后在JSX中赋值给顶层div的style属性，可以在网页中看到这个部分的margin真的变大了。</p><p>这样，React的组件可以把JavaScript、HTML和CSS的功能写在一个文件中，实现真正的组件封装。</p><hr><h3 id="三、分解React应用"><a href="#三、分解React应用" class="headerlink" title="三、分解React应用"></a>三、分解React应用</h3><p>前面我们提到过，React应用实际上依赖于一个很大很复杂的技术栈，我们使用<code>create-react-app</code>避免在一开始就费太多精力配置技术栈，不过现在是时候了解一下这个技术栈了。</p><p>我们启动React应用的命令是<code>npm start</code>，看看<code>package.json</code>中对<code>start</code>脚本的定义。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "react-scripts start",</span><br><span class="line">  "build": "react-scripts build",</span><br><span class="line">  "test": "react-scripts test --env=jsdom",</span><br><span class="line">  "eject": "react-scripts eject"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，start命令实际上是调用了react-scripts命令，<code>react-scripts</code>是<code>create-react-app</code>添加的一个npm包，所有的配置文件都藏在<code>node_modules/react-scripts</code>目录下，我们当然可以钻进这个目录去一探究竟，但是也可以使用eject方法来看清楚背后的原理。</p><p>这个eject（弹射）命令做的事情，就是把潜藏在<code>react-scripts</code>中的一系列技术栈配置都“弹射”到应用的顶层，然后我们就可以研究这些配置细节了，而且可以更灵活地定制应用的配置。</p><blockquote><p>eject命令是不可逆的，就好像战斗机飞行员选择“弹射”出驾驶舱，等于是放弃了这架战斗机，是不可能再飞回驾驶舱的。所以，当你执行eject之前，最好做一下备份。</p></blockquote><p>我们在命令行下执行下面的命令，完成“弹射”操作：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run eject</span><br></pre></td></tr></table></figure><p>这个命令会改变一些文件，也会添加一些文件。</p><p>当前目录下会增加两个目录，一个是scripts，另一个是config，同时，<code>package.json</code>文件中的scripts部分也发生了变化：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "node scripts/start.js",</span><br><span class="line">  "build": "node scripts/build.js",</span><br><span class="line">  "test": "node scripts/test.js --env=jsdom"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从此以后，start脚本将使用scripts目录下的<code>start.js</code>，而不是node_modules目录下的<code>react-scripts</code>，弹射成功，再也回不去了。</p><p>在config目录下的<code>webpack.config.dev.js</code>文件，定制的就是npm start所做的构造过程，其中有一段关于babel的定义：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test"</span>: /\.(js|jsx)$/,</span><br><span class="line">  <span class="attr">"include"</span>: paths.appSrc,</span><br><span class="line">  <span class="attr">"loader"</span>: <span class="string">"babel"</span>,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    // This is a feature of 'babel-loader' for webpack (not Babel itself).</span><br><span class="line">    // It enables caching results in ./node_modules/.cache/babel-loader/</span><br><span class="line">    // directory for faster rebuilds.</span><br><span class="line">    "cacheDirectory": true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的<code>paths.appSrc</code>的值就是<code>src</code>，所以这段配置的含义指的是所有以js或者jsx为扩展名的文件，都会由babel所处理。</p><p>并不是所有的浏览器都支持所有的ES6语法，但是有了babel，我们就可以不用顾忌太多，因为babel会把ES6语法的JavaScript代码转译为浏览器普遍支持的JavaScript代码，实际上，在React社区中，不使用ES6语法写代码才显得奇怪。</p><hr><h3 id="四、React的工作方式"><a href="#四、React的工作方式" class="headerlink" title="四、React的工作方式"></a>四、React的工作方式</h3><p>在继续深入学习React的其他知识之前，我们先就这个简单的<code>ClickCounter</code>组件思考一下React的工作方式，要了解一样东西的特点，最好的方法当然是拿这个东西和另一样东西做比较。我们就拿React和jQuery来比较。</p><h4 id="1-jQuery如何工作"><a href="#1-jQuery如何工作" class="headerlink" title="1. jQuery如何工作"></a>1. jQuery如何工作</h4><p>假设我们用jQuery来实现<code>ClickCounter</code>的功能，该怎么做呢？首先，我们要产生一个网页的HTML，写一个<code>index.html</code>文件如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"ClickMe"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        Click Count: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"clickCount"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./clickCounter.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实际产品中，产生这样的HTML可以用PHP、Java、Ruby或者任何一种服务器端语言和框架来做，也可以在浏览器中用Mustache、Hogan这样的模板来产生，这里我们只是把问题简化，直接书写HTML。</p><p>上面的HTML只是展示样式，并没有任何交互功能，现在我们用jQuery来实现交互功能，和jQuery的传统一样，我们把JavaScript写在一个独立的文件<code>clickCounter.js</code>中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#clickMe'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clickCounter = $(<span class="string">'#clickCount'</span>);</span><br><span class="line">    <span class="keyword">var</span> count = <span class="built_in">parseInt</span>(clickCounter.text(), <span class="number">10</span>);</span><br><span class="line">    clickCounter.text(count + <span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>用浏览器打开上面创造的<code>index.html</code>，可以看到实际效果和我们写的React应用一模一样，但是对比这两段程序可以看出差异。</p><p>在jQuery解决方案中，首先根据CSS规则找到id为<code>clickCount</code>的按钮，挂上一个匿名事件处理函数，在事件处理函数中，选中那个需要被修改的DOM元素，读取其中的文本值，加以修改，然后修改这个DOM元素。</p><p>选中一些DOM元素，然后对这些元素做一些操作，这是一种最容易理解的开发模式。jQuery的发明人John Resig就是发现了网页应用开发者的这种编程模式，才创造出了jQuery，其一问世就得到普遍认可，因为这种模式直观易懂。但是，对于庞大的项目，这种模式会造成代码结构复杂，难以维护，每个jQuery的使用者都会有这种体会。</p><h4 id="2-React的理念"><a href="#2-React的理念" class="headerlink" title="2. React的理念"></a>2. React的理念</h4><p>与jQuery不同，用React开发应用是另一种体验，我们回顾一下，用React开发的<code>ClickCounter</code>组件好像没有像jQuery那样做“选中一些DOM元素然后做一些事情”的动作。</p><p>打一个比方，React是一个聪明的建筑工人，而jQuery是一个比较傻的建筑工人，开发者你就是一个建筑的设计师，如果是jQuery这个建筑工人为你工作，你不得不事无巨细地告诉jQuery“如何去做”，要告诉他这面墙要拆掉重建，那面墙上要新开一个窗户。反之，如果是React这个建筑工人为你工作，你所要做的就是告诉这个工人“我想要什么样子”，只要把图纸递给React这个工人，他就会替你搞定一切，当然他不会把整个建筑拆掉重建，而是很聪明地把这次的图纸和上次的图纸做一个对比，发现不同之处，然后只去做适当的修改就完成任务了。</p><p>显而易见，React的工作方式把开发者从繁琐的操作中解放出来，开发者只需要着重“我想要显示什么”，而不用操心“怎样去做”。</p><p>这种新的思维方式，对于一个简单的例子也要编写不少代码，感觉像是用高射炮打蚊子，但是对于一个大型的项目，这种方式编写的代码会更容易管理，因为整个React应用要做的就是渲染，开发者关注的是渲染成什么样子，而不用关心如何实现增量渲染。</p><p>React的理念，归结为一个公式，就像下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UI = render(data)</span><br></pre></td></tr></table></figure><p>让我们来看看这个公示表达的含义，用户看到的界面（<code>UI</code>），应该是一个函数（在这里叫<code>render</code>）的执行结果，只接受数据（<code>data</code>）作为参数。这个函数是一个纯函数，所谓纯函数，指的是没有任何副作用，输出完全依赖于输入的函数，两次函数调用如果输入相同，得到的结果也绝对相同。如此一来，最终的用户界面，在<code>render</code>函数确定的情况下完全取决于输入数据。</p><p>对于开发者来说，重要的是区分开哪些属于<code>data</code>，哪些属于<code>render</code>，想要更新用户界面，要做的就是更新<code>data</code>，用户界面自然会做出响应，所以React实践的也是“响应式编程”（<code>Reactive Programming</code>）的思想，这也就是React为什么叫做React的原因。</p><h4 id="3-Virtual-DOM"><a href="#3-Virtual-DOM" class="headerlink" title="3. Virtual DOM"></a>3. Virtual DOM</h4><p>既然React应用就是通过重复渲染实现用户交互，我们可能会有一个疑虑：这样的重复渲染会不会效率太低了呢？毕竟，在jQuery的实现方式中，我们可以清楚地看到每次只有需要变化的那一个DOM元素被修改了；可是，在React的实现方式中，看起来每次render函数被调用，都要把整个组件重新绘制一次，这样看起来有点浪费。</p><p>事实并不是这样，React利用Virtual DOM，让每次渲染都重新渲染最少的DOM元素。</p><p>要了解Virtual DOM，就要先了解DOM，DOM是结构化文本的抽象表达形式，特定于Web环境中，这个结构化文本就是HTML文本，HTML中的每个元素都对应DOM中的某个节点，这样，因为HTML元素的逐级包含关系，DOM节点自然就构成了一个树形结构，称为DOM树。</p><p>浏览器为了渲染HTML格式的网页，会先将HTML文本解析以构建DOM树，然后根据DOM树渲染出用户看到的界面，当要改变界面内容的时候，就去改变DOM树上的节点。</p><p>Web前端开发关于性能优化有一个原则：尽量减少DOM操作。虽然DOM操作也只是一些简单的JavaScript语句，但是DOM操作会引起浏览器对网页进行重新布局，重新绘制，这就是一个比JavaScript语句执行慢很多的过程。</p><p>如果使用mustache或者hogan这样的模板工具，那就是生成HTML字符串塞到网页中，浏览器又要做一次解析产生新的DOM节点，然后替换DOM树上对应的子树部分，这个过程肯定效率不高。虽然JSX看起来很像是一个模板，但是最终会被Babel解析为一条条创建React组件或者HTML元素的语句，神奇之处在于，React并不是通过这些语句直接构建DOM树，而是首先构建Virtual DOM。</p><p>既然DOM树是对HTML的抽象，那Virtual DOM就是对DOM树的抽象。Virtual DOM不会触及浏览器的部分，只是存在于JavaScript空间的树形结构，每次自上而下渲染React组件时，会对比这一次产生的Virtual DOM和上一次渲染的Virtual DOM，对比就会发现差别，然后修改真正的DOM树时就只需要触及差别中的部分就行。</p><p>以<code>ClickCounter</code>为例，一开始点击计数为0，用户点击按钮让点击计数变成1，这一次重新渲染，React通过Virtual DOM的对比发现其实只是id为<code>clickCounter</code>的span元素中内容从0变成了1而已：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"clickCounter"</span>&gt;</span>&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React发现这次渲染要做的事情只是更换span元素的内容而已，其他DOM元素都不需要触及，于是执行类似下面的语句，就完成了任务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'clickCounter'</span>).innerHTML = <span class="string">"1"</span>;</span><br></pre></td></tr></table></figure><h4 id="4-React工作方式的优点"><a href="#4-React工作方式的优点" class="headerlink" title="4. React工作方式的优点"></a>4. React工作方式的优点</h4><p>毫无疑问，jQuery的方式直观易懂，对于初学者十分适用，但是当项目逐渐变得庞大时，用jQuery写出的代码往往互相纠缠，形成类似下图的状况，难以维护。</p><p><img src="/images/react-1/5.png" alt="jQuery方式造成的纠缠代码结构"></p><p>使用React的方式，就可以避免构建这样复杂的程序结构，无论何种事件，引发的都是React组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发者并不需要关心，程序的流程简化为如下方式。</p><p><img src="/images/react-1/6.png" alt="React的程序流程"></p><p>React利用函数式编程的思维来解决用户界面渲染的问题，最大的优势是开发者的效率会大大提高，开发出来的代码可维护性和可阅读性也大大增强。</p><p>React等于强制所有组件都按照这种由数据驱动渲染的模式来工作，无论应用的规模多大，都能让程序处于可控范围内。</p><hr><h3 id="五、本文小结"><a href="#五、本文小结" class="headerlink" title="五、本文小结"></a>五、本文小结</h3><p>在本文中，我们用<code>create-react-app</code>创造了一个简单的React应用，在一开始，我们就按照组件的思想来开发应用，React的主要理念之一就是基于组件来开发应用。</p><p>通过和同样功能的jQuery实现方式对比，我们了解了React的工作方式，React利用声明式的语法，让开发者专注于描述用户界面“显示成什么样子”，而不是重复思考“如何去显示”，这样可以大大提高开发效率，也让代码更加容易管理。</p><p>虽然React是通过重复渲染来实现动态更新效果，但是借助Virtual DOM技术，实际上这个过程并不牵涉太多的DOM操作，所以渲染效率很高。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="/resources/深入浅出React和Redux.pdf">《深入浅出React和Redux —— 程墨》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们先来只管认识React，对任何一种工具，只有使用才能够熟练掌握，React也不例外。通过对React快速上手，我们会解析React的工作原理，并通过与功能相同的jQuery程序对比，从而看出React的特点。&lt;/p&gt;
    
    </summary>
    
      <category term="React抄书笔记" scheme="http://www.xiaoleon.cn/categories/React%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.xiaoleon.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Web(5) HTTP与HTTPS</title>
    <link href="http://www.xiaoleon.cn/2018/03/02/web-5/"/>
    <id>http://www.xiaoleon.cn/2018/03/02/web-5/</id>
    <published>2018-03-02T02:15:50.000Z</published>
    <updated>2018-03-12T14:04:54.242Z</updated>
    
    <content type="html"><![CDATA[<p>超文本传输协议HTTP被用于Web浏览器和网站服务器之间传递信息，HTTP以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><a id="more"></a><p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h3 id="一、TCP-IP、HTTP、HTTPS"><a href="#一、TCP-IP、HTTP、HTTPS" class="headerlink" title="一、TCP/IP、HTTP、HTTPS"></a>一、TCP/IP、HTTP、HTTPS</h3><ul><li><p>TCP/IP：传输层协议，主要解决数据如何在网络中传输，Web服务器将HTTP封装好的文本信息，通过TCP/IP协议发送到网络上。</p></li><li><p>HTTP：应用层协议，用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p></li><li><p>HTTPS：以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p></li></ul><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><p>下面的图表显示OSI（Open System Interconnect）模型中的各项协议：</p><table><thead><tr><th>OSI层</th><th>协议名称</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP</td></tr><tr><td>表示层</td><td>XDR、ASN.1、SMB、AFP、NCP</td></tr><tr><td>会话层</td><td>ASAP、TLS、SSH、ISO 8327 / CCITT X.255、RPC、NetBIOS、ASP、Winsock、BSD sockets</td></tr><tr><td>传输层</td><td>TCP、UDP、RTP、SCTP、SPX、ATP、IL</td></tr><tr><td>网络层</td><td>IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25</td></tr><tr><td>数据链路层</td><td>以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP</td></tr><tr><td>物理层</td><td>线路、无线电、光钎、信鸽</td></tr></tbody></table><hr><h3 id="二、HTTP与HTTPS有什么区别"><a href="#二、HTTP与HTTPS有什么区别" class="headerlink" title="二、HTTP与HTTPS有什么区别"></a>二、HTTP与HTTPS有什么区别</h3><p>HTTP传输的数据都是未加密的，也就是明文的，因此使用HTTP传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTPS构建的可进行传输加密、身份认证的网络协议，要比HTTP安全。</p><p>HTTPS和HTTP的主要区别如下：</p><ul><li><p>1) HTTPS协议需要到CA申请证书，一般免费证书较少，因而需要一定费用</p></li><li><p>2) HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议</p></li><li><p>3) HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，HTTP是80，HTTPS是443</p></li><li><p>4) HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP构建的可进行加密传输、身份认证的网络协议，比HTTP更安全</p></li></ul><hr><h3 id="三、HTTP三次握手"><a href="#三、HTTP三次握手" class="headerlink" title="三、HTTP三次握手"></a>三、HTTP三次握手</h3><p><img src="/images/web-5/1.png" alt="HTTP三次握手时序图"></p><p>TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p><ul><li><p>1) 第一次握手：客户端发送syn包（syn=j）到服务器，并进入SYN_SEND状态，等待服务器确认</p></li><li><p>2) 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态</p></li><li><p>3) 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p></li></ul><hr><h3 id="四、HTTP四次挥手"><a href="#四、HTTP四次挥手" class="headerlink" title="四、HTTP四次挥手"></a>四、HTTP四次挥手</h3><p><img src="/images/web-5/2.png" alt="HTTP四次挥手时序图"></p><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>HTTP的关闭需要发送四个包，因此称为四次挥手（four-way handshake）。客户端或服务端均可主动发起挥手操作，在socket中，任何一方执行close()操作即可产生挥手操作。</p><ul><li><p>1) 客户端发送一个FIN，用来关闭客户端到服务端的数据传送</p></li><li><p>2) 服务端收到这个FIN，返回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号</p></li><li><p>3) 服务端关闭与客户端的连接，发送一个FIN到客户端</p></li><li><p>4) 客户端发挥ACK报文确认，并将确认序号设置为收到序号加1</p></li></ul><hr><h3 id="五、HTTPS的工作原理"><a href="#五、HTTPS的工作原理" class="headerlink" title="五、HTTPS的工作原理"></a>五、HTTPS的工作原理</h3><p><img src="/images/web-5/3.png" alt="HTTPS通信"></p><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><ul><li><p>1) 客户使用HTTPS的URL访问Web服务器，要求与Web服务器建立SSL连接</p></li><li><p>2) Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端</p></li><li><p>3) 客户端解析证书，首先验证公钥是否有效，比如颁发机构、过期时间等，如果发现异常，则会弹出警告框，提示证书存在问题</p></li><li><p>4) 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级</p></li><li><p>5) 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给Web服务器</p></li><li><p>6) Web服务器利用字迹的私钥解密出会话密钥</p></li><li><p>7) Web服务器利用会话密钥加密与客户端之间的通信</p></li></ul><p><img src="/images/web-5/4.png" alt="HTTPS连接时序图"></p><hr><h3 id="六、HTTPS的优点"><a href="#六、HTTPS的优点" class="headerlink" title="六、HTTPS的优点"></a>六、HTTPS的优点</h3><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是当前架构下最安全的解决方案，主要有以下几个好处：</p><ul><li><p>1) 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户端和服务器</p></li><li><p>2) HTTPS协议是由SSL+HTTP构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性</p></li><li><p>3) HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本</p></li><li><p>4) Google曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”</p></li></ul><hr><h3 id="七、HTTPS的缺点"><a href="#七、HTTPS的缺点" class="headerlink" title="七、HTTPS的缺点"></a>七、HTTPS的缺点</h3><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><ul><li><p>1) HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%-20%的耗电</p></li><li><p>2) HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响</p></li><li><p>3) SSL整数需要收费，功能越强大的整数费用越高，个人网站、小网站没有必要一般不会用</p></li><li><p>4) SSL整数通常需要绑定IP，不能再同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗</p></li><li><p>5) HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务供给、服务器劫持等方面几乎起不到什么作用。最关键的，SSL整数的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="https://www.cnblogs.com/wqhwe/p/5407468.html" target="_blank" rel="noopener">HTTP与HTTPS的区别</a></p></li><li><p><a href="https://www.cnblogs.com/lovesong/p/5186200.html" target="_blank" rel="noopener">HTTP与HTTPS握手的那些事</a></p></li><li><p><a href="https://www.cnblogs.com/Jessy/p/3535612.html" target="_blank" rel="noopener">TCP的三次握手（建立连接）和四次挥手（关闭连接）</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;超文本传输协议HTTP被用于Web浏览器和网站服务器之间传递信息，HTTP以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HTTP" scheme="http://www.xiaoleon.cn/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="http://www.xiaoleon.cn/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>其他(1) 软考论文经验</title>
    <link href="http://www.xiaoleon.cn/2018/03/01/ruankao-1/"/>
    <id>http://www.xiaoleon.cn/2018/03/01/ruankao-1/</id>
    <published>2018-03-01T05:43:29.000Z</published>
    <updated>2018-03-05T14:35:56.004Z</updated>
    
    <content type="html"><![CDATA[<p>17年下半年的信息系统项目管理师考试，前前后后间断复习了大概3个月，没想到最后一次过了，挺意外的。</p><a id="more"></a><p>由于上班比较忙，所以也没有很系统的进行相关复习，都是零碎时间看点真题，然后上信管网来看看案例分析。这里客观题和主观题就不作经验分享了，感觉自己能拿这个分数纯属巧合，主要介绍一下自己论文的一点经验。</p><h3 id="一、练字"><a href="#一、练字" class="headerlink" title="一、练字"></a>一、练字</h3><p>论文属于纯手写考试，评卷老师的第一感官便是我们的卷面整洁及清晰程度，我们至少应当做到字迹清晰工整，这样可以给评卷老师留下一个好的第一印象，同时节省评卷的时间。如果字迹优雅、布局工整，相信评卷老师也会从内心里当作是一副书法作品来阅读。</p><p>另外，我们需要做到在2个小时的考试时间内，保持字迹大体一致，减少评卷老师在字迹上的心理变化。从字迹的变化上能够很容易反映出考生的心理状态，比如没有提前做好论文的前期准备，就容易出现大量的划痕；或者后期时间不够了，容易出现心里焦躁，字迹越来越乱的情况。</p><p>我在写论文的时候，就出现了最后半小时发现时间不够用的情况，最后的500-600字由于时间特别赶，导致字迹开始越来越乱，最后写完大概只剩下了不到3分钟。从卷面上，能够很明显的感觉到我当时慌乱的心境，也是没有准备充分的体现。现在想想，如果提前有充足的准备，应该不至于在这方面出现差错，分数可能也会比当前的49要高一些吧。</p><hr><h3 id="二、提速"><a href="#二、提速" class="headerlink" title="二、提速"></a>二、提速</h3><p>论文考试是2个小时内，需要书写2500到3000字。如果没有经过提前练习，加上现在生活中提笔写字的机会接近于零，几乎是一个不可能完成的任务。因此，考前一定需要花上一段时间，每天练习写字速度，在保证文笔工整的前提下，尽量提高论文的行文速度。</p><p>这里给一个小建议，考前我们可以从网上下载一些模版论文，先完整地抄写几遍模板论文。这样可以计算出自己在完全不思考的情况下，写完一整篇论文的速度，然后再根据情况进行提速训练。</p><p>我考前大概抄写了9篇模板论文，取平均数的话，大概抄写完整篇文章需要1小时30分钟到1小时40分钟。也就是说，如果在考试过程中还需要构思，那思考时间最多只能控制在20分钟到30分钟内。这个时间可以说非常紧张，也正是因为在考试中，我还需要边写边思考后面的内容，所以才导致了最后的时间非常紧张。</p><hr><h3 id="三、模拟"><a href="#三、模拟" class="headerlink" title="三、模拟"></a>三、模拟</h3><p>由于论文考试需要书写在特定的答题纸上，因此我们可以利用这个答题纸的样式来进行提前练习。论文答题纸分为6页，摘要部分从第一页的中间到第二页的前几行，然后剩余的5页为正文部分。我们可以从信管网上下载答题纸模版pdf，然后打印出来，直接在上面抄写模板论文或书写准备的论文。</p><p>这样模拟练习后，我们就能够有个大概的概念，摘要第一部分应该写到哪一行，第二部分应该写到哪一行，总结的字数应该控制在多少。</p><p>我们把论文正文分为三大块：开头、正文、结尾。其中开头部分一般从第二页的前几行，书写到第三页的中间；正文部分从第三页的中间，书写到第五页的下方；结尾部分，从第五页的下方，书写到第六页的下方。</p><p>我们还可以划分时间节点，比如摘要大概花费20分钟，开头大概花费20分钟，正文大概花费60分钟，结尾大概花费20分钟。</p><p>这样经过模拟训练后，考场上我们就可以有条不紊的执行我们的考试规划，在指定时间和指定地点完整对应的书写工作。</p><hr><h3 id="四、模板"><a href="#四、模板" class="headerlink" title="四、模板"></a>四、模板</h3><p>由于信管考试论文的特殊性，9大类论点必考一题，使得我们可以针对这9项进行提前准备。</p><h4 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h4><p>摘要是整篇文章的内容浓缩，这里建议参考信管网或者各论坛的摘要写作指导，我建议在模拟练习中，将9大类的摘要都仔细思考并行文一遍，经过多次修改后，形成最后的模版。</p><p>考场上不太可能有足够的时间来思考摘要应该怎么写，时间是非常宝贵的，我们更应当花费时间去判断论题是否跟往年有所出入，如果题目要求与其他方面进行结合，应当怎么样在摘要模板中进行修改并点题。</p><p>可以说摘要是非常重要的，阅卷老师从摘要就能得出全文的第一印象，而且阅卷的特殊性，可能只有一两分钟的阅读时间，所以前期准备过程中需要好好斟酌。</p><p>我在考试过程中，发卷到开考前，思考了下论题是否和准备的模版有出入。开考后，直接落笔写摘要，大约10分钟写完摘要，把时间尽量多的留给正文部分。</p><h4 id="2-开头"><a href="#2-开头" class="headerlink" title="2. 开头"></a>2. 开头</h4><p>开头也是我们可以提前准备的部分，虽然9大类论题各不相同，但是论文要求我们与实际项目相结合，那么开头我们可以相对统一，比如介绍项目的背景、需求、技术等等，先提前准备好一个项目，把这个项目中涉及到的相关具体内容整理成文，同时借用一下网上模板论文中的一些好的语句进行串联，修改得到大约600-800字的开头。最后，多在准备过程中写几遍，把内容背下来，减少考试过程中的思考时间。</p><p>我在考试过程中，大约花了20分钟写论文开头，写到预先设计的第三页中间后，正好结束开头部分，开始写正文部分。</p><h4 id="3-正文"><a href="#3-正文" class="headerlink" title="3. 正文"></a>3. 正文</h4><p>正文是全文耗时最长，也最为重要的部分。这部分建议准备过程中，能够完整地把9大类论题，都思考成文一遍，考前再阅读记忆几次，这样考试过程中可以较为顺利的进行书写，从而减少构思的时间。</p><p>我在正文部分准备的不够充分，考前只思考和列举了9大类需要书写的提纲，以及能够用在这些提纲内的案例与项目结合点。在真正考试的时候，很明显的感觉到，有时候写完提纲要点，发现不知道具体的阐述内容应该如何落笔行文，还需要停下来花时间构思，这样非常浪费时间。</p><p>至于正文结构，建议采用如下格式（具体提纲忘了，请勿参考示例提纲）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">结合具体参与的项目，成本管理大概分为以下几点：</span><br><span class="line"></span><br><span class="line">1. 成本估算</span><br><span class="line"></span><br><span class="line">// 第一段，对成本估算的概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明是怎么完成成本估算过程的</span><br><span class="line"></span><br><span class="line">2. 成本预算</span><br><span class="line"></span><br><span class="line">// 第一段，对成本预算的概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明是怎么完成成本预算过程的</span><br><span class="line"></span><br><span class="line">3. 成本控制计划编制</span><br><span class="line"></span><br><span class="line">// 第一段，对成本控制计划编制进行概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明是怎么完成计划编制的</span><br><span class="line"></span><br><span class="line">4. 成本控制</span><br><span class="line"></span><br><span class="line">// 第一段，对成本控制进行概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明成本控制过程中出现了哪些问题，是怎么处理的</span><br></pre></td></tr></table></figure><p>我们可以提前准备一些项目中出现的案例，在合适的时机插入到正文当中，比如</p><ul><li><p>项目某个里程碑阶段，对项目的EV、AC、PV、SPI、CPI等进行分析，得出当前项目处于成本超支/节约，进度超前/落后，然后怎么样进行管理变化，使项目正常运行</p></li><li><p>项目某个时间点，有突发情况发生（项目组成员离开等等），我们是怎么应变调节的</p></li><li><p>项目计划编制中，我们采用了头脑风暴，技术专家评审等等方式，完成编制过程等等</p></li><li><p>分析项目的最长路径、总时差、自由时差等等</p></li></ul><h4 id="4-结尾"><a href="#4-结尾" class="headerlink" title="4. 结尾"></a>4. 结尾</h4><p>结尾部分同样可以采用提前准备的方式，9大类采用统一风格，当正文部分写到预定的区域后，即可开始书写提前准备的结尾部分。基本上按照既定的思路，写到文章结尾的时候，如果时间还比较充裕，那基本上离论文合格也就不远了。</p><p><img src="/images/ruankao-1/信管征文.jpg" alt="信管网获奖"></p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;17年下半年的信息系统项目管理师考试，前前后后间断复习了大概3个月，没想到最后一次过了，挺意外的。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://www.xiaoleon.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="软考" scheme="http://www.xiaoleon.cn/tags/%E8%BD%AF%E8%80%83/"/>
    
      <category term="信息系统项目管理师" scheme="http://www.xiaoleon.cn/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/"/>
    
  </entry>
  
</feed>
