<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张啸</title>
  
  <subtitle>世界上最快乐的事，莫过于为理想而奋斗。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaoleon.cn/"/>
  <updated>2018-01-27T08:59:45.298Z</updated>
  <id>http://www.xiaoleon.cn/</id>
  
  <author>
    <name>Leon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js-3</title>
    <link href="http://www.xiaoleon.cn/2018/01/27/js-3/"/>
    <id>http://www.xiaoleon.cn/2018/01/27/js-3/</id>
    <published>2018-01-27T08:59:24.000Z</published>
    <updated>2018-01-27T08:59:45.298Z</updated>
    
    <content type="html"><![CDATA[<!-- Todo --><a id="more"></a><!-- Todo --><h3 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h3><!-- Todo --><hr><h3 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h3><!-- Todo --><hr><h3 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h3><!-- Todo --><hr><h3 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h3><!-- Todo --><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《Todo》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- Todo --&gt;
    
    </summary>
    
      <category term="category1" scheme="http://www.xiaoleon.cn/categories/category1/"/>
    
    
      <category term="tag1" scheme="http://www.xiaoleon.cn/tags/tag1/"/>
    
  </entry>
  
  <entry>
    <title>JS(2) 对象</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/js-2/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/js-2/</id>
    <published>2018-01-22T14:27:54.000Z</published>
    <updated>2018-01-27T09:03:32.667Z</updated>
    
    <content type="html"><![CDATA[<p>对象是JavaScript的基本数据类型。对象是一种复合值：它将很多值（原始值或者其他对象）聚合在一起，可以通过名字访问这些值。对象也可看作是属性的无序集合，每个属性都是一个名值对，属性名是字符串，因此我们可以把对象看成是从字符串到值的映射。</p><a id="more"></a><p>JavaScript对象还可以从一个称为原型的对象继承属性，对象的方法通常是继承的属性，这种原型式继承（<code>prototypal inheritance</code>）是JavaScript的核心特征。</p><p>对象最常见的用法是创建（<code>create</code>）、设置（<code>set</code>）、查找（<code>query</code>）、删除（<code>delete</code>）、检测（<code>test</code>）和枚举（<code>enumerate</code>）它的属性。属性包括名字和值，属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性，值可以是任意JavaScript值，或者可以是一个<code>getter</code>或<code>setter</code>函数。除了名字和值以外，每个属性还有一些与之相关的值，称为“属性特征”（<code>property attribute</code>）。</p><ul><li><p>可写（<code>writable attribute</code>），表明是否可以设置该属性的值。</p></li><li><p>可枚举（<code>enumerable attribute</code>），表明是否可以通过<code>for/in</code>循环返回该属性。</p></li><li><p>可配置（<code>configurable attribute</code>），表明是否可以删除或修改该属性。</p></li></ul><p>除了包含属性之外，每个对象还拥有三个相关的对象特性（<code>object attribute</code>）：</p><ul><li><p>对象的原型（<code>prototype</code>）指向另外一个对象，本对象的属性继承自它的原型对象。</p></li><li><p>对象的类（<code>class</code>）是一个标识对象类型的字符串。</p></li><li><p>对象的扩展标记（<code>extensible flag</code>）指明了是否可以向该对象添加新属性。</p></li></ul><p>最后，我们用下面这些术语来对三类JavaScript对象和两类属性作区分：</p><ul><li><p>内置对象（<code>native object</code>）是由ECMAScript规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。</p></li><li><p>宿主对象（<code>host object</code>）是由JavaScript解释器所嵌入的宿主环境（比如Web浏览器）定义的。客户端JavaScript中表示网页结构的<code>HTMLElement</code>对象均是宿主对象。既然宿主环境定义的方法可以当成普通的JavaScript函数对象，那么宿主对象也可以当成内置对象。</p></li><li><p>自定义对象（<code>user-defined object</code>）是由运行中的JavaScript代码创建的对象。</p></li><li><p>自有属性（<code>own property</code>）是直接在对象中定义的属性。</p></li><li><p>继承属性（<code>inherited property</code>）是在对象的原型对象中定义的属性。</p></li></ul><h3 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h3><p>可以通过对象直接量、关键字<code>new</code>和<code>Object.create()</code>函数来创建对象。</p><h4 id="1-对象直接量"><a href="#1-对象直接量" class="headerlink" title="1. 对象直接量"></a>1. 对象直接量</h4><p>创建对象最简单的方式就是在JavaScript代码中使用对象直接量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emtpy = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> point = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="string">"main title"</span>: <span class="string">"Javascript"</span>,</span><br><span class="line">    <span class="string">'sub-title'</span>: <span class="string">'The Definitive Guide'</span>,</span><br><span class="line">    author: &#123;</span><br><span class="line">        firstname: <span class="string">'David'</span>,</span><br><span class="line">        surname: <span class="string">'Flanagan'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象直接量是一个表达式，这个表达式的每次运算都会创建并初始化一个新的对象。每次计算对象直接量的时候，也都会计算它的每个属性的值。也就是说，如果在一个重复调用的函数中的循环体内使用了对象直接量，它将创建很多新对象，并且每次创建的对象的属性值也有可能不同。</p><h4 id="2-通过new创建对象"><a href="#2-通过new创建对象" class="headerlink" title="2. 通过new创建对象"></a>2. 通过new创建对象</h4><p>new运算符创建并初始化一个新对象。关键字<code>new</code>后跟随一个函数调用。这里的函数称作构造函数（<code>constructor</code>），构造函数用以初始化一个新创建的对象。JavaScript语言核心中的原始类型都包含内置构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'js'</span>);</span><br></pre></td></tr></table></figure><h4 id="3-原型"><a href="#3-原型" class="headerlink" title="3. 原型"></a>3. 原型</h4><p>每一个JavaScript对象（<code>null</code>除外）都和另一个对象相关联。“另一个”对象就是我们熟知的原型，每一个对象都从原型继承属性。</p><p>所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过JavaScript代码<code>Object.prototype</code>获得原型对象的引用。通过关键字<code>new</code>和构造函数调用创建的对象的原型就是构造函数的<code>prototype</code>属性的值。因此，同使用<code>{}</code>创建对象一样，通过<code>new Object()</code>创建的对象也继承自<code>Object.prototype</code>。同样，通过<code>new Array()</code>创建的对象的原型就是<code>Array.prototype</code>，通过<code>new Date()</code>创建的对象的原型就是<code>Date.prototype</code>。</p><p>没有原型的对象不多，<code>Object.prototype</code>就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自<code>Object.prototype</code>的原型。例如，<code>Date.prototype</code>的属性继承自<code>Object.prototype</code>，因此由<code>new Date()</code>创建的<code>Date</code>对象的属性同时继承自<code>Date.prototype</code>和<code>Object.prototype</code>。这一系列链接的原型对象就是所谓的“原型链”（<code>prototype chain</code>）。</p><h4 id="4-Object-create"><a href="#4-Object-create" class="headerlink" title="4. Object.create()"></a>4. Object.create()</h4><p>ECMAScript5定义了一个<code>Object.create()</code>方法，它创建一个新对象，其中第一个参数是这个对象的原型，并提供第二个可选参数，用以对对象的属性进行进一步描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// o1继承了属性x和y</span></span><br><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p>可以通过传入参数<code>null</code>来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如<code>toString()</code>，也就是说，它将不能和<code>“+”</code>运算符一起正常工作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// o2不继承任何属性和方法</span></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>如果想创建一个普通的空对象（比如通过<code>{}</code>或<code>new Object()</code>创建的对象），需要传入<code>Object.prototype</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// o3和&#123;&#125;和new Object()一样</span></span><br><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure><blockquote><p><strong>可以通过任意原型创建新对象（换句话说，可以使任意对象可继承），这是一个强大的特性。</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inherit()返回一个继承自原型对象p的属性的新对象</span></span><br><span class="line"><span class="comment">// 这里使用ECMAScript5中的Object.create()函数（如果存在的话）</span></span><br><span class="line"><span class="comment">// 如果不存在，则退化使用其他方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// p是一个对象，但不能是null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>();              </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.create)</span><br><span class="line">        <span class="comment">// 如果Object.create()存在，直接使用它</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(p);</span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> p;</span><br><span class="line">    <span class="keyword">if</span> (t !== <span class="string">'object'</span> &amp;&amp; t !== <span class="string">'function'</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    <span class="comment">// 定义一个空构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 将其原型属性设置为p</span></span><br><span class="line">    f.prototype = p;</span><br><span class="line">    <span class="comment">// 使用f()创建p的继承对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，<code>inherit()</code>方法并不能完全代替<code>Object.create()</code>，它不能通过传入<code>null</code>原型来创建对象，而且不能接收可选的第二个参数。</p></blockquote><p><code>inherit()</code>函数的其中一个用途就是防止库函数无意间（非恶意地）修改那些不受控制的对象。不是将对象直接作为参数传入函数，而是将它的继承对象传入函数。当函数读取继承对象的属性时，实际上读取的是继承来的值。如果给继承对象的属性赋值，则这些属性只会影响这个继承对象自身，而不是原始对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="string">"don't change this value"</span> &#125;;</span><br><span class="line"><span class="comment">// 防止对o的意外修改</span></span><br><span class="line">library_function(inherit(o));</span><br></pre></td></tr></table></figure><hr><h3 id="二、属性的查询和设置"><a href="#二、属性的查询和设置" class="headerlink" title="二、属性的查询和设置"></a>二、属性的查询和设置</h3><p>对象可以通过点（<code>.</code>）或方括号（<code>[]</code>）运算符来获取属性的值。运算符左侧应当是一个表达式，它返回一个对象。对于点（<code>.</code>）来说，右侧必须是一个以属性名称命名的简单标识符。对于方括号来说（<code>[]</code>），方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> author = book.author;</span><br><span class="line"><span class="keyword">var</span> name = author.surname;</span><br><span class="line"><span class="keyword">var</span> title = book[<span class="string">'main title'</span>];</span><br></pre></td></tr></table></figure><p>当使用方括号时，严格来讲，表达式必须返回字符串或者返回一个可以转换为字符串的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> author = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">'John'</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">'Green'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(author[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h4 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h4><p>JavaScript对象具有“自有属性”（<code>own property</code>），也有一些属性是从原型对象继承而来的。假设要查询对象<code>o</code>的属性<code>x</code>，如果<code>o</code>中不存在<code>x</code>，那么将会继续在<code>o</code>的原型对象中查询属性<code>x</code>。如果原型对象中也没有<code>x</code>，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到<code>x</code>或者查到一个原型是<code>null</code>的对象为止。可以看到，对象的原型属性构成了一个“链”，通过这个“链”可以实现属性的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;             <span class="comment">// o从Object.prototype继承对象的方法</span></span><br><span class="line">o.x = <span class="number">1</span>;                <span class="comment">// 给o定义一个属性x</span></span><br><span class="line"><span class="keyword">var</span> p = inherit(o);     <span class="comment">// p继承o和Object.prototype</span></span><br><span class="line">p.y = <span class="number">2</span>;                <span class="comment">// 给p定义一个属性y</span></span><br><span class="line"><span class="keyword">var</span> q = inherit(p);     <span class="comment">// q继承p、o和Object.prototype</span></span><br><span class="line">q.z = <span class="number">3</span>;                <span class="comment">// 给q定义一个属性z</span></span><br><span class="line"><span class="keyword">var</span> s = q.toString()    <span class="comment">// toString继承自Object.prototype</span></span><br><span class="line">q.x + q.y               <span class="comment">// =&gt; 3  x和y分别继承自o和p</span></span><br></pre></td></tr></table></figure><p>现在假设给对象<code>o</code>的属性<code>x</code>赋值，如果<code>o</code>中已经有属性<code>x</code>（这个属性不是继承来的），那么这个赋值操作只改变这个已有属性<code>x</code>的值。如果<code>o</code>中不存在属性<code>x</code>，那么赋值操作给<code>o</code>添加一个新属性<code>x</code>。如果之前<code>o</code>继承自属性<code>x</code>，那么这个继承的属性就被新创建的同名属性覆盖了。</p><p>属性赋值操作首先检查原型链，以此判定是否允许赋值操作。例如，如果<code>o</code>继承自一个只读属性x，那么赋值操作是不允许的。如果允许属性赋值操作，它也总是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链。在Javascript中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关，这是JavaScript的一个重要特性，该特性让程序员可以有选择地覆盖（<code>override</code>）继承的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unitcircle = &#123; <span class="attr">r</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> c = inherit(unitcircle);</span><br><span class="line">c.x = <span class="number">1</span>; c.y = <span class="number">1</span>;</span><br><span class="line">c.r = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(unitcircle.r);      <span class="comment">// =&gt; 1，原型对象没有修改</span></span><br></pre></td></tr></table></figure><p>属性赋值要么失败，要么创建一个属性，要么在原始对象中设置属性，但有一个例外，如果<code>o</code>继承自属性<code>x</code>，而这个属性是一个具有<code>setter</code>方法的<code>accessor</code>属性，那么这时将调用<code>setter</code>方法而不是给<code>o</code>创建一个属性。需要注意的是，<code>setter</code>方法是由对象<code>o</code>调用的，而不是定义这个属性的原型对象调用的。因此如果<code>setter</code>方法定义在原型上，这个操作只针对<code>o</code>本身，并不会修改原型链。</p><h4 id="2-属性访问错误"><a href="#2-属性访问错误" class="headerlink" title="2. 属性访问错误"></a>2. 属性访问错误</h4><p>属性访问并不总是返回或设置一个值。查询一个不存在的属性并不会报错，如果在对象o自身的属性或继承的属性中均为找到属性x，属性访问表达式<code>o.x</code>返回<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.subtitle;      <span class="comment">// =&gt; undefined，属性不存在</span></span><br></pre></td></tr></table></figure><p>但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错，<code>null</code>和<code>undefined</code>值都没有属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> len = book.subtitle.length;     <span class="comment">// 抛出类型错误异常，undefined没有length属性</span></span><br></pre></td></tr></table></figure><p>除非确定<code>book</code>和<code>book.subtitle</code>都是对象，否则不能这样书写，应采用如下方法避免出错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">var</span> len = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (book) &#123;</span><br><span class="line">    <span class="keyword">if</span> (book.subtitle) &#123;</span><br><span class="line">        len = book.subtitle.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length;</span><br></pre></td></tr></table></figure><p>当然，给<code>null</code>和<code>undefined</code>设置属性也会报类型错误，给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性，但让人颇感意外的是，这些设置属性的失败操作不会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype = <span class="number">0</span>;       <span class="comment">// 赋值失败，但没报错，Object.prototype没有修改</span></span><br></pre></td></tr></table></figure><p>严格模式下，任何失败的属性设置操作都会抛出一个类型错误异常。</p><p>在以下场景下给对象<code>o</code>设置属性p会失败：</p><ul><li><p><code>o</code>中的属性p是只读的：不能给只读属性重新赋值（<code>defineProperty()</code>方法中有一个例外，可以对可配置的只读属性重新赋值）。</p></li><li><p><code>o</code>中的属性p是继承属性，且它是只读的：不能通过同名自有属性覆盖只读的继承属性。</p></li><li><p><code>o</code>中不存在自有属性<code>p</code>：<code>o</code>没有使用<code>setter</code>方法继承属性<code>p</code>，并且<code>o</code>的可扩展性（<code>extensible attribute</code>）是<code>false</code>。如果<code>o</code>中不存在<code>p</code>，而且没有<code>setter</code>方法可供调用，则<code>p</code>一定会添加至<code>o</code>中。但如果<code>o</code>不是可扩展的，那么在<code>o</code>中不能定义新属性。</p></li></ul><hr><h3 id="三、删除属性"><a href="#三、删除属性" class="headerlink" title="三、删除属性"></a>三、删除属性</h3><p><code>delete</code>运算符可以删除对象的属性。让人感到意外的是，<code>delete</code>只是断开属性和宿主对象的联系，而不会去操作属性中的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> book.author;</span><br><span class="line"><span class="keyword">delete</span> book[<span class="string">'main title'</span>];</span><br></pre></td></tr></table></figure><p><code>delete</code>运算符只能删除自有属性，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象）。</p><p>当<code>delete</code>表达式删除成功或没有任何副作用（比如删除不存在的属性）时，它返回<code>true</code>。如果<code>delete</code>后不是一个属性访问表达式，<code>delete</code>同样返回<code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// 删除x，返回true</span></span><br><span class="line"><span class="keyword">delete</span> o.x;</span><br><span class="line"><span class="comment">// 什么都没做，返回true</span></span><br><span class="line"><span class="keyword">delete</span> o.x;</span><br><span class="line"><span class="comment">// 什么都没做（toString是继承来的），返回true</span></span><br><span class="line"><span class="keyword">delete</span> o.toString();</span><br><span class="line"><span class="comment">// 无意义，返回true</span></span><br><span class="line"><span class="keyword">delete</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><code>delete</code>不能删除那些可配置性为<code>false</code>的属性（尽管可以删除不可扩展对象的可配置属性）。某些内置对象的属性是不可配置的，比如通过变量声明和函数声明创建的全局对象的属性。</p><p>在非严格模式中，以下情况的<code>delete</code>操作会返回<code>false</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能删除，属性是不可配置的</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype;</span><br><span class="line"><span class="comment">// 声明一个全局变量</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 不能删除这个属性</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.x;</span><br><span class="line"><span class="comment">// 声明一个全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 不能删除这个全局函数</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.f;</span><br></pre></td></tr></table></figure><p>当在非严格模式中删除全局对象的可配置属性时，可以省略对全局对象的引用，直接在<code>delete</code>操作符后跟随要删除的属性名即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个可配置的全局属性（没有用var）</span></span><br><span class="line"><span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 删除属性，返回true</span></span><br><span class="line"><span class="keyword">delete</span> x;</span><br></pre></td></tr></table></figure><p>然而在严格模式下，<code>delete</code>后跟随一个非法的操作数（比如x），则会报一个语法错误，因此必须显式指定对象及其属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格模式下报语法错误</span></span><br><span class="line"><span class="keyword">delete</span> x;</span><br><span class="line"><span class="comment">// 正常工作</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.x;</span><br></pre></td></tr></table></figure><hr><h3 id="四、检测属性"><a href="#四、检测属性" class="headerlink" title="四、检测属性"></a>四、检测属性</h3><p>JavaScript对象可以看作属性的集合，我们经常会检测集合中成员的所属关系——判断某个属性是否存在于某个对象中。可以通过<code>in</code>运算符、<code>hasOwnProperty()</code>和<code>propertyIsEnumerable()</code>方法来完成这个工作，甚至仅通过属性查询也可以做到这一点。</p><p><code>in</code>运算符的左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;           <span class="comment">// true</span></span><br><span class="line"><span class="string">"y"</span> <span class="keyword">in</span> o;           <span class="comment">// false</span></span><br><span class="line"><span class="string">"toString"</span> <span class="keyword">in</span> o;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>对象的<code>hasOwnProperty()</code>方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将会返回<code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">o.hasOwnProperty(<span class="string">"x"</span>);          <span class="comment">// true</span></span><br><span class="line">o.hasOwnProperty(<span class="string">"y"</span>);          <span class="comment">// false</span></span><br><span class="line">o.hasPownProperty(<span class="string">'toString'</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>propertyIsEnumerable()</code>是<code>hasOwnProperty()</code>的增强版，只有检测到是自有属性且这个属性的可枚举性（<code>enumerable attribute</code>）为<code>true</code>时它才返回<code>true</code>。某些内置属性是不可枚举的。通常由JavaScript代码创建的属性都是可枚举的，除非在ECMAScript5中使用一个特殊的方法来改变属性的可枚举性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = inherit(&#123; <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br><span class="line">o.x = <span class="number">1</span>;</span><br><span class="line">o.propertyIsEnumerable(<span class="string">'x'</span>);            <span class="comment">// true</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">'y'</span>);            <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.propertyIsEnumerable(<span class="string">'toString'</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>除了使用in运算符之外，另一种更简便的方法是使用<code>“!==”</code>判断一个属性是否是<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line">o.x !== <span class="literal">undefined</span>;          <span class="comment">// true</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>;          <span class="comment">// false</span></span><br><span class="line">o.toString !== <span class="literal">undefined</span>    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是有一种场景只能使用in运算符而不能使用上述属性访问的方式。in可以区分不存在的属性和存在但值为<code>undefined</code>的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">o.x !== <span class="literal">undefined</span>;          <span class="comment">// false</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>;          <span class="comment">// false</span></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;                   <span class="comment">// true</span></span><br><span class="line"><span class="string">"y"</span> <span class="keyword">in</span> o;                   <span class="comment">// false</span></span><br><span class="line"><span class="keyword">delete</span> o.x;                 <span class="comment">// true</span></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;                   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，上述代码中使用的是<code>“!==”</code>运算符，而不是<code>“!=”</code>。<code>“!==”</code>可以区分<code>undefined</code>和<code>null</code></p></blockquote><hr><h3 id="五、枚举属性"><a href="#五、枚举属性" class="headerlink" title="五、枚举属性"></a>五、枚举属性</h3><p>除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用<code>for/in</code>循环便利，ECMAScript5提供了两个更好用的替代方案。</p><p><code>for/in</code>循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承属性），把属性名称赋值给循环变量。对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的（除非使用下文中提到的一个方法将它们转换为不可枚举的）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;;</span><br><span class="line">o.propertyIsEnumerable(<span class="string">'toString'</span>);     <span class="comment">// false</span></span><br><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p);                     <span class="comment">// 输出x、y和z，不会输出toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有许多实用工具库给<code>Object.prototype</code>添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。然而在ECMAScript5之前，这些新添加的方法是不能定义为不可枚举的，因此它们都可以在<code>for/in</code>循环中枚举出来，因此需要过滤<code>for/in</code>循环中的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!o.hasOwnProperty(p))</span><br><span class="line">        <span class="comment">// 跳过继承的属性</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> o[p] === <span class="string">'function'</span>)</span><br><span class="line">        <span class="comment">// 跳过方法</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下方工具函数用来控制对象的属性，这些函数用到了<code>for/in</code>循环。实际上<code>extend()</code>函数经常出现在JavaScript实用工具库中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">把p中的可枚举属性复制到o中，并返回o</span></span><br><span class="line"><span class="comment">如果o和p中含有同名属性，则覆盖o中的属性</span></span><br><span class="line"><span class="comment">这个函数并不处理getter和setter以及复制属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历p中的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> p) &#123;</span><br><span class="line">        <span class="comment">// 将属性添加至o中</span></span><br><span class="line">        o[prop] = p[prop]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将p中的可枚举属性复制到o中，并返回o</span></span><br><span class="line"><span class="comment">如果o和p中有同名的属性，o中的属性将不受影响</span></span><br><span class="line"><span class="comment">这个函数并不处理getter和setter以及复制属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历p中的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> p) &#123;</span><br><span class="line">        <span class="comment">// 过滤掉已经在o中存在的属性</span></span><br><span class="line">        <span class="keyword">if</span> (o.hasOwnProperty(prop))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 将属性添加至o中</span></span><br><span class="line">        o[prop] = p[prop];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果o中的属性在p中没有同名属性，则从o中删除这个属性，并返回o</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restrict</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历p中的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="comment">// 如果在p中不存在，则删除</span></span><br><span class="line">        <span class="keyword">if</span> (!(prop <span class="keyword">in</span> p))</span><br><span class="line">            <span class="keyword">delete</span> o[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果o中的属性在p中存在同名属性，则从o中删除这个属性，并返回o</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历p中的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> p) &#123;</span><br><span class="line">        <span class="comment">// 从o中删除（删除一个不存在的属性不会报错）</span></span><br><span class="line">        <span class="keyword">delete</span> o[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回一个新对象，这个对象同时拥有o的属性和p的属性，</span></span><br><span class="line"><span class="comment">如果o和p中有重名属性，使用p中的属性值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> extend(extend(&#123;&#125;, o), p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回一个新对象，这个对象拥有同时在o和p中出现的属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restrict(extend(&#123;&#125;, o), p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回一个数组，这个数组包含的是o中可枚举的自有属性的名字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keys</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 参数必须是对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> o !== <span class="string">'object'</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="comment">// 判断是否是自有属性</span></span><br><span class="line">        <span class="keyword">if</span> (o.hasOwnProperty(prop)) &#123;</span><br><span class="line">            result.push(prop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了<code>for/in</code>循环之外，ECMAScript5定义了两个用以枚举属性名称的函数</p><ul><li><p>第一个是<code>Object.keys()</code>，它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。</p></li><li><p>第二个是<code>Object.getOwnPropertyNames()</code>，它和<code>Object.keys()</code>类似，只是它返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。</p></li></ul><hr><h3 id="六、属性getter和setter"><a href="#六、属性getter和setter" class="headerlink" title="六、属性getter和setter"></a>六、属性getter和setter</h3><p>对象属性是由名字、值和一对特性（<code>attribute</code>）构成的，在ES5中，属性值可以用一个或两个方法替代，这两个方法就是<code>getter</code>和<code>setter</code>。由<code>getter</code>和<code>setter</code>定义的属性称作“存取器属性”（<code>accessor property</code>），它不同于“数据属性”（<code>data property</code>），数据属性只有一个简单的值。</p><p>当程序查询存取器属性的值时，JavaScript调用<code>getter</code>方法。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript调用<code>setter</code>方法，将赋值表达式右侧的值当作参数传入<code>setter</code>。从某种意义上讲，这个方法负责“设置”属性值，可以忽略<code>setter</code>方法的返回值。</p><p>和数据属性不同，存取器属性不具有可写性（<code>writable attribute</code>）。如果属性同时具有<code>getter</code>和<code>setter</code>方法，那么它是一个读/写属性。如果它只有<code>getter</code>方法，那么它是一个只读属性。如果它只有<code>setter</code>方法，那么它是一个只写属性（数据属性中有一些例外），读取只写属性总是返回<code>undefined</code>。</p><p>定义存取器属性最简单的方法是使用对象直接量语法的一种扩展写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    data_prop: value,</span><br><span class="line"></span><br><span class="line">    get accessor_prop() &#123;</span><br><span class="line">        <span class="comment">// 函数体</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set accessor_prop(value) &#123;</span><br><span class="line">        <span class="comment">// 函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和数据属性一样，存取器属性是可以继承的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = inherit(o);</span><br><span class="line"><span class="built_in">console</span>.log(p.accessor_prop);</span><br></pre></td></tr></table></figure><p>还有很多场景可以用到存取器属性，比如智能检测属性的写入值以及在每次属性读取时返回不同值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个对象产生严格自增的序列号</span></span><br><span class="line"><span class="keyword">var</span> serialnum = &#123;</span><br><span class="line">    <span class="comment">// 这个数据属性包含下一个序列号</span></span><br><span class="line">    <span class="comment">// $符号暗示这个属性是一个私有属性</span></span><br><span class="line">    $n: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前值，然后自增</span></span><br><span class="line">    get next() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给n设置新的值，但只有当它比当前值大时才能设置成功</span></span><br><span class="line">    set next(n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="keyword">this</span>.$n)</span><br><span class="line">            <span class="keyword">this</span>.$n = n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="string">'序列号的值不能比当前值小'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="七、属性的特性"><a href="#七、属性的特性" class="headerlink" title="七、属性的特性"></a>七、属性的特性</h3><p>除了包含名字和值之外，属性还包含一些标识它们可写、可枚举和可配置的特性。本节将讲述ES5中查询和设置这些属性特性的API</p><ul><li><p>可以通过这些API给原型对象添加方法，并将它们设置成不可枚举的，这让它们看起来更像内置方法</p></li><li><p>可以通过这些API给对象定义不能修改或删除的属性，借此“锁定”这个对象</p></li></ul><p>我们将存取器属性的<code>getter</code>和<code>setter</code>方法看成是属性的特性，按照这个逻辑，我们也可以把数据属性的值同样看作属性的特性。因此，可以认为一个属性包含一个名字和4个特性。</p><p><strong><em>数据属性的4个特性分别是它的值（<code>value</code>）、可写性（<code>writable</code>）、可枚举性（<code>enumerable</code>）和可配置性（<code>configurable</code>）</em></strong></p><p>存取器属性不具有值（<code>value</code>）特性和可写性，它们的可写性是由<code>setter</code>方法存在与否决定的。因此存取器属性的4个特性是读取（<code>get</code>）、写入（<code>set</code>）、可枚举性和可配置性。</p><p>为了实现属性特性的查询和设置操作，ES5定义了一个名为“属性描述符”（<code>property descriptor</code>）的对象，这个对象代表那4个特性。描述符对象的属性有<code>value</code>、<code>writable</code>、<code>enumerable</code>和<code>configurable</code>。存取器属性的描述符对象则用<code>get</code>属性和<code>set</code>属性代替<code>value</code>和<code>writable</code>。其中<code>writable</code>、<code>enumerable</code>和<code>configurable</code>都是布尔值，当然，<code>get</code>属性和<code>set</code>属性是函数值。</p><p>通过调用<code>Object.getOwnPropertyDescriptor()</code>可以获得某个对象特定属性的属性描述符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, <span class="string">'x'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return &#123;get: /*func*/, set: undefined, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    get accessor_prop() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">'accessor_prop'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return undefined 没有这个属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">'x'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return undefined 继承属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">'toString'</span>);</span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptor()</code>只能得到自有属性的描述符，如果想要获得继承属性的特性，需要遍历原型链。如果想要设置属性的特性，或者想让新建属性具有某种特性，则需要调用<code>Object.defineProperty()</code>，传入要修改的对象、要创建或修改的属性的名称以及属性描述符对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个不可枚举的属性x，并赋值为1</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'x'</span>, &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.x;        <span class="comment">// =&gt; 1 属性存在</span></span><br><span class="line">o.keys();   <span class="comment">// =&gt; [] 属性不可枚举</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改属性x，变为只读</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'x'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.x = <span class="number">2</span>;    <span class="comment">// 操作失败但不报错，严格模式中会抛出异常</span></span><br><span class="line">o.x;        <span class="comment">// =&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性依然可配置，因此可以通过这种方式进行修改</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'x'</span>, &#123;</span><br><span class="line">    value: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line">o.x;        <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改x从数据属性变为存取器属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'x'</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;);</span><br><span class="line">o.x;        <span class="comment">// =&gt; 0</span></span><br></pre></td></tr></table></figure><p>传入<code>Object.defineProperty()</code>的属性描述符对象不必包含所有4个特性，对于新创建的属性来说，默认的特性值是<code>false</code>或<code>undefined</code>。对于修改的已有属性来说，默认的特性值没有做任何修改。注意，这个方法要么修改已有属性要么新建自有属性，但不能修改继承属性。</p><p>如果要同时修改或创建多个属性，则需要使用<code>Object.defineProperties()</code>。第一个参数是要修改的对象，第二个参数是一个映射表，它包含要新建或修改的属性的名称，以及它们的属性描述符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">    x: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    y: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    r: &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="keyword">this</span>.x * <span class="keyword">this</span>.x + <span class="keyword">this</span>.y * <span class="keyword">this</span>.y); &#125;,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段代码从一个空对象开始，然后给它添加两个数据属性和一个只读存取器属性。最终<code>Object.defineProperties()</code>返回修改后的对象（和<code>Object.defineProperty()</code>一样）。</p><p>对于那些不允许创建或修改的属性来说，如果用<code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>对其操作就会抛出类型错误异常，比如给一个不可扩展的对象新增属性就会抛出类型错误异常。造成这些方法抛出类型错误异常的其他原因则和特性本身相关。可写性控制着对值特性的修改。可配置性控制着对其他特性（包括属性是否可以删除）的修改。然而规则远不止这么简单，例如，如果属性是可配置的话，则可以修改不可写属性的值。同样，如果属性是不可配置的，仍然可以将可写属性修改为不可写属性。下面是完整规则，任何对<code>Object.defineProperty()</code>或<code>Object.defineProperties()</code>违反规则的使用都会抛出类型错误异常</p><ul><li><p>如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性</p></li><li><p>如果属性是不可配置的，则不能修改它的可配置性和可枚举性</p></li><li><p>如果存取器属性是不可配置的，则不能修改其<code>getter</code>和<code>setter</code>方法，也不能将它转换为数据属性</p></li><li><p>如果数据属性是不可配置的，则不能将它转换为存取器属性</p></li><li><p>如果数据属性是不可配置的，则不能将它的可写性从<code>false</code>修改为<code>true</code>，但可以从<code>true</code>修改为<code>false</code></p></li><li><p>如果数据属性是不可配置且不可写的，则不能修改它的值。然而可配置但不可写属性的值是可以修改的（实际上是先将它标记为可写的，然后修改它的值，最后转换为不可写的）。</p></li></ul><p>上文中的<code>extend()</code>函数，只是简单的复制属性名和值，没有复制属性的特性，而且也没有复制存取器属性的<code>getter</code>和<code>setter</code>方法，只是将它们简单的转换为静态的数据属性。下面给出改进的<code>extend()</code>，它使用<code>Object.getOwnPropertyDescriptor()</code>和<code>Object.defineProperty()</code>对属性的所有特性进行复制。新的<code>extend()</code>作为不可枚举属性添加到<code>Object.prototype</code>中，因此它是<code>Object</code>上定义的方法，而不是一个独立的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给Object.prototype添加一个不可枚举的extend()方法</span></span><br><span class="line"><span class="comment">这个方法继承自调用它的对象，将作为参数传入的对象的属性一一复制</span></span><br><span class="line"><span class="comment">除了值以外，也复制属性的所有特性，除非在目标对象中存在同名的属性</span></span><br><span class="line"><span class="comment">参数对象的所有自由对象（包括不可枚举的属性）也会一一复制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'extend'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 得到所有的自有属性，包括不可枚举属性</span></span><br><span class="line">        <span class="keyword">var</span> names = <span class="built_in">Object</span>.getOwnPropertyNames(o);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.length; i++ ) &#123;</span><br><span class="line">            <span class="comment">// 如果属性存在，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (names[i] <span class="keyword">in</span> <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 获得o中的属性描述符</span></span><br><span class="line">            <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, names[i]);</span><br><span class="line">            <span class="comment">// 用它给this创建一个属性</span></span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, names[i], desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="1-getter和setter的老式API"><a href="#1-getter和setter的老式API" class="headerlink" title="1. getter和setter的老式API"></a>1. getter和setter的老式API</h4><p>通过对象直接量语法给新对象定义存取器属性时，不能通过查询属性的方式获取<code>getter</code>和<code>setter</code>方法，或给已有的对象添加新的存取器属性。在ES5中，可以通过<code>Object.getOwnPropertyDescriptor()</code>和<code>Object.defineProperty()</code>来完成这些工作。</p><p>在ES5标准被采纳前，大多数Javascript的实现已经可以支持对象直接量语法中的<code>get</code>和<code>set</code>写法，这些实现提供了非标准的老式API用来查询和设置<code>getter</code>和<code>setter</code>，这些API由4个方法组成，所有对象都拥有这些方法。</p><ul><li><p><code>__lookupGetter__()</code>和<code>__lookupSetter__()</code>用以返回一个命名属性的<code>getter</code>和<code>setter</code>方法</p></li><li><p><code>__defineGetter__()</code>和<code>__defineSetter__()</code>用以定义<code>getter</code>和<code>setter</code>，这两个函数的第一个参数是属性名字，第二个参数是<code>getter</code>和<code>setter</code>方法。</p></li><li><p>这四个方法都是以两条下划线作前缀，两条下划线作后缀，以表明它们是非标准的方法。</p></li></ul><hr><h3 id="八、对象的三个属性"><a href="#八、对象的三个属性" class="headerlink" title="八、对象的三个属性"></a>八、对象的三个属性</h3><p>每一个对象都有与之相关的原型（<code>prototype</code>）、类（<code>class</code>）和可扩展性（<code>extensible attribute</code>）</p><h4 id="1-原型属性"><a href="#1-原型属性" class="headerlink" title="1. 原型属性"></a>1. 原型属性</h4><p>对象的原型属性是用来继承属性的，原型属性是在实例对象创建之初就设置好的。在ES5中，将对象作为参数传入<code>Object.getPrototypeOf()</code>可以查询它的原型。在ES3中，没有与之等价的函数，但经常使用表达式<code>o.constructor.prototype</code>来检测一个对象的原型。通过<code>new</code>表达式创建的对象，通常继承一个<code>constructor</code>属性，这个属性指代创建这个对象的构造函数。注意，通过对象直接量或<code>Object.create()</code>创建的对象包含一个名为<code>constructor</code>的属性，这个属性指代<code>Object()</code>构造函数。因此，<code>constructor.prototype</code>才是对象直接量的真正的原型，但对于通过<code>Object.create()</code>创建的对象则往往不是这样。</p><p>要想检测一个对象是否是另一个对象的原型（或处于原型链中），可以使用<code>isPrototypeOf()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(p);</span><br><span class="line">p.isPrototypeOf(o);         <span class="comment">// =&gt; true o继承自p</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(o)   <span class="comment">// =&gt; true p继承自Object.prototype</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>isPrototypeOf()</code>函数实现的功能和<code>instanceof</code>运算符非常类似。</p><blockquote><p>Mozilla实现的JavaScript对外暴露了一个专门命名为<code>__proto__</code>的属性，用以直接查询/设置对象的原型。但并不推荐使用<code>__proto__</code>，因为尽管Safari和Chrome的当前版本都支持它，但IE和Opera并为实现。实现了ES5的Firefox支持<code>__proto__</code>，但对修改不可扩展对象的原型做了限制。</p></blockquote><h4 id="2-类属性"><a href="#2-类属性" class="headerlink" title="2. 类属性"></a>2. 类属性</h4><p>对象的类属性（<code>class attribute</code>）是一个字符串，用以表示对象的类型信息。ES3和ES5都未提供设置这个属性的方法，并只有一种简介的方法可以查询它。默认的<code>toString()</code>方法（继承自<code>Object.prototype</code>）返回了如下这种格式的字符串<code>[object class]</code>。</p><p>因此，想要获得对象的类，可以调用对象的<code>toString()</code>方法，然后提取已返回字符串中的字符。不过让人感觉棘手的是，很多对象继承的<code>toString()</code>方法重写了，为了能调用正确的<code>toString()</code>版本，必须间接地调用<code>Function.call()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classof</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Null'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Undefined'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>classof()</code>函数可以传入任何类型的参数。数字、字符串和布尔值可以直接调用<code>toString()</code>方法，就和对象调用<code>toString()</code>方法一样，并且这个函数包含了对<code>null</code>和<code>undefined</code>的特殊处理（ES5中不需要进行特殊处理）。通过内置构造函数（比如<code>Array</code>和<code>Date</code>）创建的对象包含“类属性”（<code>class attribute</code>），它与构造函数名称相匹配。宿主对象也包含有意义的“类属性”，但这和具体的JavaScript实现有关。</p><p>对于自定义的类来说，没办法通过类属性来区分对象的类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">classof(<span class="literal">null</span>)       <span class="comment">// =&gt; 'Null'</span></span><br><span class="line">classof(<span class="number">1</span>)          <span class="comment">// =&gt; 'Number'</span></span><br><span class="line">classof(<span class="string">""</span>)         <span class="comment">// =&gt; 'String'</span></span><br><span class="line">classof(<span class="literal">false</span>)      <span class="comment">// =&gt; 'Boolean'</span></span><br><span class="line">classof(&#123;&#125;)         <span class="comment">// =&gt; 'Object'</span></span><br><span class="line">classof([])         <span class="comment">// =&gt; 'Array'</span></span><br><span class="line">classof(<span class="regexp">/./</span>)        <span class="comment">// =&gt; 'Regexp'</span></span><br><span class="line">classof(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">// =&gt; 'Date'</span></span><br><span class="line">classof(<span class="built_in">window</span>)     <span class="comment">// =&gt; 'Window'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">classof(<span class="keyword">new</span> f())    <span class="comment">// =&gt; 'Object'</span></span><br></pre></td></tr></table></figure><h4 id="3-可扩展性"><a href="#3-可扩展性" class="headerlink" title="3. 可扩展性"></a>3. 可扩展性</h4><p>对象的可扩展性用以表示是否可以给对象添加新属性。所有内置对象和自定义对象都是显示可扩展的，宿主对象的可扩展性是由JavaScript引擎定义的。在ES5中，所有的内置对象和自定义对象都是可扩展的，除非将它们转换为不可扩展的，同样，宿主对象的可扩展性也是由实现ES5的JavaScript引擎定义的。</p><p>ES5定义了用来查询和设置对象可扩展性的函数，通过将对象传入<code>Object.isExtensible()</code>，来判断该对象是否是可扩展的。如果想将对象转换为不可扩展的，需要调用<code>Object.preventExtensions()</code>，将待转换的对象作为参数穿进去。注意，一旦将对象转换为不可扩展的，就无法再将其转换回可扩展的了。同样需要注意的是，<code>preventExtensions()</code>只影响到对象本身的可扩展性。如果给一个不可扩展的对象的原型添加属性，这个不可扩展的对象同样会继承这些新属性。</p><p>可扩展属性的目的是将对象“锁定”，以避免外界的干扰。对象的可扩展性通常和属性的可配置性与可写性配合使用，ES5定义的一些函数可以更方便的设置多种属性。</p><p><code>Object.seal()</code>和<code>Object.preventExtensions()</code>类似，除了能够将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置的。也就是说，不能给这个对象添加新属性，而且它已有的属性也不能删除或配置，不过它已有的科协属性依然可以设置。对于那些已经封闭（<code>sealed</code>）起来的对象是不能解封的。可以使用<code>Object.isSealed()</code>来检测对象是否封闭。</p><p><code>Object.freeze()</code>将更加严格地锁定对象——“冻结”（<code>frozen</code>）。除了将对象设置为不可扩展的和将其属性设置为不可配置的之外，还可以将它自有的所有数据属性设置为只读（如果对象的存取器属性具有<code>setter</code>方法，存取器属性将不受影响，人可以通过给属性赋值调用它们）。使用<code>Object.isFrozen()</code>来检测对象是否冻结。</p><p><code>Object.preventExtensions()</code>、<code>Object.seal()</code>、<code>Object.freeze()</code>都返回传入的对象，也就是说，可以通过函数嵌套的方式调用它们</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个封闭对象，包括一个冻结的原型和一个不可枚举的属性</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.seal(<span class="built_in">Object</span>.create(<span class="built_in">Object</span>.freeze(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;), &#123;</span><br><span class="line">    y: &#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><hr><h3 id="九、序列化对象"><a href="#九、序列化对象" class="headerlink" title="九、序列化对象"></a>九、序列化对象</h3><p>对象序列化（<code>serialization</code>）是指将对象的状态转换为字符串，也可将字符串还原为对象。ES5提供了内置函数<code>JSON.stringfigy()</code>和<code>JSON.parse()</code>用来序列化和还原JavaScript对象。这些方法都是用JSON作为数据交换格式。</p><p>JSON的语法是JavaScript语法的子集，它并不能表示JavaScript离的所有值，支持对象、数组、字符串、无穷大数字、<code>true</code>、<code>false</code>和<code>null</code>，并且它们可以序列化和还原。<code>NaN</code>、<code>Infinity</code>和<code>-Infinity</code>序列化的结果是<code>null</code>，日期对象序列化的结果是ISO格式的日期字符串（参照<code>Date.toJson()</code>函数），但<code>JSON.parse()</code>依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、<code>RegExp</code>、<code>Error</code>对象和<code>undefined</code>值不能序列化和还原。</p><blockquote><p><strong><code>JSON.stringfy()</code>只能序列化对象可枚举的自有属性</strong></p></blockquote><p>对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。<code>JSON.stringify()</code>和<code>JSON.parse()</code>都可以接收第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。</p><hr><h3 id="十、对象方法"><a href="#十、对象方法" class="headerlink" title="十、对象方法"></a>十、对象方法</h3><p>所有的JavaScript对象都从<code>Object.prototype</code>继承属性（除了那些不通过原型显示创建的对象）。这些继承属性主要是方法，我们已经讨论过<code>hasOwnProperty()</code>、<code>propertyIsEnumerable()</code>、<code>isPrototypeOf()</code>三个方法，以及在Object构造函数里定义的静态函数<code>Object.create()</code>和<code>Object.getPrototypeOf()</code>等。本节将对定义在<code>Object.prototype</code>里的对象方法展开讲解，这些方法非常好用而且使用广泛，但一些特定的类会重写这些方法。</p><h4 id="1-toString-方法"><a href="#1-toString-方法" class="headerlink" title="1. toString()方法"></a>1. toString()方法</h4><p><code>toString()</code>方法没有参数，它返回一个表示调用这个方法的对象值的字符串。在需要将对象转换为字符串的时候，JavaScript都会调用这个方法。比如，当使用“+”运算符连接一个字符串和一个对象时或者在希望使用字符串的方法中使用了对象时都会调用<code>toString()</code>。</p><p>默认的<code>toString()</code>方法的返回值带有的信息量很少。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>&#125;.toString();        <span class="comment">// "[object Object]"</span></span><br></pre></td></tr></table></figure><p>由于默认的<code>toString()</code>方法并不会输出很多有用的信息，因此很多类都带有自定义的<code>toString()</code>。例如，当数组转换为字符串的时候，结果实一个数组元素列表，只是每个元素都换成了字符串，再比如，当函数转换为字符串的时候，得到函数的源代码。</p><h4 id="2-toLocaleString-方法"><a href="#2-toLocaleString-方法" class="headerlink" title="2. toLocaleString()方法"></a>2. toLocaleString()方法</h4><p>除了基本的<code>toString()</code>方法之外，对象都包含<code>toLocaleString()</code>方法，这个方法返回一个表示这个对象的本地化字符串。<code>Object</code>中默认的<code>toLocaleString()</code>方法并不做任何本地化自身的操作，它仅调用<code>toString()</code>方法并返回对应值。<code>Date</code>和<code>Number</code>类对<code>toLocaleString()</code>方法做了定制，可以用它对数字、日期和时间做本地化的转换。<code>Array</code>类的<code>toLocaleString()</code>方法和<code>toString()</code>方法很像，唯一的不同是每个数组元素会调用<code>toLocaleString()</code>方法转换为字符串，而不是调用各自的<code>toString()</code>方法。</p><h4 id="3-toJSON-方法"><a href="#3-toJSON-方法" class="headerlink" title="3. toJSON()方法"></a>3. toJSON()方法</h4><p><code>Object.prototype</code>实际上没有定义<code>toJSON()</code>方法，但对于需要执行序列化的对象来说，<code>JSON.stringify()</code>方法会调用<code>toJSON()</code>方法。如果在待序列化的对象中存在这个方法，则调用它，返回值即是序列化的结果，而不是原始的对象。</p><h4 id="4-valueOf-方法"><a href="#4-valueOf-方法" class="headerlink" title="4. valueOf()方法"></a>4. valueOf()方法</h4><p><code>valueOf()</code>方法和<code>toString()</code>方法非常类似，但往往当JavaScript需要将对象转换为某种原始值而非字符串的时候才会调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript就会自动调用这个方法。默认的<code>valueOf()</code>方法不足为奇，但有些内置类自定义了<code>valueOf()</code>方法（比如<code>Date.valueOf()</code>）。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对象是JavaScript的基本数据类型。对象是一种复合值：它将很多值（原始值或者其他对象）聚合在一起，可以通过名字访问这些值。对象也可看作是属性的无序集合，每个属性都是一个名值对，属性名是字符串，因此我们可以把对象看成是从字符串到值的映射。&lt;/p&gt;
    
    </summary>
    
      <category term="JS抄书笔记" scheme="http://www.xiaoleon.cn/categories/JS%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript对象" scheme="http://www.xiaoleon.cn/tags/JavaScript%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JS(1) 实现继承</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/js-1/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/js-1/</id>
    <published>2018-01-22T14:20:10.000Z</published>
    <updated>2018-01-27T09:03:25.483Z</updated>
    
    <content type="html"><![CDATA[<p>JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。那么如何在JS中实现继承呢？让我们拭目以待。</p><a id="more"></a><hr><h3 id="一、类式继承"><a href="#一、类式继承" class="headerlink" title="一、类式继承"></a>一、类式继承</h3><p>类式继承的主要思路是：<strong>采用构造函数实例化对象，通过原型链将实例对象关联起来</strong>。</p><h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h4><p>JavaScript使用原型链作为实现继承的主要方法，实现的本质是重写原型对象，代之以一个新类型的实例。下面的代码中，原来存在于<code>Super</code>的实例对象中的属性和方法，现在也存在于<code>Sub.prototype</code>中了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sub继承自Super</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getValue());           <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>原型链最主要的问题在于包含引用类型值的原型属性会被所有实例共享，而这也是为什么要在构造函数中，而不是在原型对象中定义属性的原因。通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章的变成了现在的原型属性了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub();</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);              <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);              <span class="comment">// 'red, blue, green, black'</span></span><br></pre></td></tr></table></figure><p>原型链的第二个问题是，在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有实例的情况下，给超类型的构造函数传递参数。再加上包含引用类型值的原型属性会被所有实例共享的问题，在实践中很少会单独使用原型链继承。</p><h4 id="2-借用构造函数继承"><a href="#2-借用构造函数继承" class="headerlink" title="2. 借用构造函数继承"></a>2. 借用构造函数继承</h4><p>借用构造函数的技术（有时候也叫做伪类继承或经典继承）。基本思想比较简单，即在子类型构造函数的内部调用超类型构造函数，通过使用<code>apply()</code>和<code>call()</code>方法在新创建的对象上执行构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>); <span class="comment">// 继承了Super</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub();</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);              <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);              <span class="comment">// 'red, blue, green'</span></span><br></pre></td></tr></table></figure><p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型中向超类型构造函数传递参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, <span class="string">'xiaozhang'</span>); <span class="comment">// 继承父类，同时传递参数</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="string">'28'</span>; <span class="comment">// 实例属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance.name);                 <span class="comment">// 'xiaozhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age);                  <span class="comment">// '28'</span></span><br></pre></td></tr></table></figure><p>但是，如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。</p><h4 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h4><p>组合集成有时也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub(<span class="string">'xiaozhang'</span>, <span class="number">28</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);          <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getName());       <span class="comment">// 'xiaozhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getAge());        <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub(<span class="string">'leon'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);          <span class="comment">// 'red, blue, green'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getName());       <span class="comment">// 'leon'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getAge());        <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>组合继承有它自己的问题。那就是无论什么情况下，都会调用两次父类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含父类型对象的全部实例属性，但不得不在调用子类型构造函数时重写这些属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第二次调用Super()，Sub.prototype再次获得name和colors两个属性，并对前一次的属性值进行覆盖</span></span><br><span class="line">    Super.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用Super()，Sub.prototype获得name和colors两个属性</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-寄生组合继承"><a href="#4-寄生组合继承" class="headerlink" title="4. 寄生组合继承"></a>4. 寄生组合继承</h4><p>解决两次调用父类型构造函数的方法是使用寄生组合式继承。计生组合式继承与组合继承相似，都是通过借用构造函数来继承不可共享的属性，通过原型链的混成形式来继承方法和可共享的属性。只不过把原型继承的形式变成了寄生式继承。使用寄生组合式继承可以不必为了指定子类型的原型而调用父类型的构造函数，从而寄生式继承只继承了父类型的原型属性，而父类型的实例属性是通过借用构造函数的方式来得到的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">proto</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">        F.prototype = proto;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub(<span class="string">'xiaozhang'</span>, <span class="number">28</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);          <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getName());       <span class="comment">// 'xiaozhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getAge());        <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub(<span class="string">'leon'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);          <span class="comment">// 'red, blue, green'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getName());       <span class="comment">// 'leon'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getAge());        <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>这个例子的高效率体现在它只调用了一次<code>Super</code>构造函数，并且因此避免了在<code>Sub.prototype</code>上面创建不必要的、多余的属性。与此同时，原型链还保持不变。因此，开发人员普遍认为寄生组合式继承是引用类型最理想的继承方式。</p><h4 id="5-ES6中的class"><a href="#5-ES6中的class" class="headerlink" title="5. ES6中的class"></a>5. ES6中的class</h4><p>采用ES6中的<code>class</code>语法糖，则上面代码修改如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getAge() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub(<span class="string">'xiaozhang'</span>, <span class="number">28</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);              <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getName());           <span class="comment">// 'xiaozhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getAge());            <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub(<span class="string">'leon'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);              <span class="comment">// 'red, blue, green'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getName());           <span class="comment">// 'leon'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getAge());            <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>ES6的<code>class</code>语法糖隐藏了许多技术细节，在实现同样功能的前提下，代码却优雅不少。</p><hr><h3 id="二、原型继承"><a href="#二、原型继承" class="headerlink" title="二、原型继承"></a>二、原型继承</h3><h4 id="1-原型继承"><a href="#1-原型继承" class="headerlink" title="1. 原型继承"></a>1. 原型继承</h4><p>原型继承，又称为委托继承。道格拉斯·克罗克福德（Douglas Crockford）在2006年谢了一篇文章，《Javascript中的原型式继承》。在这篇文章中，他介绍了一种实现继承的方式，这种方式并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象来创建新对象，同时不必因此创建自定义类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj = object(superObj);</span><br><span class="line">subObj.init(<span class="string">'sub'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subObj.getValue()); <span class="comment">// 'sub'</span></span><br></pre></td></tr></table></figure><p>在<code>object</code>函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的新实例。从本质上将，<code>object</code>方法对传入其中的对象执行了一次浅复制。ES5通过新增<code>Object.create</code>方法规范了原型式继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj = <span class="built_in">Object</span>.create(superObj);</span><br><span class="line">subObj.init(<span class="string">'sub'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subObj.getValue()); <span class="comment">// 'sub'</span></span><br></pre></td></tr></table></figure><h4 id="2-与原型链继承的关系"><a href="#2-与原型链继承的关系" class="headerlink" title="2. 与原型链继承的关系"></a>2. 与原型链继承的关系</h4><p>原型继承虽然只是看上去将原型链继承的一些程序性步骤包裹在函数里而已。但是，它们的一个重要区别是父类型的实例对象不再作为子类型的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用原型链继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance.value);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 使用原型继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance.value);</span><br></pre></td></tr></table></figure><p>原型继承中子类可以继承父类原型上的属性，但不可以继承父类的实例上的属性。原型继承与原型链继承都存在着子例共享父例引用类型值的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    colors: [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj1 = <span class="built_in">Object</span>.create(superObj);</span><br><span class="line">subObj1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj2 = <span class="built_in">Object</span>.create(superObj);</span><br><span class="line">subObj2.colors.push(<span class="string">'white'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(superObj.colors);           <span class="comment">// 'red, blue, green, black, white'</span></span><br><span class="line"><span class="built_in">console</span>.log(subObj1.colors);            <span class="comment">// 'red, blue, green, black, white'</span></span><br><span class="line"><span class="built_in">console</span>.log(subObj2.colors);            <span class="comment">// 'red, blue, green, black, white'</span></span><br></pre></td></tr></table></figure><h4 id="3-寄生式继承"><a href="#3-寄生式继承" class="headerlink" title="3. 寄生式继承"></a>3. 寄生式继承</h4><p>寄生式继承（<code>parasitic</code>）是与原型继承紧密相关的一种思路，并且同样是由道格拉斯·克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，最后再返回对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parasite</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(original); <span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 以某种方式来增强这个对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    colors: [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj1 = parasite(superObj);</span><br><span class="line">subObj1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj2 = parasite(superObj);</span><br><span class="line">subObj2.colors.push(<span class="string">'white'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(superObj.colors);           <span class="comment">// 'red, blue, green, black, white'</span></span><br><span class="line"><span class="built_in">console</span>.log(subObj1.colors);            <span class="comment">// 'red, blue, green, black, white'</span></span><br><span class="line"><span class="built_in">console</span>.log(subObj2.colors);            <span class="comment">// 'red, blue, green, black, white'</span></span><br></pre></td></tr></table></figure><p>由于原型继承存在着引用类型的值被共享的问题，所以使用的并不多，只在一些简单的应用场景下使用。如果需要解决该问题，则需要借用构造函数，与原型继承的初衷相违背，相当于使用了类式继承的终极写法——寄生组合继承。</p><hr><h3 id="三、拷贝继承"><a href="#三、拷贝继承" class="headerlink" title="三、拷贝继承"></a>三、拷贝继承</h3><p>拷贝继承又称为混入继承，<code>jQuery</code>中使用的就是拷贝继承。拷贝继承不需要改变原型链，通过拷贝函数将父例的属性和方法拷贝到子例即可。</p><h4 id="1-拷贝函数"><a href="#1-拷贝函数" class="headerlink" title="1. 拷贝函数"></a>1. 拷贝函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj, cloneObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj != <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cloneObj = cloneObj || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">            cloneObj[i] = (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">            <span class="built_in">arguments</span>.callee(obj[i], cloneObj[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneObj[i] = obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = extend(obj1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.c);            <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.c);            <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line">obj2.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.c);            <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.c);            <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><h4 id="2-对象间的拷贝继承"><a href="#2-对象间的拷贝继承" class="headerlink" title="2. 对象间的拷贝继承"></a>2. 对象间的拷贝继承</h4><p>由于拷贝继承解决了引用类型值共享的问题，所以其完全可以脱离构造函数实现对象间的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj, cloneObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj != <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cloneObj = cloneObj || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">            cloneObj[i] = (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">            <span class="built_in">arguments</span>.callee(obj[i], cloneObj[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneObj[i] = obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    arrayValue: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj = extend(superObj);</span><br><span class="line">subObj.arrayValue.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(subObj.arrayValue);         <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(superObj.arrayValue);       <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><h4 id="3-使用构造函数的拷贝组合继承"><a href="#3-使用构造函数的拷贝组合继承" class="headerlink" title="3. 使用构造函数的拷贝组合继承"></a>3. 使用构造函数的拷贝组合继承</h4><p>如果要使用构造函数，则属性可以使用借用构造函数的方法，而引用类型属性和方法使用拷贝继承。相当于不再通过原型链来建立对象之间的联系，而通过复制来得到对象的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj, cloneObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj != <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cloneObj = cloneObj || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">            cloneObj[i] = (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">            <span class="built_in">arguments</span>.callee(obj[i], cloneObj[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneObj[i] = obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = extend(Super.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub(<span class="string">'xiaozhang'</span>, <span class="number">28</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);          <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub(<span class="string">'leon'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);          <span class="comment">// 'red, blue, green'</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>本文介绍的 <strong>类式继承</strong> 、<strong>原型继承</strong>、<strong>拷贝继承</strong> 三种继承方式中，类式继承用的最普遍，由于ES6中<code>class</code>语法糖，使其代码复杂度大大降低；原型继承由于无法处理引用类型值共享的问题，使用较少，但是原型继承引申出的寄生组合继承是类式继承的规范式方法；拷贝继承使用范围最广泛，不仅可以实现原型之间的继承，也可以脱离构造函数，直接实现对象间的继承。</p><p>总之，继承主要就是处理父例和子例之间的两个问题，即是否使用构造函数，及如何建立联系。</p><ul><li><p>类式继承的核心就是使用构造函数，通过原型链来建立联系</p></li><li><p>原型继承不使用构造函数，通过<code>Object.create()</code>来建立联系</p></li><li><p>拷贝继承使用或者不使用构造函数都可以，通过复制来建立联系</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://geek.csdn.net/news/detail/246690" target="_blank" rel="noopener">《Javascript面向对象系列》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。那么如何在JS中实现继承呢？让我们拭目以待。&lt;/p&gt;
    
    </summary>
    
      <category term="JS抄书笔记" scheme="http://www.xiaoleon.cn/categories/JS%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="类式继承" scheme="http://www.xiaoleon.cn/tags/%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF/"/>
    
      <category term="原型继承" scheme="http://www.xiaoleon.cn/tags/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/"/>
    
      <category term="拷贝继承" scheme="http://www.xiaoleon.cn/tags/%E6%8B%B7%E8%B4%9D%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>Web(1) 域名发散与域名收敛</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/web-1/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/web-1/</id>
    <published>2018-01-22T14:15:55.000Z</published>
    <updated>2018-01-27T09:03:40.571Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器对于同一域名下允许的并发请求做了限制，通常同一域名下最大并发请求数量为6个</p><a id="more"></a><ul><li><p>为了适应当时服务器的负载能力；之前的服务器的负载能力并没有这么强，高并发的请求可能会导致服务器无法正常提供服务甚至崩溃</p></li><li><p>如果浏览器允许的最大并发请求数较大，容易造成<code>DDoS(Distributed Denial of Service)</code>攻击等安全隐患</p></li><li><p>过多的并发请求可能会造成浏览器阻塞，使之处于“假死”的无响应状态</p></li><li><p>浏览器目前已经支持了长连接，可以在同一个<code>TCP</code>连接中完成多个请求，没有必要再进行代价较大的重新开启新请求的操作</p></li></ul><hr><h3 id="一、域名发散"><a href="#一、域名发散" class="headerlink" title="一、域名发散"></a>一、域名发散</h3><p>域名发散就是为了突破浏览器对于同一域名并发请求数的限制，使用域名发散为同一个服务申请多个域名，从而可以一定程度上提高并发量；当然，由于建立新的请求需要一定的代价，因此需要在域名发散与域名收敛之间进行<code>trade off</code>，通常发散的域名个数为2-4个。</p><hr><h3 id="二、域名收敛"><a href="#二、域名收敛" class="headerlink" title="二、域名收敛"></a>二、域名收敛</h3><p>域名收敛就是将静态资源放在一个域名下不进行发散，这主要是为了适应移动端的发展需求；通常DNS是一个开销较大的操作，而移动端由于网络带宽和实时性、资源等的限制，这些开销对于移动端的用户体验是致命的，因此需要进行域名收敛。</p><hr><h3 id="三、SPDY"><a href="#三、SPDY" class="headerlink" title="三、SPDY"></a>三、SPDY</h3><p><code>SPDY</code>是谷歌的一个商标，是由Google提出的一种更加快捷的应用层协议，可以说是对<code>HTTP</code>协议的一种补充，同时也推动了<code>HTTP/2</code>的发展。</p><p><code>SPDY</code>的提出也给无线端/移动端优化提供进一步的方案。</p><p>它并不是一种<code>HTTP</code>的替代，而是修改了<code>HTTP</code>请求和相应的发送方式；能够有效降低网页加载延时并提高网络安全性；可以通过<code>HTTP</code>头部压缩、多路复用、请求优先级排序降低加载延时；<code>SPDY</code>中使用<code>SSL/TLS</code>加密提高了网络安全性，同时向后兼容<code>TCP</code>；另外，服务器在页面请求后可以主动将需要的静态资源发送到客户端而不需要客户端再次请求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器对于同一域名下允许的并发请求做了限制，通常同一域名下最大并发请求数量为6个&lt;/p&gt;
    
    </summary>
    
      <category term="Web抄书笔记" scheme="http://www.xiaoleon.cn/categories/Web%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript对象" scheme="http://www.xiaoleon.cn/tags/JavaScript%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(10) 补充样式和属性</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-10/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-10/</id>
    <published>2018-01-22T14:05:03.000Z</published>
    <updated>2018-01-27T09:01:35.522Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要对CSS3中的一些内容比较少，但也非常重要的样式和属性进行简要介绍。</p><a id="more"></a><p>主要内容如下：</p><ul><li><p>掌握css3中与颜色相关的样式，掌握<code>alpha</code>通道的使用方法，掌握css3中新增的<code>rgba</code>颜色、<code>hsl</code>颜色与<code>hsla</code>颜色的概念盒使用方法</p></li><li><p>掌握<code>opacity</code>属性的含义盒使用方法，了解使用<code>alpha</code>来指定透明度与使用<code>opacity</code>属性来指定透明度这两者之间的区别，掌握<code>transparent</code>颜色值的含义及其使用方法</p></li><li><p>掌握<code>outline</code>属性的含义及其使用方法，能够使用<code>outline</code>属性在元素周围绘制一条轮廓线并指定该轮廓线的线宽、颜色、线的样式，以及线与边框的位移距离</p></li><li><p>掌握<code>resize</code>属性的含义及其使用方法，能够使用<code>resize</code>属性来定义一个允许用户自己调节尺寸的元素</p></li><li><p>掌握<code>initial</code>属性值的含义及其使用方法，能够使用<code>initial</code>属性来取消对元素的样式设定</p></li></ul><h3 id="一、颜色相关样式"><a href="#一、颜色相关样式" class="headerlink" title="一、颜色相关样式"></a>一、颜色相关样式</h3><p>在css3之前，在样式中指定的颜色值只能为<code>rgb</code>颜色值，并且只能通过<code>opacity</code>属性来设置元素的透明度。css3中增加了3种颜色中——<code>rgba</code>颜色值、<code>hsl</code>颜色值及<code>hsla</code>颜色值，并且允许通过对<code>rgba</code>颜色值和<code>hsla</code>颜色值设定<code>alpha</code>通道的方法来更加容易地实现将半透明文字与图像互相重叠的效果。</p><h4 id="1-利用alpha通道设定颜色"><a href="#1-利用alpha通道设定颜色" class="headerlink" title="1. 利用alpha通道设定颜色"></a>1. 利用alpha通道设定颜色</h4><p>1) 对rgb颜色设定alpha通道</p><p>在css3中，可以通过对<code>rgb</code>颜色设定<code>alpha</code>通道的方法来定义<code>rgba</code>颜色。所谓<code>rgba</code>颜色，是指利用红色值（<code>R</code>）、绿色值（<code>G</code>）、蓝色值（<code>B</code>）、<code>alpha</code>通道值（<code>A</code>）来定义的颜色。其中，<code>alpha</code>通道值的范围是0-1.0，0表示完全透明，1表示不透明。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">rgba</span>(255, 0, 0, 0<span class="selector-class">.5</span>);</span><br></pre></td></tr></table></figure><p>2) 对hsl颜色设定alpha通道</p><p>在css3中，除了可以使用<code>rgb</code>颜色外，还可以使用<code>hsl</code>颜色。<code>hsl</code>颜色使用色调（<code>H</code>）、饱和度（<code>S</code>）、亮度（<code>L</code>）来定义颜色。其中，色调值中用0或360表示红色，120表示绿色，240表示蓝色，当取值大于360时，实际的值等于该值除以360之后的余数。例如，如果色调值为480，则实际的颜色值为480除以360之后的余数，等于120。饱和度盒亮度的取值范围均为0%-100%。可以通过对<code>hsl</code>颜色设定<code>alpha</code>通道的方法来定义<code>hsla</code>颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">hsla</span>(120, 100%, 50%, 0<span class="selector-class">.5</span>);</span><br></pre></td></tr></table></figure><h4 id="2-alpha和opacity的区别"><a href="#2-alpha和opacity的区别" class="headerlink" title="2. alpha和opacity的区别"></a>2. alpha和opacity的区别</h4><p>在css3中，除了使用<code>alpha</code>通道的方法来设定透明度外，也可以通过<code>opacity</code>属性来设定透明度。</p><p><code>opacity</code>属性是css中专门用来指定透明度的一个属性，取值范围也在0-1之间，0表示完全透明，1表示不透明。使用<code>alpha</code>通道对元素设定透明度时，可以单独针对元素的背景色和文字颜色等来指定透明度，而<code>opacity</code>属性只能指定整个元素的透明度。</p><p>下方示例中有4个<code>div</code>元素，其背景色均为绿色，其中第1个<code>div</code>元素不指定透明度，第2个<code>div</code>元素使用<code>alpha</code>通道指定背景色的透明度为0.5，第3个<code>div</code>元素使用<code>alpha</code>通道指定背景色与文字颜色的透明度均为0.5，第4个<code>div</code>元素使用<code>opacity</code>属性指定元素的透明度为0.5</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">48px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div1</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(0, 255, 100);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(255, 255, 255);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div2</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0, 255, 100, 0.5);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rbg</span>(255, 255, 255);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div3</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0, 255, 100, 0.5);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(255, 255, 255, 0.5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div4</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rbg</span>(0, 255, 100);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(255, 255, 255);</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span>aaaaaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span>bbbbbb<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div3"</span>&gt;</span>cccccc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div4"</span>&gt;</span>dddddd<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码中我们可以看出，对第2个<code>div</code>元素的背景色使用<code>alpha</code>通道时，并不会对文字产生影响，如果要让该元素的文字颜色也变成半透明，需要像第3个<code>div</code>元素那样同时对背景色和文字颜色使用<code>alpha</code>通道。但是，在第4个<code>div</code>元素的样式代码中，因为使用一次<code>opacity</code>属性，文字颜色和背景色都变成半透明的了。</p><h4 id="3-指定颜色值为transparent"><a href="#3-指定颜色值为transparent" class="headerlink" title="3. 指定颜色值为transparent"></a>3. 指定颜色值为transparent</h4><p>如果将颜色值指定为<code>transparent</code>，则会将背景、文字或边框等的颜色设定为完全透明，相当于使用了值为0的<code>alpha</code>通道。</p><hr><h3 id="二、用户界面相关样式"><a href="#二、用户界面相关样式" class="headerlink" title="二、用户界面相关样式"></a>二、用户界面相关样式</h3><h4 id="1-outline属性"><a href="#1-outline属性" class="headerlink" title="1. outline属性"></a>1. outline属性</h4><p>css3中定义了一个<code>outline</code>属性，用来在元素周围绘制一条轮廓线，可以起到突出元素的作用。例如，可以在原本没有边框的<code>radio</code>单选框外围加上一条轮廓线，使其在页面上显得更加突出，也可以在一组<code>radio</code>单选框中只对某个单选框加上轮廓线，使其区别于别的单选框。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">outline</span>: <span class="selector-tag">outline-color</span> <span class="selector-tag">outline-style</span> <span class="selector-tag">outline-width</span></span><br></pre></td></tr></table></figure><ul><li><p><code>outline-color</code>参数表示轮廓线的颜色，属性值为css中定义的颜色值</p></li><li><p><code>outline-style</code>参数表示轮廓线的样式，属性值为css中定义的线的样式</p></li><li><p><code>outline-width</code>参数表示轮廓线的宽度，属性值可以为一个宽度值</p></li></ul><p><code>outline</code>属性的三个参数的顺序可以呼唤，也可以分开书写成三个属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">outline-color</span>: red;</span><br><span class="line">    <span class="attribute">outline-style</span>: solid;</span><br><span class="line">    <span class="attribute">outline-width</span>: thin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-out-offset属性"><a href="#2-out-offset属性" class="headerlink" title="2. out-offset属性"></a>2. out-offset属性</h4><p>在默认情况下，对带有边框的元素来说，使用<code>outline</code>属性将紧贴着边框外围绘制一条轮廓线。有时，我们不想让这条轮廓线紧贴着边框外围，想让轮廓线稍微向外偏离几个像素，以绘制出双层边框的效果。针对这种情况，css3新增了一个<code>outline-offset</code>属性，可以使用该属性实现这个效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: blue solid thin;</span><br><span class="line">    <span class="attribute">outline</span>: red solid thin;</span><br><span class="line">    <span class="attribute">outline-offset</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以给<code>outline-offset</code>属性指定一个为负数的属性值，指定为负数的属性值后，轮廓线将向内偏移，绘制在边框内部。</p><h4 id="3-resize属性"><a href="#3-resize属性" class="headerlink" title="3. resize属性"></a>3. resize属性</h4><p>为了增强用户体验，css3增加了很多新的属性，其中一个重要的属性就是<code>resize</code>，它允许用户通过拖动的方式来修改元素的尺寸，到目前为止，主要用于可以使用<code>overflow</code>属性的任何容器元素中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">    <span class="attribute">resize</span>: both;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resize</code>属性的值分为以下几种：</p><ul><li><p><code>none</code>：用户不能修改元素尺寸</p></li><li><p><code>both</code>：用户可以修改元素的宽度和高度</p></li><li><p><code>horizontal</code>：用户可以修改元素的宽度，但不能修改元素的高度</p></li><li><p><code>vertical</code>：用户可以修改元素的高度，但不能修改元素的宽度</p></li><li><p><code>inherit</code>：继承父元素的resize属性值</p></li></ul><h4 id="4-initial属性值"><a href="#4-initial属性值" class="headerlink" title="4. initial属性值"></a>4. initial属性值</h4><p>要取消对元素的样式指定，可以通过几种方法来达到这个目的，其中最简单的方法时直接在样式表中删除设定该样式的代码。但是，在大多数情况下，一个样式写好了以后会对很多页面中的元素指定这个样式。所以，如果对单个元素取消其样式的指定时，这种做法是不可取的。</p><p>第二种方法是目前采用的使用<code>class</code>的方法，要取消对单个元素的样式指定，只要把这个元素的<code>class</code>属性取消掉就可以了，但是<code>class</code>属性本身是一个多余的、没有任何语义的属性。同时，如果多个元素使用同一个样式，还必须为每一个元素增加同样的<code>class</code>属性；如果要删除一个样式，还要逐个删除这些元素的<code>class</code>属性，所以很不实用。css3中已经不推荐使用它，取而代之的是将样式与元素或元素<code>id</code>直接绑定的做法。所以，第二种方法在下一代Web平台中使用的机会也会越来越少，直到最终随着<code>class</code>属性一起被废弃掉。</p><p>针对这种情况，css3中新增了一个<code>initial</code>属性值，使用这个<code>initail</code>属性值可以直接取消对某个元素的样式指定。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#div1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: initial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span>aaaaaaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span>bbbbbbb<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div3"</span>&gt;</span>ccccccc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>initial</code>属性值的作用是让各种属性使用默认值，在浏览器中文字的颜色默认值是黑色，所以<code>id</code>为“div1”的元素中的文字会变成黑色。</p><p><strong>使用initial属性值的特例</strong></p><p>个别情况下，对元素使用<code>initial</code>属性值后的显示结果并不等于该元素的样式设定直接删除后的结果。在浏览器中，为了使一些元素变得更容易阅读，浏览器可以自行对该元素使用一些样式，例如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在样式中对<code>h1</code>元素重新定义，例如对<code>h1</code>元素定义如下样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，在这段样式后面追加一段<code>h1</code>元素使用的样式，对上面文字的字号和字体粗细均使用<code>initial</code>属性值，追加后的样式如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: initial;</span><br><span class="line">    <span class="attribute">font-weight</span>: initial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后我们会发现，<code>h1</code>元素在浏览器中的显示结果与最初不设定时并不相同。</p><p>为什么在<code>h1</code>元素的样式代码中追加了<code>initial</code>属性值后的显示结果与不使用任何样式设定时的显示结果会不一样呢？因为追加了<code>initial</code>属性值的样式设定后，<code>h1</code>元素的字号和字体粗细均使用css中对子号和字体粗细属性设定的默认值，并不考虑浏览器对<code>h1</code>元素追加了什么样式。而在css中，字号的默认值为<code>medium</code>，字体粗细的默认值是<code>normal</code>，与浏览器对<code>h1</code>元素使用的样式并不一致，如果想要让<code>h1</code>元素的字号和字体粗细的默认值使用浏览器的默认值，还是不要在追加的样式代码中使用<code>initial</code>属性值，而是使用浏览器追加的默认样式中的属性值。在<a href="http://www.w3.org/TR/CSS21/sample.html" target="_blank" rel="noopener">http://www.w3.org/TR/CSS 21/sample.html</a>中可以查到浏览器对HTML4中元素所做的追加样式清单，目前各主流浏览器均遵照这个清单来对元素追加默认样式。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要对CSS3中的一些内容比较少，但也非常重要的样式和属性进行简要介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="颜色" scheme="http://www.xiaoleon.cn/tags/%E9%A2%9C%E8%89%B2/"/>
    
      <category term="outline" scheme="http://www.xiaoleon.cn/tags/outline/"/>
    
      <category term="out-offset" scheme="http://www.xiaoleon.cn/tags/out-offset/"/>
    
      <category term="resize" scheme="http://www.xiaoleon.cn/tags/resize/"/>
    
      <category term="initial" scheme="http://www.xiaoleon.cn/tags/initial/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(9) Media Queries相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-9/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-9/</id>
    <published>2018-01-22T14:02:35.000Z</published>
    <updated>2018-01-27T09:01:28.247Z</updated>
    
    <content type="html"><![CDATA[<p>在css3的众多模块中，有一个与各种媒体相关的重要模块——<code>Media Queries</code>，该模块中允许添加媒体查询表达式，用以指定媒体类型，然后根据媒体类型来选择应该使用的样式。换句话说，允许我们在不改变内容的情况下在样式中选择一种页面的布局以精确地适应不同的设备，从而改善用户体验。</p><a id="more"></a><h3 id="一、Media-Queries使用方法"><a href="#一、Media-Queries使用方法" class="headerlink" title="一、Media Queries使用方法"></a>一、Media Queries使用方法</h3><p><code>Media Queries</code>的使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@media 设备类型 and ( 设备特性 ) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p>在代码的开头必须要书写<code>“@media”</code>，然后指定设备类型，也可以称之为媒体类型。css定义了10种设备类型，在此处可以指定的值与该值所代表的设备类型如下所示。</p><table><thead><tr><th>可以指定的值</th><th>设备类型</th></tr></thead><tbody><tr><td>all</td><td>所有设备</td></tr><tr><td>screen</td><td>电脑显示器</td></tr><tr><td>print</td><td>打印用纸或打印预览视图</td></tr><tr><td>handheld</td><td>便携设备</td></tr><tr><td>tv</td><td>电视机类型的设备</td></tr><tr><td>speech</td><td>语音和音频合成器</td></tr><tr><td>braille</td><td>忙人用点字法触觉回馈设备</td></tr><tr><td>embossed</td><td>盲文打印机</td></tr><tr><td>projection</td><td>各种投影设备</td></tr><tr><td>tty</td><td>使用固定密度字母栅格的媒介，比如电传打字机和终端</td></tr></tbody></table><p>设备特性的书写方式与样式的书写方式很相似，分为两个部分，当中由冒号分割，冒号前书写设备的某种特性，冒号后书写该特性的具体值，如需要指定浏览器的窗口宽度大于400px时所使用的样式，书写方法如下：<code>( min-width: 400px )</code></p><p>css中的设备特性共有13种，是一个类似于css属性的集合，但与css属性不同的是，大部分设备特性的指定值接受<code>min/max</code>的前缀，用来表示大于等于或小于的逻辑，以此避免使用<code>&lt;</code>盒<code>&gt;</code>这些字符。</p><table><thead><tr><th>特性</th><th>可指定值</th><th>是否允许使用min/max前缀</th><th>特性说明</th></tr></thead><tbody><tr><td>width</td><td>带单位的长度数值，例如：400px</td><td>允许</td><td>浏览器窗口的宽度</td></tr><tr><td>height</td><td>带单位的长度数值，例如：200px</td><td>允许</td><td>浏览器窗口的高度</td></tr><tr><td>device-width</td><td>带单位的长度数值，例如：400px</td><td>允许</td><td>设备屏幕分辨率的宽度</td></tr><tr><td>device-height</td><td>带单位的宽度数值，例如：200px</td><td>允许</td><td>设备屏幕分辨率的高度</td></tr><tr><td>orientation</td><td>只能指定两个值：portrait或landscape</td><td>不允许</td><td>浏览器窗口的方向是纵向还是横向。当窗口的高度值大于等于宽度值时，该特性值为portrait，否则为landscape</td></tr><tr><td>aspect-ratio</td><td>比例值，例如：16/9</td><td>允许</td><td>浏览器窗口的纵横比，比例值为浏览器窗口的宽度值/高度值</td></tr><tr><td>device-aspect-ratio</td><td>比例值，例如：16/9</td><td>允许</td><td>屏幕分辨率的纵横比，比例值为设备屏幕分辨率的宽度值/高度值</td></tr><tr><td>color</td><td>整数值</td><td>允许</td><td>设备使用多少位的颜色值，如果不是彩色设备，该值为0</td></tr><tr><td>color-index</td><td>整数值</td><td>允许</td><td>色彩表中的色彩数</td></tr><tr><td>monochrome</td><td>整数值</td><td>允许</td><td>单色帧缓冲期中每像素的字节数</td></tr><tr><td>resolution</td><td>分辨率值，例如：300dpi</td><td>允许</td><td>设备的分辨率</td></tr><tr><td>scan</td><td>只能指定两个值：progressive或interlace</td><td>不允许</td><td>电视机类型设备的扫描方式。progressive表示逐行扫描，interlace表示隔行扫描</td></tr><tr><td>grid</td><td>只能指定两个值：0或1</td><td>不允许</td><td>设备是基于栅格还是基于位图。基于栅格时该值为1，否则该值为0</td></tr></tbody></table><p>使用<code>and</code>关键字来指定当某种设备类型的某种特性的值满足某个条件时所使用的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">639px</span>) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p>可以使用多条语句来将同一个样式应用到不同的设备类型和设备特性中，指定方式如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> handheld and (min-width: <span class="number">360px</span>), screen and (min-width: <span class="number">480px</span>) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p>可以在表达式中加上<code>not</code>关键字或<code>only</code>关键字，<code>not</code>关键字表示对后面的表达式执行取反操作，书写方法如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 除便携设备之外的其他设备或非彩色便携设备 */</span></span><br><span class="line">@<span class="keyword">media</span> not handheld and (color) &#123; 样式代码 &#125;</span><br><span class="line"><span class="comment">/* 所有非彩色设备 */</span></span><br><span class="line">@<span class="keyword">media</span> all and (not color) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p><code>only</code>关键字，让那些不支持<code>Media Queries</code>但是能够读取<code>Media Type</code>的设备的浏览器将表达式的样式隐藏起来。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (color) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p>对于支持<code>Media Queries</code>的设备来说，将能够正确地应用央视，就仿佛<code>only</code>不存在一样；对于不支持<code>Media Queries</code>但能够读取<code>Media Type</code>的设备来说，由于先读取到<code>only</code>而不是<code>screen</code>，将忽略这个样式；对于不支持<code>Media Queries</code>的浏览器，无论是否有<code>only</code>，都将忽略这个样式。</p><p>css3中的<code>Media Queries</code>模块中也支持对外部样式表的引用，使用如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(color.css) screen and (min-width: <span class="number">1000px</span>);</span><br><span class="line"></span><br><span class="line">&lt;link rel="stylesheet" type="text/css" media="screen and (min-width: 1000px)" href="style.css"&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在css3的众多模块中，有一个与各种媒体相关的重要模块——&lt;code&gt;Media Queries&lt;/code&gt;，该模块中允许添加媒体查询表达式，用以指定媒体类型，然后根据媒体类型来选择应该使用的样式。换句话说，允许我们在不改变内容的情况下在样式中选择一种页面的布局以精确地适应不同的设备，从而改善用户体验。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="响应式布局" scheme="http://www.xiaoleon.cn/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    
      <category term="媒体查询" scheme="http://www.xiaoleon.cn/tags/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(8) 布局相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-8/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-8/</id>
    <published>2018-01-22T14:00:00.000Z</published>
    <updated>2018-01-27T09:01:21.394Z</updated>
    
    <content type="html"><![CDATA[<p>Web页面中的布局，是指在页面中如何对标题、导航栏、主要内容、脚注、表单等各种构成要素进行一个合理的编排。在css3之前，主要使用<code>float</code>属性或<code>position</code>属性进行页面中的简单布局，但是存在很多缺点，譬如两栏或多栏中如果元素的内容高度不一致则由底部很难对齐的问题。</p><a id="more"></a><h3 id="一、多栏布局"><a href="#一、多栏布局" class="headerlink" title="一、多栏布局"></a>一、多栏布局</h3><p>我们首先回顾以下css3之前是如何使用<code>float</code>属性或<code>position</code>属性进行页面中的简单布局的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20em</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div1</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>float</code>属性或<code>position</code>属性进行页面布局时有一个比较明显的缺点，就是两个<code>div</code>元素是相互独立的，因此如果在第一个<code>div</code>元素中加入一些内容的话，将会使得两个元素的底部不能对其，导致页面中多出一块空白区域。</p><p>针对<code>float</code>属性或<code>position</code>属性的缺点，css3中加入了多栏布局方式，使用多栏布局可以将一个元素中的内容分为两栏或多栏显示，并且确保各栏中内容的底部对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50em</span>;</span><br><span class="line">    <span class="attribute">column-count</span>: <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>column-count</code>属性来使用多栏布局方式，该属性的含义是讲一个元素中的内容分为多栏进行显示。使用多栏布局的时候，需要将元素的宽度设置成多个栏目的总宽度，它与使用<code>float</code>属性和<code>position</code>属性时的区别是：使用两个属性时只需单独设定每个元素的宽度即可，而使用多栏布局时需要设定元素中多个栏目相加后的总的宽度。</p><p>我们也可以使用<code>column-width</code>属性单独设置每一栏的宽度而不设定元素的宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">column-count</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">column-width</span>: <span class="number">20em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>column-gap</code>属性来设定多栏之间的间隔距离。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">column-count</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">column-gap</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>column-rule</code>属性在栏与栏之间增加一条间隔线，并且设定该间隔线的宽度、颜色等，该属性的属性值的指定方法与css中<code>border</code>属性的属性值指定方法相同。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">column-count</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">column-rule</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、盒布局"><a href="#二、盒布局" class="headerlink" title="二、盒布局"></a>二、盒布局</h3><p>在css3中，除了多栏布局之外，还可以使用盒布局解决前面所说的使用<code>float</code>属性或<code>position</code>属性时左右两栏或多栏中底部不能对齐的问题。</p><p>接下来我们看一个示例，示例中有三个<code>div</code>元素，简单展示了网页中的左侧边栏、中间内容和右侧边栏。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#middle</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: limegreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span>, <span class="selector-id">#middle</span>, <span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>aaaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"middle"</span>&gt;</span>bbbb<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>cccc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例中如果<code>div</code>的内容变化时，<code>div</code>元素的底部会出现无法对齐的问题。</p><p>在css3中，我们可以通过<code>box</code>属性来使用盒布局，修改代码如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    <span class="attribute">display</span>: -moz-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#middle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: limegreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span>, <span class="selector-id">#middle</span>, <span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>盒布局与多栏布局的区别</p><p>  使用多栏布局时，各栏宽度必须是相等的，在指定每栏宽度时，也只能为所有栏指定一个统一的宽度，栏与栏之间的宽度不可能是不一样的。另外，使用多栏布局时，也不可能具体指定什么栏中显示什么内容，因此比较适合使用在显示文章内容的时候，不适合用于安排整个网页中由个元素组成的网页结构时。</p></li></ul><ul><li><p>盒布局标准</p><p>  可以采用最新的<code>display: flex</code>属性，<code>-webkit-box</code>属于2009年的提案。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="">《HTML5与CSS3权威指南》</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">《Flex 布局教程：语法篇》（阮一峰）</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web页面中的布局，是指在页面中如何对标题、导航栏、主要内容、脚注、表单等各种构成要素进行一个合理的编排。在css3之前，主要使用&lt;code&gt;float&lt;/code&gt;属性或&lt;code&gt;position&lt;/code&gt;属性进行页面中的简单布局，但是存在很多缺点，譬如两栏或多栏中如果元素的内容高度不一致则由底部很难对齐的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="layout" scheme="http://www.xiaoleon.cn/tags/layout/"/>
    
      <category term="多栏布局" scheme="http://www.xiaoleon.cn/tags/%E5%A4%9A%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    
      <category term="盒布局" scheme="http://www.xiaoleon.cn/tags/%E7%9B%92%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(7) 动画</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-7/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-7/</id>
    <published>2018-01-22T13:56:19.000Z</published>
    <updated>2018-01-27T09:01:14.651Z</updated>
    
    <content type="html"><![CDATA[<p>css3中，如果使用动画功能，可以使页面上的文字或画像具有动画效果，可以使背景色从一种颜色平滑过渡到另一种颜色。</p><a id="more"></a><p>css3中的动画功能分为<code>Transitions</code>功能与<code>Animations</code>功能，这两种功能都可以通过改变css的属性值来产生动画效果。</p><p>到目前为止，<code>Transitions</code>功能支持从一个属性值平滑过渡到另一个属性值，<code>Animations</code>功能支持通过关键帧的指定来在页面上产生更复杂的动画效果。</p><h3 id="一、Transitions功能"><a href="#一、Transitions功能" class="headerlink" title="一、Transitions功能"></a>一、Transitions功能</h3><p><code>Transitions</code>功能通过将元素的某个属性从一个属性值在指定的时间内平滑过渡到另一个属性值来实现动画功能，可通过<code>transitions</code>属性来使用<code>Transitions</code>功能。</p><p>使用方法如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">property</span> <span class="selector-tag">duration</span> <span class="selector-tag">timing-function</span></span><br></pre></td></tr></table></figure><p>其中<code>property</code>表示对哪个属性进行平滑过渡，<code>duration</code>表示在多长时间内完成属性值的平滑过渡，<code>timing-function</code>表示通过什么方法来进行平滑过渡。</p><p>我们看一个使用示例，页面中有一个<code>div</code>元素，背景色为黄色，通过<code>hover</code>属性指定当鼠标指针停留在<code>div</code>元素上时的背景色为浅蓝色，通过<code>transitions</code>属性指定：当鼠标指针移动到<code>div</code>元素上时，在1秒钟内让<code>div</code>元素的背景色从黄色平滑过度到浅蓝色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffff00</span>;</span><br><span class="line">    <span class="attribute">-webkit-transition</span>: background-color <span class="number">1s</span> linear;</span><br><span class="line">    <span class="attribute">-moz-transition</span>: background-color <span class="number">1s</span> linear;</span><br><span class="line">    <span class="attribute">-o-transition</span>: background-color <span class="number">1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#00ffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>css3中，还有另外一种使用<code>Transitions</code>功能的方法，就是将<code>transitions</code>属性中的三个参数改写成<code>transition-property</code>、<code>transition-duration</code>、<code>transition-timing-function</code>三个属性，这三个属性的含义与属性值的制定方法与<code>transitions</code>属性中的三个参数的含义及指定方法完全相同。</p><p><strong>使用Transitions功能同时平滑过渡多个属性值</strong></p><p>可以使用<code>Transitions</code>功能同时对多个属性值进行平滑过渡。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffff00</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000000</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">-webkit-transition</span>: background-color <span class="number">1s</span> linear, color <span class="number">1s</span> linear, width <span class="number">1s</span> linear;</span><br><span class="line">    <span class="attribute">-moz-transition</span>: background-color <span class="number">1s</span> linear, color <span class="number">1s</span> linear, width <span class="number">1s</span> linear;</span><br><span class="line">    <span class="attribute">-o-transition</span>: background-color <span class="number">1s</span> linear, color <span class="number">1s</span> linear, width <span class="number">1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#003366</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、Animations功能"><a href="#二、Animations功能" class="headerlink" title="二、Animations功能"></a>二、Animations功能</h3><p><code>Animations</code>功能与<code>Transitions</code>功能相同，都是通过改变元素的属性值来实现动画效果的。它们的区别在于：使用<code>Transitions</code>功能时只能通过指定属性的开始值与结束值，然后在这两个属性值之间进行平滑过渡的方式来实现动画效果，因此不能实现比较复杂的动画效果；而<code>Animations</code>则通过定义多个关键帧以及定义每个关键帧中元素的属性值来实现更为复杂的动画效果。</p><p>我们看一个代码使用示例，一个<code>div</code>元素背景色为红色，当鼠标指针移动到<code>div</code>元素上时，元素的背景色将经历从红色到深蓝色，从深蓝色到黄色，从黄色回到红色这样一系列的变化。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> mycolor &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">    40% &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: darkblue;</span><br><span class="line">    &#125;</span><br><span class="line">    70% &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="comment">/* 指定关键帧集合的名称 */</span></span><br><span class="line">    <span class="attribute">-webkit-animation-name</span>: mycolor;</span><br><span class="line">    <span class="comment">/* 指定完成整个动画的时间 */</span></span><br><span class="line">    <span class="attribute">-webkit-animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">    <span class="comment">/* 指定实现动画的方法 */</span></span><br><span class="line">    <span class="attribute">-webkit-animation-timing-function</span>: linear;</span><br><span class="line">    <span class="comment">/* 指定动画的播放次数 */</span></span><br><span class="line">    <span class="attribute">-webkit-animation-iteration-count</span>: infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码实现的动画中带有如下几个关键帧，通过这些关键帧之间的平滑过渡完成了动画的实现。</p><ul><li><p>开始帧：0%</p></li><li><p>背景色为深蓝色的关键帧：40%</p></li><li><p>背景色为黄色的关键帧：70%</p></li><li><p>结束帧：100%</p></li></ul><p><strong>实现动画的方法</strong></p><p>前面的使用示例中，我们只使用了一种实现动画的方法——<code>linear</code>。<code>linear</code>的含义是在动画从开始到结束时使用同样的速度进行各种属性值的改变，在一个动画中不改变各种属性值的改变速度。</p><table><thead><tr><th>方法</th><th>属性值的变化速度</th></tr></thead><tbody><tr><td>linear</td><td>在动画开始时到结束时以同样速度进行改变</td></tr><tr><td>ease-in</td><td>动画开始时速度很慢，然后速度沿曲线值进行加快</td></tr><tr><td>ease-out</td><td>动画开始时速度很快，然后沿曲线值进行放慢</td></tr><tr><td>ease</td><td>动画开始时速度很慢，然后速度沿曲线值进行加快，然后再沿曲线值放慢</td></tr><tr><td>ease-in-out</td><td>动画开始时速度很慢，然后沿曲线值进行加快，然后再沿曲线值放慢</td></tr></tbody></table><p>示例：实现网页的淡入效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> fadein &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: white;</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: white;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-animation-name</span>: fadein;</span><br><span class="line">    <span class="attribute">-webkit-animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">    <span class="attribute">-webkit-animation-timing-function</span>: linear;</span><br><span class="line">    <span class="attribute">-webkit-animation-iteration-count</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css3中，如果使用动画功能，可以使页面上的文字或画像具有动画效果，可以使背景色从一种颜色平滑过渡到另一种颜色。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Transitions" scheme="http://www.xiaoleon.cn/tags/Transitions/"/>
    
      <category term="Animations" scheme="http://www.xiaoleon.cn/tags/Animations/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(6) 变形处理</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-6/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-6/</id>
    <published>2018-01-22T13:53:57.000Z</published>
    <updated>2018-01-27T09:00:52.649Z</updated>
    
    <content type="html"><![CDATA[<p>在css3中，可以利用<code>transform</code>功能来实现文字或图像的旋转、缩放、倾斜、移动这四种类型的变形处理。</p><a id="more"></a><h3 id="一、缩放"><a href="#一、缩放" class="headerlink" title="一、缩放"></a>一、缩放</h3><p>使用<code>scale</code>方法实现文字或图像的缩放处理，在参数中指定缩放倍率。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 缩小50% */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以分别指定元素水平方向的放大倍率与垂直方向的放大倍率。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向缩小50%，垂直方向放大一倍 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.5, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、倾斜"><a href="#二、倾斜" class="headerlink" title="二、倾斜"></a>二、倾斜</h3><p>使用<code>skew</code>方法实现文字或图像的倾斜处理，在参数中分别指定水平方向上的倾斜角度与垂直方向上的倾斜角度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向倾斜30度，垂直方向倾斜30度 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(30deg, 30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>skew</code>方法中的两个参数可以修改成只使用一个参数，省略另一个参数——这种情况下视为只在水平方向上进行倾斜，垂直方向上不倾斜。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向倾斜30度，垂直方向不倾斜 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、移动"><a href="#三、移动" class="headerlink" title="三、移动"></a>三、移动</h3><p>使用<code>translate</code>方法来将文字或图像进行移动，在参数中分别指定水平方向上的移动距离与垂直方向上的移动距离。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向上移动50px，垂直方向上移动50px */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(50px, 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>translate</code>方法中的两个参数可以修改成只使用一个参数，省略另一个参数——这种情况下视为只在水平方向上移动，垂直方向上不移动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向上移动50px，垂直方向不移动 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、指定变形的基准点"><a href="#四、指定变形的基准点" class="headerlink" title="四、指定变形的基准点"></a>四、指定变形的基准点</h3><p>在使用<code>transform</code>方法进行文字或图像的变形时，是以元素的中心点为基准点进行的。使用<code>transform-origin</code>属性，可以改变变形的基准点。</p><p>指定<code>transform-origin</code>属性值的时候，采用“基准点在元素水平方向上的位置，基准点在元素垂直方向上的位置”的方法，其中“基准点在元素水平方向上的位置”中可以指定的值为<code>left</code>、<code>center</code>、<code>right</code>，“基准点在元素垂直方向上的位置”中可以指定的值为<code>top</code>、<code>center</code>、<code>bottom</code>。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在css3中，可以利用&lt;code&gt;transform&lt;/code&gt;功能来实现文字或图像的旋转、缩放、倾斜、移动这四种类型的变形处理。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="transform" scheme="http://www.xiaoleon.cn/tags/transform/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(5) 背景边框相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-5/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-5/</id>
    <published>2018-01-22T13:49:17.000Z</published>
    <updated>2018-01-27T09:00:45.815Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍CSS3中的背景和边框相关的一些样式，其中包括与背景相关的几个属性，如何在一个元素的背景中使用多个图像文件；如何绘制圆角边框；如何给元素添加图像边框。</p><a id="more"></a><p>在css3中，追加了一些与背景相关的属性，如下表所示</p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>background-clip</td><td>指定背景的显示范围</td></tr><tr><td>background-origin</td><td>指定绘制背景图像时的起点</td></tr><tr><td>background-size</td><td>指定背景中图像的尺寸</td></tr><tr><td>background-break</td><td>指定内联元素的背景图片进行平铺时的循环方式</td></tr></tbody></table><h3 id="一、指定背景的显示范围"><a href="#一、指定背景的显示范围" class="headerlink" title="一、指定背景的显示范围"></a>一、指定背景的显示范围</h3><p>在HTML页面中，一个具有背景的元素通常由元素的内容、内部补白（<code>padding</code>）、边框、外部补白（<code>margin</code>）构成。</p><p>元素背景的显示范围在css2、css2.1、css3中并不相同：</p><ul><li><p>css2中背景的显示范围是指内部补白之内的范围，不包括边框</p></li><li><p>css2.1至css3中，背景的显示范围是指包括边框在内的范围</p></li><li><p>css3中，可以使用<code>background-clip</code>来修改背景的显示范围，如果将<code>background-clip</code>设定为<code>border-box</code>，则背景范围包括边框区域，如果设定为<code>padding-box</code>或<code>content-box</code>，则不包括边框区域</p></li></ul><hr><h3 id="二、指定背景的绘制起点"><a href="#二、指定背景的绘制起点" class="headerlink" title="二、指定背景的绘制起点"></a>二、指定背景的绘制起点</h3><p>在绘制背景图像时，默认是从内部补白（<code>padding</code>）区域的左上角开始，但是可以利用<code>background-origin</code>属性来指定绘制时从边框的左上角开始，或者从内容的左上角开始。</p><blockquote><p>在firefox浏览器中，需要书写成“<code>-moz-background-origin</code>”形式；在safari浏览器或chrome浏览器中指定绘制起点时，需要书写成“<code>-webkit-background-origin</code>”形式。</p></blockquote><p><code>background-origin</code>属性为<code>border-box</code>、<code>padding-box</code>、<code>content-box</code>，分别代表从边框的左上角、内容补白区域的左上角或内容的左上角开始绘制。</p><hr><h3 id="三、指定背景图像的尺寸"><a href="#三、指定背景图像的尺寸" class="headerlink" title="三、指定背景图像的尺寸"></a>三、指定背景图像的尺寸</h3><p>在css3中，可以使用<code>background-size</code>属性来指定背景图像的尺寸。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-size</span>: 40<span class="selector-tag">px</span> 20<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p>其中第一个参数为图像的宽度，第二个参数为图像的高度，中间用半角空格进行分隔。如果要维持图像横纵比的话，可以将另一个参数设定为<code>auto</code>。</p><hr><h3 id="四、指定内联元素背景图片平铺循环方式"><a href="#四、指定内联元素背景图片平铺循环方式" class="headerlink" title="四、指定内联元素背景图片平铺循环方式"></a>四、指定内联元素背景图片平铺循环方式</h3><p>在css3中，可以使用<code>background-break</code>属性来指定平铺内联元素背景图像时的循环方式，可以指定<code>bounding-box</code>、<code>each-box</code>、<code>continuous</code>这三种循环方式。</p><p>将<code>background-break</code>属性指定为<code>bounding-box</code>时，背景图像在整个内联元素中进行平铺。指定为<code>each-box</code>时，背景图像在每一行中进行平铺。指定<code>continuous</code>的时候，下一行中的图像紧接着上一行中的图像继续平铺。</p><hr><h3 id="五、在一个元素中显示多个背景图像"><a href="#五、在一个元素中显示多个背景图像" class="headerlink" title="五、在一个元素中显示多个背景图像"></a>五、在一个元素中显示多个背景图像</h3><p>在css3中可以在一个元素里显示多个背景图像，还可以将多个背景图像进行重叠显示，从而使得背景图像中所用素材的调整变得更加容易。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(flower-red.png), <span class="built_in">url</span>(flower-green.png), <span class="built_in">url</span>(sky.jpg);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat, repeat-x, no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">3%</span> <span class="number">98%</span>, <span class="number">85%</span>, center center, top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>background-image</code>属性指定图像文件的时候，时按在浏览器中显示时图像叠放的顺序从上往下指定的，第一个图像文件是放在最上面的，最后制定的文件是放在最下面的。</p><p>允许多重制定并配合着多个图像文件一起利用的属性有如下几个：</p><p><code>background-image, background-repeat, background-position</code><br><code>background-clip, background-origin, background-size</code></p><hr><h3 id="六、border-radius属性"><a href="#六、border-radius属性" class="headerlink" title="六、border-radius属性"></a>六、border-radius属性</h3><p>在css3中，使用<code>border-radius</code>属性指定好圆角的半径，就可以绘制圆角边框了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">40px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用了<code>border-radius</code>属性但是把边框设定为不显示的时候，浏览器将把背景的四个角绘制为圆角。</p><p>使用了<code>border-radius</code>属性后，不管边框是什么种类，都会将边框沿着圆角曲线进行绘制。</p><hr><h3 id="七、border-image属性"><a href="#七、border-image属性" class="headerlink" title="七、border-image属性"></a>七、border-image属性</h3><p>css3中增加了一个<code>border-image</code>属性，可以让处于随时变化状态的元素的长或款的边框统一使用一个图像文件来绘制。使用<code>border-image</code>属性，会让浏览器在显示图像边框时，自动将所使用到的图像分割为9部分进行处理，这样就不需要页面再另外进行人工处理了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border-image</span>: <span class="built_in">url</span>(borderimage.png) <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> / <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>border-image</code>属性值中至少必须指定五个参数，其中第一个参数为边框所使用的图片文件的路径，后面四个参数表示当浏览器自动把边框所使用到的图像进行分隔时的上边距、右边距、下边距及左边距。</p><h4 id="1-指定边框宽度"><a href="#1-指定边框宽度" class="headerlink" title="1. 指定边框宽度"></a>1. 指定边框宽度</h4><p>在css3中，除了可以使用<code>border</code>属性或<code>border-width</code>属性来指定边框的宽度外，使用<code>border-image</code>属性同样可以指定边框的宽度。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image: url(图像文件的路径) A B C D / border-width</span><br></pre></td></tr></table></figure><p>下面代码中，指定了上边距、右边距、下边距和左边距为18px，4条边分别为5px、10px、15px、20px。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: solid;</span><br><span class="line">    <span class="attribute">border-image</span>: <span class="built_in">url</span>(borderimage.png) <span class="number">18</span> / <span class="number">5px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-中央图像的自动拉伸"><a href="#2-中央图像的自动拉伸" class="headerlink" title="2. 中央图像的自动拉伸"></a>2. 中央图像的自动拉伸</h4><p>浏览器将边框所用图像自动分割为9部分后，除了将<code>border-top-image</code>、<code>border-left-image</code>、<code>border-right-image</code>、<code>border-bottom-image</code>这四部分自动分配为四条边所用的图像之外，将位于中间部分的图像分配给元素边框所包围的中间区域，随着<code>div</code>元素内容变化的同时，或者在样式代码中修改div元素的宽度或高度的同时，中间部分的图像也会自动进行伸缩，以填满该中间区域。</p><h4 id="3-指定四条边中图像的显示方法"><a href="#3-指定四条边中图像的显示方法" class="headerlink" title="3. 指定四条边中图像的显示方法"></a>3. 指定四条边中图像的显示方法</h4><p>可以在<code>border-image</code>属性中指定元素四条边中的图像是以拉伸的方式显示，还是以平铺的方式显示</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image: url(文件路径) A B C D / border-width topbottom leftright</span><br></pre></td></tr></table></figure><p>其中，<code>topbottom</code>表示元素的上下两条边中图像的显示方法，<code>leftright</code>表示元素的左右两条边中的显示方法，显示方法中可以指定的值为<code>repeat</code>、<code>stretch</code>与<code>round</code>三种。</p><ul><li><p><code>repeat</code>：图像以平铺的方式进行显示</p></li><li><p><code>stretch</code>：图像以拉伸的方式进行显示</p></li><li><p><code>repeat+stretch</code>：将上下两条边中的图像的显示方式指定为平铺显示，左右两条边中的图像的显示方式指定为拉伸显示，或者上下两条边中的图像的显示方式指定为拉伸显示，左右两条边中的图像的显示方式指定为平铺显示。</p></li><li><p><code>round</code>：与<code>repeat</code>类似，都是将图像进行平铺显示，区别在于如果最后显示的衣服图像不能被完全显示，且能够现实的部分不到图像的一半，就不显示最后的图像，然后扩大前面的图像，使显示区域正好完整平铺全部图像；如果能够显示的部分超过图像的一半，就显示最后的图像，但是将全部显示的图像缩小，使显示区域正好完整平铺全部图像。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍CSS3中的背景和边框相关的一些样式，其中包括与背景相关的几个属性，如何在一个元素的背景中使用多个图像文件；如何绘制圆角边框；如何给元素添加图像边框。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="background样式" scheme="http://www.xiaoleon.cn/tags/background%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="border样式" scheme="http://www.xiaoleon.cn/tags/border%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(4) 盒相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-4/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-4/</id>
    <published>2018-01-22T13:44:04.000Z</published>
    <updated>2018-01-27T09:00:36.114Z</updated>
    
    <content type="html"><![CDATA[<p>在css中，使用<code>display</code>属性来定义盒的类型。总体上来说，css的盒分为<code>block</code>类型与<code>inline</code>类型。</p> <a id="more"></a><h3 id="一、inline-block"><a href="#一、inline-block" class="headerlink" title="一、inline-block"></a>一、inline-block</h3><p><code>inline-block</code>是在css2.1中追加的一个盒类型，属于<code>block</code>类型盒的一种，但是在显示时具有<code>inline</code>类型盒的特点。</p><p>默认情况下使用<code>inline-block</code>类型时并列显示的元素的垂直对齐方式是底部对其，为了将垂直对齐方式改为顶部对齐，还需要在<code>div</code>元素的样式中加入<code>vertical-align</code>属性。</p><hr><h3 id="二、inline-table"><a href="#二、inline-table" class="headerlink" title="二、inline-table"></a>二、inline-table</h3><p>由于<code>table</code>元素属于<code>block</code>类型，所以不能与其他文字处于同一行中，但是如果将<code>table</code>元素修改wei<code>inline-table</code>类型，就可以让表格与其他文字处于同一行中了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-table;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#00aaff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在样式中利用<code>vertical-align</code>属性显示指定表格与文字的对齐方式。</p><hr><h3 id="三、list-item"><a href="#三、list-item" class="headerlink" title="三、list-item"></a>三、list-item</h3><p>如果在<code>display</code>中将元素的类型设定为<code>list-item</code>类型，可以将多个元素作为列表来显示，同时在元素的开头加上列表的标记。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: list-item;</span><br><span class="line">    <span class="attribute">list-style-type</span>: circle;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、run-in、compact"><a href="#四、run-in、compact" class="headerlink" title="四、run-in、compact"></a>四、run-in、compact</h3><p>将元素指定为<code>run-in</code>类型或者<code>compact</code>类型的时候，如果元素后面还有block类型的元素，<code>run-in</code>类型的元素将被包含在<code>block</code>类型的元素内部，而<code>compact</code>类型的元素将被放置在<code>block</code>类型的元素左边。</p><hr><h3 id="五、超出盒容纳的内容"><a href="#五、超出盒容纳的内容" class="headerlink" title="五、超出盒容纳的内容"></a>五、超出盒容纳的内容</h3><p>如果在样式中指定了盒的宽度与高度，就有可能出现某些内容在盒中容纳不下的情况，可以使用<code>overflow</code>属性来指定如何显示这些内容。</p><ul><li><p>overflow: hidden</p><p>  超出容纳范围的文字被隐藏</p></li><li><p>overflow: scroll</p><p>  元素中出现固定的水平滚动条与垂直滚动条</p></li><li><p>overflow: auto</p><p>  文字超出div元素的容纳范围时，根据需要出现水平滚动条或垂直滚动条</p></li><li><p>overflow: visible</p><p>  显示效果与不使用overflow属性时一样</p></li><li><p>text-overflow</p><p>  当通过把<code>overflow</code>属性设定为<code>ellipsis</code>，将盒中容纳不下的内容隐藏起来时，如果使用<code>text-overflow</code>属性，可以在盒的末尾显示一个代表省略的符号<code>“...”</code>。但是，<code>text-overflow</code>属性只在当盒中的内容在水平方向上超出盒的容纳范围时有效。通过将<code>white-space</code>属性设定为<code>nowrap</code>，使得盒右端的内容不能换行显示。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="attribute">-webkit-text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="attribute">-o-text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="六、对盒使用阴影"><a href="#六、对盒使用阴影" class="headerlink" title="六、对盒使用阴影"></a>六、对盒使用阴影</h3><p>在css3中，可以使用<code>box-shadow</code>属性让盒在显示时产生阴影特效</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">length</span> <span class="selector-tag">length</span> <span class="selector-tag">length</span> <span class="selector-tag">color</span>;</span><br><span class="line">-webkit-box-shadow: length length length color; // safari</span><br><span class="line">-moz-box-shadow: length length length color; // firefox</span><br></pre></td></tr></table></figure><p>前面三个<code>length</code>分别指阴影离开文字的 <strong>横向距离</strong>、<strong>纵向距离</strong>、<strong>模糊半径</strong>，color指阴影的 <strong>颜色</strong></p><p><strong>对第一个文字或第一行使用阴影</strong></p><p>可以使用<code>first-letter</code>选择器或<code>first-line</code>选择器来只让第一个文字或第一行具有阴影效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:first-letter</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">22px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:first-line</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="七、盒的宽度和高度"><a href="#七、盒的宽度和高度" class="headerlink" title="七、盒的宽度和高度"></a>七、盒的宽度和高度</h3><p>在css3中，使用<code>box-sizing</code>属性来指定针对元素的宽度和高度的计算方法，是否包含元素内部的补白区域，以及边框的宽度和高度。</p><h4 id="1-content-box"><a href="#1-content-box" class="headerlink" title="1. content-box"></a>1. content-box</h4><p>元素的宽度和高度不包括内容补白区域，以及边框的宽度和高度</p><h4 id="2-border-box"><a href="#2-border-box" class="headerlink" title="2. border-box"></a>2. border-box</h4><p>元素的宽度和高度包括内部补白区域，以及边框的宽度和高度</p><h4 id="3-为什么要使用box-sizing属性"><a href="#3-为什么要使用box-sizing属性" class="headerlink" title="3. 为什么要使用box-sizing属性"></a>3. 为什么要使用box-sizing属性</h4><p>使用<code>box-sizing</code>属性的目的是控制元素的总宽度，如果不使用该属性，样式中默认使用的是<code>content-box</code>属性值，它只对内容的宽度做了一个指定，却没有对元素的总宽度进行指定。有些场合下利用<code>border-box</code>属性值会使得页面布局更加方便。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在css中，使用&lt;code&gt;display&lt;/code&gt;属性来定义盒的类型。总体上来说，css的盒分为&lt;code&gt;block&lt;/code&gt;类型与&lt;code&gt;inline&lt;/code&gt;类型。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="盒模型" scheme="http://www.xiaoleon.cn/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="box-sizing" scheme="http://www.xiaoleon.cn/tags/box-sizing/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(3) 文字与字体相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-3/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-3/</id>
    <published>2018-01-22T13:40:32.000Z</published>
    <updated>2018-01-27T09:00:27.251Z</updated>
    
    <content type="html"><![CDATA[<p>本章针对css3中与文字、字体相关的一些属性做详细介绍，其中包括<code>text-shadow</code>属性、<code>word-break</code>属性、<code>word-wrap</code>属性、<code>Web Font</code>和<code>@font-face</code>属性，以及<code>font-size-adjust</code>属性。</p><a id="more"></a><h3 id="一、文字添加阴影"><a href="#一、文字添加阴影" class="headerlink" title="一、文字添加阴影"></a>一、文字添加阴影</h3><p><code>text-shadow</code>属性用于给页面上的文字添加阴影效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text-shadow</span>: <span class="selector-tag">length</span> <span class="selector-tag">length</span> <span class="selector-tag">length</span> <span class="selector-tag">color</span></span><br></pre></td></tr></table></figure><p>其中，前三个<code>length</code>分别指阴影离开文字的 <strong>横方向距离</strong>、<strong>纵方向距离</strong>、<strong>模糊半径</strong>，color指阴影的 <strong>颜色</strong>。</p><p><strong>指定多个阴影</strong></p><p>可以使用<code>text-shadow</code>属性给文字指定多个阴影，并且针对每个阴影使用不同颜色，指定多个阴影时使用逗号将多个阴影进行分隔。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">5px</span> <span class="number">#f39800</span>,</span><br><span class="line">                <span class="number">40px</span> <span class="number">35px</span> <span class="number">5px</span> <span class="number">#fff100</span>,</span><br><span class="line">                <span class="number">70px</span> <span class="number">60px</span> <span class="number">5px</span> <span class="number">#c0ff00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、文本自动换行"><a href="#二、文本自动换行" class="headerlink" title="二、文本自动换行"></a>二、文本自动换行</h3><p>在css3中，使用<code>word-break</code>属性来让文字自动换行</p><p>浏览器显示文本的时候，会让文本在浏览器或div元素的右端自动实现换行。对于西方文字来说，浏览器会在半角空格或连字符的地方自动换行，而不会在单词的当中突然换行。对于中文来说，可以在任何一个中文字后面进行换行。如果中文当中含有西方文字，浏览器也会在半角空格或连字符的地方进行换行，而不会在单词中强制换行。</p><p>当中文当中含有标点符号的时候，浏览器总是不可能让标点符号位于一行文字的行首，通常将标点符号以及它前面的一个文字作为一个整体来统一换行。</p><h4 id="1-指定自动换行"><a href="#1-指定自动换行" class="headerlink" title="1. 指定自动换行"></a>1. 指定自动换行</h4><p>在css3中，可以使用<code>word-break</code>属性来自己决定自动换行的处理方法。通过<code>word-break</code>属性的指定，不仅仅可以让浏览器实现半角空格或连字符后面的换行，而且可以让浏览器实现任意位置的换行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">word-break</span>: keep-all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>换行规则</th></tr></thead><tbody><tr><td>normal</td><td>使用浏览器默认换行规则</td></tr><tr><td>keep-all</td><td>只能在半角空格或连字符处换行</td></tr><tr><td>break-all</td><td>允许在单词内换行</td></tr></tbody></table><h4 id="2-长单词与URL地址自动换行"><a href="#2-长单词与URL地址自动换行" class="headerlink" title="2. 长单词与URL地址自动换行"></a>2. 长单词与URL地址自动换行</h4><p>对于西方文字来说，浏览器在半角空格或连字符的地方进行换行。因此，浏览器不能给较长的单词自动换行。当浏览器窗口比较窄的时候，文字会超出浏览器的窗口，浏览器下部出现滚动条，让用户通过拖动滚动条的方法来查看没有在当前窗口显示的文字。</p><p>在css3中，使用<code>word-wrap</code>属性来实现长单词与url地址的自动换行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>word-wrap</code>属性可以使用的属性值为<code>normal</code>与<code>break-word</code>两个。使用<code>normal</code>属性值时浏览器保持默认处理，只在半角空格或连字符的地方进行换行。使用<code>break-word</code>时浏览器可以在长单词或url地址内部进行换行。</p><hr><h3 id="三、使用服务器端字体"><a href="#三、使用服务器端字体" class="headerlink" title="三、使用服务器端字体"></a>三、使用服务器端字体</h3><p>在css3之前，页面文字所使用的字体必须已经在客户端中被安装才能正常显示，在样式表中允许指定当前字体不能正常显示时使用的替代字体，但是如果这个替代字体在客户端中也没有被安装时，使用这个字体的文字就不能正常显示了。</p><p>在css3中，使用<code>@font-face</code>属性来利用服务器端字体</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: WebFont;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'font/Fontin_Sans_R_45b.otf'</span>) <span class="built_in">format</span>(<span class="string">'opentype'</span>);</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>font-family</code>属性值用<code>WebFont</code>来声明使用服务器端的字体。<code>src</code>属性值指定服务器端字体的字体文件所在的路径。</p><p>在针对元素使用这个服务器端字体的时候，还需要在元素样式中将<code>font-family</code>属性值指定为<code>WebFont</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: WebFont;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@font-face</code>属性不仅可以用于显示服务器端的字体，也可以用来显示客户端本地的字体。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">local</span>(<span class="string">'Arial'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@font-face</code>属性显示客户端本地字体的好处是可以让浏览器在对字体进行显示时首先在客户端本地寻找是否存在该字体，当客户端寻找不到时在可使用服务器端的字体。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: MyHelvetica;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">local</span>(<span class="string">'Helvetica Neue'</span>) <span class="built_in">url</span>(MgOpenModernaRegular.ttf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、修改字体种类而保持字体尺寸不变"><a href="#四、修改字体种类而保持字体尺寸不变" class="headerlink" title="四、修改字体种类而保持字体尺寸不变"></a>四、修改字体种类而保持字体尺寸不变</h3><p>如果改变了字体的种类，则页面中所有使用改字体的文字大小都可能发生变化，从而使得原来安排好的页面布局产生混乱。</p><p>因此，在css3中增加了<code>font-size-adjust</code>属性，可以在保持文字大小不发生变化的情况下改变字体的种类。</p><p><code>font-size-adjust</code>属性的使用方法很简单，但是它需要使用每个字体种类自带的一个<code>aspect</code>值（比例值）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Times New Roman;</span><br><span class="line">    <span class="attribute">font-size-adjust</span>: <span class="number">0.46</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>aspect</code>值可以用来在将字体修改为其他字体时保持字体大小基本不变，这个<code>aspect</code>值的计算方法为<code>x-height</code>值除以该字体的尺寸，<code>x-height</code>值是指使用这个字体书写出来的小写<code>x</code>的高度（像素为单位）。如果某个字体的尺寸为100px时，<code>x-height</code>值为58px，则该字体的<code>aspect</code>为0.58，因为字体的<code>x-height</code>值总是随着字体的尺寸一起改变的，所以字体的<code>aspect</code>值都是一个常数。</p><p><strong>常用的西方字体aspect值</strong></p><table><thead><tr><th>字体种类</th><th>aspect值</th></tr></thead><tbody><tr><td>Verdana</td><td>0.58</td></tr><tr><td>Comic Sans MS</td><td>0.54</td></tr><tr><td>Trebuchet MS</td><td>0.53</td></tr><tr><td>Georgia</td><td>0.5</td></tr><tr><td>Myriad Web</td><td>0.48</td></tr><tr><td>Minion Web</td><td>0.47</td></tr><tr><td>Times New Roman</td><td>0.46</td></tr><tr><td>Gill Sans</td><td>0.46</td></tr><tr><td>Bernhard Modern</td><td>0.4</td></tr><tr><td>Caflisch Script Web</td><td>0.37</td></tr><tr><td>Fjemish Script</td><td>0.28</td></tr></tbody></table><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章针对css3中与文字、字体相关的一些属性做详细介绍，其中包括&lt;code&gt;text-shadow&lt;/code&gt;属性、&lt;code&gt;word-break&lt;/code&gt;属性、&lt;code&gt;word-wrap&lt;/code&gt;属性、&lt;code&gt;Web Font&lt;/code&gt;和&lt;code&gt;@font-face&lt;/code&gt;属性，以及&lt;code&gt;font-size-adjust&lt;/code&gt;属性。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="文字样式" scheme="http://www.xiaoleon.cn/tags/%E6%96%87%E5%AD%97%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="服务器端字体" scheme="http://www.xiaoleon.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(2) 巧用Content</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-2/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-2/</id>
    <published>2018-01-22T13:36:53.000Z</published>
    <updated>2018-01-27T09:00:09.432Z</updated>
    
    <content type="html"><![CDATA[<p><code>content</code>是<code>before</code>与<code>after</code>伪元素中的属性值，用于在伪元素中展示相关内容，我们可以利用这个属性实现一些小功能。</p><a id="more"></a><h3 id="一、读取元素属性"><a href="#一、读取元素属性" class="headerlink" title="一、读取元素属性"></a>一、读取元素属性</h3><p>可以将<code>alt</code>属性的值作为图像的标题来显示，如果在<code>content</code>属性中通过<code>“attr(属性名)”</code>这种形式来指定<code>attr</code>属性值，可以将某个属性的属性值显示出来。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">attr</span>(alt);</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"sky.jpg"</span> <span class="attr">alt</span>=<span class="string">"蓝天白云"</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="二、插入项目编号"><a href="#二、插入项目编号" class="headerlink" title="二、插入项目编号"></a>二、插入项目编号</h3><p>可以使用<code>content</code>属性来插入项目编号，在<code>content</code>属性中使用<code>counter</code>属性来针对多个项目追加连续编号。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(mycounter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'Part '</span><span class="built_in">counter</span>(mycounter)<span class="string">': '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>before</code>选择器或<code>after</code>选择器的<code>content</code>属性，不仅可以追加数字编号，还可以追加字母编号或罗马数字编号</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(mycounter, upper-alpha)<span class="string">'. '</span>;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">42px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>list-style-type</code>属性来指定编号的种类，例如，指定大写字母编号时，使用<code>upper-alpha</code>属性，指定大写罗马字母时，使用<code>upper-roman</code>属性。</p><h4 id="1-编号嵌套"><a href="#1-编号嵌套" class="headerlink" title="1. 编号嵌套"></a>1. 编号嵌套</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(mycounter)<span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(subcounter)<span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: subcounter;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要对编号进行重置，则需要使用 <code>counter-reset</code> 属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: mycounter;</span><br><span class="line">    <span class="attribute">counter-reset</span>: subcounter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-大编号嵌套中编号"><a href="#2-大编号嵌套中编号" class="headerlink" title="2. 大编号嵌套中编号"></a>2. 大编号嵌套中编号</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(mycounter) <span class="string">'-'</span> <span class="built_in">counter</span>(subcounter) <span class="string">'. '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、添加嵌套文字符号"><a href="#三、添加嵌套文字符号" class="headerlink" title="三、添加嵌套文字符号"></a>三、添加嵌套文字符号</h3><p>可以使用<code>content</code>属性的<code>open-quote</code>属性值与<code>close-quote</code>属性值在字符串两边添加诸如括号、单引号、双引号之类的嵌套文字符号。</p><p>另外，在元素的样式中使用<code>quotes</code>属性来指定使用什么嵌套文字符号。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: open-quote;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: close-quote;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">quotes</span>: <span class="string">"("</span> <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;content&lt;/code&gt;是&lt;code&gt;before&lt;/code&gt;与&lt;code&gt;after&lt;/code&gt;伪元素中的属性值，用于在伪元素中展示相关内容，我们可以利用这个属性实现一些小功能。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Content应用" scheme="http://www.xiaoleon.cn/tags/Content%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(1) 选择器</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-1/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-1/</id>
    <published>2018-01-22T13:29:23.000Z</published>
    <updated>2018-01-27T08:59:56.781Z</updated>
    
    <content type="html"><![CDATA[<p>选择器是CSS3中的一个重要内容，使用它可以大幅度提高开发人员书写或修改样式表时的工作效率。</p><a id="more"></a><p>通常我们会在元素上定义<code>class</code>属性，然后根据元素的<code>class</code>属性在css文件中定义相关的样式。使用<code>class</code>属性有两个缺点：</p><ul><li><p><code>class</code>属性本身没有语义，它纯粹时用来为css样式服务的，属于多余属性。</p></li><li><p>使用<code>class</code>属性的话，并没有把样式与元素绑定起来，针对同一个<code>class</code>属性，文本框也可以使用，下拉框也可以使用，甚至按钮也可以使用，这样其实是非常混乱的，修改样式的时候也很不方便。</p></li></ul><p>所以在CSS3中，提倡使用选择器来将样式与元素直接绑定起来，这样的话，在样式表中什么样式与什么元素相匹配变得一目了然，修改起来也很方便。不仅如此，通过选择器，我们还可以实现各种复杂的指定，同时也能大量减少样式表的代码书写量，最终书写出来的样式表也会变得简洁明了。</p><h3 id="一、属性选择器"><a href="#一、属性选择器" class="headerlink" title="一、属性选择器"></a>一、属性选择器</h3><p>html中，我们可以通过各种各样的属性，给元素增加很多附加信息。例如通过<code>width</code>属性，我们可以指定<code>div</code>元素的宽度；通过<code>id</code>属性，我们可以将不同的<code>div</code>元素进行区分。</p><p>css3中，增加了如下所示三种属性选择器，使得属性选择器有了通配符的概念</p><ul><li><p>[att*=val]</p><p>  如果元素用<code>att</code>表示的属性之属性值包含用<code>val</code>指定的字符的话，则该元素使用这个样式。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[id*=section]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id="section1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="section1-1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="hs-section"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="hs-section-1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><p>[att^=val]</p><p>  如果元素用<code>att</code>表示的属性之属性值的开头字符为用<code>val</code>指定的字符的话，则该元素使用这个样式。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[id^=section]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id="section1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="section1-1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><p>[att$=val]</p><p>  如果元素用<code>att</code>表示的属性之属性值的结尾字符为用<code>val</code>指定的字符的话，则该元素使用这个样式。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[id$=section]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id="hssection"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="hs-section"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>使用示例</strong>: 根据<code>a</code>标签的<code>href</code>中不同的文件扩展符，使用不同的样式，在超链接地址的末尾添加不同的文字</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=\/]</span><span class="selector-pseudo">:after</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$=htm]</span><span class="selector-pseudo">:after</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$=html]</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'web网页'</span>;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=jpg]</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'jpg图片'</span>;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、伪类选择器"><a href="#二、伪类选择器" class="headerlink" title="二、伪类选择器"></a>二、伪类选择器</h3><p>所谓伪类选择器，是指并不是针对真正的元素使用的选择器，而针对CSS中已经定义号的伪元素使用的选择器。CSS中主要有四个伪元素选择器：</p><ul><li><p><code>first-line</code>伪元素选择器</p><p>  用于为某个元素中的第一行文字使用样式</p></li><li><p><code>first-letter</code>伪元素选择器</p><p>  用于为某个元素中的文字的首字母或第一个字使用样式</p></li><li><p><code>before</code>伪元素选择器</p><p>  用于在某个元素之前插入一些内容</p></li><li><p><code>after</code>伪元素选择器</p><p>  用于在某个元素之后插入一些内容</p></li></ul><hr><h3 id="三、root、not、empty、target"><a href="#三、root、not、empty、target" class="headerlink" title="三、root、not、empty、target"></a>三、root、not、empty、target</h3><h4 id="1-root选择器"><a href="#1-root选择器" class="headerlink" title="1. root选择器"></a>1. root选择器</h4><p><code>root</code>选择器将样式绑定到页面的根元素中。所谓根元素，是指位于文档树中最顶层结构的元素，在HTML页面中就是指包含着整个页面的<code>“&lt;html&gt;”</code>部分。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: limegreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-not"><a href="#2-not" class="headerlink" title="2. not"></a>2. not</h4><p>如果相对某个结构元素使用样式，但是想排除这个结构元素下面的子结构元素，让它不使用这个样式时，可以使用<code>not</code>选择器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> *<span class="selector-pseudo">:not(h1)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-empty"><a href="#3-empty" class="headerlink" title="3. empty"></a>3. empty</h4><p>使用<code>empty</code>选择器来指定当元素内容为空白时使用的样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:empty</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-target"><a href="#4-target" class="headerlink" title="4. target"></a>4. target</h4><p>使用<code>target</code>选择器来对页面中的某个<code>target</code>元素（该元素的<code>id</code>被当作页面中的超链接来使用）指定样式，该样式只在用户点击了页面中的超链接，并且跳转到<code>target</code>元素后起作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:target</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、first-child、last-child、nth-child、nth-last-child"><a href="#四、first-child、last-child、nth-child、nth-last-child" class="headerlink" title="四、first-child、last-child、nth-child、nth-last-child"></a>四、first-child、last-child、nth-child、nth-last-child</h3><p>利用这几个选择器，能够特殊针对父元素的第一个子元素、最后一个子元素、指定序号的子元素、甚至第偶数个、第奇数个子元素进行样式的指定。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(n)</span> &#123;</span><br><span class="line">    <span class="comment">/* css中的n从1开始计数 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(even)</span> &#123;</span><br><span class="line">    <span class="comment">/* 所有正数下来的第偶数个子元素 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(odd)</span> &#123;</span><br><span class="line">    <span class="comment">/* 所有正数下来的第奇数个子元素 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-last-child(odd)</span> &#123;</span><br><span class="line">    <span class="comment">/* 所有倒数上去的第奇数个子元素 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="五、nth-of-type、nth-last-of-type"><a href="#五、nth-of-type、nth-last-of-type" class="headerlink" title="五、nth-of-type、nth-last-of-type"></a>五、nth-of-type、nth-last-of-type</h3><p>在css3中，使用<code>nth-of-type</code>选择器与<code>nth-last-of-type</code>选择器可以避免父元素下不同类型子元素的序号选择问题。使用这两个选择器的时候，css3在计算子元素是第奇数个还是第偶数个的时候，就只针对同类型的子元素进行计算。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:nth-of-type(odd)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:nth-of-type(even)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="六、循环使用样式"><a href="#六、循环使用样式" class="headerlink" title="六、循环使用样式"></a>六、循环使用样式</h3><p>如果我们有100个列表项目，需要重复使用前四种样式的设置，可以采用循环指定的方式，只要在 <code>nth-child(n)</code> 语句中，把参数 <code>n</code> 改成可循环的 <code>an + b</code> 的形式就可以，<code>a</code> 表示每次循环中共包括几种样式， <code>b</code> 表示指定的样式在循环中的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(4n+1)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(4n+2)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: limegreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(4n+3)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(4n)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="七、only-child"><a href="#七、only-child" class="headerlink" title="七、only-child"></a>七、only-child</h3><p>如果采用如下琐事的方法结合运用<code>nth-child</code>选择器与<code>nth-last-child</code>选择器的话，可以指定当某个父元素中只有一个子元素时才使用的样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span><span class="selector-pseudo">:nth-last-child(1)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外也可以使用<code>only-child</code>选择器来替代上面的实现方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:only-child</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="八、UI元素状态伪类选择器"><a href="#八、UI元素状态伪类选择器" class="headerlink" title="八、UI元素状态伪类选择器"></a>八、UI元素状态伪类选择器</h3><p>在CSS3的选择器中，除了结构性伪类选择器外，还有一种UI元素状态伪类选择器。这些选择器的共同特征是：指定的样式只有当元素处于某种状态下时才起作用，在默认状态下不起作用。</p><p>在CSS3中，共有11种UI元素状态伪类选择器，分别是</p><p><code>E:hover  E:active  E:focus  E:enabled  E:disabled  E:read-only  E:read-write  E:checked  E:default  E:indeterminate  E::selection</code></p><h4 id="1-E-hover"><a href="#1-E-hover" class="headerlink" title="1. E:hover"></a>1. E:hover</h4><p>指定当鼠标指针移动到元素上面时元素所使用的样式</p><h4 id="2-E-active"><a href="#2-E-active" class="headerlink" title="2. E:active"></a>2. E:active</h4><p>指定元素被激活（鼠标在元素上按下还没有松开）时使用的样式</p><h4 id="3-E-focus"><a href="#3-E-focus" class="headerlink" title="3. E:focus"></a>3. E:focus</h4><p>指定元素获得光标焦点时使用的样式，主要是在文本框控件获得焦点并进行文字输入的时候使用</p><h4 id="4-E-enabled"><a href="#4-E-enabled" class="headerlink" title="4. E:enabled"></a>4. E:enabled</h4><p>指定当元素处于可用状态时的样式</p><h4 id="5-E-disabled"><a href="#5-E-disabled" class="headerlink" title="5. E:disabled"></a>5. E:disabled</h4><p>指定当元素处于不可用状态时的样式</p><h4 id="6-E-read-only"><a href="#6-E-read-only" class="headerlink" title="6. E:read-only"></a>6. E:read-only</h4><p>指定当元素处于只读状态时的样式</p><h4 id="7-E-read-write"><a href="#7-E-read-write" class="headerlink" title="7. E:read-write"></a>7. E:read-write</h4><p>指定当元素处于非只读状态时的样式</p><h4 id="8-E-checked"><a href="#8-E-checked" class="headerlink" title="8. E:checked"></a>8. E:checked</h4><p>指定当表单中的<code>radio</code>或<code>checkbox</code>处于选取状态时的样式，在firefox浏览器中，需要写成 <code>-moz-checked</code> 的形式</p><h4 id="9-E-default"><a href="#9-E-default" class="headerlink" title="9. E:default"></a>9. E:default</h4><p>指定当页面打开默认处于选取状态的单选框或复选框控件的样式</p><h4 id="10-E-indeterminate"><a href="#10-E-indeterminate" class="headerlink" title="10. E:indeterminate"></a>10. E:indeterminate</h4><p>指定当页面打开时，如果一组单选框中任何一个单选框都没有被设定为选取状态时整组单选框的样式，如果用户选取了对其中任何一个单选框，则该样式被取消指定</p><h4 id="11-E-selection"><a href="#11-E-selection" class="headerlink" title="11. E::selection"></a>11. E::selection</h4><p>指定当元素处于选中状态时的样式</p><hr><h3 id="九、通用兄弟元素选择器"><a href="#九、通用兄弟元素选择器" class="headerlink" title="九、通用兄弟元素选择器"></a>九、通用兄弟元素选择器</h3><p>通用兄弟元素选择器，用来指定位于同一个父元素之中的某个元素之后的所有其他某个种类的兄弟元素所使用的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;子元素&gt;~&lt;子元素之后的同级兄弟元素&gt; &#123;</span><br><span class="line">    // 指定样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;选择器是CSS3中的一个重要内容，使用它可以大幅度提高开发人员书写或修改样式表时的工作效率。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS选择器" scheme="http://www.xiaoleon.cn/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>H5(13) Geolocation</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/html5-13/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/html5-13/</id>
    <published>2018-01-22T13:23:54.000Z</published>
    <updated>2018-01-27T09:03:18.531Z</updated>
    
    <content type="html"><![CDATA[<p>在HTML5中，为<code>window.navigator</code>对象新增了一个<code>geolocation</code>属性，可以使用<code>Geolocation API</code>来对该属性进行访问。</p><a id="more"></a><h3 id="一、获取当前位置"><a href="#一、获取当前位置" class="headerlink" title="一、获取当前位置"></a>一、获取当前位置</h3><p>可以使用<code>getCurrentPosition</code>方法来取得用户当前的地理位置信息，该方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> getCurrentPosition(onSuccess, onError, options);</span><br></pre></td></tr></table></figure><p>第一个参数为获取当前地理位置信息成功时所执行的回调函数</p><p>第二个参数为获取当前地理位置信息失败时所执行的回调函数（可选）</p><p>第三个参数为一些可选属性的列表（可选）</p><p><code>onSuccess</code>回调函数中，用到了一个参数<code>position</code>，它代表一个<code>position</code>对象，我们在后面对这个对象进行介绍</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(<span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取成功时的处理</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>onError</code>回调函数中，用到了一个<code>error</code>对象，该对象具有以下两个属性：</p><ul><li><p><code>code</code>属性。<code>code</code>属性为以下三个值其中之一：</p><ul><li><p>用户拒绝了位置服务（数字值为1）</p></li><li><p>获取不到位置信息（数字值为2）</p></li><li><p>获取信息超时错误（数字值为3）</p></li></ul></li><li><p><code>message</code>属性。</p><p>  <code>message</code>属性为一个字符串，在该字符串中包含了错误信息。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> coords = position.coords;</span><br><span class="line">        showMap(coords.latitude, coords.longitude, coords.accuracy);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> errorTypes = &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="string">'位置服务被拒绝'</span>,</span><br><span class="line">            <span class="number">2</span>: <span class="string">'获取不到位置信息'</span>,</span><br><span class="line">            <span class="number">3</span>: <span class="string">'获取信息超时'</span></span><br><span class="line">        &#125;;</span><br><span class="line">        alert(errorTypes[error.code] + <span class="string">': 不能确定你的当前地理位置'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>options</code>是一些可选属性的列表，包含如下：</p><ul><li><p>enableHighAccuracy</p><p>  是否要求高精度的地理位置信息，这个参数在很多设备上设置了都没用，因为使用在设备上时要结合设备电量、具体地理情况来综合考虑</p></li><li><p>timeout</p><p>  对地理位置信息的获取操作做一个超时限制（单位为毫秒）。如果在改时间内未获取到地理位置信息，则返回错误</p></li><li><p>maximumAge</p><p>  对地理位置信息进行缓存的有效时间（单位为毫秒）。如果该值指定为0，则无条件重新获取新的地理位置信息</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        maximumAge: <span class="number">60</span> * <span class="number">1000</span> * <span class="number">2</span>,</span><br><span class="line">        timeout: <span class="number">5000</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h3 id="二、持续监视当前地理位置信息"><a href="#二、持续监视当前地理位置信息" class="headerlink" title="二、持续监视当前地理位置信息"></a>二、持续监视当前地理位置信息</h3><p>使用<code>watchPosition</code>方法来持续获取用户当前地理位置信息，它会定期地自动获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int watchCurrentPosition(onSuccess, onError, options);</span><br></pre></td></tr></table></figure><p>该方法与<code>getCurrentPosition</code>方法的参数说明与使用方法相同，该方法返回一个数字，这个数字的使用与<code>setInterval</code>的返回参数值类似，可以被<code>clearWatch</code>方法使用，停止对当前地理位置信息的监视。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> clearWatch(watchId)</span><br></pre></td></tr></table></figure><hr><h3 id="三、position对象"><a href="#三、position对象" class="headerlink" title="三、position对象"></a>三、position对象</h3><p>通过访问<code>position</code>对象，可以得到地理位置信息</p><ul><li><p>latitude</p><p>  当前地理位置的纬度</p></li><li><p>longitude</p><p>  当前地理位置的精度</p></li><li><p>altitude</p><p>  当前位置的海拔高度</p></li><li><p>accuracy</p><p>  获取到的纬度或经度的精度（单位为米）</p></li><li><p>altitudeAccurancy</p><p>  获取到的海拔高度的精度（单位为米）</p></li><li><p>heading</p><p>  设备的前进方向，以面朝正北方向的顺时针旋转角度来表示</p></li><li><p>speed</p><p>  设备的前进速度（单位为米/秒）</p></li><li><p>timestamp</p><p>  获取地理位置信息时的时间</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在HTML5中，为&lt;code&gt;window.navigator&lt;/code&gt;对象新增了一个&lt;code&gt;geolocation&lt;/code&gt;属性，可以使用&lt;code&gt;Geolocation API&lt;/code&gt;来对该属性进行访问。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5抄书笔记" scheme="http://www.xiaoleon.cn/categories/HTML5%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Geolocation" scheme="http://www.xiaoleon.cn/tags/Geolocation/"/>
    
  </entry>
  
  <entry>
    <title>H5(12) Web Workers</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/html5-12/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/html5-12/</id>
    <published>2018-01-22T13:19:17.000Z</published>
    <updated>2018-01-27T09:03:09.203Z</updated>
    
    <content type="html"><![CDATA[<p><code>Web Workers</code>是HTML5中新增的，用来在Web应用程序中实现后台处理的一项技术。</p><p>在使用HTML4与Javascript创建出来的Web程序中，因为所有的处理都是在单线程内执行的，所以如果花费的事件比较长的话，程序界面会处于长时间没有响应的状态。最恶劣的是，当时间长到一定程度的话，浏览器还会跳出一个提示脚本运行时间过长的提示框，使用户不得不中断正在执行的处理。</p><a id="more"></a><h3 id="一、Web-Worker介绍"><a href="#一、Web-Worker介绍" class="headerlink" title="一、Web Worker介绍"></a>一、Web Worker介绍</h3><p>为了解决这个问题，HTML5新增了一个<code>Web Workers API</code>。使用这个API，用户可以很容易地创建在后台运行的线程（在HTML5中被称为<code>worker</code>），如果将可能耗费较长时间的处理交给后台去执行的话，对用户在前台页面中执行的操作就完全没有影响了。</p><p>创建后台线程的步骤十分简单。只要在<code>Worker</code>类的构造器中，将需要在后台线程中执行的脚本文件的url地址作为参数，然后创建<code>Worker</code>对象就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>要注意在后台线程中是不能访问页面或窗口对象的。如果在后台线程的脚本文件中使用到<code>window</code>对象或<code>document</code>对象，则会引起错误的发生。</p></blockquote><p>另外，可以通过发送和接收消息来与后台线程互相传递数据。通过对<code>Worker</code>对象的<code>onmessage</code>事件句柄的获取可以在后台线程之中接收消息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理收到的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>Worker</code>对象的<code>postMessage</code>方法来对后台线程发送消息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(message);</span><br></pre></td></tr></table></figure><p>另外，同样可以通过获取<code>Worker</code>对象的<code>onmessage</code>事件句柄及<code>Worker</code>对象的<code>postMessage</code>方法在后台线程内部进行消息的接收和发送。</p><p>使用示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>从1到给定数值的求和示例<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    输入数值：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">id</span>=<span class="string">"num"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"calculate()"</span>&gt;</span>计算<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'calculate.js'</span>);</span></span><br><span class="line"><span class="javascript">        worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">`合计值：<span class="subst">$&#123;event.data&#125;</span>`</span>);</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="built_in">document</span>.getElementById(<span class="string">'num'</span>).value, <span class="number">10</span>);</span></span><br><span class="line"><span class="undefined">            worker.postMessage(num);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate.js</span></span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = event.data;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        result += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向线程创建源送回消息</span></span><br><span class="line">    postMessage(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、线程嵌套"><a href="#二、线程嵌套" class="headerlink" title="二、线程嵌套"></a>二、线程嵌套</h3><p>线程中可以嵌套子线程，这样的话我们可以把一个较大的后台线程切分成几个子线程，在每个子线程中各自完成相对独立的一部分工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker1.js</span></span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> intArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        intArray[i] = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> worker;</span><br><span class="line">    worker = <span class="keyword">new</span> Worker(<span class="string">'worker2.js'</span>);</span><br><span class="line">    worker.postMessage(<span class="built_in">JSON</span>.stringify(intArray));</span><br><span class="line">    worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        postMessage(event.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker2.js</span></span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> intArray = <span class="built_in">JSON</span>.parse(event.data);</span><br><span class="line">    <span class="keyword">var</span> returnStr = <span class="string">''</span>;</span><br><span class="line">    ...</span><br><span class="line">    postMessage(returnStr);</span><br><span class="line">    close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：在子线程中向发送源发送回消息后，最好使用<code>close</code>语句关闭子线程，如果该子线程不再使用的话。</p></blockquote><hr><h3 id="三、线程中可用的变量、函数与类"><a href="#三、线程中可用的变量、函数与类" class="headerlink" title="三、线程中可用的变量、函数与类"></a>三、线程中可用的变量、函数与类</h3><p>我们总体看一下在线程用的Javascript中所有可用的变量、函数与类</p><h4 id="1-self"><a href="#1-self" class="headerlink" title="1. self"></a>1. self</h4><p><code>self</code>关键词用来表示本线程范围内的作用域</p><h4 id="2-postMessage-message"><a href="#2-postMessage-message" class="headerlink" title="2. postMessage(message)"></a>2. postMessage(message)</h4><p>向创建线程的源窗口发送消息</p><h4 id="3-onmessage"><a href="#3-onmessage" class="headerlink" title="3. onmessage"></a>3. onmessage</h4><p>获取接收消息的事件句柄</p><h4 id="4-importScripts-urls"><a href="#4-importScripts-urls" class="headerlink" title="4. importScripts(urls)"></a>4. importScripts(urls)</h4><p>导入其他Javascript文件，参数为该文件的url地址，可以导入多个文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importScripts(<span class="string">'script1.js'</span>, <span class="string">'scripts\script2.js'</span>, <span class="string">'script\script3.js'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>导入的文件必须与使用该线程的文件的页面在同一个域中，并在同一个端口中</p></blockquote><h4 id="5-navigator对象"><a href="#5-navigator对象" class="headerlink" title="5. navigator对象"></a>5. navigator对象</h4><p>与<code>window.navigator</code>对象相似，具有<code>appName</code>、<code>platform</code>、<code>userAgent</code>、<code>appVersion</code>属性</p><h4 id="6-sessionStorage-localStorage"><a href="#6-sessionStorage-localStorage" class="headerlink" title="6. sessionStorage/localStorage"></a>6. sessionStorage/localStorage</h4><p>可以在线程中使用<code>Web Storage</code></p><h4 id="7-XMLHttpRequest"><a href="#7-XMLHttpRequest" class="headerlink" title="7. XMLHttpRequest"></a>7. XMLHttpRequest</h4><p>可以在线程中处理<code>Ajax</code>请求</p><h4 id="8-Web-Workers"><a href="#8-Web-Workers" class="headerlink" title="8. Web Workers"></a>8. Web Workers</h4><p>可以在线程中嵌套线程</p><h4 id="9-setTimeout-setInterval"><a href="#9-setTimeout-setInterval" class="headerlink" title="9. setTimeout()/setInterval()"></a>9. setTimeout()/setInterval()</h4><p>可以在线程中实现定时处理</p><h4 id="10-close"><a href="#10-close" class="headerlink" title="10. close"></a>10. close</h4><p>可以结束本线程</p><h4 id="11-eval-、isNaN-、escape-等"><a href="#11-eval-、isNaN-、escape-等" class="headerlink" title="11. eval()、isNaN()、escape()等"></a>11. eval()、isNaN()、escape()等</h4><p>可以使用所有的Javascript核心函数</p><h4 id="12-object"><a href="#12-object" class="headerlink" title="12. object"></a>12. object</h4><p>可以创建和使用本地对象</p><h4 id="13-WebSockets"><a href="#13-WebSockets" class="headerlink" title="13. WebSockets"></a>13. WebSockets</h4><p>可以使用<code>WebSockets API</code>来向服务器发送和接收消息</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Web Workers&lt;/code&gt;是HTML5中新增的，用来在Web应用程序中实现后台处理的一项技术。&lt;/p&gt;
&lt;p&gt;在使用HTML4与Javascript创建出来的Web程序中，因为所有的处理都是在单线程内执行的，所以如果花费的事件比较长的话，程序界面会处于长时间没有响应的状态。最恶劣的是，当时间长到一定程度的话，浏览器还会跳出一个提示脚本运行时间过长的提示框，使用户不得不中断正在执行的处理。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5抄书笔记" scheme="http://www.xiaoleon.cn/categories/HTML5%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Web Workers" scheme="http://www.xiaoleon.cn/tags/Web-Workers/"/>
    
  </entry>
  
  <entry>
    <title>H5(11) Web Sockets</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/html5-11/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/html5-11/</id>
    <published>2018-01-22T13:14:50.000Z</published>
    <updated>2018-01-27T09:03:02.027Z</updated>
    
    <content type="html"><![CDATA[<p><code>Web Sockets</code>是HTML5提供的在Web应用程序客户端与服务器端之间进行的非HTTP的通信机制。它实现了用HTTP不容易实现的服务器端的数据推送等智能通信技术，因此受到了高度关注。</p><p>使用<code>Web Sockets API</code>可以在服务器与客户端之间建立一个非HTTP的双向连接。这个连接时实时的，也是永久的，除非被显式关闭。这意味着当服务器想向客户端发送数据时，可以立即将数据推送到客户端的浏览器中，无须重新建立连接。只要客户端有一个被打开的<code>socket</code>（套接字）并且与服务器建立了连接，服务器就可以把数据推送到这个<code>socket</code>上，服务器不再需要轮训客户端的请求，从被动转为了主动。</p><a id="more"></a><p><code>Web Sockets</code>的API本身非常简单，将url字符串作为参数，然后调用<code>WebSocket</code>对象的构造器来建立与服务器之间的通信连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webSocket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost/socket'</span>);</span><br></pre></td></tr></table></figure><p>url字符串必须以<code>“ws”</code>或<code>“wss”</code>（加密通信时）文字作为开头。这个url字符串被设定好之后，在JS脚本中可以通过访问<code>WebSocket</code>对象的<code>url</code>属性来重新获取。</p><p>通信建立好之后，就可以进行客户端与服务器端的双向通信了。使用<code>WebSocket</code>对象的<code>send</code>方法对服务器发送数据，只能发送文本数据，但是可以使用JSON对象把任何Javascript对象转换成文本数据后进行发送</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webSocket.send(<span class="string">'data'</span>);</span><br></pre></td></tr></table></figure><p>通过获取<code>onmessage</code>事件的句柄来接收服务器传过来的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webSocket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.data;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过获取<code>onopen</code>事件句柄来监听<code>socket</code>的打开事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webSocket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 开始通信时的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过获取<code>onclose</code>事件句柄来监听<code>socket</code>的关闭事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webSocket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通信结束时的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>close</code>方法来关闭<code>socket</code>，切断通信连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webSocket.close();</span><br></pre></td></tr></table></figure><p>另外，可以通过读取<code>readyState</code>的属性值来获取<code>WebSocket</code>对象的状态，<code>readyState</code>属性存在以下几种值：</p><ul><li><p><code>CONNECTING</code>（数字值为0） —— 正在连接</p></li><li><p><code>OPEN</code>（数字值为1） —— 已建立连接</p></li><li><p><code>CLOSING</code>（数字值为2） —— 正在关闭连接</p></li><li><p><code>CLOSED</code>（数字值为3） —— 已关闭连接</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Web Sockets&lt;/code&gt;是HTML5提供的在Web应用程序客户端与服务器端之间进行的非HTTP的通信机制。它实现了用HTTP不容易实现的服务器端的数据推送等智能通信技术，因此受到了高度关注。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;Web Sockets API&lt;/code&gt;可以在服务器与客户端之间建立一个非HTTP的双向连接。这个连接时实时的，也是永久的，除非被显式关闭。这意味着当服务器想向客户端发送数据时，可以立即将数据推送到客户端的浏览器中，无须重新建立连接。只要客户端有一个被打开的&lt;code&gt;socket&lt;/code&gt;（套接字）并且与服务器建立了连接，服务器就可以把数据推送到这个&lt;code&gt;socket&lt;/code&gt;上，服务器不再需要轮训客户端的请求，从被动转为了主动。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5抄书笔记" scheme="http://www.xiaoleon.cn/categories/HTML5%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Web Sockets" scheme="http://www.xiaoleon.cn/tags/Web-Sockets/"/>
    
  </entry>
  
  <entry>
    <title>H5(10) 跨文档消息传输</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/html5-10/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/html5-10/</id>
    <published>2018-01-22T13:10:17.000Z</published>
    <updated>2018-01-27T09:02:50.852Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5提供了在网页文档之间相互接收与发送信息的功能。使用这个功能，只要获取到网页所在窗口对象的实例，不仅同源（域+端口号）的Web网页之间可以互相通信，甚至可以实现跨域通信。</p><a id="more"></a><p>首先，想要接受从其他的窗口那里发过来的消息，就必须对窗口对象的<code>message</code>事件进行监视，代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>使用<code>window</code>对象的<code>postMessage</code>方法向其他窗口发送消息，该方法的定义如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin);</span><br></pre></td></tr></table></figure><p>otherWindow为要发送窗口对象的引用，可以通过<code>window.open</code>返回该对象，或通过对<code>window.frames</code>数组指定序号或名字的方式来返回单个frame所属的窗口对象。</p><p>第一个参数为所发送的消息文本，或JSON转换后的文本。</p><p>第二个参数为接收消息的对象窗口的url地址。可以在url地址字符串中使用通配符<code>“*”</code>指定全部地址，不过建议使用准确的url地址。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.html  http://localhost:8100/html/parent.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        div &#123;</span></span><br><span class="line"><span class="undefined">            margin: 10px;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Parent Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line">            Message Content</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"postMessage()"</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Child Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:8111/html/child.html"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (ev.origin != <span class="string">'http://localhost:8111'</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'msg'</span>).innerHTML = <span class="string">`</span></span></span><br><span class="line"><span class="undefined">                从$&#123;ev.origin&#125;那里传过来的消息：$&#123;ev.data&#125;</span></span><br><span class="line"><span class="undefined">            `</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">postMessage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> msg = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).value;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> iframe = <span class="built_in">window</span>.frames[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">            iframe.postMessage(msg, <span class="string">'http://localhost:8111/html/child.html'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- child.html  http://localhost:8111/html/child.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        div &#123;</span></span><br><span class="line"><span class="undefined">            margin: 10px;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line">        Message Content</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"postMessage()"</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> source, origin;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (ev.origin != <span class="string">'http://localhost:8100'</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            source = ev.source;</span></span><br><span class="line"><span class="undefined">            origin = ev.origin;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'msg'</span>).innerHTML = <span class="string">`</span></span></span><br><span class="line"><span class="undefined">                从$&#123;ev.origin&#125;那里来的消息：$&#123;ev.data&#125;</span></span><br><span class="line"><span class="undefined">            `;</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">postMessage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> msg = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).value;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (source &amp;&amp; origin) &#123;</span></span><br><span class="line"><span class="undefined">                source.postMessage(msg, origin);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>本示例中的几个关键之处：</p><ol><li><p>通过对<code>window</code>对象的<code>message</code>事件进行监听，可以接收消息。</p></li><li><p>通过访问<code>message</code>事件的<code>origin</code>属性，可以获取消息的发送源。</p><blockquote><p>发送源与网站的url地址不是同一概念，发送源只包含域名和端口号，为了不接收从其他源恶意发送过来的消息，最好对发送源做个检查。</p></blockquote></li><li><p>通过访问<code>message</code>事件的<code>data</code>属性，可以获取消息内容</p></li><li><p>使用<code>postMessage</code>方法发送消息</p></li><li><p>通过访问<code>message</code>事件的<code>source</code>属性，可以获取消息发送源的窗口对象（准确的说，应该时窗口的代理对象）</p></li></ol><p>通过这种方式，可以实现网页文档与网页文档之间、端口与端口之间、域与域之间互相传递消息。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML5提供了在网页文档之间相互接收与发送信息的功能。使用这个功能，只要获取到网页所在窗口对象的实例，不仅同源（域+端口号）的Web网页之间可以互相通信，甚至可以实现跨域通信。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5抄书笔记" scheme="http://www.xiaoleon.cn/categories/HTML5%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="文档通信" scheme="http://www.xiaoleon.cn/tags/%E6%96%87%E6%A1%A3%E9%80%9A%E4%BF%A1/"/>
    
      <category term="跨域通信" scheme="http://www.xiaoleon.cn/tags/%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>H5(9) 离线Web应用程序</title>
    <link href="http://www.xiaoleon.cn/2018/01/21/html5-9/"/>
    <id>http://www.xiaoleon.cn/2018/01/21/html5-9/</id>
    <published>2018-01-21T14:00:12.000Z</published>
    <updated>2018-01-27T09:02:44.315Z</updated>
    
    <content type="html"><![CDATA[<p>Web应用程序已经变得越来越复杂，越来越成熟了，很多领域都在利用着Web应用程序。但是，它有一个致命的缺点：如果用户没有和Internet建立连接，他就不能利用这个Web应用程序了。</p><a id="more"></a><p>因此，HTML5中新增了一个API，它使用一个本地缓存机制很好地解决了这个问题，为离线Web应用程序的开发提供了可能性。</p><p>为了让Web应用程序在离线状态时候也能正常工作，就必须要把所有构成Web应用程序的资源文件，诸如HTML文件、CSS文件、Javascript脚本文件等放在本地缓存中，当服务器没有和Internet建立连接的时候，也可以利用本地缓存中的资源文件来正常运行Web应用程序。</p><h3 id="一、本地缓存与浏览器网页缓存的区别"><a href="#一、本地缓存与浏览器网页缓存的区别" class="headerlink" title="一、本地缓存与浏览器网页缓存的区别"></a>一、本地缓存与浏览器网页缓存的区别</h3><p>本地缓存是为整个Web应用程序服务的，而浏览器的网页缓存只服务于单个网页。任何网页都具有网页缓存，而本地缓存只缓存那些你指定缓存的网页。</p><p>网页缓存是不安全、不可靠的，因为我们不知道在网站中到底缓存了哪些网页，以及缓存了网页上的哪些资源。而本地缓存是可靠的，我们可以控制对哪些内容进行缓存，不对哪些内容进行缓存，开发人员还可以用编程的手段来控制缓存的更新，利用缓存对象的各种属性、状态和事件来开发出更为强大的离线应用程序。</p><hr><h3 id="二、manifest文件"><a href="#二、manifest文件" class="headerlink" title="二、manifest文件"></a>二、manifest文件</h3><p>Web应用程序的本地缓存是通过每个页面的<code>manifest</code>文件来管理的。<code>manifest</code>文件是一个简单文本文件，在该文件中以清单的形式列举了需要被缓存或不需要被缓存的资源文件的文件名称，以及这些资源文件的访问路径。</p><p>可以为每一个页面单独指定一个<code>manifest</code>文件，也可以对整个Web应用程序指定一个总的<code>manifest</code>文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#version 7</span><br><span class="line">CACHE:</span><br><span class="line">other.html</span><br><span class="line">hello.js</span><br><span class="line">images/myphoto.jpg</span><br><span class="line">NETWORK:</span><br><span class="line">http://lulingniu/NotOffline</span><br><span class="line">NotOffline.asp</span><br><span class="line">*</span><br><span class="line">FALLBACK:</span><br><span class="line">online.js locale.js</span><br><span class="line">CACHE:</span><br><span class="line">newhello.html</span><br><span class="line">newhello.js</span><br></pre></td></tr></table></figure><p>在manifest文件中，第一行必须是“<code>CACHE MANIFEST</code>”文字，以把本文件的作用告知给浏览器，即对本地缓存中的资源文件进行具体设置。同时，真正运行或测试离线Web应用程序的时候，需要对服务器进行配置，让服务器支持<code>text/cache-manifest</code>这个MIME类型。</p><p>例如对Apache服务器进行配置的时候，需要找到<code>{apache_home}/conf/mime.types</code>这个文件，并在文件最后添加代码<code>text/cache-manifest   manifest</code></p><p>在指定资源文件的时候，可以把资源文件分为三类，分别是<code>CACHE</code>、<code>NETWORK</code>、<code>FALLBACK</code>：</p><ul><li><p><code>CACHE</code>类别中指定需要被缓存在本地的资源文件。为某个页面指定需要本地缓存的资源文件时，不需要把这个页面本身指定在<code>CACHE</code>类别中，因为如果一个页面具有<code>manifest</code>文件，浏览器会自动对这个页面进行本地缓存</p></li><li><p><code>NETWORK</code>类别为显式指定不进行本地缓存的资源文件，这些资源文件只有当客户端与服务器端建立连接的时候才能访问。本示例中该类别的<code>“*”</code>为通配符，表示没有在本<code>manifest</code>文件中指定的资源文件都不进行本地缓存</p></li><li><p><code>FALLBACK</code>类别中的每行中指定两个资源文件，第一个资源文件为能够在线访问时使用的资源文件，第二个资源文件为不能在线访问时使用的备用资源文件。</p></li></ul><p>每个类别都是可选的，但是如果文件开头没有指定类别而直接书写资源文件时，浏览器把这些资源文件视为<code>CACHE</code>类别，直到看见文件中第一个被书写出来的类别为止。</p><p>为了让浏览器能够正常阅读该文本文件，需要在Web应用程序页面上的html标签的<code>manifest</code>属性中指定<code>manifest</code>文件的url地址。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可以为每个页面单独指定一个manifest文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"hello.manifest"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 也可以为整个Web应用程序指定一个总的manifest文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"global.manifest"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过这些步骤，将资源文件保存到本地缓存去的基本操作就完成了。当需要对本地缓存去的内容进行修改时，只需要修改<code>manifest</code>文件就可以了。文件被修改后，浏览器可以自动检查<code>manifest</code>文件，并自动更新本地缓存区的内容。</p><hr><h3 id="三、浏览器与服务器的交互过程"><a href="#三、浏览器与服务器的交互过程" class="headerlink" title="三、浏览器与服务器的交互过程"></a>三、浏览器与服务器的交互过程</h3><p>当使用离线Web应用程序进行工作的时候，有必要理解一下浏览器与服务器的交互过程。</p><p>例如一个<code>http://lulingniu</code>网站，以<code>index.html</code>为主页，<code>index.manifest</code>文件为<code>manifest</code>文件，在该文件中请求本地缓存<code>index.html</code>、<code>hello.js</code>、<code>hello1.jpg</code>、<code>hello2.jpg</code>这几个资源文件。</p><p><strong>交互过程</strong>：</p><h4 id="1-首次访问"><a href="#1-首次访问" class="headerlink" title="1. 首次访问"></a>1. 首次访问</h4><ul><li><p>1) 浏览器请求访问<code>http://lulingniu</code></p></li><li><p>2) 服务器返回<code>index.html</code>网页</p></li><li><p>3) 浏览器解析<code>index.html</code>网页，请求页面上所有资源文件，包括HTML文件、图像文件、CSS文件、JS文件，以及<code>manifest</code>文件</p></li><li><p>4) 服务器返回所有资源文件</p></li><li><p>5) 浏览器处理<code>manifest</code>文件，请求<code>manifest</code>中所有要求本地缓存的文件，包括<code>index.html</code>。如果要求本地缓存所有文件，这将是一个比较大的重复的请求过程</p></li><li><p>6) 服务器返回所有要求本地缓存的文件</p></li><li><p>7) 浏览器对本地缓存进行更新，存入包括页面本身在内的所有要求本地缓存的资源文件，并且触发一个事件，通知本地缓存被更新</p></li></ul><h4 id="2-再次访问（manifest文件未更新）"><a href="#2-再次访问（manifest文件未更新）" class="headerlink" title="2. 再次访问（manifest文件未更新）"></a>2. 再次访问（manifest文件未更新）</h4><ul><li><p>1) 浏览器再次请求访问<code>http://lulingniu</code></p></li><li><p>2) 浏览器发现这个页面被本地缓存，于是使用本地缓存中的<code>index.html</code>页面</p></li><li><p>3) 浏览器解析<code>index.html</code>页面，使用所有本地缓存中的资源文件</p></li><li><p>4) 浏览器向服务器请求<code>manifest</code>文件</p></li><li><p>5) 服务器返回一个304代码，通知浏览器<code>manifest</code>没有发生变化</p></li></ul><h4 id="3-再次访问（manifest文件已更新）"><a href="#3-再次访问（manifest文件已更新）" class="headerlink" title="3. 再次访问（manifest文件已更新）"></a>3. 再次访问（manifest文件已更新）</h4><ul><li><p>1) 浏览器再次请求访问<code>http://lulingniu</code></p></li><li><p>2) 浏览器发现这个页面被本地缓存，于是使用本地缓存中的<code>index.html</code>页面</p></li><li><p>3) 浏览器解析<code>index.html</code>页面，使用所有本地缓存中的资源文件</p></li><li><p>4) 浏览器向服务器请求<code>manifest</code>文件</p></li><li><p>5) 服务器返回更新过的<code>manifest</code>文件</p></li><li><p>6) 浏览器处理<code>manifest</code>文件，发现该文件已被更新，于是请求所有要求进行本地缓存的资源文件，包括<code>index.html</code>页面本身</p></li><li><p>7) 浏览器返回要求进行本地缓存的资源文件</p></li><li><p>8) 浏览器对本地缓存进行更新，存入所有新的资源文件。并且触发一个事件，通知本地缓存被更新。</p></li></ul><p>需要注意的时，即使资源文件被修改过了，上面的第3步中已装入的资源文件是不会发生变化的，譬如图片不会突然变成新的图片，脚本文件也不会突然使用新的脚本文件，也就是说，这时更新的本地缓存中的内容还不能被使用，只有重新打开这个页面的时候才会使用更新过后的资源文件。</p><p>另外，如果不想修改<code>manifest</code>文件中对于资源文件的设置，但是对服务器上请求缓存的资源文件进行了修改，那么可以通过修改版本号的方式让浏览器认为<code>manifest</code>文件已经被更新过了，以便重新下载修改过的资源文件。</p><hr><h3 id="四、applicationCache对象"><a href="#四、applicationCache对象" class="headerlink" title="四、applicationCache对象"></a>四、applicationCache对象</h3><p><code>applicationCache</code>对象代表了本地缓存，可以用它来通知本地缓存中已经被更新，也允许用户手工更新本地缓存。</p><p>当浏览器对本地缓存进行更新，装入新的资源文件时，会触发<code>applicationCache</code>对象的<code>updateready</code>事件，通知本地缓存已被更新。我们可以利用这个事件告诉用户本地缓存已经被更新，用户需要手工刷新页面来得到最新版本的应用程序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">applicationCache.onUpdateReady = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 本地缓存已被更新，通知用户</span></span><br><span class="line">    alert(<span class="string">'本地缓存已被更新，您可以刷新页面来得到本程序的最新版本。'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-swapCache方法"><a href="#1-swapCache方法" class="headerlink" title="1. swapCache方法"></a>1. swapCache方法</h4><p><code>swapCache</code>方法用来手工执行本地缓存的更新，它只能在<code>applicationCache</code>对象的<code>updateReady</code>事件被触发时调用，<code>updateReady</code>事件只有在服务器的<code>manifest</code>文件被更新，并且把<code>manifest</code>文件中所要求的资源文件下载到本地后触发。顾名思义，这个事件的含义是“本地缓存准备被更新”。</p><p>当这个事件被触发后，我们可以用<code>swapCache</code>方法来手工进行本地缓存的更新。</p><p>例如，如果本地缓存的容量非常大（譬如超过100M），本地缓存的更新工作将需要相对较长的时间，而且还会把浏览器给锁住。这时最好有一个提示，告诉用户正在进行本地缓存的更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">applicationCache.onUpdateReady = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 本地缓存已被更新，通知用户</span></span><br><span class="line">    alert(<span class="string">'正在更新本地缓存...'</span>);</span><br><span class="line">    applicationCache.swapCache();</span><br><span class="line">    alert(<span class="string">'本地缓存已被更新，您可以刷新页面来得到本程序的最新版本。'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如果我们不调用<code>swapCache</code>方法会怎么样？本地缓存就不会被更新了吗？答案时否定的，但是更新的时间不一样。如果不调用<code>swapCache</code>方法，本地缓存将在下一次打开本页面时被更新；如果调用<code>swapCache</code>方法的话，本地缓存将会立刻更新。因此，我们可以使用<code>confirm</code>方法让用户自己选择更新的时机——是立刻更新，还是在下次打开画面时再更新，特别是当他们有可能正在页面上执行一个较大的操作的时候。</p><p>另外，尽管使用<code>swapCache</code>方法立刻更新了本地缓存，但是并不意味着我们页面上的图像和脚本文件也会立刻更新，它们都是在重新打开本页面时才会生效。</p><h4 id="2-update方法"><a href="#2-update方法" class="headerlink" title="2. update方法"></a>2. update方法</h4><p><code>applicationCache</code>的<code>update</code>方法，作用是检查服务器上的<code>manifest</code>文件是否有更新，如果有更新，浏览器会自动下载<code>manifest</code>文件中所有请求本地缓存的资源文件，当这些资源文件下载完毕时，会触发<code>updateReady</code>事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!doctype HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"swapCache.manifest"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">'utf-8'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>swapCache方法实例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>swapCache方法示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 手工检查manifest是否有更新</span></span><br><span class="line">        applicationCache.update();</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    applicationCache.addEventListener(<span class="string">'updateready'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (confirm(<span class="string">'本地缓存已被更新，需要刷新画面来获取应用程序最新版本，是否刷新？'</span>)) &#123;</span><br><span class="line">            applicationCache.swapCache();</span><br><span class="line">            location.reload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># swapCache.manifest</span><br><span class="line"></span><br><span class="line">CACHE MANIFEST</span><br><span class="line">#version 1.20</span><br><span class="line">CACHE:</span><br><span class="line">script.js</span><br></pre></td></tr></table></figure><hr><h3 id="五、applicationCache对象的事件"><a href="#五、applicationCache对象的事件" class="headerlink" title="五、applicationCache对象的事件"></a>五、applicationCache对象的事件</h3><h4 id="1-首次访问-1"><a href="#1-首次访问-1" class="headerlink" title="1. 首次访问"></a>1. 首次访问</h4><ul><li><p>1) 浏览器请求访问<code>http://lilingniu</code></p></li><li><p>2) 服务器返回<code>index.html</code>网页</p></li><li><p>3) 浏览器发现该网页具有<code>manifest</code>属性，触发<code>checking</code>事件，检查<code>manifest</code>文件是否存在。不存在时，触发<code>error</code>事件，表示<code>manifest</code>文件未找到，不执行步骤6开始的交互过程</p></li><li><p>4) 浏览器解析<code>index.html</code>网页，请求页面上的所有资源文件</p></li><li><p>5) 服务器返回所有资源文件</p></li><li><p>6) 浏览器处理<code>manifest</code>文件，请求<code>manifest</code>中所有要求本地缓存的文件，包括<code>index.html</code>页面本身，即使刚才已经请求过该文件。如果要求本地缓存所有文件，这将是一个比较大的重复的请求过程</p></li><li><p>7) 服务器返回所有要求本地缓存的文件</p></li><li><p>8) 浏览器触发<code>downloading</code>事件，然后开始下载这些资源。在下载的同时，周期性地触发<code>progress</code>事件，开发人员可以用编程的手段获取多少文件已被下载，多少文件仍然处于下载队列等信息</p></li><li><p>9) 下载结束后触发<code>cached</code>事件，表示首次缓存成功，存入所有要求本地缓存的资源文件</p></li></ul><h4 id="2-再次访问"><a href="#2-再次访问" class="headerlink" title="2. 再次访问"></a>2. 再次访问</h4><ul><li><p>1) 步骤1-5同上，步骤5执行完之后，浏览器将核对<code>manifest</code>文件是否被更新。</p></li><li><p>2) 若没有被更新，触发<code>noupdate</code>事件，步骤6开始的交互过程不会被执行。</p></li><li><p>3) 若发生了更新，将继续执行后面的步骤，在步骤9中不触发<code>cached</code>事件，而是触发<code>updateready</code>事件，这表示下载结束，可以通过刷新页面来使用更新后的本地缓存，或调用<code>swapCache</code>方法来立刻使用更新后的本地缓存。</p></li><li><p>4) 另外，在访问缓存名单时如果返回一个HTTP 404错误，或者410错误，则触发<code>obsolete</code>事件。</p></li><li><p>5) 在整个过程中，如果任何与本地缓存有关的处理中发生错误的话，都会触发<code>error</code>事件。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#version 1.0</span><br><span class="line">CACHE:</span><br><span class="line">index.html</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">manifest</span>=<span class="string">"applicationCacheEvent.manifest"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> msg = <span class="built_in">document</span>.getElementById(<span class="string">'msg'</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'checking'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'checking &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'noupdate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'noupdate &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'downloading'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'downloading &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'progress'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'progress &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'updateready'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'updateready &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'cached'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'cached &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'error &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>applicationCache事件流程示例<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web应用程序已经变得越来越复杂，越来越成熟了，很多领域都在利用着Web应用程序。但是，它有一个致命的缺点：如果用户没有和Internet建立连接，他就不能利用这个Web应用程序了。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5抄书笔记" scheme="http://www.xiaoleon.cn/categories/HTML5%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="本地缓存" scheme="http://www.xiaoleon.cn/tags/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/"/>
    
      <category term="离线Web应用程序" scheme="http://www.xiaoleon.cn/tags/%E7%A6%BB%E7%BA%BFWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>H5(8) Web Storage与本地数据库</title>
    <link href="http://www.xiaoleon.cn/2018/01/21/html5-8/"/>
    <id>http://www.xiaoleon.cn/2018/01/21/html5-8/</id>
    <published>2018-01-21T13:53:48.000Z</published>
    <updated>2018-01-27T09:02:36.787Z</updated>
    
    <content type="html"><![CDATA[<p><code>Web Storage</code>存储机制是对HTML4中<code>cookies</code>存储机制的一个改善。由于<code>cookies</code>存储机制有很多缺点，HTML5中不再使用它，转而使用改良后的<code>Web Storage</code>存储机制。</p><p>本地数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库——原本需要保存在服务器端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访问数据的速度。</p><a id="more"></a><h3 id="一、Web-Storage"><a href="#一、Web-Storage" class="headerlink" title="一、Web Storage"></a>一、Web Storage</h3><p><code>Cookies</code>存储永久数据存在以下几个问题：</p><ul><li><p>大小：<code>cookies</code>的大小被限制在4KB</p></li><li><p>带宽：<code>cookies</code>是随HTTP事务一起被发送的，因此会浪费一部分发送<code>cookies</code>时使用的带宽</p></li><li><p>复杂性：要正确的操纵<code>cookies</code>是很困难的</p></li></ul><p><code>Web Storage</code>，顾名思义，就是在Web上存储数据的功能，这里的存储是针对客户端本地而言的，具体来说，又分为两种</p><ul><li><p>sessionStorage</p><p>  将数据保存在<code>session</code>对象中。所谓<code>session</code>，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。<code>session</code>对象可以用来保存在这段时间内所要求保存的任何数据</p></li><li><p>localStorage</p><p>  将数据保存在客户端本地的硬件设备中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用</p></li></ul><p>两者区别在于，<code>sessionStorage</code>为临时保存，而<code>localStorage</code>为永久保存。</p><p>读写数据时使用的基本方法：</p><ul><li><p>sessionStorage</p><p>  保存数据：<code>sessionStorage.setItem(key, value)</code></p><p>  读取数据：<code>var value = sessionStorage.getItem(key)</code></p></li><li><p>localStorage</p><p>  保存数据：<code>localStorage.setItem(key, value)</code></p><p>  读取数据：<code>var value = localStorage.getItem(key)</code></p></li></ul><hr><h3 id="二、本地数据库"><a href="#二、本地数据库" class="headerlink" title="二、本地数据库"></a>二、本地数据库</h3><p>HTML5中可以通过sql语句来访问本地的sqlite数据库，有两个必要的步骤</p><ol><li><p>创建访问数据库的对象</p></li><li><p>使用事务处理</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = openDatabase(<span class="string">'mydb'</span>, <span class="string">'1.0'</span>, <span class="string">'Test DB'</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>方法中的四个参数，第一个为数据库名，第二个为版本号，第三个为数据库的描述，第四个为数据库的大小。该方法返回创建后的数据库访问对象，如果该数据库不存在，则创建该数据库。</p><p>实际访问数据库的时候，还需要调用<code>transaction</code>方法，来执行事务处理。使用事务处理，可以防止在对数据库进行访问及执行有关操作的时候受到外界的打扰，因为在web上，同时会有许多人都在对页面进行访问。如果在访问数据库的过程中，正在操作的数据被别的用户给修改掉的话，会引起很多意想不到的后果。因此，可以使用事务来达到在操作完了之前，阻止别的用户访问数据库的目的。</p><p>transaction方法的使用如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.transaction(<span class="function"><span class="keyword">function</span>(<span class="params">tx</span>) </span>&#123;</span><br><span class="line">    tx.executeSql(<span class="string">'create table if not exists logs (id unique, Log)'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>transaction</code>方法使用一个回调函数为参数。在这个函数中，执行访问数据库的语句。</p><p><code>executeSql</code>方法的完整定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction.executeSql(sqlquery, [], dataHandler, errorHandler);</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数为需要执行的SQL语句</p></li><li><p>第二个参数为SQL语句中所有使用到的参数的数组</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction.executeSql(<span class="string">'update people set age=? where name=?;'</span>, [age, name]);</span><br></pre></td></tr></table></figure><ul><li>第三个参数为执行SQL语句成功时调用的回调函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataHandler</span>(<span class="params">transaction, results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行SQL语句成功后的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第四个参数为执行SQL语句出错时调用的回调函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span>(<span class="params">transaction, errmsg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行SQL语句出错时的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Web Storage&lt;/code&gt;存储机制是对HTML4中&lt;code&gt;cookies&lt;/code&gt;存储机制的一个改善。由于&lt;code&gt;cookies&lt;/code&gt;存储机制有很多缺点，HTML5中不再使用它，转而使用改良后的&lt;code&gt;Web Storage&lt;/code&gt;存储机制。&lt;/p&gt;
&lt;p&gt;本地数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库——原本需要保存在服务器端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访问数据的速度。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5抄书笔记" scheme="http://www.xiaoleon.cn/categories/HTML5%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Web Storage" scheme="http://www.xiaoleon.cn/tags/Web-Storage/"/>
    
      <category term="本地数据库" scheme="http://www.xiaoleon.cn/tags/%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
