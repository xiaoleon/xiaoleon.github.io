<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张啸</title>
  
  <subtitle>世界上最快乐的事，莫过于为理想而奋斗。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaoleon.cn/"/>
  <updated>2018-01-28T15:07:19.438Z</updated>
  <id>http://www.xiaoleon.cn/</id>
  
  <author>
    <name>Leon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS(4) 函数</title>
    <link href="http://www.xiaoleon.cn/2018/01/28/js-4/"/>
    <id>http://www.xiaoleon.cn/2018/01/28/js-4/</id>
    <published>2018-01-28T02:26:20.000Z</published>
    <updated>2018-01-28T15:07:19.438Z</updated>
    
    <content type="html"><![CDATA[<p>函数是这样的一段JavaScript代码，它只定义一次，但可能被执行或调用任意次。JavaScript函数是参数化的：函数的定义会包括一个称为形参（<code>parameter</code>）的标识符列表，这些参数在函数体中像局部变量一样工作。函数调用会为形参提供实参的值。函数使用它们实参的值来计算返回值，称为该函数调用表达式的值。除了实参之外，每次调用还会拥有另外一个值——本次调用的上下文——就是<code>this</code>关键字的值。</p><a id="more"></a><p>如果函数挂载在一个对象上，作为对象的一个属性，就称他为对象的方法。当通过这个对象来调用函数时，该对象就是此次调用的上下文（<code>context</code>），也就是该函数的<code>this</code>的值。</p><p>在JavaScript里，函数即对象，程序可以随意操控它们。比如，JavaScript可以把函数赋值给变量，或者作为参数传递给其他函数。因为函数就是对象，所以可以给它们设置属性，甚至调用它们的方法。</p><p>JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。这意味着JavaScript函数构成了一个闭包（<code>closure</code>），它给JavaScript带来了非常强劲的编程能力。</p><h3 id="一、函数定义"><a href="#一、函数定义" class="headerlink" title="一、函数定义"></a>一、函数定义</h3><p>函数使用<code>function</code>关键字来定义，它可以用在函数定义表达式或者函数声明语句离。在两种形式中，函数定义都从<code>function</code>关键字开始，其后跟随这些组成部分：</p><ul><li><p>函数名称标识符</p><p>函数名称是函数声明语句必须的部分。它的用途就像变量的名字，新定义的函数对象会赋值给这个变量。对函数定义表达式来说，这个名字是可选的：如果存在，改名字只存在于函数体中，并指代该函数对象本身。</p></li><li><p>一对圆括号</p><p>其中包含由0个或者多个用逗号隔开的标识符组成的列表。这些标识符是函数的参数名称，它们就像函数体中的局部变量一样。</p></li><li><p>一对花括号</p><p>其中包含0条或多条JavaScript语句。这些语句构成了函数体：一旦调用函数，就会执行这些语句。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printprops</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(p + <span class="string">': '</span> + o[p] + <span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">x1, y1, x2, y2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dx = x2 - x1;</span><br><span class="line">    <span class="keyword">var</span> dy = y2 - y1;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：以表达式方式定义的函数，函数的名称是可选的。一条函数声明语句实际上声明了一个变量，并把一个函数对象赋值给它。相对而言，定义函数表达式时并没有声明一个变量。如果一个函数定义表达式包含名称，函数的局部作用域会包含一个绑定到函数对象的名称。实际上，函数的名称将会成为函数内部的一个局部变量。</p></blockquote><p><strong>函数命名</strong></p><p>任何合法的JavaScript标识符都可以用作一个函数的名称。命名时要尽量选择描述性强而又简洁的函数名。通常函数名的第一个字符为小写，这是一种编程约定。当函数名包含多个单词时，一种约定是将单词以下划线分隔，就像<code>like_this()</code>。还有另外一种约定，就是除了第一个单词之外的单词首字母使用大写字母，就像<code>likeThis()</code>。有些函数是用作内部函数或私有函数（不是作为公用API的一部分），这种函数名通常以一条下划线为前缀。</p><p>函数声明语句“被提前”到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用。不过，以表达式定义的函数就另当别论了，为了调用一个函数，必须要能引用它，而要使用一个以表达式方式定义的函数之前，必须把它赋值给一个变量。变量的声明提前了，但是变量赋值是不会提前的，所以，以表达式方式定义的函数在定义之前无法调用。</p><p>大多数函数都会包含一条<code>return</code>语句，<code>return</code>语句会导致函数停止执行，并返回它的表达式的值给调用者。如果<code>return</code>语句没有一个与之相关的表达式，则它返回undefined值。如果一个函数不包含<code>return</code>语句，那它就只执行函数体中的每条语句，并返回<code>undefined</code>给调用者。</p><hr><h3 id="二、嵌套函数"><a href="#二、嵌套函数" class="headerlink" title="二、嵌套函数"></a>二、嵌套函数</h3><p>在JavaScript里，函数可以嵌套在其他函数里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hypotenuse</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(square(a) + square(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套函数的有趣之处在于它的变量作用域规则：它们可以访问嵌套它们（或多重嵌套）的函数的参数和变量。这些作用于规则对内嵌函数非常重要。</p><p>上文提到，函数声明语句并非真正的语句，ES规范只是允许它们作为顶级语句。它们可以出现在全局代码里，或者内嵌在其他函数中，但它们不能出现在循环、条件判断，或者<code>try/catch/finally</code>以及<code>with</code>语句中。注意，此限制仅适用于以语句声明形式定义的函数。函数定义表达式可以出现在JavaScript代码的任何地方。</p><hr><h3 id="三、函数调用"><a href="#三、函数调用" class="headerlink" title="三、函数调用"></a>三、函数调用</h3><p>构成函数主体的JavaScript代码在定义之时并不会执行，只有调用该函数时，它们才会执行。有4种方式来调用JavaScript函数</p><ul><li><p>作为函数</p></li><li><p>作为方法</p></li><li><p>作为构造函数</p></li><li><p>通过它们的<code>call()</code>和<code>apply()</code>方法直接调用</p></li></ul><h4 id="1-函数调用"><a href="#1-函数调用" class="headerlink" title="1. 函数调用"></a>1. 函数调用</h4><p>使用调用表达式可以进行普通的函数调用也可进行方法调用。一个调用表达式由多个函数表达式组成，每个函数表达式都是由一个函数对象和左圆括号、参数列表和右圆括号组成，参数列表是由逗号分隔的零个或多个参数表达式组成。如果函数表达式是一个属性访问表达式，即该函数是一个对象的属性或属性中的一个元素，那么它就是一个方法调用表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printprops(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> total = distance(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>) + distance(<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> probability = factorial(<span class="number">5</span>) / factorial(<span class="number">13</span>);</span><br></pre></td></tr></table></figure><p>在一个调用中，每个参数表达式（圆括号之间的部分）都会计算出一个值，计算的结果作为参数传递给另外一个函数。这些值作为实参传递给声明函数时定义的形参。在函数体中存在一个形参的引用，指向当前传入的实参列表，通过它可以获得参数的值。</p><p>在ES3和非严格模式的ES5中，函数的调用上下文（this）是全局对象，然而在严格模式下，调用上下文则是undefined。</p><p>以函数形式调用的函数通常不使用this关键字，不过，this可以用来判断当前是否是严格模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并调用一个函数来确定当前脚本运行时是否为严格模式</span></span><br><span class="line"><span class="keyword">var</span> strict = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> !<span class="keyword">this</span>; &#125;());</span><br></pre></td></tr></table></figure><h4 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h4><p>一个方法无非是个保存在一个对象的属性里的JavaScript函数。如果有一个函数f和一个对象o，则可以用下面的代码给<code>o</code>定义一个名为<code>m()</code>的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o.m = f;</span><br><span class="line">o.m();</span><br><span class="line">o.m(x, y);</span><br></pre></td></tr></table></figure><p>对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致。但是，方法调用和函数调用有一个重要的区别，即调用上下文。属性访问表达式由两部分组成：一个对象（<code>o</code>）和属性名称（<code>m</code>），在像这样的方法调用表达式里，对象<code>o</code>称为调用上下文，函数体可以使用关键字<code>this</code>引用该对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculator = &#123;</span><br><span class="line">    operand1: <span class="number">1</span>,</span><br><span class="line">    operand2: <span class="number">1</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="keyword">this</span>.operand1 + <span class="keyword">this</span>.operand2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculator.add();</span><br><span class="line">calculator.result;                          <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure><p>大多数方法调用使用点符号来访问属性，使用方括号也可以进行属性访问操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o[<span class="string">'m'</span>](x, y);</span><br><span class="line">a[o](z)</span><br></pre></td></tr></table></figure><p>方法调用可能包括更复杂的属性访问表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">customer.surname.toUpperCase();</span><br><span class="line">f().m();</span><br></pre></td></tr></table></figure><p>方法和<code>this</code>关键字是面向对象编程范例的核心。任何函数只要作为方法调用实际上都会传入一个隐式的实参——这个实参是一个对象，方法调用的母体就是这个对象。通常来讲，基于那个对象的方法可以执行多种操作，方法调用的语法已经很清晰的表明了函数将基于一个对象进行操作。比较下面两行代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rect.setSize(width, height);</span><br><span class="line">setRectSize(rect, width, height);</span><br></pre></td></tr></table></figure><p>我们假设这两行代码的功能完全一样，它们都作用于一个假定的对象<code>rect</code>。可以看出，第一行的方法调用语法非常清晰地表明这个函数执行的载体是<code>rect</code>对象，函数中的所有操作都将基于这个对象。</p><p>需要注意的是，<code>this</code>是一个关键字，不是变量，也不是属性名。JavaScript的语法不允许给<code>this</code>赋值。</p><p>和变量不同，关键字<code>this</code>没有作用域的限制，嵌套的函数不会从调用它的函数中继承<code>this</code>。如果嵌套函数作为方法调用，其<code>this</code>指向调用它的对象。如果嵌套函数作为函数调用，其<code>this</code>值不是全局对象（非严格模式下）就是<code>undefined</code>（严格模式下）。很多人误以为调用嵌套函数时<code>this</code>会指向调用外层函数的上下文。如果你想访问这个外部函数的<code>this</code>值，需要将<code>this</code>的值保存在一个变量里，这个变量和内部函数都同在一个作用域内。通常使用<code>self</code>变量来保存<code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                         <span class="comment">// 对象中的方法m()</span></span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);            <span class="comment">// true  this的值就是这个对象o</span></span><br><span class="line">        f();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;                      <span class="comment">// 定义嵌套函数f()</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);        <span class="comment">// false  this的值是全局变量或undefined</span></span><br><span class="line">            <span class="built_in">console</span>.log(self === o);        <span class="comment">// true  self指外部函数的this值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">o.m();                                      <span class="comment">// 调用对象o中的方法m()</span></span><br></pre></td></tr></table></figure><h4 id="3-方法链"><a href="#3-方法链" class="headerlink" title="3. 方法链"></a>3. 方法链</h4><p>当方法的返回值是一个对象，这个对象还可以再调用它的方法。这种方法调用序列中（通常称为“链”或“级联”）每次的调用结果都是另外一个表达式的组成部分。比如基于jQuery库，我们常常会这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到所有的header，取得它们id的映射，转换为数组并对它们进行排序</span></span><br><span class="line">$(<span class="string">':header'</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.id; &#125;).get().sort();</span><br></pre></td></tr></table></figure><p>当方法不需要返回值时，最好直接返回<code>this</code>。如果在设计的API中一直采用这种方式，使用API就可以进行“链式调用”风格的变成，在这种编程风格中，只要指定一次要调用的对象即可，余下的方法都可以基于此进行调用。</p><h4 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4. 构造函数"></a>4. 构造函数</h4><p>如果函数或者方法调用之前带有关键字<code>new</code>，他就构成构造函数调用。构造函数调用和普通的函数调用以及方法调用在实参处理、调用上下文和返回值方面都有不同。</p><p>如果构造函数调用在圆括号内包含一组实参列表，先计算这些实参表达式，然后传入函数内，这和函数调用和方法调用是一致的。但如果构造函数没有形参，JavaScript调用的语法是允许省略实参列表和圆括号的。凡是没有形参的构造函数调用都可以省略圆括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两行代码是等价的</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure><p>构造函数调用创建一个新的空对象，这个对象继承自构造函数的<code>prototype</code>属性。构造函数试图初始化这个新创建的对象，并将这个对象用作其调用上下文，因此构造函数可以使用<code>this</code>关键字来引用这个新创建的对象。注意，尽管构造函数看起来像一个方法调用，它依然会使用这个新对象作为调用上下文。也就是说，在表达式<code>new o.m()</code>中，调用上下文并不是<code>o</code>，而是<code>m</code>。</p><p>构造函数通常不使用<code>return</code>关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式地使用<code>return</code>语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用<code>return</code>语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。</p><h4 id="5-间接调用"><a href="#5-间接调用" class="headerlink" title="5. 间接调用"></a>5. 间接调用</h4><p>JavaScript中的函数也是对象，和其他JavaScript对象没什么两样，函数对象也可以包含方法。其中的<code>call()</code>和<code>apply()</code>可以用来间接地调用函数，两个方法都允许显式地调用所需的<code>this</code>值。也就是说，任何函数可以作为任意对象的方法来调用，哪怕这个函数不是那对对象的方法。两个方法都可以指定调用的实参。<code>call()</code>方法使用它自有的实参列表作为函数的实参，<code>apply()</code>方法则要求以数组的形式传入参数。</p><hr><h3 id="四、函数的实参和形参"><a href="#四、函数的实参和形参" class="headerlink" title="四、函数的实参和形参"></a>四、函数的实参和形参</h3><p>JavaScript中的函数定义并未指定函数形参的类型，函数调用也未对传入的实参值作任何类型检查。实际上，JavaScript函数调用甚至不检查传入形参的个数。</p><h4 id="1-可选形参"><a href="#1-可选形参" class="headerlink" title="1. 可选形参"></a>1. 可选形参</h4><p>当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为<code>undefined</code>值。因此在调用函数时形参是否可选以及是否可以省略应当保持较好的适应性。为了做到这一点，应当给省略的参数赋一个合理的默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPropertyNames</span>(<span class="params">o, <span class="regexp">/* optional */</span> a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        a = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> o) &#123;</span><br><span class="line">        a.push(property);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = getPropertyNames(o);                <span class="comment">// 将o的属性存储到一个新数组中</span></span><br><span class="line">getPropertyNames(p, a);                     <span class="comment">// 将p的属性追加到数组a中</span></span><br></pre></td></tr></table></figure><p>如果在第一行代码中不使用<code>if</code>语句，可以使用“<code>||</code>”运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a || [];</span><br></pre></td></tr></table></figure><p>需要注意的是，当用这种可选实参来实现函数时，需要将可选实参放在实参列表的最后。那些调用你的函数的程序员是没法省略第一个实参并传入第二个实参的，它必须将<code>undefined</code>作为第一个实参显式传入。同样注意在函数定义中使用注释<code>/*optional*/</code>来强调形参是可以选的。</p><h4 id="2-可变长的实参列表：实参对象"><a href="#2-可变长的实参列表：实参对象" class="headerlink" title="2. 可变长的实参列表：实参对象"></a>2. 可变长的实参列表：实参对象</h4><p>当调用函数的时候传入的实参个数超过函数定义时的形参个数时，没有办法直接获得未命名的引用。参数对象解决了这个问题。在函数体内，标识符<code>arguments</code>是指向实参对象的引用，实参对象是一个类数组对象，这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。</p><p>实参对象在很多地方都非常有用，下面的例子展示了使用它来验证实参的个数，从而调用正确的逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'function f called with '</span> + <span class="built_in">arguments</span>.length + <span class="string">' arguments, but it expects 3 arguments.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数的其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，通常不必像这样检查实参个数。大多数情况下JavaScript的默认行为是可以满足需要的。省略的实参都将是<code>undefined</code>，多出的参数会自动省略。</p><p>实参对象有一个重要的用处，就是让函数可以操作任意数量的实参。下面的函数就可以接收任意数量的实参，并返回传入实参的最大值（内置函数<code>Max.max()</code>的功能与之类似）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params"><span class="regexp">/* ... */</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="built_in">Number</span>.NEGATIVE_INFINITY;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>[i] &gt; max) &#123;</span><br><span class="line">            max = <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> largest = max(<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1000</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10000</span>, <span class="number">6</span>);      <span class="comment">// =&gt; 10000</span></span><br></pre></td></tr></table></figure><p>类似这种函数可以接收任意个数的实参，这种函数也成为“不定实参函数”（<code>varargs function</code>）。注意，不定实参函数的实参个数不能为零，<code>arguments[]</code>对象最适合的应用场景是在这样一类函数中，这类函数包含固定个数的命名和必须参数，以及随后个数不定的可选实参。</p><p>数组对象包含一个非同寻常的特性。在非严格模式下，当一个函数包含若干形参，实参对象的数组元素是函数形参所对应实参的别名，实参对象中以数字索引，并且形参名称可以认为是相同变量的不同命名。通过实参名字来修改实参值的话，通过<code>arguments[]</code>数组也可以获取到更改后的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);         <span class="comment">// 输出实参的初始值</span></span><br><span class="line">    <span class="built_in">arguments</span>[o] = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x);         <span class="comment">// =&gt; null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果实参对象是一个普通数组的话，第二条<code>console.log(x)</code>语句的结果绝对不会是<code>null</code>，在这个例子中，<code>arguments[0]</code>和<code>x</code>指代同一个值，修改其中一个的值会影响到另一个。</p><p>在严格模式下还有一点（和非严格模式下相比的）不同，在非严格模式中，函数里的<code>arguments</code>仅仅是一个标识符，在严格模式中，它变成了一个保留字。严格模式中的函数无法使用<code>arguments</code>作为形参名或局部变量名，也不能给<code>arguments</code>赋值。</p><p><strong>callee和caller属性</strong></p><p>除了数组元素，实参对象还定义了<code>callee</code>和<code>caller</code>属性，在ES5严格模式中，对这两个属性的读写操作都会产生一个类型错误。而在非严格模式下，ES标准规范规定<code>callee</code>属性指代当前正在执行的函数。<code>caller</code>是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数。通过<code>caller</code>属性可以访问调用栈。<code>callee</code>属性在某些时候会非常有用，比如在匿名函数中通过<code>callee</code>来递归地调用自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="built_in">arguments</span>.callee(x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-将对象属性用作实参"><a href="#3-将对象属性用作实参" class="headerlink" title="3. 将对象属性用作实参"></a>3. 将对象属性用作实参</h4><p>当一个函数包含超过三个形参时，对于程序员来说，要记住调用函数中实参的正确顺序实在让人头疼。最好通过名值对的形式来传入参数，这样参数的顺序就无关紧要了。为了实现这种风格的方法调用，定义函数的时候，传入的实参都写入一个单独的对象之中，在调用的时候传入一个对象，对象中的名值对是真正需要的实参数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arraycopy</span>(<span class="params">from, from_start, to, to_start, length</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">easycopy</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    arraycopy(args.from,</span><br><span class="line">            args.from_start || <span class="number">0</span>,</span><br><span class="line">            args.to,</span><br><span class="line">            args.to_start || <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], b = [];</span><br><span class="line">easycopy(&#123; <span class="attr">from</span>: a, <span class="attr">to</span>: b, <span class="attr">length</span>: <span class="number">4</span> &#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="五、作为值的函数"><a href="#五、作为值的函数" class="headerlink" title="五、作为值的函数"></a>五、作为值的函数</h3><p>函数定义和调用是JavaScript的词法特性，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另外一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = square;</span><br><span class="line">square(<span class="number">4</span>);                              <span class="comment">// =&gt; 16</span></span><br><span class="line">s(<span class="number">4</span>);                                   <span class="comment">// =&gt; 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    square: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> y = o.square(<span class="number">16</span>);                   <span class="comment">// =&gt; 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x; &#125;, <span class="number">20</span>];</span><br><span class="line">a[<span class="number">0</span>](a[<span class="number">1</span>]);                             <span class="comment">// =&gt; 400</span></span><br></pre></td></tr></table></figure><p>考虑一下<code>Array.sort()</code>方法，这个方法可以接收一个函数作为参数，用来处理具体的排序操作。这个函数的作用非常简单，对于任意两个值都返回一个值，以指定它们在排序后的数组中的先后顺序。</p><h4 id="1-自定义函数属性"><a href="#1-自定义函数属性" class="headerlink" title="1. 自定义函数属性"></a>1. 自定义函数属性</h4><p>JavaScript中的函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。当函数需要一个“静态”变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量，显然定义全局变量会让命名空间变得更加杂乱无章。</p><p>比如，我们想写一个返回一个唯一整数的函数，不管在哪里调用函数都会返回这个整数。而函数不能两次返回同一个值，可以把这些信息存放到全局变量中，但这并不是必须的，因为这个信息仅仅是函数本身用到的。最好将这个信息保存到函数对象的一个属性中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uniqueInteger.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueInterger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniqueInterger.counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个函数<code>factorial()</code>使用了自身的属性来缓存上一次的计算结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isFinite</span>(n) &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; n == <span class="built_in">Math</span>.round(n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(n <span class="keyword">in</span> factorial)) &#123;</span><br><span class="line">            factorial[n] = n * factorial(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factorial[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial[<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="六、作为命名空间的函数"><a href="#六、作为命名空间的函数" class="headerlink" title="六、作为命名空间的函数"></a>六、作为命名空间的函数</h3><p><strong>函数作用域</strong>：在函数中声明的变量在整个函数体内都是可见的（包括在嵌套的函数中），在函数的外部是不可见的。不在任何函数内声明的变量是全局变量，在整个JavaScript程序中都是可见的。在JavaScript中是无法声明只在一个代码块内可见的变量的，基于这个原因，我们常常简单的定一个函数用作临时的命名空间，在这个命名空间内定义的变量都不会污染到全局命名空间。</p><p>比如，假设我们写了一段JavaScript模块代码，这段代码将要用在不同的JavaScript程序中。和大多数代码一样，假定这段代码定义了一个用以存储中间计算结果的变量。这样问题就来了，当模块代码放到不同的程序中运行时，我们无法得知这个变量是否已经创建了，如果已经存在这个变量，那么将会和代码发生冲突。解决办法当然是将代码放入一个函数内，然后调用这个函数。这样全局变量就变成了函数内的局部变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mymodule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模块代码</span></span><br><span class="line">    <span class="comment">// 这个模块所使用的所有变量都是局部变量</span></span><br><span class="line">    <span class="comment">// 而不是污染全局命名空间</span></span><br><span class="line">&#125;</span><br><span class="line">mymodule();</span><br></pre></td></tr></table></figure><p>这段代码仅仅定义了一个单独的全局变量，名叫“<code>mymodule</code>”的函数，这样还是太麻烦，可以直接定义一个匿名函数，并在单个表达式中调用它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模块代码</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>最外层的圆括号是习惯用法，尽管有些时候没有必要也不应当省略，这里定义的函数会立即调用。</p><p>下文示例中定义一个返回<code>extend()</code>函数的匿名函数，代码检测是否出现了一个众所周知的IE bug，如果出现了这个bug，就返回一个带补丁的函数版本。此外，这个匿名函数命名空间用来隐藏一组属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个扩展函数，用来将第二个以及后续参数复制至第一个参数</span></span><br><span class="line"><span class="comment">// 这里我们处理了IE bug：在多数IE版本中，如果o的属性拥有一个不可枚举的同名属性，则for/in循环</span></span><br><span class="line"><span class="comment">// 不会枚举对象o的可枚举性，也就是说，将不会正确地处理诸如toString的属性</span></span><br><span class="line"><span class="comment">// 除非我们显式检测它</span></span><br><span class="line"><span class="keyword">var</span> extend = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 修复bug之前，首先检测是否存在</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> &#123;<span class="attr">toString</span>: <span class="literal">null</span>&#125;) &#123;</span><br><span class="line">        <span class="comment">// 如果代码执行到这里，那么for/in循环会正确工作并返回</span></span><br><span class="line">        <span class="comment">// 一个简单版本的extend()函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> source = <span class="built_in">arguments</span>[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> source) &#123;</span><br><span class="line">                    o[prop] = source[prop];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果代码执行到这里，说明for/in循环不会枚举测试对象的toString属性</span></span><br><span class="line">    <span class="comment">// 因此返回另一个版本的extend()函数，这个函数显式测试</span></span><br><span class="line">    <span class="comment">// Object.prototype中的不可枚举属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patched_extend</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> source = <span class="built_in">arguments</span>[i];</span><br><span class="line">            <span class="comment">// 复制所有的可枚举属性</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> source) &#123;</span><br><span class="line">                o[prop] = source[prop];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在检查特殊属性</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; protoprops.length; j++) &#123;</span><br><span class="line">                prop = protoprops[j];</span><br><span class="line">                <span class="keyword">if</span> (source.hasOwnProperty(prop)) &#123;</span><br><span class="line">                    o[prop] = source[prop];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个列表列出了需要检查的特殊属性</span></span><br><span class="line">    <span class="keyword">var</span> protoprops = [<span class="string">'toString'</span>, <span class="string">'valueOf'</span>, <span class="string">'constructor'</span>, <span class="string">'hasOwnProperty'</span>, <span class="string">'isPrototypeOf'</span>, <span class="string">'propertyIsEnumerable'</span>, <span class="string">'toLocaleString'</span>];</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><hr><h3 id="七、闭包"><a href="#七、闭包" class="headerlink" title="七、闭包"></a>七、闭包</h3><p>和其他大多数现代编程语言一样，JavaScript也采用词法作用域（<code>lexical scoping</code>），也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现这种词法作用域，JavaScript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为 “<strong>闭包</strong>”。</p><p>从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链。定义大多数函数时的作用域链在调用函数时依然有效，但这并不影响闭包。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，事件就变得非常微妙。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数必报，以至于这种编程模式在JavaScript中非常常见。</p><p>理解闭包首先要了解嵌套函数的词法作用域规则，看一下这段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;                                 <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;                              <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;                                       <span class="comment">// 在作用域中返回这个值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();                                               <span class="comment">// =&gt; 'local scope'</span></span><br></pre></td></tr></table></figure><p><code>checkscope()</code>函数声明了一个局部变量，并定义了一个函数<code>f()</code>，函数<code>f()</code>返回了这个变量的值，最后将函数<code>f()</code>的执行结果返回。我们应当非常清楚为什么调用<code>checkscope()</code>会返回“<code>local scope</code>”。现在我们对这段代码做一点改动，看看会返回什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;                                 <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;                              <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;                                       <span class="comment">// 在作用域中返回这个值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();                                             <span class="comment">// 返回值是什么？</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们将函数内的一对圆括号移动到了<code>checkscope()</code>之后，<code>checkscope()</code>现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对圆括号）会发生什么事情呢？</p><p>回想一下词法作用域的基本规则：JavaScript函数的执行涌动阿勒作用域链，这个作用域链是函数定义的时候创建的。嵌套的函数定义在这个作用域链里，其中的变量<code>scope</code>一定是局部变量，不管在何时何地执行函数<code>f()</code>，这种绑定在执行<code>f()时</code>依然有效。因此最后一行代码返回<code>&quot;local scope&quot;</code>，而不是<code>&quot;global scope&quot;</code>。简而言之，闭包的这个恶性强大到让人吃惊：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了在其中定义它们的外部函数。</p><blockquote><p><strong>实现闭包</strong></p><p>如果我们理解了词法作用域的规则，我们就能很容易地理解闭包：函数定义时的作用域链到函数执行时依然有效。我们将作用域链描述为一个对象列表，不是绑定的栈。每次调用JavaScript函数的时候，都会为之创建一个新的对象用来保存局部变量，把这个对象添加至作用域链中。当函数返回的时候，就从作用域链中将这个绑定变量的对象删除。如果不存在嵌套的函数，也没有其他引用指向这个绑定对象，它就会被当作垃圾回收掉。如果定义了嵌套的函数，每个嵌套的函数都各自对应一个作用域链，并且这个作用域链指向一个变量绑定对象。但如果这些嵌套的函数对象在外部函数中保存下来，那么它们也会和所指向的变量绑定对象一样当作垃圾回收。但是如果这个函数定义了嵌套的函数，并将它作为返回值返回或者存储在某处的属性里，这时就会有一个外部引用指向这个嵌套的函数。它就不会被当作垃圾回收，并且它所指向的变量绑定对象也不会被当作垃圾回收。</p></blockquote><p>在前文定义的<code>uniqueInteger()</code>函数中，这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟踪上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致<code>uniqueInteger()</code>函数不一定能产生“唯一”的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用作私有状态。我们可以利用闭包这样重写<code>uniqueInteger()</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniqueInteger = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                           <span class="comment">// 定义函数并立即调用</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;                                        <span class="comment">// 函数的私有状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>粗略来看，第一行代码看起来像将函数赋值给一个变量<code>uniqueInteger</code>，实际上，这段代码定义了一个立即调用的函数（函数的开始带有左圆括号），因此是这个函数的返回值赋值给变量<code>uniqueInteger</code>。现在，我们来看函数体，这个函数返回另外一个函数，这是一个嵌套的函数，我们将它赋值给变量<code>uniqueInteger</code>，嵌套的函数是可以访问作用域内的变量的，而且可以访问外部函数中定义的<code>counter</code>变量。当外部函数返回之后，其他任何代码都无法访问<code>counter</code>变量，只有内部的函数才能访问到它。</p><p>像<code>counter</code>一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数定定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n++;</span><br><span class="line">        &#125;,</span><br><span class="line">        reset: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = counter(), d = counter();                           <span class="comment">// 创建两个计数器</span></span><br><span class="line">c.count();                                                  <span class="comment">// =&gt; 0</span></span><br><span class="line">d.count();                                                  <span class="comment">// =&gt; 0  它们互不干扰</span></span><br><span class="line">c.reset();                                                  <span class="comment">// reset()和count()方法共享状态</span></span><br><span class="line">c.count();                                                  <span class="comment">// =&gt; 0  因为我们重置了c</span></span><br><span class="line">d.count();                                                  <span class="comment">// =&gt; 1  没有重置d</span></span><br></pre></td></tr></table></figure><p><code>counter()</code>函数返回了一个“计数器”对象，这个对象包含两个方法：<code>count()</code>返回下一个整数，<code>reset()</code>将计数器重置为内部状态。首先要理解，这两个方法都可以访问私有变量<code>n</code>。再者，每次调用<code>counter()</code>都会创建爱你一个新的作用域链和一个新的私有变量。因此，如果调用<code>counter()</code>两次，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的<code>count()</code>或<code>reset()</code>不会影响到另外一个对象。</p><p>从技术角度看，其实可以将这个闭包合并为属性存取器方法<code>getter</code>和<code>setter</code>。下面这段代码所示的<code>counter()</code>函数，这里私有状态的实现是利用了闭包，而不是利用普通的对象属性来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">n</span>) </span>&#123;                                       <span class="comment">// 函数参数n是一个私有变量</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        get count() &#123;                                       <span class="comment">// 属性getter方法返回并给私有计数器递增1</span></span><br><span class="line">            <span class="keyword">return</span> n++;</span><br><span class="line">        &#125;,</span><br><span class="line">        set count(m) &#123;                                      <span class="comment">// 属性setter不允许n递减</span></span><br><span class="line">            <span class="keyword">if</span> (m &gt;= n)</span><br><span class="line">                n = m;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'count can only be set to a larger value'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = counter(<span class="number">1000</span>);</span><br><span class="line">c.count;                                                    <span class="comment">// =&gt; 1000</span></span><br><span class="line">c.count;                                                    <span class="comment">// =&gt; 1001</span></span><br><span class="line">c.count = <span class="number">2000</span>;</span><br><span class="line">c.count;                                                    <span class="comment">// =&gt; 2000</span></span><br><span class="line">c.count;                                                    <span class="comment">// =&gt; 2001</span></span><br><span class="line">c.count = <span class="number">2000</span>;                                             <span class="comment">// =&gt; Error!</span></span><br></pre></td></tr></table></figure><p>需要注意的是，这个版本的<code>counter()</code>函数并未生命局部变量，而只是使用参数<code>n</code>来保存私有状态，属性存取器方法可以访问<code>n</code>。这样的话，调用<code>counter()</code>的函数就可以指定私有变量的初始值了。</p><p>下文示例是使用闭包技术来共享私有状态的通用做法。这个例子定义了<code>addPrivateProperty()</code>函数，这个函数定义了一个私有变量，以及两个嵌套的函数用来获取和设置这个私有变量的值。它将这些嵌套函数添加为所指定对象的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数给对象o增加了属性存取器方法</span></span><br><span class="line"><span class="comment">// 方法名称为get&lt;name&gt;和set&lt;name&gt;。如果提供了一个判定函数</span></span><br><span class="line"><span class="comment">// setter方法就会用它来检测参数的合法性，然后再存储它</span></span><br><span class="line"><span class="comment">// 如果判定函数返回false，setter方法会抛出一个异常</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这个函数有一个非同寻常之处，就是getter和setter函数</span></span><br><span class="line"><span class="comment">// 所操作的属性值并没有存储在对象o中</span></span><br><span class="line"><span class="comment">// 相反，这个值仅仅是保存在函数的局部变量中</span></span><br><span class="line"><span class="comment">// getter和setter方法同样是局部函数，因此可以访问这个局部变量</span></span><br><span class="line"><span class="comment">// 也就是说，对于两个存取器方法来说这个变量是私有的</span></span><br><span class="line"><span class="comment">// 没有办法绕过存取器方法来设置或修改这个值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPrivateProperty</span>(<span class="params">o, name, predicate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value;                                              <span class="comment">// 这是一个属性值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter方法简单地将其返回</span></span><br><span class="line">    o[<span class="string">'get'</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter方法首先检查值是否合法，若不合法就抛出异常</span></span><br><span class="line">    o[<span class="string">'set'</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate &amp;&amp; !predicate(v))</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'set'</span> + name + <span class="string">': invalid value '</span> + v);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            value = v;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码展示了addPrivateProperty()方法</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;                                                 <span class="comment">// 设置一个空对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加属性存取器方法getName()和setName()</span></span><br><span class="line"><span class="comment">// 确保只允许字符串值</span></span><br><span class="line">addPrivateProperty(o, <span class="string">'Name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.setName(<span class="string">'Frank'</span>);                                         <span class="comment">// 设置属性值</span></span><br><span class="line"><span class="built_in">console</span>.log(o.getName());                                   <span class="comment">// 得到属性值</span></span><br><span class="line">o.setName(<span class="number">0</span>);                                               <span class="comment">// 试图设置一个错误类型的值</span></span><br></pre></td></tr></table></figure><p>我们已经给出了很多例子，在同一个作用域链中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是一种非常重要的技术，但还是要特别小心那些不希望共享的变量往往不经意间共享给了其他的闭包，了解这一点也很重要，看看下面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数返回一个总是返回v的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfunc</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个数组用来存储常数函数</span></span><br><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs[i] = constfunc(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第5个位置的元素所表示的函数返回值为5</span></span><br><span class="line">funcs[<span class="number">5</span>]();                                                 <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure><p>这段代码利用循环创建了很多个闭包，当写类似这种代码的时候往往会犯一个错误：那就是试图将循环代码移入定义这个闭包的函数之内，看一下这段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个函数组成的数组，它们的返回值是0~9</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfuncs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> funcs = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        funcs[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcs = constfuncs();</span><br><span class="line">funcs[<span class="number">5</span>]();                                                 <span class="comment">// 返回值是什么？</span></span><br></pre></td></tr></table></figure><p>上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些必报都是在同一个函数调用中定义的，因此它们可以共享变量<code>i</code>。当<code>constfuncs()</code>返回时，变量<code>i</code>的值是10，所有的闭包够共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是我们想要的结果。关联到闭包的作用域链都是“活动的”，记住这一点非常重要。嵌套的函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照（<code>static snapshot</code>）。</p><p>书写闭包的时候还需注意一件事情，<code>this</code>是JavaScript的关键字，而不是变量。正如之前讨论的，每个函数调用都包含一个<code>this</code>值，如果闭包在外部函数里是无法访问<code>this</code>的，除非外部函数将<code>this</code>转存为一个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;                                            <span class="comment">// 将this保存至一个变量中</span></span><br></pre></td></tr></table></figure><p>绑定<code>arguments</code>的问题与之类似，<code>arguments</code>并不是一个关键字，但在调用每个函数时都会自动声明它，由于闭包具有自己所绑定的<code>arguments</code>，因此闭包内无法直接访问外部函数的参数数组，除非外部函数将参数数组保存到另外一个变量中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outerArguments = <span class="built_in">arguments</span>;                             <span class="comment">// 保存起来以便嵌套的函数能使用它</span></span><br></pre></td></tr></table></figure><hr><h3 id="八、函数属性、方法和构造函数"><a href="#八、函数属性、方法和构造函数" class="headerlink" title="八、函数属性、方法和构造函数"></a>八、函数属性、方法和构造函数</h3><p>我们看到在JavaScript程序中，函数是值。对函数执行<code>typeof</code>运算符会返回字符串“<code>function</code>”，但是函数是JavaScript中特殊的对象。因为函数也是对象，它们也可以拥有属性和方法，就像普通的对象可以拥有属性和方法一样。甚至可以用<code>Function()</code>构造函数来创建新的对象。</p><h4 id="1-length属性"><a href="#1-length属性" class="headerlink" title="1. length属性"></a>1. length属性</h4><p>在函数体里，<code>arguments.length</code>表示传入函数的实参的个数。而函数本身的<code>length</code>属性则由不同含义。函数的<code>length</code>属性是只读属性，它代表函数实参的数量，这里的参数指的是“形参”而非“实参”，也就是在函数定义时给出的实参个数，通常也是在函数调用时期望传入函数的实参个数。</p><p>下面的代码定义了一个名叫<code>check()</code>的函数，从另外一个函数给它传入<code>arguments</code>数组，它比较<code>arguments.length</code>（实际传入的实参个数）和<code>arguments.callee.length</code>（期望传入的实参个数）来判断所传入的实参个数是否正确。如果个数不正确，则抛出异常。<code>check()</code>函数之后定义一个测试函数<code>f()</code>，用来展示<code>check()</code>的用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数使用arguments.callee，因此它不能在严格模式下工作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> actual = args.length;                               <span class="comment">// 实参的真实个数</span></span><br><span class="line">    <span class="keyword">var</span> expected = args.callee.length;                      <span class="comment">// 期望的实参个数</span></span><br><span class="line">    <span class="keyword">if</span> (actual !== expected) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Expeced '</span> + expected + <span class="string">' args; got '</span> + actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    check(<span class="built_in">arguments</span>);                                       <span class="comment">// 检查实参个数和期望的实参个数是否一致</span></span><br><span class="line">    <span class="keyword">return</span> x + y + z;                                       <span class="comment">// 再执行函数的后续逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-prototype属性"><a href="#2-prototype属性" class="headerlink" title="2. prototype属性"></a>2. prototype属性</h4><p>每一个函数都包含一个<code>prototype</code>属性，这个属性是指向一个对象的引用，这个对象称作“原型对象”（<code>prototype object</code>）。每一个函数都包含不同的原型对象，当将函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。</p><h4 id="3-call-方法和apply-方法"><a href="#3-call-方法和apply-方法" class="headerlink" title="3. call()方法和apply()方法"></a>3. call()方法和apply()方法</h4><p>我们可以将<code>call()</code>和<code>apply()</code>看作是某个对象的方法，通过调用方法的形式来间接调用函数。<code>call()</code>和<code>apply()</code>的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内通过<code>this</code>来获得对它的引用。要想以对象<code>o</code>的方法来调用函数<code>f()</code>，可以这样使用<code>call()</code>和<code>apply()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.call(o);</span><br><span class="line">f.apply(o);</span><br></pre></td></tr></table></figure><p>每行代码和下面代码的功能类似（假设对象<code>o</code>中预先不存在名为<code>m</code>的属性）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o.m = f;                                                    <span class="comment">// 将f存储为o的临时方法</span></span><br><span class="line">o.m();                                                      <span class="comment">// 调用它，不传入参数</span></span><br><span class="line"><span class="keyword">delete</span> o.m;                                                 <span class="comment">// 将临时方法删除</span></span><br></pre></td></tr></table></figure><p>在ES5的严格模式中，<code>call()</code>和<code>apply()</code>的第一个实参都会变为<code>this</code>的值，哪怕传入的实参是原始值甚至是<code>null</code>或<code>undefined</code>。在ES3和非严格模式中，传入的<code>null</code>和<code>undefined</code>都会被全局对象替代，而其他原始值则会被相应的包装对象（<code>wrapper object</code>）所替代。</p><p>对于<code>call()</code>来说，第一个调用上下文实参之后的所有实参就是要传入待调用函数的值。比如，以对象<code>o</code>的方法的形式调用函数<code>f()</code>，并传入两个参数，可以使用这样的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.call(o, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><code>apply()</code>方法和<code>call()</code>类似，但传入实参的形式和<code>call()</code>有所不同，它的实参都放入一个数组当中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.apply(o, [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>如果一个函数的实参可以是任意数量，给<code>apply()</code>传入的参数数组可以是任意长度的。比如，为了找出数组中最大的数值元素，调用<code>Math.max()</code>方法的时候可以给<code>apply()</code>传入一个包含任意元素的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> biggest = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, array_of_numbers);</span><br></pre></td></tr></table></figure><p>需要注意的是，传入<code>apply()</code>的参数数组可以是类数组对象也可以是真实数组。实际上，可以将当前函数的<code>arguments</code>数组直接传入（另一个函数的）<code>apply()</code>来调用另一个函数，参考如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将对象o中名为m()的方法替换为另一个方法</span></span><br><span class="line"><span class="comment">// 可以在调用原始的方法之前和之后记录日志消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>(<span class="params">o, m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> original = o[m];                                <span class="comment">// 在闭包中保存原始方法</span></span><br><span class="line">    o[m] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">'Entering:'</span>, m);        <span class="comment">// 输出日志消息</span></span><br><span class="line">        <span class="keyword">var</span> resut = original.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);    <span class="comment">// 调用原始函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">'Existing:'</span>, m);        <span class="comment">// 输入日志消息</span></span><br><span class="line">        <span class="keyword">return</span> result;                                  <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>trace()</code>函数接收两个参数，一个对象和一个方法名，它将指定的方法替换为一个新方法，这个新方法是“包裹”原始方法的另一个泛函数。这种动态修改已有方法的做法有时称作“<code>monkey-patching</code>”。</p><h4 id="4-bind-方法"><a href="#4-bind-方法" class="headerlink" title="4. bind()方法"></a>4. bind()方法</h4><p><code>bind()</code>是在ES5中新增的方法，但在ES3中可以轻易模拟<code>bind()</code>。从名字就可以看出，这个方法的主要作用就是将函数绑定至某个对象。当在函数<code>f()</code>上调用<code>bind()</code>方法并传入一个对象<code>o</code>作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数<code>f()</code>当作<code>o</code>的方法来调用。传入新函数的任何实参都将传入原始函数，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + y;                                  <span class="comment">// 这是个待绑定的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;                                       <span class="comment">// 将要绑定的对象</span></span><br><span class="line"><span class="keyword">var</span> g = f.bind(o);                                      <span class="comment">// 通过调用g(x)来调用o.f(x);</span></span><br><span class="line">g(<span class="number">2</span>);                                                   <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><p>可以通过如下代码轻易地实现这种绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个函数，通过调用它来调用o中的方法f()，传递它所有的实参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">f, o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f.bind) &#123;</span><br><span class="line">        <span class="keyword">return</span> f.bind(o);                               <span class="comment">// 如果bind()方法存在的话，使用bind()方法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> f.apply(o, <span class="built_in">arguments</span>);               <span class="comment">// 否则，这样绑定</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES5中的<code>bind()</code>方法不仅仅是将函数绑定至一个对象，它还附带一些其他应用：除了第一个实参之外，传入<code>bind()</code>的实参也会绑定至<code>this</code>，这个附带的应用是一种常见的函数式编程技术，有时也被称为“柯里化”（<code>currying</code>）。参照下面这个例子中的<code>bind()</code>方法的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;                                       <span class="comment">// 返回两个实参的和</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个类似sum的新函数，但this的值绑定到null</span></span><br><span class="line"><span class="comment">// 并且第一个参数绑定到1，这个新的函数期望只传入一个实参</span></span><br><span class="line"><span class="keyword">var</span> succ = sum.bind(<span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line">succ(<span class="number">2</span>);                                                <span class="comment">// =&gt; 3  x绑定到1，并传入2作为实参y</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + y + z;                              <span class="comment">// 另外一个做累加计算的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, <span class="number">2</span>);                              <span class="comment">// 绑定this和y</span></span><br><span class="line">g(<span class="number">3</span>);                                                   <span class="comment">// =&gt; 6  this.x绑定到1，y绑定到2，z绑定到3</span></span><br></pre></td></tr></table></figure><p>我们可以绑定<code>this</code>的值并在ES3中实现这个附带的应用，下面代码就模拟实现标准的<code>bind()</code>方法。注意我们将这个方法另存为<code>Function.prototype.bind</code>，以便所有的函数对象都继承它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">o <span class="regexp">/*, args */</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将this和arguments的值保存至变量中</span></span><br><span class="line">        <span class="comment">// 以便在后面嵌套的函数中可以使用它们</span></span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>, boundArgs = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bind()方法的返回值是一个函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 创建一个实参列表，将传入bind()的第二个及后续的实参都传入这个函数</span></span><br><span class="line">            <span class="keyword">var</span> args = [], i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; boundArgs.length; i++) &#123;</span><br><span class="line">                args.push(boundArgs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在将self作为o的方法来调用，传入这些实参</span></span><br><span class="line">            <span class="keyword">return</span> self.apply(o, args);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到，<code>bind()</code>方法返回的函数是一个闭包，在这个闭包的外部函数中声明了<code>self</code>和<code>boundArgs</code>变量，这两个变量在闭包里用到。尽管定义闭包的内部函数已经从外部函数中返回，而且调用这个闭包逻辑的时刻要在外部函数返回之后（在闭包中照样可以正确访问这两个变量）。</p><p>ES5定义的<code>bind()</code>方法也有一些特性是上述ES3代码无法模拟的。首先，真正的<code>bind()</code>方法返回的是一个函数对象，这个函数对象的<code>length</code>属性是绑定函数的形参个数减去绑定实参的个数（<code>length</code>的值不能小于0）。再者，ES5的<code>bind()</code>方法可以顺带用作构造函数。如果<code>bind()</code>返回的函数用作构造函数，将忽略传入<code>bind()</code>的<code>this</code>，原始函数就会以构造函数的形式调用，其实参也已经绑定。由<code>bind()</code>方法所返回的函数并不包含<code>prototype</code>属性（普通函数固有的<code>prototype</code>属性是不能删除的），并且将这些绑定的函数用作构造函数时所创建的对象从原始的未绑定的构造函数中继承<code>prototype</code>。同样，在使用<code>instanceof</code>运算符时，绑定构造函数和未绑定构造函数并无两样。</p><h4 id="5-toString-方法"><a href="#5-toString-方法" class="headerlink" title="5. toString()方法"></a>5. toString()方法</h4><p>和所有的JavaScript对象一样，函数也有<code>toString()</code>方法，ES规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数的<code>toString()</code>方法的实现都返回函数的完整源码。内置函数往往返回一个类似“<code>[native code]</code>”的字符串作为函数体。</p><h4 id="6-Function-构造函数"><a href="#6-Function-构造函数" class="headerlink" title="6. Function()构造函数"></a>6. Function()构造函数</h4><p>不管是通过函数定义语句还是函数直接量表达式，函数的定义都要使用<code>function</code>关键字。但函数还是可以通过<code>Function()</code>构造函数来定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x * y;'</span>);</span><br></pre></td></tr></table></figure><p>这行代码创建一个新的函数，这个函数和通过下面代码定义的函数几乎等价</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x * y; &#125;;</span><br></pre></td></tr></table></figure><p><code>Function()</code>构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体：它可以包含任意的JavaScript语句，每两条语句之间用分号分隔。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只需给构造函数简单地传入一个字符串——函数体——即可。</p><p>注意，<code>Function()</code>构造函数并不需要通过传入实参以指定函数名。就像函数直接量一样，<code>Function()</code>构造函数创建一个匿名函数。</p><p>关于<code>Function()</code>构造函数有几点需要特别注意：</p><ul><li><p><code>Function()</code>构造函数允许JavaScript在运行时动态地创建并编译函数。</p></li><li><p>每次调用<code>Function()</code>构造函数都会解析函数体，并创建新的函数对象。如果是在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响。相比之下，循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译。</p></li><li><p>最后一点，也是关于<code>Function()</code>构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译总是会在顶层函数执行，正如下面代码所示</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">'local'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'return scope;'</span>);               <span class="comment">// 无法捕获局部作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一行代码返回global，因为通过Function()构造函数</span></span><br><span class="line"><span class="comment">// 所返回的函数使用的不是局部作用域</span></span><br><span class="line">constructionFunction()();                               <span class="comment">// =&gt; 'global'</span></span><br></pre></td></tr></table></figure><p>我们可以将<code>Function()</code>构造函数认为是在全局作用域中执行的<code>eval()</code>，<code>eval()</code>可以在自己的私有作用域内定义新变量和函数，<code>Function()</code>构造函数在实际编程过程中很少会用到。</p><h4 id="7-可调用的对象"><a href="#7-可调用的对象" class="headerlink" title="7. 可调用的对象"></a>7. 可调用的对象</h4><p>我们在前面提到的“类数组对象”并不是真正的数组，但大部分场景下可以将其当作数组来对待。对于函数也存在类似的情况。“可调用对象”（<code>callable object</code>）是一个对象，可以在函数调用表达式中调用这个对象。所有的函数都是可调用的，但并非所有的可调用对象都是函数。</p><p>截至目前，可调用对象在两个JavaScript实现中不能算作函数：</p><ul><li><p>1) IE8及之前的版本实现了客户端方法（<code>window.alert()</code>和<code>document.getElementById()</code>），使用了可调用的宿主对象，而不是内置函数对象。IE中的这些方法在其他浏览器中也都存在，但它们本质上不是<code>Function</code>对象。IE9将它们实现为真正的函数，因此这类可调用的对象越来越罕见。</p></li><li><p>2) <code>RegExp</code>对象，可以直接调用<code>RegExp</code>对象，这比调用它的<code>exec()</code>方法更快捷一些。在JavaScript中这是一个彻头彻尾的非标准特性，代码最好不要对可调用的<code>RegExp</code>对象由太多依赖，这个特性在不久的将来可能会废弃并删除。</p></li></ul><p>如果想检测一个对象是否是真正的函数对象（并且具有函数方法），可以检测它的<code>class</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(x) === <span class="string">'[object Function]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="九、函数式编程"><a href="#九、函数式编程" class="headerlink" title="九、函数式编程"></a>九、函数式编程</h3><p>和Lisp、Haskell不同，JavaScript并非函数式编程语言，但在JavaScript中可以像操控对象一样操控函数，也就是说可以在JavaScript中应用函数式编程技术。ES5中的数组方法（诸如<code>map()</code>和<code>reduce()</code>）就可以非常适合用于函数式编程风格。</p><h4 id="1-使用函数处理数组"><a href="#1-使用函数处理数组" class="headerlink" title="1. 使用函数处理数组"></a>1. 使用函数处理数组</h4><p>假设有一个数组，数组元素都是数字，我们想要计算这些元素的平均值和标准差。若使用非函数式编程风格的话，代码会是这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>];                             <span class="comment">// 待处理数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平均数是所有元素的累加和值除以元素个数</span></span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    total += data[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mean = total / data.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算标准差，首先计算每个数据减去平均数之后偏差的平方然后求和</span></span><br><span class="line">total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> deviation = data[i] - mean;</span><br><span class="line">    total += deviation * deviation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stddev = <span class="built_in">Math</span>.sqrt(total / (data.length - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>可以使用数组方法<code>map()</code>和<code>reduce()</code>来实现同样的计算，这种实现极其简洁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先定义两个简单的函数</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x &#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将这些函数和数组方法配合使用计算出平均数和标准差</span></span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> mean = data.reduce(sum) / data.length;</span><br><span class="line"><span class="keyword">var</span> deviations = data.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x - mean; &#125;);</span><br><span class="line"><span class="keyword">var</span> stddev = <span class="built_in">Math</span>.sqrt(deviations.map(square).reduce(sum) / (data.length - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>如果我们基于ES3来如何实现呢？因为ES3中并不包含这些数组方法，如果不存在内置方法的话我们可以自定义<code>map()</code>和<code>reduce()</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个数组元素调用f()，并返回一个结果数组</span></span><br><span class="line"><span class="comment">// 如果Array.prototype.map定义了的话，就使用这个方法</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="built_in">Array</span>.prototype.map ? </span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a, f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.map(f);</span><br><span class="line">    &#125;:</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a, f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> results = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = a.length; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i <span class="keyword">in</span> a) &#123;</span><br><span class="line">                results[i] = f.call(<span class="literal">null</span>, a[i], i, a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数f()和可选的初始值将数组a减至一个值</span></span><br><span class="line"><span class="comment">// 如果Array.prototype.reduce存在的话，就使用这个方法</span></span><br><span class="line"><span class="keyword">var</span> reduce = <span class="built_in">Array</span>.prototype.reduce ?</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a, f, initial</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.reduce(f, initial);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.reduce(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;:</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a, f, initial</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span>, len = a.length, accumulator;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以特定的初始值开始，否则第一个值取自a</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            accumulator = initial;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i <span class="keyword">in</span> a) &#123;</span><br><span class="line">                    accumulator = a[i++];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == len) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于数组中剩下的元素依次调用f()</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i <span class="keyword">in</span> a) &#123;</span><br><span class="line">                accumulator = f.call(<span class="literal">undefined</span>, accumulator, a[i], i, a);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用定义的<code>map()</code>和<code>reduce()</code>函数，计算平均值和标准差的代码看起来像这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> mean = reduce(data, sum) / data.length;</span><br><span class="line"><span class="keyword">var</span> deviations = map(data, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - mean;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> stddev = <span class="built_in">Math</span>.sqrt(reduce(map(deviations, square), sum) / (data.length - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2. 高阶函数"></a>2. 高阶函数</h4><p>所谓高阶函数（<code>higher-order function</code>）就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个高阶函数返回一个新的函数，这个新函数将它的实参传入f()</span></span><br><span class="line"><span class="comment">// 并返回f的返回值的逻辑非</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">not</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = f.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);          <span class="comment">// 调用f()</span></span><br><span class="line">        <span class="keyword">return</span> !result;                                 <span class="comment">// 对结果求反</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> even = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> odd = not(even);                                    <span class="comment">// 一个新函数，所做的事情和even()相反</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>].every(odd);                             <span class="comment">// =&gt; true  每个元素都是奇数</span></span><br></pre></td></tr></table></figure><p>上面的<code>not()</code>函数就是一个高阶函数，因为它接收一个函数作为参数，并返回一个新函数。另外一个例子，来看下面的<code>mapper()</code>函数，它也是接收一个函数作为参数，并返回一个新函数，这个新函数将一个数组映射到另一个使用这个函数的数组上。这个函数使用了之前定义的<code>map()</code>函数，但要首先理解这两个函数有哪些不同，这一点至关重要</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所返回的函数的参数应当是一个实参数组，并对每个数组元素执行函数f()</span></span><br><span class="line"><span class="comment">// 并返回所有计算结果组成的数组</span></span><br><span class="line"><span class="comment">// 可以对比一下这个函数和上文提到的map()函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapper</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map(a, f);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increment = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> incrementer = mapper(increment);</span><br><span class="line"></span><br><span class="line">incrementer([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);                                 <span class="comment">// =&gt; [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>这里是一个更常见的例子，它接收两个函数<code>f()</code>和<code>g()</code>，并返回一个新的函数用以计算<code>f(g())</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个新的可以计算f(g(...))的函数</span></span><br><span class="line"><span class="comment">// 返回的函数h()将它所有的实参传入g()，然后将g()的返回值传入f()</span></span><br><span class="line"><span class="comment">// 调用f()和g()时的this值和调用h()时的this值是同一个this</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">f, g</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 需要给f()传入一个参数，所以使用f()的call()方法</span></span><br><span class="line">        <span class="comment">// 需要给g()传入很多参数，所以使用g()的apply()方法</span></span><br><span class="line">        <span class="keyword">return</span> f.call(<span class="keyword">this</span>, g.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> squareofsum = compose(square, sum);</span><br><span class="line"></span><br><span class="line">squareofsum(<span class="number">2</span>, <span class="number">3</span>);                                      <span class="comment">// =&gt; 25</span></span><br></pre></td></tr></table></figure><h4 id="3-不完全函数"><a href="#3-不完全函数" class="headerlink" title="3. 不完全函数"></a>3. 不完全函数</h4><p>函数<code>f()</code>的<code>bind()</code>方法返回一个新函数，给新函数传入特定的上下文和一组指定的参数，然后调用函数<code>f()</code>。我们说它把函数“绑定至”对象并传入一部分参数。<code>bind()</code>方法只是将实参放在（完整实参列表的）左侧，也就是说<code>bind()</code>的实参都是放在传入原始函数的实参列表开始的位置，但有时我们期望将传入<code>bind()</code>的实参放在（完整实参列表的）右侧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个工具函数将类数组对象（或对象）转换为真正的数组</span></span><br><span class="line"><span class="comment">// 在后面的示例代码中用到了这个方法将arguments对象转换为真正的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">array</span>(<span class="params">a, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(a, n || <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实参传递至左侧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialLeft</span>(<span class="params">f <span class="regexp">/*, ...*/</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;                               <span class="comment">// 保存外部的实参数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = array(args, <span class="number">1</span>);                         <span class="comment">// 开始处理外部的第一个args</span></span><br><span class="line">        a = a.concat(array(<span class="built_in">arguments</span>));                 <span class="comment">// 然后增加所有的内部实参</span></span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="keyword">this</span>, a);                        <span class="comment">// 然后基于这个实参列表调用f()</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实参传递至右侧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialRight</span>(<span class="params">f <span class="regexp">/*, ...*/</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;                               <span class="comment">// 保存外部实参数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = array(<span class="built_in">arguments</span>);                       <span class="comment">// 从内部参数开始</span></span><br><span class="line">        a = a.concat(array(args, <span class="number">1</span>));                   <span class="comment">// 然后从外部第一个args开始添加</span></span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="keyword">this</span>, a);                        <span class="comment">// 最后基于这个实参列表调用f()</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实参被用作模板</span></span><br><span class="line"><span class="comment">// 实参列表中的undefined值都被填充</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">f <span class="regexp">/*, ...*/</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;                               <span class="comment">// 保存外部实参数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = array(args, <span class="number">1</span>);                         <span class="comment">// 从外部args开始</span></span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历args，从内部实参填充undefined值</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                a[i] = <span class="built_in">arguments</span>[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 现在将剩下的内部实参都追加进去</span></span><br><span class="line">        a = a.concat(array(<span class="built_in">arguments</span>, j));</span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="keyword">this</span>, a);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数带有三个实参</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * (y - z);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个不完全调用</span></span><br><span class="line">partialLeft(f, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>);                                <span class="comment">// =&gt; -2  绑定第一个实参：2*(3-4)</span></span><br><span class="line">partialRight(f, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>);                               <span class="comment">// =&gt; 6  绑定最后一个实参：3*(4-2)</span></span><br><span class="line">partial(f, <span class="literal">undefined</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>);                         <span class="comment">// =&gt; -6  绑定中间的实参：3*(2-4)</span></span><br></pre></td></tr></table></figure><p>利用这种不完全函数的编程技巧，可以编写一些有意思的代码，利用已有的函数来定义新的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> increment = partialLeft(sum, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> cuberoot = partialRight(<span class="built_in">Math</span>.pow, <span class="number">1</span>/<span class="number">3</span>);</span><br><span class="line"><span class="built_in">String</span>.prototype.first = partial(<span class="built_in">String</span>.prototype.charAt, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">String</span>.prototype.last = partial(<span class="built_in">String</span>.prototype.substr, <span class="number">-1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当将不完全调用和其他高阶函数整合在一起的时候，事情就变得格外有趣了。比如，这里的例子定义了<code>not()</code>函数，它用到了刚才提到的不完全调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> not = partialLeft(compose, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !x;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> even = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> odd = not(even);</span><br><span class="line"><span class="keyword">var</span> isNumber = not(<span class="built_in">isNaN</span>);</span><br></pre></td></tr></table></figure><p>我们也可以使用不完全调用的组合来重新组织求平均数和标准差的代码，这种编码风格是非常纯粹的函数式编程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>];                                 <span class="comment">// 待处理的数据</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;                                  <span class="comment">// 两个初等函数</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> product = functon(x, y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> neg = partial(product, <span class="number">-1</span>);                             <span class="comment">// 定义其他函数</span></span><br><span class="line"><span class="keyword">var</span> square = partial(<span class="built_in">Math</span>.pow, <span class="literal">undefined</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> sqrt = partial(<span class="built_in">Math</span>.pow, <span class="literal">undefined</span>, <span class="number">.5</span>);</span><br><span class="line"><span class="keyword">var</span> reciprocal = partial(<span class="built_in">Math</span>.pow, <span class="literal">undefined</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在计算平均值和标准差，所有的函数调用都不带运算符</span></span><br><span class="line"><span class="keyword">var</span> mean = product(reduce(data, sum), reciprocal(data.length));</span><br><span class="line"><span class="keyword">var</span> stddev = sqrt(product(reduce(map(data, </span><br><span class="line">                                    compose(square, </span><br><span class="line">                                            partial(sum, neg(mean)))), </span><br><span class="line">                                sum), </span><br><span class="line">                        reciprocal(sum(data.length, <span class="number">-1</span>))));</span><br></pre></td></tr></table></figure><h4 id="4-记忆"><a href="#4-记忆" class="headerlink" title="4. 记忆"></a>4. 记忆</h4><p>在函数式编程中，采用缓存的方式记录结果的技巧称为“记忆”（<code>memorization</code>）。下面的代码展示了一个高阶函数，<code>memorize()</code>接收一个函数作为实参，并返回带有记忆能力的函数。</p><blockquote><p>需要注意的是，记忆只是一种编程技巧，本质上是牺牲算法的空间复杂度以换取更优的时间复杂度，在客户端JavaScript中代码的执行时间复杂度往往成为瓶颈，因此在大多数场景下，这种牺牲空间换取时间的做法以提升程序执行效率的做法是非常可取的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回f()的带有记忆功能的版本</span></span><br><span class="line"><span class="comment">// 只有当f()的实参的字符串表示都不相同时它才会工作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;                                         <span class="comment">// 将值保存在闭包内</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将实参转换为字符串形式，并将其用作缓存的键</span></span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">arguments</span>.length + <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">','</span>);</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[key];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[key] = f.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>memorize()</code>函数创建一个新的对象，这个对象被当作缓存（的宿主）并赋值给一个局部变量，因此对于返回的函数来说它是私有的（在闭包中）。所返回的函数将它的实参数组转换成字符串，并将字符串用作缓存对象的属性名。如果在缓存中存在这个值，则直接返回它。</p><p>否则，就调用既定的函数对实参进行计算，将计算结果换存起来并返回，下面的代码展示了如何使用<code>memorize()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回两个整数的最大公约数</span></span><br><span class="line"><span class="comment">// 使用欧几里德算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        t = b;</span><br><span class="line">        b = a;</span><br><span class="line">        a = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>) &#123;</span><br><span class="line">        t = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gcdmemo = memorize(gcd);</span><br><span class="line">gcdmemo(<span class="number">85</span>, <span class="number">187</span>);                                           <span class="comment">// =&gt; 187</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，当我们写一个递归函数时，往往需要实现记忆功能</span></span><br><span class="line"><span class="comment">// 我们更希望调用实现了记忆功能的递归函数，而不是原递归函数</span></span><br><span class="line"><span class="keyword">var</span> factorial = memorize(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>);                                               <span class="comment">// =&gt; 120  对于4~1的值也有缓存</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数是这样的一段JavaScript代码，它只定义一次，但可能被执行或调用任意次。JavaScript函数是参数化的：函数的定义会包括一个称为形参（&lt;code&gt;parameter&lt;/code&gt;）的标识符列表，这些参数在函数体中像局部变量一样工作。函数调用会为形参提供实参的值。函数使用它们实参的值来计算返回值，称为该函数调用表达式的值。除了实参之外，每次调用还会拥有另外一个值——本次调用的上下文——就是&lt;code&gt;this&lt;/code&gt;关键字的值。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript数组" scheme="http://www.xiaoleon.cn/tags/JavaScript%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JS(3) 数组</title>
    <link href="http://www.xiaoleon.cn/2018/01/27/js-3/"/>
    <id>http://www.xiaoleon.cn/2018/01/27/js-3/</id>
    <published>2018-01-27T09:48:25.000Z</published>
    <updated>2018-01-28T15:07:22.340Z</updated>
    
    <content type="html"><![CDATA[<p>数组是值的有序集合，每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。JavaScript数组的索引是基于零的32位数，第一个元素的索引为0，最大可能的索引为<code>4 294 967 294</code>（<code>2e32-2</code>），数组最大能容纳<code>4 294 967 295</code>个元素。</p><a id="more"></a><p>JavaScript数组可能是稀疏的：数组元素的索引不一定要连续的，它们之间可以有空缺。每个JavaScript数组都有一个<code>length</code>属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，<code>length</code>比所有元素的索引要大。</p><p>JavaScript数组是JavaScript对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。我们将在本文的其他地方更多地讨论特殊化的数组。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。</p><h3 id="一、创建数组"><a href="#一、创建数组" class="headerlink" title="一、创建数组"></a>一、创建数组</h3><p>使用数组直接量是创建数组最简单的方法，在方括号中将数组元素用逗号隔开即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = [];</span><br><span class="line"><span class="keyword">var</span> primes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> misc = [<span class="number">1.1</span>, <span class="literal">true</span>, <span class="string">'a'</span>, ];</span><br></pre></td></tr></table></figure><p>数组直接量中的值不一定要是常量，它们可以是任意的表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> base = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">var</span> table = [table, base+<span class="number">1</span>, base+<span class="number">2</span>, base+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = [[<span class="number">1</span>, &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;], [<span class="number">2</span>, &#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>:<span class="number">4</span>&#125;]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = [<span class="number">1</span>, ,<span class="number">3</span>];        <span class="comment">// 数组有3个元素，中间那个元素值为undefined</span></span><br><span class="line"><span class="keyword">var</span> undefs = [,,];          <span class="comment">// 数组有2个元素，都是undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>数组直接量的语法允许有可选的结尾的逗号，故<code>[,,]</code>只有两个元素而非三个。</p></blockquote><p>调用构造函数<code>Array()</code>是创建数组的另一种方法。可以用三种方式调用构造函数。</p><ul><li><p>调用时没有参数</p><p>  该方法创建一个没有任何元素的空数组，等同于数组直接量<code>[]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br></pre></td></tr></table></figure></li><li><p>调用时有一个数值参数，它指定长度</p><p>  该方法创建指定长度的数组。当预先知道所需元素个数时，这种形式的Array构造函数可以用来预分配一个数组空间。注意，数组中没有存储值，甚至数组的索引属性还未定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><p>显示指定两个或多个数组元素或者数组的一个非数值元素</p><p>  以这种形式，构造函数的参数将会称为新数组的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">'testing, testing'</span>);</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="二、数组元素的读和写"><a href="#二、数组元素的读和写" class="headerlink" title="二、数组元素的读和写"></a>二、数组元素的读和写</h3><p>使用<code>[]</code>操作符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。因此，下方代码都是合法的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'world'</span>];</span><br><span class="line"><span class="keyword">var</span> value = a[<span class="number">0</span>];</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">3.14</span>;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">a[i] = <span class="number">3</span>;</span><br><span class="line">a[i+<span class="number">1</span>] = <span class="string">'hello'</span>;</span><br><span class="line">a[a[i]] = a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><blockquote><p><strong>请记住，数组是对象的特殊形式</strong></p></blockquote><p>使用方括号访问数组元素就像用方括号访问对象的属性一样。JavaScript将指定的数字索引值转换成字符串——索引值<code>1</code>变成<code>“1”</code>——然后将其作为属性名来使用。关于索引值从数字转换为字符串没什么特别之处：对常规对象也可以这么做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o[<span class="number">1</span>] = <span class="string">'one'</span>;</span><br></pre></td></tr></table></figure><p>数组的特别之处在于，当使用小于<code>2e32</code>的非负整数作为属性名时，数组会自动维护其<code>length</code>属性值。</p><p>清晰地区分数组的索引和对象的属性名是非常有用的。所有的索引都是属性名，但只有<code>0~2e32-2</code>之间的整数属性名才是索引。所有的数组都是对象，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的<code>length</code>属性值。</p><p>注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当作常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负整数的字符串，它就当作数组索引，而非对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这将创建一个名为“-1.23”的属性</span></span><br><span class="line">a[<span class="number">-1.23</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 这是数组的第1001个元素</span></span><br><span class="line">a[<span class="string">'1000'</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 和a[1]相等</span></span><br><span class="line">a[<span class="number">1.000</span>];</span><br></pre></td></tr></table></figure><p>事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着JavaScript数组没有“越界”错误的概念。当试图查询任意对象中不存在的属性时，不会报错，只会得到<code>undefined</code>值。</p><p>既然数组是对象，那么它们可以从原型中继承元素。ES5中，数组可以定义元素的<code>getter</code>和<code>setter</code>方法。如果一个数组确实继承了元素或使用了元素的<code>getter</code>和<code>setter</code>方法，我们应该期望它使用非优化的代码路径：访问者中数组的元素的时间会与常规对象属性的查找时间相近。</p><hr><h3 id="三、稀疏数组"><a href="#三、稀疏数组" class="headerlink" title="三、稀疏数组"></a>三、稀疏数组</h3><p>稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的<code>length</code>属性值代表数组中元素的个数。如果数组是稀疏的，<code>length</code>属性值大于元素的个数。可以用<code>Array()</code>构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);       <span class="comment">// 数组没有元素，但是a.length=5</span></span><br><span class="line">a = [];                 <span class="comment">// 创建一个空数组，length=0</span></span><br><span class="line">a[<span class="number">1000</span>] = <span class="number">0</span>;            <span class="comment">// 赋值添加一个元素，但是length=1001</span></span><br></pre></td></tr></table></figure><p>足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。</p><p>需要注意的是，当省略数组直接量中的值时（使用连续的逗号，比如<code>[1,,3]</code>），这时所得到的数组也是稀疏数组，省略掉的值是不存在的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = [,,,];</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a1;                    <span class="comment">// false a1在索引0处有一个元素</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a2;                    <span class="comment">// false a2在索引0处没有元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、数组长度"><a href="#四、数组长度" class="headerlink" title="四、数组长度"></a>四、数组长度</h3><p>每个数组都有一个<code>length</code>属性，就是这个属性使其区别于常规的JavaScript对象。针对稠密数组（非稀疏数组），<code>length</code>属性值代表数组中元素的个数。其值比数组中最大的索引大1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[].length;                  <span class="comment">// 0 数组没有元素</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].length      <span class="comment">// 3 最大索引值为2，length=3</span></span><br></pre></td></tr></table></figure><p>在数组中肯定找不到一个元素的索引值大于或等于它的长度，为了维持此规则不变化，数组有两个特殊的行为</p><ul><li><p>如果为一个数组元素赋值，它的索引<code>i</code>大于或等于现有数组的长度是，<code>length</code>属性的值将设置为<code>i+1</code></p></li><li><p>设置<code>length</code>属性为一个小于当前长度的非负整数<code>n</code>时，当前数组中那些索引值大于或等于<code>n</code>的元素将从中删除</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.length = <span class="number">3</span>;               <span class="comment">// a = [1, 2, 3]</span></span><br><span class="line">a.length = <span class="number">0</span>;               <span class="comment">// a = []</span></span><br><span class="line">a.length = <span class="number">5</span>;               <span class="comment">// 长度为5，但是没有元素，就像new Array(5)</span></span><br></pre></td></tr></table></figure><p>还可以将数组的<code>length</code>属性值设置为大于其当前的长度，实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个空的区域。</p><p>在ES5中，可用用<code>Object.defineProperty()</code>让数组的<code>length</code>属性变成只读的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'length'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a.length = <span class="number">0</span>;               <span class="comment">// a不会改变</span></span><br></pre></td></tr></table></figure><p>类似的，如果让一个数组元素不能配置，就不能删除它。如果不能删除它，<code>length</code>属性就不能设置为小于不可配置元素的索引值。</p><hr><h3 id="五、数组元素的添加和删除"><a href="#五、数组元素的添加和删除" class="headerlink" title="五、数组元素的添加和删除"></a>五、数组元素的添加和删除</h3><ul><li><p>push()</p><p>我们可以使用<code>push()</code>方法在数组末尾增加一个或多个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [];</span><br><span class="line">a.push(<span class="string">'zero'</span>);             <span class="comment">// a = ['zero']</span></span><br><span class="line">a.push(<span class="string">'one'</span>, <span class="string">'two'</span>);       <span class="comment">// a = ['zero', 'one', 'two']</span></span><br></pre></td></tr></table></figure><p>在数组尾部压入一个元素与给数组<code>a[a.length]</code>赋值是一样的。</p></li><li><p>unshift()</p><p>可以使用<code>unshift()</code>方法在数组的首部插入一个元素，并且将其他元素依次移到更高的索引处。</p></li><li><p>delete</p><p>可以像删除对象属性一样使用<code>delete</code>运算符来删除数组元素。</p><p>删除数组元素与为其赋值<code>undefined</code>值是类似的（但有一些微妙的区别）。</p><p>注意，对一个数组元素使用<code>delete</code>不会修改数组的<code>length</code>属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，它就变成稀疏数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];</span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> a;                     <span class="comment">// false 数组索引1并未在数组中定义</span></span><br><span class="line">a.length;                   <span class="comment">// 3 delete操作不影响数组长度</span></span><br></pre></td></tr></table></figure></li><li><p>pop()</p><p>可以使用<code>pop()</code>方法，使长度减少1并返回被删除元素的值</p></li><li><p>shift()</p><p>可以使用<code>shift()</code>方法，从数组头部删除一个元素，和<code>delete</code>不同的是，<code>shift()</code>方法将所有元素下移到比当前索引低<code>1</code>的地方</p></li><li><p>splice()</p><p>可以使用<code>splice()</code>方法来插入、删除或替换数组元素，它会根据需要修改<code>length</code>属性并移动元素到更高或更低的索引处</p></li></ul><hr><h3 id="六、数组遍历"><a href="#六、数组遍历" class="headerlink" title="六、数组遍历"></a>六、数组遍历</h3><p>使用<code>for</code>循环是遍历数组元素最常见的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(o);</span><br><span class="line"><span class="keyword">var</span> values = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i= <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i];</span><br><span class="line">    values[i] = o[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在嵌套循环或其他性能非常重要的上下文中，可以看到这种基本的数组遍历需要优化，数组的长度应该只查询一次而非每次循环都要查询</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 循环体不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些例子假设数组是稠密的，并且所有的元素都是合法数组。否则，使用数组元素之前应该先检测它们。如果想要排除<code>null</code>、<code>undefined</code>和不存在的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!a[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果只想跳过undefined和不存在的元素</span></span><br><span class="line">    <span class="keyword">if</span> (a[i] === <span class="literal">undefined</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果只想跳过不存在的元素，仍然要处理存在的undefined元素</span></span><br><span class="line">    <span class="keyword">if</span> (!(i <span class="keyword">in</span> a)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用<code>for/in</code>循环处理稀疏数组。循环每次将一个可枚举的属性名（包括数组索引）赋值给循环变量，不存在索引将不会遍历到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> sparseArray) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = sparseArray[index];</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是由于<code>for/in</code>循环能够枚举继承的属性名，如添加到<code>Array.prototype</code>中的方法，在数组上不应该使用<code>for/in</code>循环，除非使用额外的检测方法来过滤不想要的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="comment">// 跳过继承的属性</span></span><br><span class="line">    <span class="keyword">if</span> (!a.hasOwnProperty(i)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="comment">// 跳过不是非负整数的属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">String</span>(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(i)))) !== i) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES规范允许<code>for/in</code>循环以不同的顺序遍历对象的属性，通常数组元素的遍历实现是升序的，但不能保证一定是这样。特别的，如果数序同时拥有对象属性和数组元素，返回的属性名很可能是按照创建的顺序而非数值的大小顺序。如何处理这个问题的实现各不相同，如果算法依赖于遍历的顺序，那么最好不要使用<code>for/in</code>而用常规的<code>for</code>循环。</p><p>ES5定义了一些遍历数组元素的新方法，按照索引的顺序按个传递给定义的一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sumOfSquares = <span class="number">0</span>;</span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    sumOfSquares += x * x;</span><br><span class="line">&#125;)</span><br><span class="line">sumOfSquares;</span><br></pre></td></tr></table></figure><hr><h3 id="七、多维数组"><a href="#七、多维数组" class="headerlink" title="七、多维数组"></a>七、多维数组</h3><p>JavaScript不支持真正的多维数组，但可以用数组的数组来近似。访问数组的数组中的元素，只要简单地使用两次<code>[]</code>操作符即可。例如，假设变量<code>matrix</code>是一个数组的数组，它的基本元素是数值，那么<code>matrix[x]</code>的每个元素是包含一个数值数组，访问数组中特定数值的代码为<code>matrix[x][y]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> row = <span class="number">0</span>; row &lt; table.length; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (col = <span class="number">0</span>; col &lt; table[row].length; col++) &#123;</span><br><span class="line">        table[row][col] = row * col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> product = table[<span class="number">5</span>][<span class="number">7</span>];              <span class="comment">// =&gt; 35</span></span><br></pre></td></tr></table></figure><hr><h3 id="八、数组方法"><a href="#八、数组方法" class="headerlink" title="八、数组方法"></a>八、数组方法</h3><p>ES3在<code>Array.prototype</code>中定义了一些很有用的操作数组的函数，这意味着这些函数作为任何数组的方法都是可用的。</p><ul><li><p>join()</p><p><code>Array.join()</code>方法将数组中的所有元素都转化为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生成的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。</p><p><code>Array.join()</code>是<code>String.split()</code>方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.join();                               <span class="comment">// =&gt; '1,2,3'</span></span><br><span class="line">a.join(<span class="string">' '</span>);                            <span class="comment">// =&gt; '1 2 3'</span></span><br><span class="line">a.join(<span class="string">''</span>);                             <span class="comment">// =&gt; '123'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line">b.join(<span class="string">'-'</span>);                            <span class="comment">// =&gt; '---------'</span></span><br></pre></td></tr></table></figure></li><li><p>reverse()</p><p><code>Array.reverse()</code>方法将数组中的元素颠倒顺序，返回逆序的数组。它采取了替换，换句话说，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列它们</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.reverse();                    <span class="comment">// =&gt; [3, 2, 1]</span></span><br><span class="line">a == b;                                 <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure></li><li><p>sort()</p><p><code>Array.sort()</code>方法将数组中的元素排序并返回排序后的数组，当不带参数调用<code>sort()</code>时，数组元素以字母表顺序排序（如有必要将临时转化为字符串进行比较）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'banana'</span>, <span class="string">'cherry'</span>, <span class="string">'apple'</span>);</span><br><span class="line">a.sort();</span><br><span class="line"><span class="keyword">var</span> s = a.join(<span class="string">','</span>);                    <span class="comment">// 'apple,banana,cherry'</span></span><br></pre></td></tr></table></figure><p>如果数组包含<code>undefined</code>元素，它们会被排到数组的尾部。</p><p>为了按照其他方式而非字母顺序进行数组排序，必须给<code>sort()</code>方法传递一个比较函数，该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小于0的数值。反之，假设第一个参数应该在后，函数应该返回一个大于0的数值。并且，假设两个值相等（也就是说，它们的顺序无关紧要），函数应该返回0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">33</span>, <span class="number">4</span>, <span class="number">1111</span>, <span class="number">222</span>];</span><br><span class="line">a.sort();                               <span class="comment">// [1111, 222, 33, 4]</span></span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);                                     <span class="comment">// [4, 33, 222, 1111]</span></span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b - a;               </span><br><span class="line">&#125;);                                     <span class="comment">// [1111, 222, 33, 4]</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意，这里使用匿名函数表达式非常方便，既然比较函数只使用一次，就没必要给它们命名了</p></blockquote><h4 id="4-concat"><a href="#4-concat" class="headerlink" title="4. concat()"></a>4. concat()</h4><p>Array.concat()方法创建并返回一个新书组，它的元素包括调用concat()的原是数组的元素和concat()的每个参数。如果这些参数中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，concat()不会递归扁平化的数组，concat()也不会修改调用的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.concat(<span class="number">4</span>, <span class="number">5</span>);                         <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>, <span class="number">5</span>]);                       <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>]);               <span class="comment">// [1,2,3,4,5,6,7]</span></span><br><span class="line">a.concat(<span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]]);               <span class="comment">// [1,2,3,4,5,[6,7]]</span></span><br></pre></td></tr></table></figure><h4 id="5-slice"><a href="#5-slice" class="headerlink" title="5. slice()"></a>5. slice()</h4><p>Array.slice()方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束位置。返回的数组包含第一个参数指定的位置和所有到但不含第二个参数指定的位置之间的所有数组元素。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如参数中出现负数，它表示相对于数组的最后一个元素的位置。</p><p>注意，slice()方法不会修改调用的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.slice(<span class="number">0</span>, <span class="number">3</span>);                          <span class="comment">// [1,2,3]</span></span><br><span class="line">a.slice(<span class="number">3</span>);                             <span class="comment">// [4,5]</span></span><br><span class="line">a.slice(<span class="number">1</span>, <span class="number">-1</span>);                         <span class="comment">// [2,3,4]</span></span><br><span class="line">a.slice(<span class="number">-3</span>, <span class="number">-2</span>);                        <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure><h4 id="6-splice"><a href="#6-splice" class="headerlink" title="6. splice()"></a>6. splice()</h4><p>Array.splice()方法是在数组中插入或删除元素的通用方法，不同于slice()和concat()，splice()会修改调用的数组。</p><p>splice()能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其它部分仍然保持连续的。splice()第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素的个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。splice()返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">a.splice(<span class="number">4</span>);                            <span class="comment">// return [5,6,7,8]  a = [1,2,3,4]</span></span><br><span class="line">a.splice(<span class="number">1</span>, <span class="number">2</span>);                         <span class="comment">// return [2,3]  a = [1,4]</span></span><br><span class="line">a.splice(<span class="number">1</span>, <span class="number">1</span>);                         <span class="comment">// return [4]  a = [1]</span></span><br></pre></td></tr></table></figure><p>splice()的前两个参数指定了需要删除的数组元素，紧随其后的任意个数的参数指定了需要插入到数组的元素，从第一个参数指定的位置开始插入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'b'</span>);               <span class="comment">// return []  a = [1,2,'a','b',3,4,5]</span></span><br><span class="line">a.splice(<span class="number">2</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>);              <span class="comment">// return ['a', 'b']  a = [1,2,[1,2],3,3,4,5]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，区别于concat()，splice()会插入数组本身，而非数组的元素</p></blockquote><h4 id="7-push-和pop"><a href="#7-push-和pop" class="headerlink" title="7. push()和pop()"></a>7. push()和pop()</h4><p>push()和pop()方法允许将数组当作栈来使用。push()方法在数组的尾部添加一个或多个元素，并返回数组新的长度。pop()方法则相反，它删除数组的最后一个元素，减小数组长度并返回它删除的值。组合使用push()和pop()能够用JavaScript数组实现先进后出的栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = [];</span><br><span class="line">stack.push(<span class="number">1</span>, <span class="number">2</span>);                       <span class="comment">// return 2  stack = [1,2]</span></span><br><span class="line">stack.pop();                            <span class="comment">// return 2  stack = [1]</span></span><br><span class="line">stack.push(<span class="number">3</span>);                          <span class="comment">// return 2  stack = [1,3]</span></span><br><span class="line">stack.pop();                            <span class="comment">// return 3  stack = [1]</span></span><br><span class="line">stack.push([<span class="number">4</span>, <span class="number">5</span>]);                     <span class="comment">// return 2  stack = [1,[4,5]]</span></span><br><span class="line">stack.pop();                            <span class="comment">// return [4,5]  stack = [1]</span></span><br><span class="line">stack.pop();                            <span class="comment">// return 1  stack = []</span></span><br></pre></td></tr></table></figure><h4 id="8-unshift-和shift"><a href="#8-unshift-和shift" class="headerlink" title="8. unshift()和shift()"></a>8. unshift()和shift()</h4><p>unshift()和shift()方法的行为类似于push()和pop()，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">a.unshift(<span class="number">1</span>);                           <span class="comment">// return 1  a = [1]</span></span><br><span class="line">a.unshift(<span class="number">22</span>);                          <span class="comment">// return 2  a = [22,1]</span></span><br><span class="line">a.shift();                              <span class="comment">// return 22  a = [1]</span></span><br><span class="line">a.unshift(<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]);                   <span class="comment">// return 3  a = [3,[4,5],1]</span></span><br><span class="line">a.shift();                              <span class="comment">// return 3  a = [[4,5],1]</span></span><br><span class="line">a.shift();                              <span class="comment">// return [4,5]  a = [1]</span></span><br><span class="line">a.shift();                              <span class="comment">// return 1  a = []</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，当使用多个参数调用unshift()时，参数是一次性插入的，而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致。</p></blockquote><h4 id="9-toString-和toLocaleString"><a href="#9-toString-和toLocaleString" class="headerlink" title="9. toString()和toLocaleString()"></a>9. toString()和toLocaleString()</h4><p>数组和其他JavaScript对象一样拥有toString()方法。针对数组，该方法将其每个元素转化为字符串（如有必要将调用元素的toString()方法）并且输出用逗号分隔的字符串列表。注意，输出不包括方括号或其他任何形式的包裹数组值的分隔符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toString();                     <span class="comment">// '1,2,3'</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].toString();               <span class="comment">// 'a,b,c'</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, <span class="string">'c'</span>]].toString();                 <span class="comment">// '1,2,c'</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，这里与不使用任何参数调用join()方法返回的字符串是一样的</p></blockquote><p>toLocaleString()是toString()方法的本地化版本，它调用元素的toLocaleString()方法将每个数组元素转化为字符串，并且使用本地化（和自定义实现的）分隔符将这些字符串连接起来生成最终的字符串</p><hr><h3 id="九、ES5中的数组方法"><a href="#九、ES5中的数组方法" class="headerlink" title="九、ES5中的数组方法"></a>九、ES5中的数组方法</h3><p>ES5定义了9个新的数组方法来遍历、映射、过滤、检测、简化和搜索数组。</p><p>ES5数组方法大多数的第一个参数接收一个函数，并且对数组的每个元素调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。在大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。第二个参数是可选的，如果由第二个参数，则调用的函数被看作是第二个参数的方法，也就是说，在调用函数时传递进度的第二个参数作为它的this关键字的值来使用。</p><h4 id="1-forEach"><a href="#1-forEach" class="headerlink" title="1. forEach()"></a>1. forEach()</h4><p>forEach()方法从头至尾遍历数组，为每个元素调用指定的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    sum += value;</span><br><span class="line">&#125;);</span><br><span class="line">sum;                                        <span class="comment">// =&gt; 15</span></span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v, i, a</span>) </span>&#123;</span><br><span class="line">    a[i] = v + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">data;                                       <span class="comment">// =&gt; [2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，forEach()无法在所有元素都传递给调用的函数之前中止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach()方法放在一个try块中，并能抛出一个异常。如果forEach()调用的函数抛出foreach.break异常，循环会提前终止</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foreach</span>(<span class="params">a, f, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        a.forEach(f, t);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e === foreach.break)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach.break = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'StopIteration'</span>);</span><br></pre></td></tr></table></figure><h4 id="2-map"><a href="#2-map" class="headerlink" title="2. map()"></a>2. map()</h4><p>map()方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">b = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);                                         <span class="comment">// b = [1,4,9]</span></span><br></pre></td></tr></table></figure><p>传递给map()的函数的调用方式和传递给forEach()的函数的调用方式一样。但传递给map()的函数应该由返回值。注意，map()返回的是新书组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素。</p><h4 id="3-filter"><a href="#3-filter" class="headerlink" title="3. filter()"></a>3. filter()</h4><p>filter()方法返回的数组元素是调用的数组的一个子集。传递的函数用来逻辑判定的：该函数返回true或false。调用判定函数就像调用forEach()和map()一样。如果返回值为true或能转化为true的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">smallvalues = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">3</span>; &#125;);          <span class="comment">// [2,1]</span></span><br><span class="line">everyother = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x, i</span>) </span>&#123; <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>; &#125;);   <span class="comment">// [5,3,1]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，filter()会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺，代码如下</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dense = sparse.filter(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;);</span><br></pre></td></tr></table></figure><p>甚至，压缩空缺并删除undefined和null元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x !== <span class="literal">undefined</span> &amp;&amp; x !== <span class="literal">null</span>; &#125;);</span><br></pre></td></tr></table></figure><h4 id="4-every-和some"><a href="#4-every-和some" class="headerlink" title="4. every()和some()"></a>4. every()和some()</h4><p>every()和some()方法是数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回true或false。</p><p>every()方法就像数学中的“针对所有”的量词：当且仅当针对数组中的所有元素调用判定方法都返回true，它才返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">10</span>; &#125;);        <span class="comment">// true  所有值都&lt;10</span></span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>; &#125;);   <span class="comment">// false  不是所有值都是偶数</span></span><br></pre></td></tr></table></figure><p>some()方法就像数学中的“存在”的量词：当数组中至少有一个元素调用判定函数返回true，它就返回true；并且当且仅当数值中的所有元素调用判定函数都返回false，它才返回false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>; &#125;);    <span class="comment">// true  a含有偶数值</span></span><br><span class="line">a.some(<span class="built_in">isNaN</span>);                                  <span class="comment">// false  a不包含非数值元素</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，一旦every()和some()确认该返回什么值它们就会停止遍历数组元素。some()在判定函数第一次返回true后就返回true，但如果判定函数一直返回false，它将会遍历整个数组。every()恰好相反：它在判定函数第一次返回false后就返回false，但如果判定函数一直返回true，它将会遍历整个数组。</p><p>根据数学上的惯例，在空数组上调用时，every()返回true，some()返回false</p></blockquote><h4 id="5-reduce-和reduceRight"><a href="#5-reduce-和reduceRight" class="headerlink" title="5. reduce()和reduceRight()"></a>5. reduce()和reduceRight()</h4><p>reduce()和reduceRight()方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作，也可以称为“注入”和“折叠”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;, <span class="number">0</span>);        <span class="comment">// 数组求和</span></span><br><span class="line"><span class="keyword">var</span> product = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x * y; &#125;, <span class="number">1</span>);    <span class="comment">// 数组求积</span></span><br><span class="line"><span class="keyword">var</span> max = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> (x &gt; y) ? x: y; &#125;);  <span class="comment">// 求最大值</span></span><br></pre></td></tr></table></figure><p>reduce()需要两个参数，第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简后的值。上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的参数是一个传递给函数的初始值。</p><p>当不指定初始值调用reduce()时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就是用了第一个和第二个数组元素作为其第一个和第二个参数。在上面求和与求积的例子中，可以省略初始值参数。</p><p>在空数组上，不带初始值参数调用reduce()将导致类型错误异常。如果调用它的时候只有一个值——数组只有一个元素并且没有指定初始值，或者有一个空数组并且指定一个初始值——reduce()只是简单地返回那个值而不会调用化简函数。</p><p>reduceRight()的工作原理和reduce()一样，不同的是它按照数组索引从高到低处理数组，而不是从低到高。</p><p>在对象章节中，我们定义了一个union()函数，它计算两个对象的“并集”，并返回另一个新对象，新对象具有二者的属性。该函数期待两个对象并返回另一个对象，所以它的工作原理和一个化简函数一样，并且可以使用reduce()来把它一般化，计算任意数目的对象的“并集”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">y</span>:<span class="number">2</span>&#125;, &#123;<span class="attr">z</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> merged = objects.reduce(union);                     <span class="comment">// &#123;x:1, y:2, z:3&#125;</span></span><br></pre></td></tr></table></figure><p>当两个对象拥有同名的属性时，union()函数使用了第一个参数的属性值，这样，reduce()和reduceRight()在使用union()时给出了不同的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">a</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">y</span>:<span class="number">2</span>, <span class="attr">a</span>:<span class="number">2</span>&#125;, &#123;<span class="attr">z</span>:<span class="number">3</span>, <span class="attr">a</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> leftunion = objects.reduce(union);                  <span class="comment">// &#123;x:1, y:2, z:3, a:1&#125;</span></span><br><span class="line"><span class="keyword">var</span> rightunion = objects.reduce(union);                 <span class="comment">// &#123;x:2, y:2, z:3, a:3&#125;</span></span><br></pre></td></tr></table></figure><h4 id="6-indexOf-和lastIndexOf"><a href="#6-indexOf-和lastIndexOf" class="headerlink" title="6. indexOf()和lastIndexOf()"></a>6. indexOf()和lastIndexOf()</h4><p>indexOf()和lastIndexOf()搜索整个数组中具有给定值的元素，返回找到的第一个或最后一个元素的索引，如果没有找到就返回-1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>];</span><br><span class="line">a.indexOf(<span class="number">1</span>);                               <span class="comment">// 1  a[1] == 1</span></span><br><span class="line">a.lastIndexOf(<span class="number">1</span>);                           <span class="comment">// 3  a[3] == 1</span></span><br><span class="line">a.indeOf(<span class="number">3</span>);                                <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p>indexOf()和lastIndexOf()方法不接收函数作为其参数，第一个参数是需要搜索的值，第二个参数是可选的，它指定数组中的一个索引，从指定位置开始搜索。第二个参数也可以是负数，它代表数组末尾的偏移量。</p><blockquote><p>注意，字符串也有indexOf()和lastIndexOf()方法，它们和数组方法的功能类似</p></blockquote><hr><h3 id="十、数组类型"><a href="#十、数组类型" class="headerlink" title="十、数组类型"></a>十、数组类型</h3><p>在ES5中，可以使用Array.isArray()函数来判断未知的对象是否为数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([]);                          <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;);                          <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>ES5以前，要区分数组和非数组对象却令人惊讶地困难。typeof操作符对数组返回“对象”（并且对于除了函数以外的所有对象都是如此）。instanceof操作符只能用于简单的情形</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>;                        <span class="comment">// true</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Array</span>;                      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>使用instanceof的问题是在web浏览器中有可能由多个窗口或窗体(frame)存在，每个窗口都有自己的JavaScript环境，有自己的全局对象。并且，每个全局对象有自己的一组构造函数。因此一个窗体中的对象将不可能是另外窗体中的构造函数的实例。窗体之间的混淆不常发生，但这个问题足以证明instanceof操作符不能视为一个可靠的数组检测方法。</p><p>解决方案是检查对象的类属性，对数组而言该属性的值总是“Array”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = <span class="built_in">Function</span>.isArray || <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> o === <span class="string">'object'</span> &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(o) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="十一、类数组对象"><a href="#十一、类数组对象" class="headerlink" title="十一、类数组对象"></a>十一、类数组对象</h3><p>我们已经看到，JavaScript数组的有一些特性是其他对象所没有的：</p><ul><li><p>当有新的元素添加到列表中时，自动更新length属性</p></li><li><p>设置length为一个较小值将截断数组</p></li><li><p>从Array.prototype中继承一些有用的方法</p></li><li><p>其类属性为“Array”</p></li></ul><p>这些特性让JavaScript数组和常规的对象有明显的区别，但是它们不是定义数组的本质特性。一种常常完全合理的看法把拥有一个数值length属性和对应非负整数属性的对象看作一种类型的数组。</p><p>实践中这些“类数组”对象实际上偶尔出现，虽然不能在它们之上直接调用数组方法或者期望length属性有什么特殊的行为，但是仍然可以用针对真正数组遍历的代码来遍历它们。结论就是很多数组算法针对类数组对象工作得很好，就像针对真正的数组一样。如果算法把数组看成只读的或者如果它们至少保持数组长度不变，也尤其是这种情况。以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的“元素”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="comment">// 添加一些属性，称为“类数组”</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">a.length = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，当作真正的数组遍历它</span></span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">    total += a[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，Arguments对象就是一个类数组对象。在客户端JavaScript中，一些dom方法（如document.getElementsByTagName()）也返回类数组对象。下面有一个函数可以用来检测类数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判定o是否是一个类数组对象</span></span><br><span class="line"><span class="comment">字符串和函数有length属性，但是它们可以用typeof检测将其排除。</span></span><br><span class="line"><span class="comment">在客户端JavaScript中，dom文本节点也有length属性，需要用额外判断o.nodeType != 3将其排除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp;                                        <span class="comment">// o不是null、undefined</span></span><br><span class="line">        <span class="keyword">typeof</span> o === <span class="string">'object'</span> &amp;&amp;                    <span class="comment">// o是对象</span></span><br><span class="line">        <span class="built_in">isFinite</span>(o.length) &amp;&amp;                       <span class="comment">// o.length是有限数值</span></span><br><span class="line">        o.length &gt;= <span class="number">0</span> &amp;&amp;                            <span class="comment">// o.length为非负值</span></span><br><span class="line">        o.length === <span class="built_in">Math</span>.floor(o.length) &amp;&amp;        <span class="comment">// o.length是整数</span></span><br><span class="line">        o.length &lt; <span class="number">4294967296</span>&gt;)                     <span class="comment">// o.length &lt; 2e32</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后文中我们可以看到在ES5中字符串的行为与数组类似，然而，类似上述的类数组对象的检测方法针对字符串常常返回false——它们最好当作字符串处理，而非数组。</p><p>JavaScript数组方法是特意定义为通用的，因此它们不仅应用在真正的数组而且在类数组对象上都能正确工作。除了toString()和toLocaleString()以外的方法都是通用的。</p><p>concat()方法是一个特例，虽然可以用在类数组对象上，但它没有将那个对象扩充进返回的数组中。</p><p>既然类数组对象没有继承自Array.prototype，那就不能在它们上面直接调用数组方法。尽管如此，可以间接地使用Function.call方法调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="string">'0'</span>: <span class="string">'a'</span>, <span class="string">'1'</span>: <span class="string">'b'</span>, <span class="string">'3'</span>: <span class="string">'c'</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(a, <span class="string">'+'</span>);                  <span class="comment">// 'a+b+c'</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(a, <span class="number">0</span>);                   <span class="comment">// ['a','b','c']  真正数组的副本</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.map.call(a, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.toUpperCase();</span><br><span class="line">&#125;);                                                 <span class="comment">// ['A','B','C']</span></span><br></pre></td></tr></table></figure><hr><h3 id="十二、作为数组的字符串"><a href="#十二、作为数组的字符串" class="headerlink" title="十二、作为数组的字符串"></a>十二、作为数组的字符串</h3><p>在ES5中，字符串的行为类似于只读的数组。除了用charAt()方法来访问单个的字符以外，还可以使用方括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'test'</span>;</span><br><span class="line">s.charAt(<span class="number">0</span>);                                    <span class="comment">// 't'</span></span><br><span class="line">s[<span class="number">1</span>];                                           <span class="comment">// 'e'</span></span><br></pre></td></tr></table></figure><p>当然，针对字符串的typeof操作符仍然返回”string”，但是如果给Array.isArray()传递字符串，它将会返回false。</p><p>可索引的字符串的最大的好处就是简单，用方括号代替了charAt()调用，这样更加简洁、可读并且可能更高效。不仅如此，字符串的行为类似于数组的事实使得通用的数组方法可以应用到字符串上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'JavaScript'</span>;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(s, <span class="string">' '</span>);              <span class="comment">// 'J a v a S c r i p t'</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.filter.call(s, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.match(<span class="regexp">/[^aeiou]/</span>);                 <span class="comment">// 只匹配非元音字母</span></span><br><span class="line">&#125;).join(<span class="string">''</span>);                                    <span class="comment">// 'JvScrpt'</span></span><br></pre></td></tr></table></figure><p>请记住，字符串是不可变值，故当把它们作为数组看待时，它们是只读的。如push()、sort()、reverse()和splice()等数组方法会修改数组，它们在字符串上是无效的。不仅如此，使用数组方法来修改字符串会导致错误：出错的时候没有提示。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组是值的有序集合，每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。JavaScript数组的索引是基于零的32位数，第一个元素的索引为0，最大可能的索引为&lt;code&gt;4 294 967 294&lt;/code&gt;（&lt;code&gt;2e32-2&lt;/code&gt;），数组最大能容纳&lt;code&gt;4 294 967 295&lt;/code&gt;个元素。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript数组" scheme="http://www.xiaoleon.cn/tags/JavaScript%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JS(2) 对象</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/js-2/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/js-2/</id>
    <published>2018-01-22T14:27:54.000Z</published>
    <updated>2018-01-28T15:07:26.195Z</updated>
    
    <content type="html"><![CDATA[<p>对象是JavaScript的基本数据类型。对象是一种复合值：它将很多值（原始值或者其他对象）聚合在一起，可以通过名字访问这些值。对象也可看作是属性的无序集合，每个属性都是一个名值对，属性名是字符串，因此我们可以把对象看成是从字符串到值的映射。</p><a id="more"></a><p>JavaScript对象还可以从一个称为原型的对象继承属性，对象的方法通常是继承的属性，这种原型式继承（<code>prototypal inheritance</code>）是JavaScript的核心特征。</p><p>对象最常见的用法是创建（<code>create</code>）、设置（<code>set</code>）、查找（<code>query</code>）、删除（<code>delete</code>）、检测（<code>test</code>）和枚举（<code>enumerate</code>）它的属性。属性包括名字和值，属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性，值可以是任意JavaScript值，或者可以是一个<code>getter</code>或<code>setter</code>函数。除了名字和值以外，每个属性还有一些与之相关的值，称为“属性特征”（<code>property attribute</code>）。</p><ul><li><p>可写（<code>writable attribute</code>），表明是否可以设置该属性的值。</p></li><li><p>可枚举（<code>enumerable attribute</code>），表明是否可以通过<code>for/in</code>循环返回该属性。</p></li><li><p>可配置（<code>configurable attribute</code>），表明是否可以删除或修改该属性。</p></li></ul><p>除了包含属性之外，每个对象还拥有三个相关的对象特性（<code>object attribute</code>）：</p><ul><li><p>对象的原型（<code>prototype</code>）指向另外一个对象，本对象的属性继承自它的原型对象。</p></li><li><p>对象的类（<code>class</code>）是一个标识对象类型的字符串。</p></li><li><p>对象的扩展标记（<code>extensible flag</code>）指明了是否可以向该对象添加新属性。</p></li></ul><p>最后，我们用下面这些术语来对三类JavaScript对象和两类属性作区分：</p><ul><li><p>内置对象（<code>native object</code>）是由ECMAScript规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。</p></li><li><p>宿主对象（<code>host object</code>）是由JavaScript解释器所嵌入的宿主环境（比如Web浏览器）定义的。客户端JavaScript中表示网页结构的<code>HTMLElement</code>对象均是宿主对象。既然宿主环境定义的方法可以当成普通的JavaScript函数对象，那么宿主对象也可以当成内置对象。</p></li><li><p>自定义对象（<code>user-defined object</code>）是由运行中的JavaScript代码创建的对象。</p></li><li><p>自有属性（<code>own property</code>）是直接在对象中定义的属性。</p></li><li><p>继承属性（<code>inherited property</code>）是在对象的原型对象中定义的属性。</p></li></ul><h3 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h3><p>可以通过对象直接量、关键字<code>new</code>和<code>Object.create()</code>函数来创建对象。</p><h4 id="1-对象直接量"><a href="#1-对象直接量" class="headerlink" title="1. 对象直接量"></a>1. 对象直接量</h4><p>创建对象最简单的方式就是在JavaScript代码中使用对象直接量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emtpy = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> point = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="string">"main title"</span>: <span class="string">"Javascript"</span>,</span><br><span class="line">    <span class="string">'sub-title'</span>: <span class="string">'The Definitive Guide'</span>,</span><br><span class="line">    author: &#123;</span><br><span class="line">        firstname: <span class="string">'David'</span>,</span><br><span class="line">        surname: <span class="string">'Flanagan'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象直接量是一个表达式，这个表达式的每次运算都会创建并初始化一个新的对象。每次计算对象直接量的时候，也都会计算它的每个属性的值。也就是说，如果在一个重复调用的函数中的循环体内使用了对象直接量，它将创建很多新对象，并且每次创建的对象的属性值也有可能不同。</p><h4 id="2-通过new创建对象"><a href="#2-通过new创建对象" class="headerlink" title="2. 通过new创建对象"></a>2. 通过new创建对象</h4><p>new运算符创建并初始化一个新对象。关键字<code>new</code>后跟随一个函数调用。这里的函数称作构造函数（<code>constructor</code>），构造函数用以初始化一个新创建的对象。JavaScript语言核心中的原始类型都包含内置构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'js'</span>);</span><br></pre></td></tr></table></figure><h4 id="3-原型"><a href="#3-原型" class="headerlink" title="3. 原型"></a>3. 原型</h4><p>每一个JavaScript对象（<code>null</code>除外）都和另一个对象相关联。“另一个”对象就是我们熟知的原型，每一个对象都从原型继承属性。</p><p>所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过JavaScript代码<code>Object.prototype</code>获得原型对象的引用。通过关键字<code>new</code>和构造函数调用创建的对象的原型就是构造函数的<code>prototype</code>属性的值。因此，同使用<code>{}</code>创建对象一样，通过<code>new Object()</code>创建的对象也继承自<code>Object.prototype</code>。同样，通过<code>new Array()</code>创建的对象的原型就是<code>Array.prototype</code>，通过<code>new Date()</code>创建的对象的原型就是<code>Date.prototype</code>。</p><p>没有原型的对象不多，<code>Object.prototype</code>就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自<code>Object.prototype</code>的原型。例如，<code>Date.prototype</code>的属性继承自<code>Object.prototype</code>，因此由<code>new Date()</code>创建的<code>Date</code>对象的属性同时继承自<code>Date.prototype</code>和<code>Object.prototype</code>。这一系列链接的原型对象就是所谓的“原型链”（<code>prototype chain</code>）。</p><h4 id="4-Object-create"><a href="#4-Object-create" class="headerlink" title="4. Object.create()"></a>4. Object.create()</h4><p>ECMAScript5定义了一个<code>Object.create()</code>方法，它创建一个新对象，其中第一个参数是这个对象的原型，并提供第二个可选参数，用以对对象的属性进行进一步描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// o1继承了属性x和y</span></span><br><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p>可以通过传入参数<code>null</code>来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如<code>toString()</code>，也就是说，它将不能和<code>“+”</code>运算符一起正常工作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// o2不继承任何属性和方法</span></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>如果想创建一个普通的空对象（比如通过<code>{}</code>或<code>new Object()</code>创建的对象），需要传入<code>Object.prototype</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// o3和&#123;&#125;和new Object()一样</span></span><br><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure><blockquote><p><strong>可以通过任意原型创建新对象（换句话说，可以使任意对象可继承），这是一个强大的特性。</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inherit()返回一个继承自原型对象p的属性的新对象</span></span><br><span class="line"><span class="comment">// 这里使用ECMAScript5中的Object.create()函数（如果存在的话）</span></span><br><span class="line"><span class="comment">// 如果不存在，则退化使用其他方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// p是一个对象，但不能是null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>();              </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.create)</span><br><span class="line">        <span class="comment">// 如果Object.create()存在，直接使用它</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(p);</span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> p;</span><br><span class="line">    <span class="keyword">if</span> (t !== <span class="string">'object'</span> &amp;&amp; t !== <span class="string">'function'</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    <span class="comment">// 定义一个空构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 将其原型属性设置为p</span></span><br><span class="line">    f.prototype = p;</span><br><span class="line">    <span class="comment">// 使用f()创建p的继承对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，<code>inherit()</code>方法并不能完全代替<code>Object.create()</code>，它不能通过传入<code>null</code>原型来创建对象，而且不能接收可选的第二个参数。</p></blockquote><p><code>inherit()</code>函数的其中一个用途就是防止库函数无意间（非恶意地）修改那些不受控制的对象。不是将对象直接作为参数传入函数，而是将它的继承对象传入函数。当函数读取继承对象的属性时，实际上读取的是继承来的值。如果给继承对象的属性赋值，则这些属性只会影响这个继承对象自身，而不是原始对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="string">"don't change this value"</span> &#125;;</span><br><span class="line"><span class="comment">// 防止对o的意外修改</span></span><br><span class="line">library_function(inherit(o));</span><br></pre></td></tr></table></figure><hr><h3 id="二、属性的查询和设置"><a href="#二、属性的查询和设置" class="headerlink" title="二、属性的查询和设置"></a>二、属性的查询和设置</h3><p>对象可以通过点（<code>.</code>）或方括号（<code>[]</code>）运算符来获取属性的值。运算符左侧应当是一个表达式，它返回一个对象。对于点（<code>.</code>）来说，右侧必须是一个以属性名称命名的简单标识符。对于方括号来说（<code>[]</code>），方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> author = book.author;</span><br><span class="line"><span class="keyword">var</span> name = author.surname;</span><br><span class="line"><span class="keyword">var</span> title = book[<span class="string">'main title'</span>];</span><br></pre></td></tr></table></figure><p>当使用方括号时，严格来讲，表达式必须返回字符串或者返回一个可以转换为字符串的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> author = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">'John'</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">'Green'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(author[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h4 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h4><p>JavaScript对象具有“自有属性”（<code>own property</code>），也有一些属性是从原型对象继承而来的。假设要查询对象<code>o</code>的属性<code>x</code>，如果<code>o</code>中不存在<code>x</code>，那么将会继续在<code>o</code>的原型对象中查询属性<code>x</code>。如果原型对象中也没有<code>x</code>，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到<code>x</code>或者查到一个原型是<code>null</code>的对象为止。可以看到，对象的原型属性构成了一个“链”，通过这个“链”可以实现属性的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;             <span class="comment">// o从Object.prototype继承对象的方法</span></span><br><span class="line">o.x = <span class="number">1</span>;                <span class="comment">// 给o定义一个属性x</span></span><br><span class="line"><span class="keyword">var</span> p = inherit(o);     <span class="comment">// p继承o和Object.prototype</span></span><br><span class="line">p.y = <span class="number">2</span>;                <span class="comment">// 给p定义一个属性y</span></span><br><span class="line"><span class="keyword">var</span> q = inherit(p);     <span class="comment">// q继承p、o和Object.prototype</span></span><br><span class="line">q.z = <span class="number">3</span>;                <span class="comment">// 给q定义一个属性z</span></span><br><span class="line"><span class="keyword">var</span> s = q.toString()    <span class="comment">// toString继承自Object.prototype</span></span><br><span class="line">q.x + q.y               <span class="comment">// =&gt; 3  x和y分别继承自o和p</span></span><br></pre></td></tr></table></figure><p>现在假设给对象<code>o</code>的属性<code>x</code>赋值，如果<code>o</code>中已经有属性<code>x</code>（这个属性不是继承来的），那么这个赋值操作只改变这个已有属性<code>x</code>的值。如果<code>o</code>中不存在属性<code>x</code>，那么赋值操作给<code>o</code>添加一个新属性<code>x</code>。如果之前<code>o</code>继承自属性<code>x</code>，那么这个继承的属性就被新创建的同名属性覆盖了。</p><p>属性赋值操作首先检查原型链，以此判定是否允许赋值操作。例如，如果<code>o</code>继承自一个只读属性x，那么赋值操作是不允许的。如果允许属性赋值操作，它也总是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链。在Javascript中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关，这是JavaScript的一个重要特性，该特性让程序员可以有选择地覆盖（<code>override</code>）继承的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unitcircle = &#123; <span class="attr">r</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> c = inherit(unitcircle);</span><br><span class="line">c.x = <span class="number">1</span>; c.y = <span class="number">1</span>;</span><br><span class="line">c.r = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(unitcircle.r);      <span class="comment">// =&gt; 1，原型对象没有修改</span></span><br></pre></td></tr></table></figure><p>属性赋值要么失败，要么创建一个属性，要么在原始对象中设置属性，但有一个例外，如果<code>o</code>继承自属性<code>x</code>，而这个属性是一个具有<code>setter</code>方法的<code>accessor</code>属性，那么这时将调用<code>setter</code>方法而不是给<code>o</code>创建一个属性。需要注意的是，<code>setter</code>方法是由对象<code>o</code>调用的，而不是定义这个属性的原型对象调用的。因此如果<code>setter</code>方法定义在原型上，这个操作只针对<code>o</code>本身，并不会修改原型链。</p><h4 id="2-属性访问错误"><a href="#2-属性访问错误" class="headerlink" title="2. 属性访问错误"></a>2. 属性访问错误</h4><p>属性访问并不总是返回或设置一个值。查询一个不存在的属性并不会报错，如果在对象o自身的属性或继承的属性中均为找到属性x，属性访问表达式<code>o.x</code>返回<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.subtitle;      <span class="comment">// =&gt; undefined，属性不存在</span></span><br></pre></td></tr></table></figure><p>但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错，<code>null</code>和<code>undefined</code>值都没有属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> len = book.subtitle.length;     <span class="comment">// 抛出类型错误异常，undefined没有length属性</span></span><br></pre></td></tr></table></figure><p>除非确定<code>book</code>和<code>book.subtitle</code>都是对象，否则不能这样书写，应采用如下方法避免出错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">var</span> len = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (book) &#123;</span><br><span class="line">    <span class="keyword">if</span> (book.subtitle) &#123;</span><br><span class="line">        len = book.subtitle.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length;</span><br></pre></td></tr></table></figure><p>当然，给<code>null</code>和<code>undefined</code>设置属性也会报类型错误，给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性，但让人颇感意外的是，这些设置属性的失败操作不会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype = <span class="number">0</span>;       <span class="comment">// 赋值失败，但没报错，Object.prototype没有修改</span></span><br></pre></td></tr></table></figure><p>严格模式下，任何失败的属性设置操作都会抛出一个类型错误异常。</p><p>在以下场景下给对象<code>o</code>设置属性p会失败：</p><ul><li><p><code>o</code>中的属性p是只读的：不能给只读属性重新赋值（<code>defineProperty()</code>方法中有一个例外，可以对可配置的只读属性重新赋值）。</p></li><li><p><code>o</code>中的属性p是继承属性，且它是只读的：不能通过同名自有属性覆盖只读的继承属性。</p></li><li><p><code>o</code>中不存在自有属性<code>p</code>：<code>o</code>没有使用<code>setter</code>方法继承属性<code>p</code>，并且<code>o</code>的可扩展性（<code>extensible attribute</code>）是<code>false</code>。如果<code>o</code>中不存在<code>p</code>，而且没有<code>setter</code>方法可供调用，则<code>p</code>一定会添加至<code>o</code>中。但如果<code>o</code>不是可扩展的，那么在<code>o</code>中不能定义新属性。</p></li></ul><hr><h3 id="三、删除属性"><a href="#三、删除属性" class="headerlink" title="三、删除属性"></a>三、删除属性</h3><p><code>delete</code>运算符可以删除对象的属性。让人感到意外的是，<code>delete</code>只是断开属性和宿主对象的联系，而不会去操作属性中的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> book.author;</span><br><span class="line"><span class="keyword">delete</span> book[<span class="string">'main title'</span>];</span><br></pre></td></tr></table></figure><p><code>delete</code>运算符只能删除自有属性，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象）。</p><p>当<code>delete</code>表达式删除成功或没有任何副作用（比如删除不存在的属性）时，它返回<code>true</code>。如果<code>delete</code>后不是一个属性访问表达式，<code>delete</code>同样返回<code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// 删除x，返回true</span></span><br><span class="line"><span class="keyword">delete</span> o.x;</span><br><span class="line"><span class="comment">// 什么都没做，返回true</span></span><br><span class="line"><span class="keyword">delete</span> o.x;</span><br><span class="line"><span class="comment">// 什么都没做（toString是继承来的），返回true</span></span><br><span class="line"><span class="keyword">delete</span> o.toString();</span><br><span class="line"><span class="comment">// 无意义，返回true</span></span><br><span class="line"><span class="keyword">delete</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><code>delete</code>不能删除那些可配置性为<code>false</code>的属性（尽管可以删除不可扩展对象的可配置属性）。某些内置对象的属性是不可配置的，比如通过变量声明和函数声明创建的全局对象的属性。</p><p>在非严格模式中，以下情况的<code>delete</code>操作会返回<code>false</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能删除，属性是不可配置的</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype;</span><br><span class="line"><span class="comment">// 声明一个全局变量</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 不能删除这个属性</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.x;</span><br><span class="line"><span class="comment">// 声明一个全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 不能删除这个全局函数</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.f;</span><br></pre></td></tr></table></figure><p>当在非严格模式中删除全局对象的可配置属性时，可以省略对全局对象的引用，直接在<code>delete</code>操作符后跟随要删除的属性名即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个可配置的全局属性（没有用var）</span></span><br><span class="line"><span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 删除属性，返回true</span></span><br><span class="line"><span class="keyword">delete</span> x;</span><br></pre></td></tr></table></figure><p>然而在严格模式下，<code>delete</code>后跟随一个非法的操作数（比如x），则会报一个语法错误，因此必须显式指定对象及其属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格模式下报语法错误</span></span><br><span class="line"><span class="keyword">delete</span> x;</span><br><span class="line"><span class="comment">// 正常工作</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.x;</span><br></pre></td></tr></table></figure><hr><h3 id="四、检测属性"><a href="#四、检测属性" class="headerlink" title="四、检测属性"></a>四、检测属性</h3><p>JavaScript对象可以看作属性的集合，我们经常会检测集合中成员的所属关系——判断某个属性是否存在于某个对象中。可以通过<code>in</code>运算符、<code>hasOwnProperty()</code>和<code>propertyIsEnumerable()</code>方法来完成这个工作，甚至仅通过属性查询也可以做到这一点。</p><p><code>in</code>运算符的左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;           <span class="comment">// true</span></span><br><span class="line"><span class="string">"y"</span> <span class="keyword">in</span> o;           <span class="comment">// false</span></span><br><span class="line"><span class="string">"toString"</span> <span class="keyword">in</span> o;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>对象的<code>hasOwnProperty()</code>方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将会返回<code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">o.hasOwnProperty(<span class="string">"x"</span>);          <span class="comment">// true</span></span><br><span class="line">o.hasOwnProperty(<span class="string">"y"</span>);          <span class="comment">// false</span></span><br><span class="line">o.hasPownProperty(<span class="string">'toString'</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>propertyIsEnumerable()</code>是<code>hasOwnProperty()</code>的增强版，只有检测到是自有属性且这个属性的可枚举性（<code>enumerable attribute</code>）为<code>true</code>时它才返回<code>true</code>。某些内置属性是不可枚举的。通常由JavaScript代码创建的属性都是可枚举的，除非在ECMAScript5中使用一个特殊的方法来改变属性的可枚举性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = inherit(&#123; <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br><span class="line">o.x = <span class="number">1</span>;</span><br><span class="line">o.propertyIsEnumerable(<span class="string">'x'</span>);            <span class="comment">// true</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">'y'</span>);            <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.propertyIsEnumerable(<span class="string">'toString'</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>除了使用in运算符之外，另一种更简便的方法是使用<code>“!==”</code>判断一个属性是否是<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line">o.x !== <span class="literal">undefined</span>;          <span class="comment">// true</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>;          <span class="comment">// false</span></span><br><span class="line">o.toString !== <span class="literal">undefined</span>    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是有一种场景只能使用in运算符而不能使用上述属性访问的方式。in可以区分不存在的属性和存在但值为<code>undefined</code>的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">o.x !== <span class="literal">undefined</span>;          <span class="comment">// false</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>;          <span class="comment">// false</span></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;                   <span class="comment">// true</span></span><br><span class="line"><span class="string">"y"</span> <span class="keyword">in</span> o;                   <span class="comment">// false</span></span><br><span class="line"><span class="keyword">delete</span> o.x;                 <span class="comment">// true</span></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;                   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，上述代码中使用的是<code>“!==”</code>运算符，而不是<code>“!=”</code>。<code>“!==”</code>可以区分<code>undefined</code>和<code>null</code></p></blockquote><hr><h3 id="五、枚举属性"><a href="#五、枚举属性" class="headerlink" title="五、枚举属性"></a>五、枚举属性</h3><p>除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用<code>for/in</code>循环便利，ECMAScript5提供了两个更好用的替代方案。</p><p><code>for/in</code>循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承属性），把属性名称赋值给循环变量。对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的（除非使用下文中提到的一个方法将它们转换为不可枚举的）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;;</span><br><span class="line">o.propertyIsEnumerable(<span class="string">'toString'</span>);     <span class="comment">// false</span></span><br><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p);                     <span class="comment">// 输出x、y和z，不会输出toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有许多实用工具库给<code>Object.prototype</code>添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。然而在ECMAScript5之前，这些新添加的方法是不能定义为不可枚举的，因此它们都可以在<code>for/in</code>循环中枚举出来，因此需要过滤<code>for/in</code>循环中的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!o.hasOwnProperty(p))</span><br><span class="line">        <span class="comment">// 跳过继承的属性</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> o[p] === <span class="string">'function'</span>)</span><br><span class="line">        <span class="comment">// 跳过方法</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下方工具函数用来控制对象的属性，这些函数用到了<code>for/in</code>循环。实际上<code>extend()</code>函数经常出现在JavaScript实用工具库中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">把p中的可枚举属性复制到o中，并返回o</span></span><br><span class="line"><span class="comment">如果o和p中含有同名属性，则覆盖o中的属性</span></span><br><span class="line"><span class="comment">这个函数并不处理getter和setter以及复制属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历p中的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> p) &#123;</span><br><span class="line">        <span class="comment">// 将属性添加至o中</span></span><br><span class="line">        o[prop] = p[prop]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将p中的可枚举属性复制到o中，并返回o</span></span><br><span class="line"><span class="comment">如果o和p中有同名的属性，o中的属性将不受影响</span></span><br><span class="line"><span class="comment">这个函数并不处理getter和setter以及复制属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历p中的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> p) &#123;</span><br><span class="line">        <span class="comment">// 过滤掉已经在o中存在的属性</span></span><br><span class="line">        <span class="keyword">if</span> (o.hasOwnProperty(prop))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 将属性添加至o中</span></span><br><span class="line">        o[prop] = p[prop];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果o中的属性在p中没有同名属性，则从o中删除这个属性，并返回o</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restrict</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历p中的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="comment">// 如果在p中不存在，则删除</span></span><br><span class="line">        <span class="keyword">if</span> (!(prop <span class="keyword">in</span> p))</span><br><span class="line">            <span class="keyword">delete</span> o[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果o中的属性在p中存在同名属性，则从o中删除这个属性，并返回o</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历p中的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> p) &#123;</span><br><span class="line">        <span class="comment">// 从o中删除（删除一个不存在的属性不会报错）</span></span><br><span class="line">        <span class="keyword">delete</span> o[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回一个新对象，这个对象同时拥有o的属性和p的属性，</span></span><br><span class="line"><span class="comment">如果o和p中有重名属性，使用p中的属性值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> extend(extend(&#123;&#125;, o), p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回一个新对象，这个对象拥有同时在o和p中出现的属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restrict(extend(&#123;&#125;, o), p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回一个数组，这个数组包含的是o中可枚举的自有属性的名字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keys</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 参数必须是对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> o !== <span class="string">'object'</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="comment">// 判断是否是自有属性</span></span><br><span class="line">        <span class="keyword">if</span> (o.hasOwnProperty(prop)) &#123;</span><br><span class="line">            result.push(prop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了<code>for/in</code>循环之外，ECMAScript5定义了两个用以枚举属性名称的函数</p><ul><li><p>第一个是<code>Object.keys()</code>，它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。</p></li><li><p>第二个是<code>Object.getOwnPropertyNames()</code>，它和<code>Object.keys()</code>类似，只是它返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。</p></li></ul><hr><h3 id="六、属性getter和setter"><a href="#六、属性getter和setter" class="headerlink" title="六、属性getter和setter"></a>六、属性getter和setter</h3><p>对象属性是由名字、值和一对特性（<code>attribute</code>）构成的，在ES5中，属性值可以用一个或两个方法替代，这两个方法就是<code>getter</code>和<code>setter</code>。由<code>getter</code>和<code>setter</code>定义的属性称作“存取器属性”（<code>accessor property</code>），它不同于“数据属性”（<code>data property</code>），数据属性只有一个简单的值。</p><p>当程序查询存取器属性的值时，JavaScript调用<code>getter</code>方法。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript调用<code>setter</code>方法，将赋值表达式右侧的值当作参数传入<code>setter</code>。从某种意义上讲，这个方法负责“设置”属性值，可以忽略<code>setter</code>方法的返回值。</p><p>和数据属性不同，存取器属性不具有可写性（<code>writable attribute</code>）。如果属性同时具有<code>getter</code>和<code>setter</code>方法，那么它是一个读/写属性。如果它只有<code>getter</code>方法，那么它是一个只读属性。如果它只有<code>setter</code>方法，那么它是一个只写属性（数据属性中有一些例外），读取只写属性总是返回<code>undefined</code>。</p><p>定义存取器属性最简单的方法是使用对象直接量语法的一种扩展写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    data_prop: value,</span><br><span class="line"></span><br><span class="line">    get accessor_prop() &#123;</span><br><span class="line">        <span class="comment">// 函数体</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set accessor_prop(value) &#123;</span><br><span class="line">        <span class="comment">// 函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和数据属性一样，存取器属性是可以继承的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = inherit(o);</span><br><span class="line"><span class="built_in">console</span>.log(p.accessor_prop);</span><br></pre></td></tr></table></figure><p>还有很多场景可以用到存取器属性，比如智能检测属性的写入值以及在每次属性读取时返回不同值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个对象产生严格自增的序列号</span></span><br><span class="line"><span class="keyword">var</span> serialnum = &#123;</span><br><span class="line">    <span class="comment">// 这个数据属性包含下一个序列号</span></span><br><span class="line">    <span class="comment">// $符号暗示这个属性是一个私有属性</span></span><br><span class="line">    $n: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前值，然后自增</span></span><br><span class="line">    get next() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给n设置新的值，但只有当它比当前值大时才能设置成功</span></span><br><span class="line">    set next(n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="keyword">this</span>.$n)</span><br><span class="line">            <span class="keyword">this</span>.$n = n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="string">'序列号的值不能比当前值小'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="七、属性的特性"><a href="#七、属性的特性" class="headerlink" title="七、属性的特性"></a>七、属性的特性</h3><p>除了包含名字和值之外，属性还包含一些标识它们可写、可枚举和可配置的特性。本节将讲述ES5中查询和设置这些属性特性的API</p><ul><li><p>可以通过这些API给原型对象添加方法，并将它们设置成不可枚举的，这让它们看起来更像内置方法</p></li><li><p>可以通过这些API给对象定义不能修改或删除的属性，借此“锁定”这个对象</p></li></ul><p>我们将存取器属性的<code>getter</code>和<code>setter</code>方法看成是属性的特性，按照这个逻辑，我们也可以把数据属性的值同样看作属性的特性。因此，可以认为一个属性包含一个名字和4个特性。</p><p><strong><em>数据属性的4个特性分别是它的值（<code>value</code>）、可写性（<code>writable</code>）、可枚举性（<code>enumerable</code>）和可配置性（<code>configurable</code>）</em></strong></p><p>存取器属性不具有值（<code>value</code>）特性和可写性，它们的可写性是由<code>setter</code>方法存在与否决定的。因此存取器属性的4个特性是读取（<code>get</code>）、写入（<code>set</code>）、可枚举性和可配置性。</p><p>为了实现属性特性的查询和设置操作，ES5定义了一个名为“属性描述符”（<code>property descriptor</code>）的对象，这个对象代表那4个特性。描述符对象的属性有<code>value</code>、<code>writable</code>、<code>enumerable</code>和<code>configurable</code>。存取器属性的描述符对象则用<code>get</code>属性和<code>set</code>属性代替<code>value</code>和<code>writable</code>。其中<code>writable</code>、<code>enumerable</code>和<code>configurable</code>都是布尔值，当然，<code>get</code>属性和<code>set</code>属性是函数值。</p><p>通过调用<code>Object.getOwnPropertyDescriptor()</code>可以获得某个对象特定属性的属性描述符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, <span class="string">'x'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return &#123;get: /*func*/, set: undefined, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    get accessor_prop() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">'accessor_prop'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return undefined 没有这个属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">'x'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return undefined 继承属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">'toString'</span>);</span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptor()</code>只能得到自有属性的描述符，如果想要获得继承属性的特性，需要遍历原型链。如果想要设置属性的特性，或者想让新建属性具有某种特性，则需要调用<code>Object.defineProperty()</code>，传入要修改的对象、要创建或修改的属性的名称以及属性描述符对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个不可枚举的属性x，并赋值为1</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'x'</span>, &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.x;        <span class="comment">// =&gt; 1 属性存在</span></span><br><span class="line">o.keys();   <span class="comment">// =&gt; [] 属性不可枚举</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改属性x，变为只读</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'x'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.x = <span class="number">2</span>;    <span class="comment">// 操作失败但不报错，严格模式中会抛出异常</span></span><br><span class="line">o.x;        <span class="comment">// =&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性依然可配置，因此可以通过这种方式进行修改</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'x'</span>, &#123;</span><br><span class="line">    value: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line">o.x;        <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改x从数据属性变为存取器属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'x'</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;);</span><br><span class="line">o.x;        <span class="comment">// =&gt; 0</span></span><br></pre></td></tr></table></figure><p>传入<code>Object.defineProperty()</code>的属性描述符对象不必包含所有4个特性，对于新创建的属性来说，默认的特性值是<code>false</code>或<code>undefined</code>。对于修改的已有属性来说，默认的特性值没有做任何修改。注意，这个方法要么修改已有属性要么新建自有属性，但不能修改继承属性。</p><p>如果要同时修改或创建多个属性，则需要使用<code>Object.defineProperties()</code>。第一个参数是要修改的对象，第二个参数是一个映射表，它包含要新建或修改的属性的名称，以及它们的属性描述符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">    x: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    y: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    r: &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="keyword">this</span>.x * <span class="keyword">this</span>.x + <span class="keyword">this</span>.y * <span class="keyword">this</span>.y); &#125;,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段代码从一个空对象开始，然后给它添加两个数据属性和一个只读存取器属性。最终<code>Object.defineProperties()</code>返回修改后的对象（和<code>Object.defineProperty()</code>一样）。</p><p>对于那些不允许创建或修改的属性来说，如果用<code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>对其操作就会抛出类型错误异常，比如给一个不可扩展的对象新增属性就会抛出类型错误异常。造成这些方法抛出类型错误异常的其他原因则和特性本身相关。可写性控制着对值特性的修改。可配置性控制着对其他特性（包括属性是否可以删除）的修改。然而规则远不止这么简单，例如，如果属性是可配置的话，则可以修改不可写属性的值。同样，如果属性是不可配置的，仍然可以将可写属性修改为不可写属性。下面是完整规则，任何对<code>Object.defineProperty()</code>或<code>Object.defineProperties()</code>违反规则的使用都会抛出类型错误异常</p><ul><li><p>如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性</p></li><li><p>如果属性是不可配置的，则不能修改它的可配置性和可枚举性</p></li><li><p>如果存取器属性是不可配置的，则不能修改其<code>getter</code>和<code>setter</code>方法，也不能将它转换为数据属性</p></li><li><p>如果数据属性是不可配置的，则不能将它转换为存取器属性</p></li><li><p>如果数据属性是不可配置的，则不能将它的可写性从<code>false</code>修改为<code>true</code>，但可以从<code>true</code>修改为<code>false</code></p></li><li><p>如果数据属性是不可配置且不可写的，则不能修改它的值。然而可配置但不可写属性的值是可以修改的（实际上是先将它标记为可写的，然后修改它的值，最后转换为不可写的）。</p></li></ul><p>上文中的<code>extend()</code>函数，只是简单的复制属性名和值，没有复制属性的特性，而且也没有复制存取器属性的<code>getter</code>和<code>setter</code>方法，只是将它们简单的转换为静态的数据属性。下面给出改进的<code>extend()</code>，它使用<code>Object.getOwnPropertyDescriptor()</code>和<code>Object.defineProperty()</code>对属性的所有特性进行复制。新的<code>extend()</code>作为不可枚举属性添加到<code>Object.prototype</code>中，因此它是<code>Object</code>上定义的方法，而不是一个独立的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给Object.prototype添加一个不可枚举的extend()方法</span></span><br><span class="line"><span class="comment">这个方法继承自调用它的对象，将作为参数传入的对象的属性一一复制</span></span><br><span class="line"><span class="comment">除了值以外，也复制属性的所有特性，除非在目标对象中存在同名的属性</span></span><br><span class="line"><span class="comment">参数对象的所有自由对象（包括不可枚举的属性）也会一一复制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'extend'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 得到所有的自有属性，包括不可枚举属性</span></span><br><span class="line">        <span class="keyword">var</span> names = <span class="built_in">Object</span>.getOwnPropertyNames(o);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.length; i++ ) &#123;</span><br><span class="line">            <span class="comment">// 如果属性存在，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (names[i] <span class="keyword">in</span> <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 获得o中的属性描述符</span></span><br><span class="line">            <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, names[i]);</span><br><span class="line">            <span class="comment">// 用它给this创建一个属性</span></span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, names[i], desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="1-getter和setter的老式API"><a href="#1-getter和setter的老式API" class="headerlink" title="1. getter和setter的老式API"></a>1. getter和setter的老式API</h4><p>通过对象直接量语法给新对象定义存取器属性时，不能通过查询属性的方式获取<code>getter</code>和<code>setter</code>方法，或给已有的对象添加新的存取器属性。在ES5中，可以通过<code>Object.getOwnPropertyDescriptor()</code>和<code>Object.defineProperty()</code>来完成这些工作。</p><p>在ES5标准被采纳前，大多数Javascript的实现已经可以支持对象直接量语法中的<code>get</code>和<code>set</code>写法，这些实现提供了非标准的老式API用来查询和设置<code>getter</code>和<code>setter</code>，这些API由4个方法组成，所有对象都拥有这些方法。</p><ul><li><p><code>__lookupGetter__()</code>和<code>__lookupSetter__()</code>用以返回一个命名属性的<code>getter</code>和<code>setter</code>方法</p></li><li><p><code>__defineGetter__()</code>和<code>__defineSetter__()</code>用以定义<code>getter</code>和<code>setter</code>，这两个函数的第一个参数是属性名字，第二个参数是<code>getter</code>和<code>setter</code>方法。</p></li><li><p>这四个方法都是以两条下划线作前缀，两条下划线作后缀，以表明它们是非标准的方法。</p></li></ul><hr><h3 id="八、对象的三个属性"><a href="#八、对象的三个属性" class="headerlink" title="八、对象的三个属性"></a>八、对象的三个属性</h3><p>每一个对象都有与之相关的原型（<code>prototype</code>）、类（<code>class</code>）和可扩展性（<code>extensible attribute</code>）</p><h4 id="1-原型属性"><a href="#1-原型属性" class="headerlink" title="1. 原型属性"></a>1. 原型属性</h4><p>对象的原型属性是用来继承属性的，原型属性是在实例对象创建之初就设置好的。在ES5中，将对象作为参数传入<code>Object.getPrototypeOf()</code>可以查询它的原型。在ES3中，没有与之等价的函数，但经常使用表达式<code>o.constructor.prototype</code>来检测一个对象的原型。通过<code>new</code>表达式创建的对象，通常继承一个<code>constructor</code>属性，这个属性指代创建这个对象的构造函数。注意，通过对象直接量或<code>Object.create()</code>创建的对象包含一个名为<code>constructor</code>的属性，这个属性指代<code>Object()</code>构造函数。因此，<code>constructor.prototype</code>才是对象直接量的真正的原型，但对于通过<code>Object.create()</code>创建的对象则往往不是这样。</p><p>要想检测一个对象是否是另一个对象的原型（或处于原型链中），可以使用<code>isPrototypeOf()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(p);</span><br><span class="line">p.isPrototypeOf(o);         <span class="comment">// =&gt; true o继承自p</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(o)   <span class="comment">// =&gt; true p继承自Object.prototype</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>isPrototypeOf()</code>函数实现的功能和<code>instanceof</code>运算符非常类似。</p><blockquote><p>Mozilla实现的JavaScript对外暴露了一个专门命名为<code>__proto__</code>的属性，用以直接查询/设置对象的原型。但并不推荐使用<code>__proto__</code>，因为尽管Safari和Chrome的当前版本都支持它，但IE和Opera并为实现。实现了ES5的Firefox支持<code>__proto__</code>，但对修改不可扩展对象的原型做了限制。</p></blockquote><h4 id="2-类属性"><a href="#2-类属性" class="headerlink" title="2. 类属性"></a>2. 类属性</h4><p>对象的类属性（<code>class attribute</code>）是一个字符串，用以表示对象的类型信息。ES3和ES5都未提供设置这个属性的方法，并只有一种简介的方法可以查询它。默认的<code>toString()</code>方法（继承自<code>Object.prototype</code>）返回了如下这种格式的字符串<code>[object class]</code>。</p><p>因此，想要获得对象的类，可以调用对象的<code>toString()</code>方法，然后提取已返回字符串中的字符。不过让人感觉棘手的是，很多对象继承的<code>toString()</code>方法重写了，为了能调用正确的<code>toString()</code>版本，必须间接地调用<code>Function.call()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classof</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Null'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Undefined'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>classof()</code>函数可以传入任何类型的参数。数字、字符串和布尔值可以直接调用<code>toString()</code>方法，就和对象调用<code>toString()</code>方法一样，并且这个函数包含了对<code>null</code>和<code>undefined</code>的特殊处理（ES5中不需要进行特殊处理）。通过内置构造函数（比如<code>Array</code>和<code>Date</code>）创建的对象包含“类属性”（<code>class attribute</code>），它与构造函数名称相匹配。宿主对象也包含有意义的“类属性”，但这和具体的JavaScript实现有关。</p><p>对于自定义的类来说，没办法通过类属性来区分对象的类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">classof(<span class="literal">null</span>)       <span class="comment">// =&gt; 'Null'</span></span><br><span class="line">classof(<span class="number">1</span>)          <span class="comment">// =&gt; 'Number'</span></span><br><span class="line">classof(<span class="string">""</span>)         <span class="comment">// =&gt; 'String'</span></span><br><span class="line">classof(<span class="literal">false</span>)      <span class="comment">// =&gt; 'Boolean'</span></span><br><span class="line">classof(&#123;&#125;)         <span class="comment">// =&gt; 'Object'</span></span><br><span class="line">classof([])         <span class="comment">// =&gt; 'Array'</span></span><br><span class="line">classof(<span class="regexp">/./</span>)        <span class="comment">// =&gt; 'Regexp'</span></span><br><span class="line">classof(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">// =&gt; 'Date'</span></span><br><span class="line">classof(<span class="built_in">window</span>)     <span class="comment">// =&gt; 'Window'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">classof(<span class="keyword">new</span> f())    <span class="comment">// =&gt; 'Object'</span></span><br></pre></td></tr></table></figure><h4 id="3-可扩展性"><a href="#3-可扩展性" class="headerlink" title="3. 可扩展性"></a>3. 可扩展性</h4><p>对象的可扩展性用以表示是否可以给对象添加新属性。所有内置对象和自定义对象都是显示可扩展的，宿主对象的可扩展性是由JavaScript引擎定义的。在ES5中，所有的内置对象和自定义对象都是可扩展的，除非将它们转换为不可扩展的，同样，宿主对象的可扩展性也是由实现ES5的JavaScript引擎定义的。</p><p>ES5定义了用来查询和设置对象可扩展性的函数，通过将对象传入<code>Object.isExtensible()</code>，来判断该对象是否是可扩展的。如果想将对象转换为不可扩展的，需要调用<code>Object.preventExtensions()</code>，将待转换的对象作为参数穿进去。注意，一旦将对象转换为不可扩展的，就无法再将其转换回可扩展的了。同样需要注意的是，<code>preventExtensions()</code>只影响到对象本身的可扩展性。如果给一个不可扩展的对象的原型添加属性，这个不可扩展的对象同样会继承这些新属性。</p><p>可扩展属性的目的是将对象“锁定”，以避免外界的干扰。对象的可扩展性通常和属性的可配置性与可写性配合使用，ES5定义的一些函数可以更方便的设置多种属性。</p><p><code>Object.seal()</code>和<code>Object.preventExtensions()</code>类似，除了能够将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置的。也就是说，不能给这个对象添加新属性，而且它已有的属性也不能删除或配置，不过它已有的科协属性依然可以设置。对于那些已经封闭（<code>sealed</code>）起来的对象是不能解封的。可以使用<code>Object.isSealed()</code>来检测对象是否封闭。</p><p><code>Object.freeze()</code>将更加严格地锁定对象——“冻结”（<code>frozen</code>）。除了将对象设置为不可扩展的和将其属性设置为不可配置的之外，还可以将它自有的所有数据属性设置为只读（如果对象的存取器属性具有<code>setter</code>方法，存取器属性将不受影响，人可以通过给属性赋值调用它们）。使用<code>Object.isFrozen()</code>来检测对象是否冻结。</p><p><code>Object.preventExtensions()</code>、<code>Object.seal()</code>、<code>Object.freeze()</code>都返回传入的对象，也就是说，可以通过函数嵌套的方式调用它们</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个封闭对象，包括一个冻结的原型和一个不可枚举的属性</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.seal(<span class="built_in">Object</span>.create(<span class="built_in">Object</span>.freeze(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;), &#123;</span><br><span class="line">    y: &#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><hr><h3 id="九、序列化对象"><a href="#九、序列化对象" class="headerlink" title="九、序列化对象"></a>九、序列化对象</h3><p>对象序列化（<code>serialization</code>）是指将对象的状态转换为字符串，也可将字符串还原为对象。ES5提供了内置函数<code>JSON.stringfigy()</code>和<code>JSON.parse()</code>用来序列化和还原JavaScript对象。这些方法都是用JSON作为数据交换格式。</p><p>JSON的语法是JavaScript语法的子集，它并不能表示JavaScript离的所有值，支持对象、数组、字符串、无穷大数字、<code>true</code>、<code>false</code>和<code>null</code>，并且它们可以序列化和还原。<code>NaN</code>、<code>Infinity</code>和<code>-Infinity</code>序列化的结果是<code>null</code>，日期对象序列化的结果是ISO格式的日期字符串（参照<code>Date.toJson()</code>函数），但<code>JSON.parse()</code>依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、<code>RegExp</code>、<code>Error</code>对象和<code>undefined</code>值不能序列化和还原。</p><blockquote><p><strong><code>JSON.stringfy()</code>只能序列化对象可枚举的自有属性</strong></p></blockquote><p>对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。<code>JSON.stringify()</code>和<code>JSON.parse()</code>都可以接收第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。</p><hr><h3 id="十、对象方法"><a href="#十、对象方法" class="headerlink" title="十、对象方法"></a>十、对象方法</h3><p>所有的JavaScript对象都从<code>Object.prototype</code>继承属性（除了那些不通过原型显示创建的对象）。这些继承属性主要是方法，我们已经讨论过<code>hasOwnProperty()</code>、<code>propertyIsEnumerable()</code>、<code>isPrototypeOf()</code>三个方法，以及在Object构造函数里定义的静态函数<code>Object.create()</code>和<code>Object.getPrototypeOf()</code>等。本节将对定义在<code>Object.prototype</code>里的对象方法展开讲解，这些方法非常好用而且使用广泛，但一些特定的类会重写这些方法。</p><h4 id="1-toString-方法"><a href="#1-toString-方法" class="headerlink" title="1. toString()方法"></a>1. toString()方法</h4><p><code>toString()</code>方法没有参数，它返回一个表示调用这个方法的对象值的字符串。在需要将对象转换为字符串的时候，JavaScript都会调用这个方法。比如，当使用“+”运算符连接一个字符串和一个对象时或者在希望使用字符串的方法中使用了对象时都会调用<code>toString()</code>。</p><p>默认的<code>toString()</code>方法的返回值带有的信息量很少。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>&#125;.toString();        <span class="comment">// "[object Object]"</span></span><br></pre></td></tr></table></figure><p>由于默认的<code>toString()</code>方法并不会输出很多有用的信息，因此很多类都带有自定义的<code>toString()</code>。例如，当数组转换为字符串的时候，结果实一个数组元素列表，只是每个元素都换成了字符串，再比如，当函数转换为字符串的时候，得到函数的源代码。</p><h4 id="2-toLocaleString-方法"><a href="#2-toLocaleString-方法" class="headerlink" title="2. toLocaleString()方法"></a>2. toLocaleString()方法</h4><p>除了基本的<code>toString()</code>方法之外，对象都包含<code>toLocaleString()</code>方法，这个方法返回一个表示这个对象的本地化字符串。<code>Object</code>中默认的<code>toLocaleString()</code>方法并不做任何本地化自身的操作，它仅调用<code>toString()</code>方法并返回对应值。<code>Date</code>和<code>Number</code>类对<code>toLocaleString()</code>方法做了定制，可以用它对数字、日期和时间做本地化的转换。<code>Array</code>类的<code>toLocaleString()</code>方法和<code>toString()</code>方法很像，唯一的不同是每个数组元素会调用<code>toLocaleString()</code>方法转换为字符串，而不是调用各自的<code>toString()</code>方法。</p><h4 id="3-toJSON-方法"><a href="#3-toJSON-方法" class="headerlink" title="3. toJSON()方法"></a>3. toJSON()方法</h4><p><code>Object.prototype</code>实际上没有定义<code>toJSON()</code>方法，但对于需要执行序列化的对象来说，<code>JSON.stringify()</code>方法会调用<code>toJSON()</code>方法。如果在待序列化的对象中存在这个方法，则调用它，返回值即是序列化的结果，而不是原始的对象。</p><h4 id="4-valueOf-方法"><a href="#4-valueOf-方法" class="headerlink" title="4. valueOf()方法"></a>4. valueOf()方法</h4><p><code>valueOf()</code>方法和<code>toString()</code>方法非常类似，但往往当JavaScript需要将对象转换为某种原始值而非字符串的时候才会调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript就会自动调用这个方法。默认的<code>valueOf()</code>方法不足为奇，但有些内置类自定义了<code>valueOf()</code>方法（比如<code>Date.valueOf()</code>）。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对象是JavaScript的基本数据类型。对象是一种复合值：它将很多值（原始值或者其他对象）聚合在一起，可以通过名字访问这些值。对象也可看作是属性的无序集合，每个属性都是一个名值对，属性名是字符串，因此我们可以把对象看成是从字符串到值的映射。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript对象" scheme="http://www.xiaoleon.cn/tags/JavaScript%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JS(1) 实现继承</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/js-1/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/js-1/</id>
    <published>2018-01-22T14:20:10.000Z</published>
    <updated>2018-01-28T15:07:28.095Z</updated>
    
    <content type="html"><![CDATA[<p>JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。那么如何在JS中实现继承呢？让我们拭目以待。</p><a id="more"></a><hr><h3 id="一、类式继承"><a href="#一、类式继承" class="headerlink" title="一、类式继承"></a>一、类式继承</h3><p>类式继承的主要思路是：<strong>采用构造函数实例化对象，通过原型链将实例对象关联起来</strong>。</p><h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h4><p>JavaScript使用原型链作为实现继承的主要方法，实现的本质是重写原型对象，代之以一个新类型的实例。下面的代码中，原来存在于<code>Super</code>的实例对象中的属性和方法，现在也存在于<code>Sub.prototype</code>中了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sub继承自Super</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getValue());           <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>原型链最主要的问题在于包含引用类型值的原型属性会被所有实例共享，而这也是为什么要在构造函数中，而不是在原型对象中定义属性的原因。通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章的变成了现在的原型属性了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub();</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);              <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);              <span class="comment">// 'red, blue, green, black'</span></span><br></pre></td></tr></table></figure><p>原型链的第二个问题是，在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有实例的情况下，给超类型的构造函数传递参数。再加上包含引用类型值的原型属性会被所有实例共享的问题，在实践中很少会单独使用原型链继承。</p><h4 id="2-借用构造函数继承"><a href="#2-借用构造函数继承" class="headerlink" title="2. 借用构造函数继承"></a>2. 借用构造函数继承</h4><p>借用构造函数的技术（有时候也叫做伪类继承或经典继承）。基本思想比较简单，即在子类型构造函数的内部调用超类型构造函数，通过使用<code>apply()</code>和<code>call()</code>方法在新创建的对象上执行构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>); <span class="comment">// 继承了Super</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub();</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);              <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);              <span class="comment">// 'red, blue, green'</span></span><br></pre></td></tr></table></figure><p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型中向超类型构造函数传递参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, <span class="string">'xiaozhang'</span>); <span class="comment">// 继承父类，同时传递参数</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="string">'28'</span>; <span class="comment">// 实例属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance.name);                 <span class="comment">// 'xiaozhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age);                  <span class="comment">// '28'</span></span><br></pre></td></tr></table></figure><p>但是，如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。</p><h4 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h4><p>组合集成有时也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub(<span class="string">'xiaozhang'</span>, <span class="number">28</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);          <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getName());       <span class="comment">// 'xiaozhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getAge());        <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub(<span class="string">'leon'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);          <span class="comment">// 'red, blue, green'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getName());       <span class="comment">// 'leon'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getAge());        <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>组合继承有它自己的问题。那就是无论什么情况下，都会调用两次父类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含父类型对象的全部实例属性，但不得不在调用子类型构造函数时重写这些属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第二次调用Super()，Sub.prototype再次获得name和colors两个属性，并对前一次的属性值进行覆盖</span></span><br><span class="line">    Super.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用Super()，Sub.prototype获得name和colors两个属性</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-寄生组合继承"><a href="#4-寄生组合继承" class="headerlink" title="4. 寄生组合继承"></a>4. 寄生组合继承</h4><p>解决两次调用父类型构造函数的方法是使用寄生组合式继承。计生组合式继承与组合继承相似，都是通过借用构造函数来继承不可共享的属性，通过原型链的混成形式来继承方法和可共享的属性。只不过把原型继承的形式变成了寄生式继承。使用寄生组合式继承可以不必为了指定子类型的原型而调用父类型的构造函数，从而寄生式继承只继承了父类型的原型属性，而父类型的实例属性是通过借用构造函数的方式来得到的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">proto</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">        F.prototype = proto;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub(<span class="string">'xiaozhang'</span>, <span class="number">28</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);          <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getName());       <span class="comment">// 'xiaozhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getAge());        <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub(<span class="string">'leon'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);          <span class="comment">// 'red, blue, green'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getName());       <span class="comment">// 'leon'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getAge());        <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>这个例子的高效率体现在它只调用了一次<code>Super</code>构造函数，并且因此避免了在<code>Sub.prototype</code>上面创建不必要的、多余的属性。与此同时，原型链还保持不变。因此，开发人员普遍认为寄生组合式继承是引用类型最理想的继承方式。</p><h4 id="5-ES6中的class"><a href="#5-ES6中的class" class="headerlink" title="5. ES6中的class"></a>5. ES6中的class</h4><p>采用ES6中的<code>class</code>语法糖，则上面代码修改如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getAge() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub(<span class="string">'xiaozhang'</span>, <span class="number">28</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);              <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getName());           <span class="comment">// 'xiaozhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getAge());            <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub(<span class="string">'leon'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);              <span class="comment">// 'red, blue, green'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getName());           <span class="comment">// 'leon'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getAge());            <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>ES6的<code>class</code>语法糖隐藏了许多技术细节，在实现同样功能的前提下，代码却优雅不少。</p><hr><h3 id="二、原型继承"><a href="#二、原型继承" class="headerlink" title="二、原型继承"></a>二、原型继承</h3><h4 id="1-原型继承"><a href="#1-原型继承" class="headerlink" title="1. 原型继承"></a>1. 原型继承</h4><p>原型继承，又称为委托继承。道格拉斯·克罗克福德（Douglas Crockford）在2006年谢了一篇文章，《Javascript中的原型式继承》。在这篇文章中，他介绍了一种实现继承的方式，这种方式并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象来创建新对象，同时不必因此创建自定义类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj = object(superObj);</span><br><span class="line">subObj.init(<span class="string">'sub'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subObj.getValue()); <span class="comment">// 'sub'</span></span><br></pre></td></tr></table></figure><p>在<code>object</code>函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的新实例。从本质上将，<code>object</code>方法对传入其中的对象执行了一次浅复制。ES5通过新增<code>Object.create</code>方法规范了原型式继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj = <span class="built_in">Object</span>.create(superObj);</span><br><span class="line">subObj.init(<span class="string">'sub'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subObj.getValue()); <span class="comment">// 'sub'</span></span><br></pre></td></tr></table></figure><h4 id="2-与原型链继承的关系"><a href="#2-与原型链继承的关系" class="headerlink" title="2. 与原型链继承的关系"></a>2. 与原型链继承的关系</h4><p>原型继承虽然只是看上去将原型链继承的一些程序性步骤包裹在函数里而已。但是，它们的一个重要区别是父类型的实例对象不再作为子类型的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用原型链继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance.value);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 使用原型继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance.value);</span><br></pre></td></tr></table></figure><p>原型继承中子类可以继承父类原型上的属性，但不可以继承父类的实例上的属性。原型继承与原型链继承都存在着子例共享父例引用类型值的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    colors: [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj1 = <span class="built_in">Object</span>.create(superObj);</span><br><span class="line">subObj1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj2 = <span class="built_in">Object</span>.create(superObj);</span><br><span class="line">subObj2.colors.push(<span class="string">'white'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(superObj.colors);           <span class="comment">// 'red, blue, green, black, white'</span></span><br><span class="line"><span class="built_in">console</span>.log(subObj1.colors);            <span class="comment">// 'red, blue, green, black, white'</span></span><br><span class="line"><span class="built_in">console</span>.log(subObj2.colors);            <span class="comment">// 'red, blue, green, black, white'</span></span><br></pre></td></tr></table></figure><h4 id="3-寄生式继承"><a href="#3-寄生式继承" class="headerlink" title="3. 寄生式继承"></a>3. 寄生式继承</h4><p>寄生式继承（<code>parasitic</code>）是与原型继承紧密相关的一种思路，并且同样是由道格拉斯·克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，最后再返回对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parasite</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(original); <span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 以某种方式来增强这个对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    colors: [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj1 = parasite(superObj);</span><br><span class="line">subObj1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj2 = parasite(superObj);</span><br><span class="line">subObj2.colors.push(<span class="string">'white'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(superObj.colors);           <span class="comment">// 'red, blue, green, black, white'</span></span><br><span class="line"><span class="built_in">console</span>.log(subObj1.colors);            <span class="comment">// 'red, blue, green, black, white'</span></span><br><span class="line"><span class="built_in">console</span>.log(subObj2.colors);            <span class="comment">// 'red, blue, green, black, white'</span></span><br></pre></td></tr></table></figure><p>由于原型继承存在着引用类型的值被共享的问题，所以使用的并不多，只在一些简单的应用场景下使用。如果需要解决该问题，则需要借用构造函数，与原型继承的初衷相违背，相当于使用了类式继承的终极写法——寄生组合继承。</p><hr><h3 id="三、拷贝继承"><a href="#三、拷贝继承" class="headerlink" title="三、拷贝继承"></a>三、拷贝继承</h3><p>拷贝继承又称为混入继承，<code>jQuery</code>中使用的就是拷贝继承。拷贝继承不需要改变原型链，通过拷贝函数将父例的属性和方法拷贝到子例即可。</p><h4 id="1-拷贝函数"><a href="#1-拷贝函数" class="headerlink" title="1. 拷贝函数"></a>1. 拷贝函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj, cloneObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj != <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cloneObj = cloneObj || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">            cloneObj[i] = (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">            <span class="built_in">arguments</span>.callee(obj[i], cloneObj[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneObj[i] = obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = extend(obj1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.c);            <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.c);            <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line">obj2.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.c);            <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.c);            <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><h4 id="2-对象间的拷贝继承"><a href="#2-对象间的拷贝继承" class="headerlink" title="2. 对象间的拷贝继承"></a>2. 对象间的拷贝继承</h4><p>由于拷贝继承解决了引用类型值共享的问题，所以其完全可以脱离构造函数实现对象间的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj, cloneObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj != <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cloneObj = cloneObj || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">            cloneObj[i] = (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">            <span class="built_in">arguments</span>.callee(obj[i], cloneObj[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneObj[i] = obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    arrayValue: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj = extend(superObj);</span><br><span class="line">subObj.arrayValue.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(subObj.arrayValue);         <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(superObj.arrayValue);       <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><h4 id="3-使用构造函数的拷贝组合继承"><a href="#3-使用构造函数的拷贝组合继承" class="headerlink" title="3. 使用构造函数的拷贝组合继承"></a>3. 使用构造函数的拷贝组合继承</h4><p>如果要使用构造函数，则属性可以使用借用构造函数的方法，而引用类型属性和方法使用拷贝继承。相当于不再通过原型链来建立对象之间的联系，而通过复制来得到对象的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj, cloneObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj != <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cloneObj = cloneObj || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">            cloneObj[i] = (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">            <span class="built_in">arguments</span>.callee(obj[i], cloneObj[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneObj[i] = obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = extend(Super.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub(<span class="string">'xiaozhang'</span>, <span class="number">28</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);          <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub(<span class="string">'leon'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);          <span class="comment">// 'red, blue, green'</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>本文介绍的 <strong>类式继承</strong> 、<strong>原型继承</strong>、<strong>拷贝继承</strong> 三种继承方式中，类式继承用的最普遍，由于ES6中<code>class</code>语法糖，使其代码复杂度大大降低；原型继承由于无法处理引用类型值共享的问题，使用较少，但是原型继承引申出的寄生组合继承是类式继承的规范式方法；拷贝继承使用范围最广泛，不仅可以实现原型之间的继承，也可以脱离构造函数，直接实现对象间的继承。</p><p>总之，继承主要就是处理父例和子例之间的两个问题，即是否使用构造函数，及如何建立联系。</p><ul><li><p>类式继承的核心就是使用构造函数，通过原型链来建立联系</p></li><li><p>原型继承不使用构造函数，通过<code>Object.create()</code>来建立联系</p></li><li><p>拷贝继承使用或者不使用构造函数都可以，通过复制来建立联系</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://geek.csdn.net/news/detail/246690" target="_blank" rel="noopener">《Javascript面向对象系列》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。那么如何在JS中实现继承呢？让我们拭目以待。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="类式继承" scheme="http://www.xiaoleon.cn/tags/%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF/"/>
    
      <category term="原型继承" scheme="http://www.xiaoleon.cn/tags/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/"/>
    
      <category term="拷贝继承" scheme="http://www.xiaoleon.cn/tags/%E6%8B%B7%E8%B4%9D%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>Web(1) 域名发散与域名收敛</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/web-1/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/web-1/</id>
    <published>2018-01-22T14:15:55.000Z</published>
    <updated>2018-01-27T09:03:40.571Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器对于同一域名下允许的并发请求做了限制，通常同一域名下最大并发请求数量为6个</p><a id="more"></a><ul><li><p>为了适应当时服务器的负载能力；之前的服务器的负载能力并没有这么强，高并发的请求可能会导致服务器无法正常提供服务甚至崩溃</p></li><li><p>如果浏览器允许的最大并发请求数较大，容易造成<code>DDoS(Distributed Denial of Service)</code>攻击等安全隐患</p></li><li><p>过多的并发请求可能会造成浏览器阻塞，使之处于“假死”的无响应状态</p></li><li><p>浏览器目前已经支持了长连接，可以在同一个<code>TCP</code>连接中完成多个请求，没有必要再进行代价较大的重新开启新请求的操作</p></li></ul><hr><h3 id="一、域名发散"><a href="#一、域名发散" class="headerlink" title="一、域名发散"></a>一、域名发散</h3><p>域名发散就是为了突破浏览器对于同一域名并发请求数的限制，使用域名发散为同一个服务申请多个域名，从而可以一定程度上提高并发量；当然，由于建立新的请求需要一定的代价，因此需要在域名发散与域名收敛之间进行<code>trade off</code>，通常发散的域名个数为2-4个。</p><hr><h3 id="二、域名收敛"><a href="#二、域名收敛" class="headerlink" title="二、域名收敛"></a>二、域名收敛</h3><p>域名收敛就是将静态资源放在一个域名下不进行发散，这主要是为了适应移动端的发展需求；通常DNS是一个开销较大的操作，而移动端由于网络带宽和实时性、资源等的限制，这些开销对于移动端的用户体验是致命的，因此需要进行域名收敛。</p><hr><h3 id="三、SPDY"><a href="#三、SPDY" class="headerlink" title="三、SPDY"></a>三、SPDY</h3><p><code>SPDY</code>是谷歌的一个商标，是由Google提出的一种更加快捷的应用层协议，可以说是对<code>HTTP</code>协议的一种补充，同时也推动了<code>HTTP/2</code>的发展。</p><p><code>SPDY</code>的提出也给无线端/移动端优化提供进一步的方案。</p><p>它并不是一种<code>HTTP</code>的替代，而是修改了<code>HTTP</code>请求和相应的发送方式；能够有效降低网页加载延时并提高网络安全性；可以通过<code>HTTP</code>头部压缩、多路复用、请求优先级排序降低加载延时；<code>SPDY</code>中使用<code>SSL/TLS</code>加密提高了网络安全性，同时向后兼容<code>TCP</code>；另外，服务器在页面请求后可以主动将需要的静态资源发送到客户端而不需要客户端再次请求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器对于同一域名下允许的并发请求做了限制，通常同一域名下最大并发请求数量为6个&lt;/p&gt;
    
    </summary>
    
      <category term="Web抄书笔记" scheme="http://www.xiaoleon.cn/categories/Web%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript对象" scheme="http://www.xiaoleon.cn/tags/JavaScript%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(10) 补充样式和属性</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-10/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-10/</id>
    <published>2018-01-22T14:05:03.000Z</published>
    <updated>2018-01-27T09:01:35.522Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要对CSS3中的一些内容比较少，但也非常重要的样式和属性进行简要介绍。</p><a id="more"></a><p>主要内容如下：</p><ul><li><p>掌握css3中与颜色相关的样式，掌握<code>alpha</code>通道的使用方法，掌握css3中新增的<code>rgba</code>颜色、<code>hsl</code>颜色与<code>hsla</code>颜色的概念盒使用方法</p></li><li><p>掌握<code>opacity</code>属性的含义盒使用方法，了解使用<code>alpha</code>来指定透明度与使用<code>opacity</code>属性来指定透明度这两者之间的区别，掌握<code>transparent</code>颜色值的含义及其使用方法</p></li><li><p>掌握<code>outline</code>属性的含义及其使用方法，能够使用<code>outline</code>属性在元素周围绘制一条轮廓线并指定该轮廓线的线宽、颜色、线的样式，以及线与边框的位移距离</p></li><li><p>掌握<code>resize</code>属性的含义及其使用方法，能够使用<code>resize</code>属性来定义一个允许用户自己调节尺寸的元素</p></li><li><p>掌握<code>initial</code>属性值的含义及其使用方法，能够使用<code>initial</code>属性来取消对元素的样式设定</p></li></ul><h3 id="一、颜色相关样式"><a href="#一、颜色相关样式" class="headerlink" title="一、颜色相关样式"></a>一、颜色相关样式</h3><p>在css3之前，在样式中指定的颜色值只能为<code>rgb</code>颜色值，并且只能通过<code>opacity</code>属性来设置元素的透明度。css3中增加了3种颜色中——<code>rgba</code>颜色值、<code>hsl</code>颜色值及<code>hsla</code>颜色值，并且允许通过对<code>rgba</code>颜色值和<code>hsla</code>颜色值设定<code>alpha</code>通道的方法来更加容易地实现将半透明文字与图像互相重叠的效果。</p><h4 id="1-利用alpha通道设定颜色"><a href="#1-利用alpha通道设定颜色" class="headerlink" title="1. 利用alpha通道设定颜色"></a>1. 利用alpha通道设定颜色</h4><p>1) 对rgb颜色设定alpha通道</p><p>在css3中，可以通过对<code>rgb</code>颜色设定<code>alpha</code>通道的方法来定义<code>rgba</code>颜色。所谓<code>rgba</code>颜色，是指利用红色值（<code>R</code>）、绿色值（<code>G</code>）、蓝色值（<code>B</code>）、<code>alpha</code>通道值（<code>A</code>）来定义的颜色。其中，<code>alpha</code>通道值的范围是0-1.0，0表示完全透明，1表示不透明。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">rgba</span>(255, 0, 0, 0<span class="selector-class">.5</span>);</span><br></pre></td></tr></table></figure><p>2) 对hsl颜色设定alpha通道</p><p>在css3中，除了可以使用<code>rgb</code>颜色外，还可以使用<code>hsl</code>颜色。<code>hsl</code>颜色使用色调（<code>H</code>）、饱和度（<code>S</code>）、亮度（<code>L</code>）来定义颜色。其中，色调值中用0或360表示红色，120表示绿色，240表示蓝色，当取值大于360时，实际的值等于该值除以360之后的余数。例如，如果色调值为480，则实际的颜色值为480除以360之后的余数，等于120。饱和度盒亮度的取值范围均为0%-100%。可以通过对<code>hsl</code>颜色设定<code>alpha</code>通道的方法来定义<code>hsla</code>颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">hsla</span>(120, 100%, 50%, 0<span class="selector-class">.5</span>);</span><br></pre></td></tr></table></figure><h4 id="2-alpha和opacity的区别"><a href="#2-alpha和opacity的区别" class="headerlink" title="2. alpha和opacity的区别"></a>2. alpha和opacity的区别</h4><p>在css3中，除了使用<code>alpha</code>通道的方法来设定透明度外，也可以通过<code>opacity</code>属性来设定透明度。</p><p><code>opacity</code>属性是css中专门用来指定透明度的一个属性，取值范围也在0-1之间，0表示完全透明，1表示不透明。使用<code>alpha</code>通道对元素设定透明度时，可以单独针对元素的背景色和文字颜色等来指定透明度，而<code>opacity</code>属性只能指定整个元素的透明度。</p><p>下方示例中有4个<code>div</code>元素，其背景色均为绿色，其中第1个<code>div</code>元素不指定透明度，第2个<code>div</code>元素使用<code>alpha</code>通道指定背景色的透明度为0.5，第3个<code>div</code>元素使用<code>alpha</code>通道指定背景色与文字颜色的透明度均为0.5，第4个<code>div</code>元素使用<code>opacity</code>属性指定元素的透明度为0.5</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">48px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div1</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(0, 255, 100);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(255, 255, 255);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div2</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0, 255, 100, 0.5);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rbg</span>(255, 255, 255);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div3</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0, 255, 100, 0.5);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(255, 255, 255, 0.5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div4</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rbg</span>(0, 255, 100);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(255, 255, 255);</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span>aaaaaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span>bbbbbb<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div3"</span>&gt;</span>cccccc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div4"</span>&gt;</span>dddddd<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码中我们可以看出，对第2个<code>div</code>元素的背景色使用<code>alpha</code>通道时，并不会对文字产生影响，如果要让该元素的文字颜色也变成半透明，需要像第3个<code>div</code>元素那样同时对背景色和文字颜色使用<code>alpha</code>通道。但是，在第4个<code>div</code>元素的样式代码中，因为使用一次<code>opacity</code>属性，文字颜色和背景色都变成半透明的了。</p><h4 id="3-指定颜色值为transparent"><a href="#3-指定颜色值为transparent" class="headerlink" title="3. 指定颜色值为transparent"></a>3. 指定颜色值为transparent</h4><p>如果将颜色值指定为<code>transparent</code>，则会将背景、文字或边框等的颜色设定为完全透明，相当于使用了值为0的<code>alpha</code>通道。</p><hr><h3 id="二、用户界面相关样式"><a href="#二、用户界面相关样式" class="headerlink" title="二、用户界面相关样式"></a>二、用户界面相关样式</h3><h4 id="1-outline属性"><a href="#1-outline属性" class="headerlink" title="1. outline属性"></a>1. outline属性</h4><p>css3中定义了一个<code>outline</code>属性，用来在元素周围绘制一条轮廓线，可以起到突出元素的作用。例如，可以在原本没有边框的<code>radio</code>单选框外围加上一条轮廓线，使其在页面上显得更加突出，也可以在一组<code>radio</code>单选框中只对某个单选框加上轮廓线，使其区别于别的单选框。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">outline</span>: <span class="selector-tag">outline-color</span> <span class="selector-tag">outline-style</span> <span class="selector-tag">outline-width</span></span><br></pre></td></tr></table></figure><ul><li><p><code>outline-color</code>参数表示轮廓线的颜色，属性值为css中定义的颜色值</p></li><li><p><code>outline-style</code>参数表示轮廓线的样式，属性值为css中定义的线的样式</p></li><li><p><code>outline-width</code>参数表示轮廓线的宽度，属性值可以为一个宽度值</p></li></ul><p><code>outline</code>属性的三个参数的顺序可以呼唤，也可以分开书写成三个属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">outline-color</span>: red;</span><br><span class="line">    <span class="attribute">outline-style</span>: solid;</span><br><span class="line">    <span class="attribute">outline-width</span>: thin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-out-offset属性"><a href="#2-out-offset属性" class="headerlink" title="2. out-offset属性"></a>2. out-offset属性</h4><p>在默认情况下，对带有边框的元素来说，使用<code>outline</code>属性将紧贴着边框外围绘制一条轮廓线。有时，我们不想让这条轮廓线紧贴着边框外围，想让轮廓线稍微向外偏离几个像素，以绘制出双层边框的效果。针对这种情况，css3新增了一个<code>outline-offset</code>属性，可以使用该属性实现这个效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: blue solid thin;</span><br><span class="line">    <span class="attribute">outline</span>: red solid thin;</span><br><span class="line">    <span class="attribute">outline-offset</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以给<code>outline-offset</code>属性指定一个为负数的属性值，指定为负数的属性值后，轮廓线将向内偏移，绘制在边框内部。</p><h4 id="3-resize属性"><a href="#3-resize属性" class="headerlink" title="3. resize属性"></a>3. resize属性</h4><p>为了增强用户体验，css3增加了很多新的属性，其中一个重要的属性就是<code>resize</code>，它允许用户通过拖动的方式来修改元素的尺寸，到目前为止，主要用于可以使用<code>overflow</code>属性的任何容器元素中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">    <span class="attribute">resize</span>: both;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resize</code>属性的值分为以下几种：</p><ul><li><p><code>none</code>：用户不能修改元素尺寸</p></li><li><p><code>both</code>：用户可以修改元素的宽度和高度</p></li><li><p><code>horizontal</code>：用户可以修改元素的宽度，但不能修改元素的高度</p></li><li><p><code>vertical</code>：用户可以修改元素的高度，但不能修改元素的宽度</p></li><li><p><code>inherit</code>：继承父元素的resize属性值</p></li></ul><h4 id="4-initial属性值"><a href="#4-initial属性值" class="headerlink" title="4. initial属性值"></a>4. initial属性值</h4><p>要取消对元素的样式指定，可以通过几种方法来达到这个目的，其中最简单的方法时直接在样式表中删除设定该样式的代码。但是，在大多数情况下，一个样式写好了以后会对很多页面中的元素指定这个样式。所以，如果对单个元素取消其样式的指定时，这种做法是不可取的。</p><p>第二种方法是目前采用的使用<code>class</code>的方法，要取消对单个元素的样式指定，只要把这个元素的<code>class</code>属性取消掉就可以了，但是<code>class</code>属性本身是一个多余的、没有任何语义的属性。同时，如果多个元素使用同一个样式，还必须为每一个元素增加同样的<code>class</code>属性；如果要删除一个样式，还要逐个删除这些元素的<code>class</code>属性，所以很不实用。css3中已经不推荐使用它，取而代之的是将样式与元素或元素<code>id</code>直接绑定的做法。所以，第二种方法在下一代Web平台中使用的机会也会越来越少，直到最终随着<code>class</code>属性一起被废弃掉。</p><p>针对这种情况，css3中新增了一个<code>initial</code>属性值，使用这个<code>initail</code>属性值可以直接取消对某个元素的样式指定。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#div1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: initial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span>aaaaaaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span>bbbbbbb<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div3"</span>&gt;</span>ccccccc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>initial</code>属性值的作用是让各种属性使用默认值，在浏览器中文字的颜色默认值是黑色，所以<code>id</code>为“div1”的元素中的文字会变成黑色。</p><p><strong>使用initial属性值的特例</strong></p><p>个别情况下，对元素使用<code>initial</code>属性值后的显示结果并不等于该元素的样式设定直接删除后的结果。在浏览器中，为了使一些元素变得更容易阅读，浏览器可以自行对该元素使用一些样式，例如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在样式中对<code>h1</code>元素重新定义，例如对<code>h1</code>元素定义如下样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，在这段样式后面追加一段<code>h1</code>元素使用的样式，对上面文字的字号和字体粗细均使用<code>initial</code>属性值，追加后的样式如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: initial;</span><br><span class="line">    <span class="attribute">font-weight</span>: initial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后我们会发现，<code>h1</code>元素在浏览器中的显示结果与最初不设定时并不相同。</p><p>为什么在<code>h1</code>元素的样式代码中追加了<code>initial</code>属性值后的显示结果与不使用任何样式设定时的显示结果会不一样呢？因为追加了<code>initial</code>属性值的样式设定后，<code>h1</code>元素的字号和字体粗细均使用css中对子号和字体粗细属性设定的默认值，并不考虑浏览器对<code>h1</code>元素追加了什么样式。而在css中，字号的默认值为<code>medium</code>，字体粗细的默认值是<code>normal</code>，与浏览器对<code>h1</code>元素使用的样式并不一致，如果想要让<code>h1</code>元素的字号和字体粗细的默认值使用浏览器的默认值，还是不要在追加的样式代码中使用<code>initial</code>属性值，而是使用浏览器追加的默认样式中的属性值。在<a href="http://www.w3.org/TR/CSS21/sample.html" target="_blank" rel="noopener">http://www.w3.org/TR/CSS 21/sample.html</a>中可以查到浏览器对HTML4中元素所做的追加样式清单，目前各主流浏览器均遵照这个清单来对元素追加默认样式。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要对CSS3中的一些内容比较少，但也非常重要的样式和属性进行简要介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="颜色" scheme="http://www.xiaoleon.cn/tags/%E9%A2%9C%E8%89%B2/"/>
    
      <category term="outline" scheme="http://www.xiaoleon.cn/tags/outline/"/>
    
      <category term="out-offset" scheme="http://www.xiaoleon.cn/tags/out-offset/"/>
    
      <category term="resize" scheme="http://www.xiaoleon.cn/tags/resize/"/>
    
      <category term="initial" scheme="http://www.xiaoleon.cn/tags/initial/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(9) Media Queries相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-9/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-9/</id>
    <published>2018-01-22T14:02:35.000Z</published>
    <updated>2018-01-27T09:01:28.247Z</updated>
    
    <content type="html"><![CDATA[<p>在css3的众多模块中，有一个与各种媒体相关的重要模块——<code>Media Queries</code>，该模块中允许添加媒体查询表达式，用以指定媒体类型，然后根据媒体类型来选择应该使用的样式。换句话说，允许我们在不改变内容的情况下在样式中选择一种页面的布局以精确地适应不同的设备，从而改善用户体验。</p><a id="more"></a><h3 id="一、Media-Queries使用方法"><a href="#一、Media-Queries使用方法" class="headerlink" title="一、Media Queries使用方法"></a>一、Media Queries使用方法</h3><p><code>Media Queries</code>的使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@media 设备类型 and ( 设备特性 ) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p>在代码的开头必须要书写<code>“@media”</code>，然后指定设备类型，也可以称之为媒体类型。css定义了10种设备类型，在此处可以指定的值与该值所代表的设备类型如下所示。</p><table><thead><tr><th>可以指定的值</th><th>设备类型</th></tr></thead><tbody><tr><td>all</td><td>所有设备</td></tr><tr><td>screen</td><td>电脑显示器</td></tr><tr><td>print</td><td>打印用纸或打印预览视图</td></tr><tr><td>handheld</td><td>便携设备</td></tr><tr><td>tv</td><td>电视机类型的设备</td></tr><tr><td>speech</td><td>语音和音频合成器</td></tr><tr><td>braille</td><td>忙人用点字法触觉回馈设备</td></tr><tr><td>embossed</td><td>盲文打印机</td></tr><tr><td>projection</td><td>各种投影设备</td></tr><tr><td>tty</td><td>使用固定密度字母栅格的媒介，比如电传打字机和终端</td></tr></tbody></table><p>设备特性的书写方式与样式的书写方式很相似，分为两个部分，当中由冒号分割，冒号前书写设备的某种特性，冒号后书写该特性的具体值，如需要指定浏览器的窗口宽度大于400px时所使用的样式，书写方法如下：<code>( min-width: 400px )</code></p><p>css中的设备特性共有13种，是一个类似于css属性的集合，但与css属性不同的是，大部分设备特性的指定值接受<code>min/max</code>的前缀，用来表示大于等于或小于的逻辑，以此避免使用<code>&lt;</code>盒<code>&gt;</code>这些字符。</p><table><thead><tr><th>特性</th><th>可指定值</th><th>是否允许使用min/max前缀</th><th>特性说明</th></tr></thead><tbody><tr><td>width</td><td>带单位的长度数值，例如：400px</td><td>允许</td><td>浏览器窗口的宽度</td></tr><tr><td>height</td><td>带单位的长度数值，例如：200px</td><td>允许</td><td>浏览器窗口的高度</td></tr><tr><td>device-width</td><td>带单位的长度数值，例如：400px</td><td>允许</td><td>设备屏幕分辨率的宽度</td></tr><tr><td>device-height</td><td>带单位的宽度数值，例如：200px</td><td>允许</td><td>设备屏幕分辨率的高度</td></tr><tr><td>orientation</td><td>只能指定两个值：portrait或landscape</td><td>不允许</td><td>浏览器窗口的方向是纵向还是横向。当窗口的高度值大于等于宽度值时，该特性值为portrait，否则为landscape</td></tr><tr><td>aspect-ratio</td><td>比例值，例如：16/9</td><td>允许</td><td>浏览器窗口的纵横比，比例值为浏览器窗口的宽度值/高度值</td></tr><tr><td>device-aspect-ratio</td><td>比例值，例如：16/9</td><td>允许</td><td>屏幕分辨率的纵横比，比例值为设备屏幕分辨率的宽度值/高度值</td></tr><tr><td>color</td><td>整数值</td><td>允许</td><td>设备使用多少位的颜色值，如果不是彩色设备，该值为0</td></tr><tr><td>color-index</td><td>整数值</td><td>允许</td><td>色彩表中的色彩数</td></tr><tr><td>monochrome</td><td>整数值</td><td>允许</td><td>单色帧缓冲期中每像素的字节数</td></tr><tr><td>resolution</td><td>分辨率值，例如：300dpi</td><td>允许</td><td>设备的分辨率</td></tr><tr><td>scan</td><td>只能指定两个值：progressive或interlace</td><td>不允许</td><td>电视机类型设备的扫描方式。progressive表示逐行扫描，interlace表示隔行扫描</td></tr><tr><td>grid</td><td>只能指定两个值：0或1</td><td>不允许</td><td>设备是基于栅格还是基于位图。基于栅格时该值为1，否则该值为0</td></tr></tbody></table><p>使用<code>and</code>关键字来指定当某种设备类型的某种特性的值满足某个条件时所使用的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">639px</span>) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p>可以使用多条语句来将同一个样式应用到不同的设备类型和设备特性中，指定方式如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> handheld and (min-width: <span class="number">360px</span>), screen and (min-width: <span class="number">480px</span>) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p>可以在表达式中加上<code>not</code>关键字或<code>only</code>关键字，<code>not</code>关键字表示对后面的表达式执行取反操作，书写方法如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 除便携设备之外的其他设备或非彩色便携设备 */</span></span><br><span class="line">@<span class="keyword">media</span> not handheld and (color) &#123; 样式代码 &#125;</span><br><span class="line"><span class="comment">/* 所有非彩色设备 */</span></span><br><span class="line">@<span class="keyword">media</span> all and (not color) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p><code>only</code>关键字，让那些不支持<code>Media Queries</code>但是能够读取<code>Media Type</code>的设备的浏览器将表达式的样式隐藏起来。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (color) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p>对于支持<code>Media Queries</code>的设备来说，将能够正确地应用央视，就仿佛<code>only</code>不存在一样；对于不支持<code>Media Queries</code>但能够读取<code>Media Type</code>的设备来说，由于先读取到<code>only</code>而不是<code>screen</code>，将忽略这个样式；对于不支持<code>Media Queries</code>的浏览器，无论是否有<code>only</code>，都将忽略这个样式。</p><p>css3中的<code>Media Queries</code>模块中也支持对外部样式表的引用，使用如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(color.css) screen and (min-width: <span class="number">1000px</span>);</span><br><span class="line"></span><br><span class="line">&lt;link rel="stylesheet" type="text/css" media="screen and (min-width: 1000px)" href="style.css"&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在css3的众多模块中，有一个与各种媒体相关的重要模块——&lt;code&gt;Media Queries&lt;/code&gt;，该模块中允许添加媒体查询表达式，用以指定媒体类型，然后根据媒体类型来选择应该使用的样式。换句话说，允许我们在不改变内容的情况下在样式中选择一种页面的布局以精确地适应不同的设备，从而改善用户体验。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="响应式布局" scheme="http://www.xiaoleon.cn/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    
      <category term="媒体查询" scheme="http://www.xiaoleon.cn/tags/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(8) 布局相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-8/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-8/</id>
    <published>2018-01-22T14:00:00.000Z</published>
    <updated>2018-01-27T09:01:21.394Z</updated>
    
    <content type="html"><![CDATA[<p>Web页面中的布局，是指在页面中如何对标题、导航栏、主要内容、脚注、表单等各种构成要素进行一个合理的编排。在css3之前，主要使用<code>float</code>属性或<code>position</code>属性进行页面中的简单布局，但是存在很多缺点，譬如两栏或多栏中如果元素的内容高度不一致则由底部很难对齐的问题。</p><a id="more"></a><h3 id="一、多栏布局"><a href="#一、多栏布局" class="headerlink" title="一、多栏布局"></a>一、多栏布局</h3><p>我们首先回顾以下css3之前是如何使用<code>float</code>属性或<code>position</code>属性进行页面中的简单布局的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20em</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div1</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>float</code>属性或<code>position</code>属性进行页面布局时有一个比较明显的缺点，就是两个<code>div</code>元素是相互独立的，因此如果在第一个<code>div</code>元素中加入一些内容的话，将会使得两个元素的底部不能对其，导致页面中多出一块空白区域。</p><p>针对<code>float</code>属性或<code>position</code>属性的缺点，css3中加入了多栏布局方式，使用多栏布局可以将一个元素中的内容分为两栏或多栏显示，并且确保各栏中内容的底部对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50em</span>;</span><br><span class="line">    <span class="attribute">column-count</span>: <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>column-count</code>属性来使用多栏布局方式，该属性的含义是讲一个元素中的内容分为多栏进行显示。使用多栏布局的时候，需要将元素的宽度设置成多个栏目的总宽度，它与使用<code>float</code>属性和<code>position</code>属性时的区别是：使用两个属性时只需单独设定每个元素的宽度即可，而使用多栏布局时需要设定元素中多个栏目相加后的总的宽度。</p><p>我们也可以使用<code>column-width</code>属性单独设置每一栏的宽度而不设定元素的宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">column-count</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">column-width</span>: <span class="number">20em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>column-gap</code>属性来设定多栏之间的间隔距离。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">column-count</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">column-gap</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>column-rule</code>属性在栏与栏之间增加一条间隔线，并且设定该间隔线的宽度、颜色等，该属性的属性值的指定方法与css中<code>border</code>属性的属性值指定方法相同。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">column-count</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">column-rule</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、盒布局"><a href="#二、盒布局" class="headerlink" title="二、盒布局"></a>二、盒布局</h3><p>在css3中，除了多栏布局之外，还可以使用盒布局解决前面所说的使用<code>float</code>属性或<code>position</code>属性时左右两栏或多栏中底部不能对齐的问题。</p><p>接下来我们看一个示例，示例中有三个<code>div</code>元素，简单展示了网页中的左侧边栏、中间内容和右侧边栏。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#middle</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: limegreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span>, <span class="selector-id">#middle</span>, <span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>aaaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"middle"</span>&gt;</span>bbbb<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>cccc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例中如果<code>div</code>的内容变化时，<code>div</code>元素的底部会出现无法对齐的问题。</p><p>在css3中，我们可以通过<code>box</code>属性来使用盒布局，修改代码如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    <span class="attribute">display</span>: -moz-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#middle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: limegreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span>, <span class="selector-id">#middle</span>, <span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>盒布局与多栏布局的区别</p><p>  使用多栏布局时，各栏宽度必须是相等的，在指定每栏宽度时，也只能为所有栏指定一个统一的宽度，栏与栏之间的宽度不可能是不一样的。另外，使用多栏布局时，也不可能具体指定什么栏中显示什么内容，因此比较适合使用在显示文章内容的时候，不适合用于安排整个网页中由个元素组成的网页结构时。</p></li></ul><ul><li><p>盒布局标准</p><p>  可以采用最新的<code>display: flex</code>属性，<code>-webkit-box</code>属于2009年的提案。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="">《HTML5与CSS3权威指南》</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">《Flex 布局教程：语法篇》（阮一峰）</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web页面中的布局，是指在页面中如何对标题、导航栏、主要内容、脚注、表单等各种构成要素进行一个合理的编排。在css3之前，主要使用&lt;code&gt;float&lt;/code&gt;属性或&lt;code&gt;position&lt;/code&gt;属性进行页面中的简单布局，但是存在很多缺点，譬如两栏或多栏中如果元素的内容高度不一致则由底部很难对齐的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="layout" scheme="http://www.xiaoleon.cn/tags/layout/"/>
    
      <category term="多栏布局" scheme="http://www.xiaoleon.cn/tags/%E5%A4%9A%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    
      <category term="盒布局" scheme="http://www.xiaoleon.cn/tags/%E7%9B%92%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(7) 动画</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-7/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-7/</id>
    <published>2018-01-22T13:56:19.000Z</published>
    <updated>2018-01-27T09:01:14.651Z</updated>
    
    <content type="html"><![CDATA[<p>css3中，如果使用动画功能，可以使页面上的文字或画像具有动画效果，可以使背景色从一种颜色平滑过渡到另一种颜色。</p><a id="more"></a><p>css3中的动画功能分为<code>Transitions</code>功能与<code>Animations</code>功能，这两种功能都可以通过改变css的属性值来产生动画效果。</p><p>到目前为止，<code>Transitions</code>功能支持从一个属性值平滑过渡到另一个属性值，<code>Animations</code>功能支持通过关键帧的指定来在页面上产生更复杂的动画效果。</p><h3 id="一、Transitions功能"><a href="#一、Transitions功能" class="headerlink" title="一、Transitions功能"></a>一、Transitions功能</h3><p><code>Transitions</code>功能通过将元素的某个属性从一个属性值在指定的时间内平滑过渡到另一个属性值来实现动画功能，可通过<code>transitions</code>属性来使用<code>Transitions</code>功能。</p><p>使用方法如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">property</span> <span class="selector-tag">duration</span> <span class="selector-tag">timing-function</span></span><br></pre></td></tr></table></figure><p>其中<code>property</code>表示对哪个属性进行平滑过渡，<code>duration</code>表示在多长时间内完成属性值的平滑过渡，<code>timing-function</code>表示通过什么方法来进行平滑过渡。</p><p>我们看一个使用示例，页面中有一个<code>div</code>元素，背景色为黄色，通过<code>hover</code>属性指定当鼠标指针停留在<code>div</code>元素上时的背景色为浅蓝色，通过<code>transitions</code>属性指定：当鼠标指针移动到<code>div</code>元素上时，在1秒钟内让<code>div</code>元素的背景色从黄色平滑过度到浅蓝色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffff00</span>;</span><br><span class="line">    <span class="attribute">-webkit-transition</span>: background-color <span class="number">1s</span> linear;</span><br><span class="line">    <span class="attribute">-moz-transition</span>: background-color <span class="number">1s</span> linear;</span><br><span class="line">    <span class="attribute">-o-transition</span>: background-color <span class="number">1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#00ffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>css3中，还有另外一种使用<code>Transitions</code>功能的方法，就是将<code>transitions</code>属性中的三个参数改写成<code>transition-property</code>、<code>transition-duration</code>、<code>transition-timing-function</code>三个属性，这三个属性的含义与属性值的制定方法与<code>transitions</code>属性中的三个参数的含义及指定方法完全相同。</p><p><strong>使用Transitions功能同时平滑过渡多个属性值</strong></p><p>可以使用<code>Transitions</code>功能同时对多个属性值进行平滑过渡。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffff00</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000000</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">-webkit-transition</span>: background-color <span class="number">1s</span> linear, color <span class="number">1s</span> linear, width <span class="number">1s</span> linear;</span><br><span class="line">    <span class="attribute">-moz-transition</span>: background-color <span class="number">1s</span> linear, color <span class="number">1s</span> linear, width <span class="number">1s</span> linear;</span><br><span class="line">    <span class="attribute">-o-transition</span>: background-color <span class="number">1s</span> linear, color <span class="number">1s</span> linear, width <span class="number">1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#003366</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、Animations功能"><a href="#二、Animations功能" class="headerlink" title="二、Animations功能"></a>二、Animations功能</h3><p><code>Animations</code>功能与<code>Transitions</code>功能相同，都是通过改变元素的属性值来实现动画效果的。它们的区别在于：使用<code>Transitions</code>功能时只能通过指定属性的开始值与结束值，然后在这两个属性值之间进行平滑过渡的方式来实现动画效果，因此不能实现比较复杂的动画效果；而<code>Animations</code>则通过定义多个关键帧以及定义每个关键帧中元素的属性值来实现更为复杂的动画效果。</p><p>我们看一个代码使用示例，一个<code>div</code>元素背景色为红色，当鼠标指针移动到<code>div</code>元素上时，元素的背景色将经历从红色到深蓝色，从深蓝色到黄色，从黄色回到红色这样一系列的变化。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> mycolor &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">    40% &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: darkblue;</span><br><span class="line">    &#125;</span><br><span class="line">    70% &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="comment">/* 指定关键帧集合的名称 */</span></span><br><span class="line">    <span class="attribute">-webkit-animation-name</span>: mycolor;</span><br><span class="line">    <span class="comment">/* 指定完成整个动画的时间 */</span></span><br><span class="line">    <span class="attribute">-webkit-animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">    <span class="comment">/* 指定实现动画的方法 */</span></span><br><span class="line">    <span class="attribute">-webkit-animation-timing-function</span>: linear;</span><br><span class="line">    <span class="comment">/* 指定动画的播放次数 */</span></span><br><span class="line">    <span class="attribute">-webkit-animation-iteration-count</span>: infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码实现的动画中带有如下几个关键帧，通过这些关键帧之间的平滑过渡完成了动画的实现。</p><ul><li><p>开始帧：0%</p></li><li><p>背景色为深蓝色的关键帧：40%</p></li><li><p>背景色为黄色的关键帧：70%</p></li><li><p>结束帧：100%</p></li></ul><p><strong>实现动画的方法</strong></p><p>前面的使用示例中，我们只使用了一种实现动画的方法——<code>linear</code>。<code>linear</code>的含义是在动画从开始到结束时使用同样的速度进行各种属性值的改变，在一个动画中不改变各种属性值的改变速度。</p><table><thead><tr><th>方法</th><th>属性值的变化速度</th></tr></thead><tbody><tr><td>linear</td><td>在动画开始时到结束时以同样速度进行改变</td></tr><tr><td>ease-in</td><td>动画开始时速度很慢，然后速度沿曲线值进行加快</td></tr><tr><td>ease-out</td><td>动画开始时速度很快，然后沿曲线值进行放慢</td></tr><tr><td>ease</td><td>动画开始时速度很慢，然后速度沿曲线值进行加快，然后再沿曲线值放慢</td></tr><tr><td>ease-in-out</td><td>动画开始时速度很慢，然后沿曲线值进行加快，然后再沿曲线值放慢</td></tr></tbody></table><p>示例：实现网页的淡入效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> fadein &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: white;</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: white;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-animation-name</span>: fadein;</span><br><span class="line">    <span class="attribute">-webkit-animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">    <span class="attribute">-webkit-animation-timing-function</span>: linear;</span><br><span class="line">    <span class="attribute">-webkit-animation-iteration-count</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css3中，如果使用动画功能，可以使页面上的文字或画像具有动画效果，可以使背景色从一种颜色平滑过渡到另一种颜色。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Transitions" scheme="http://www.xiaoleon.cn/tags/Transitions/"/>
    
      <category term="Animations" scheme="http://www.xiaoleon.cn/tags/Animations/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(6) 变形处理</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-6/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-6/</id>
    <published>2018-01-22T13:53:57.000Z</published>
    <updated>2018-01-27T09:00:52.649Z</updated>
    
    <content type="html"><![CDATA[<p>在css3中，可以利用<code>transform</code>功能来实现文字或图像的旋转、缩放、倾斜、移动这四种类型的变形处理。</p><a id="more"></a><h3 id="一、缩放"><a href="#一、缩放" class="headerlink" title="一、缩放"></a>一、缩放</h3><p>使用<code>scale</code>方法实现文字或图像的缩放处理，在参数中指定缩放倍率。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 缩小50% */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以分别指定元素水平方向的放大倍率与垂直方向的放大倍率。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向缩小50%，垂直方向放大一倍 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.5, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、倾斜"><a href="#二、倾斜" class="headerlink" title="二、倾斜"></a>二、倾斜</h3><p>使用<code>skew</code>方法实现文字或图像的倾斜处理，在参数中分别指定水平方向上的倾斜角度与垂直方向上的倾斜角度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向倾斜30度，垂直方向倾斜30度 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(30deg, 30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>skew</code>方法中的两个参数可以修改成只使用一个参数，省略另一个参数——这种情况下视为只在水平方向上进行倾斜，垂直方向上不倾斜。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向倾斜30度，垂直方向不倾斜 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、移动"><a href="#三、移动" class="headerlink" title="三、移动"></a>三、移动</h3><p>使用<code>translate</code>方法来将文字或图像进行移动，在参数中分别指定水平方向上的移动距离与垂直方向上的移动距离。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向上移动50px，垂直方向上移动50px */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(50px, 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>translate</code>方法中的两个参数可以修改成只使用一个参数，省略另一个参数——这种情况下视为只在水平方向上移动，垂直方向上不移动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向上移动50px，垂直方向不移动 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、指定变形的基准点"><a href="#四、指定变形的基准点" class="headerlink" title="四、指定变形的基准点"></a>四、指定变形的基准点</h3><p>在使用<code>transform</code>方法进行文字或图像的变形时，是以元素的中心点为基准点进行的。使用<code>transform-origin</code>属性，可以改变变形的基准点。</p><p>指定<code>transform-origin</code>属性值的时候，采用“基准点在元素水平方向上的位置，基准点在元素垂直方向上的位置”的方法，其中“基准点在元素水平方向上的位置”中可以指定的值为<code>left</code>、<code>center</code>、<code>right</code>，“基准点在元素垂直方向上的位置”中可以指定的值为<code>top</code>、<code>center</code>、<code>bottom</code>。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在css3中，可以利用&lt;code&gt;transform&lt;/code&gt;功能来实现文字或图像的旋转、缩放、倾斜、移动这四种类型的变形处理。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="transform" scheme="http://www.xiaoleon.cn/tags/transform/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(5) 背景边框相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-5/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-5/</id>
    <published>2018-01-22T13:49:17.000Z</published>
    <updated>2018-01-27T09:00:45.815Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍CSS3中的背景和边框相关的一些样式，其中包括与背景相关的几个属性，如何在一个元素的背景中使用多个图像文件；如何绘制圆角边框；如何给元素添加图像边框。</p><a id="more"></a><p>在css3中，追加了一些与背景相关的属性，如下表所示</p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>background-clip</td><td>指定背景的显示范围</td></tr><tr><td>background-origin</td><td>指定绘制背景图像时的起点</td></tr><tr><td>background-size</td><td>指定背景中图像的尺寸</td></tr><tr><td>background-break</td><td>指定内联元素的背景图片进行平铺时的循环方式</td></tr></tbody></table><h3 id="一、指定背景的显示范围"><a href="#一、指定背景的显示范围" class="headerlink" title="一、指定背景的显示范围"></a>一、指定背景的显示范围</h3><p>在HTML页面中，一个具有背景的元素通常由元素的内容、内部补白（<code>padding</code>）、边框、外部补白（<code>margin</code>）构成。</p><p>元素背景的显示范围在css2、css2.1、css3中并不相同：</p><ul><li><p>css2中背景的显示范围是指内部补白之内的范围，不包括边框</p></li><li><p>css2.1至css3中，背景的显示范围是指包括边框在内的范围</p></li><li><p>css3中，可以使用<code>background-clip</code>来修改背景的显示范围，如果将<code>background-clip</code>设定为<code>border-box</code>，则背景范围包括边框区域，如果设定为<code>padding-box</code>或<code>content-box</code>，则不包括边框区域</p></li></ul><hr><h3 id="二、指定背景的绘制起点"><a href="#二、指定背景的绘制起点" class="headerlink" title="二、指定背景的绘制起点"></a>二、指定背景的绘制起点</h3><p>在绘制背景图像时，默认是从内部补白（<code>padding</code>）区域的左上角开始，但是可以利用<code>background-origin</code>属性来指定绘制时从边框的左上角开始，或者从内容的左上角开始。</p><blockquote><p>在firefox浏览器中，需要书写成“<code>-moz-background-origin</code>”形式；在safari浏览器或chrome浏览器中指定绘制起点时，需要书写成“<code>-webkit-background-origin</code>”形式。</p></blockquote><p><code>background-origin</code>属性为<code>border-box</code>、<code>padding-box</code>、<code>content-box</code>，分别代表从边框的左上角、内容补白区域的左上角或内容的左上角开始绘制。</p><hr><h3 id="三、指定背景图像的尺寸"><a href="#三、指定背景图像的尺寸" class="headerlink" title="三、指定背景图像的尺寸"></a>三、指定背景图像的尺寸</h3><p>在css3中，可以使用<code>background-size</code>属性来指定背景图像的尺寸。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-size</span>: 40<span class="selector-tag">px</span> 20<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p>其中第一个参数为图像的宽度，第二个参数为图像的高度，中间用半角空格进行分隔。如果要维持图像横纵比的话，可以将另一个参数设定为<code>auto</code>。</p><hr><h3 id="四、指定内联元素背景图片平铺循环方式"><a href="#四、指定内联元素背景图片平铺循环方式" class="headerlink" title="四、指定内联元素背景图片平铺循环方式"></a>四、指定内联元素背景图片平铺循环方式</h3><p>在css3中，可以使用<code>background-break</code>属性来指定平铺内联元素背景图像时的循环方式，可以指定<code>bounding-box</code>、<code>each-box</code>、<code>continuous</code>这三种循环方式。</p><p>将<code>background-break</code>属性指定为<code>bounding-box</code>时，背景图像在整个内联元素中进行平铺。指定为<code>each-box</code>时，背景图像在每一行中进行平铺。指定<code>continuous</code>的时候，下一行中的图像紧接着上一行中的图像继续平铺。</p><hr><h3 id="五、在一个元素中显示多个背景图像"><a href="#五、在一个元素中显示多个背景图像" class="headerlink" title="五、在一个元素中显示多个背景图像"></a>五、在一个元素中显示多个背景图像</h3><p>在css3中可以在一个元素里显示多个背景图像，还可以将多个背景图像进行重叠显示，从而使得背景图像中所用素材的调整变得更加容易。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(flower-red.png), <span class="built_in">url</span>(flower-green.png), <span class="built_in">url</span>(sky.jpg);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat, repeat-x, no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">3%</span> <span class="number">98%</span>, <span class="number">85%</span>, center center, top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>background-image</code>属性指定图像文件的时候，时按在浏览器中显示时图像叠放的顺序从上往下指定的，第一个图像文件是放在最上面的，最后制定的文件是放在最下面的。</p><p>允许多重制定并配合着多个图像文件一起利用的属性有如下几个：</p><p><code>background-image, background-repeat, background-position</code><br><code>background-clip, background-origin, background-size</code></p><hr><h3 id="六、border-radius属性"><a href="#六、border-radius属性" class="headerlink" title="六、border-radius属性"></a>六、border-radius属性</h3><p>在css3中，使用<code>border-radius</code>属性指定好圆角的半径，就可以绘制圆角边框了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">40px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用了<code>border-radius</code>属性但是把边框设定为不显示的时候，浏览器将把背景的四个角绘制为圆角。</p><p>使用了<code>border-radius</code>属性后，不管边框是什么种类，都会将边框沿着圆角曲线进行绘制。</p><hr><h3 id="七、border-image属性"><a href="#七、border-image属性" class="headerlink" title="七、border-image属性"></a>七、border-image属性</h3><p>css3中增加了一个<code>border-image</code>属性，可以让处于随时变化状态的元素的长或款的边框统一使用一个图像文件来绘制。使用<code>border-image</code>属性，会让浏览器在显示图像边框时，自动将所使用到的图像分割为9部分进行处理，这样就不需要页面再另外进行人工处理了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border-image</span>: <span class="built_in">url</span>(borderimage.png) <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> / <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>border-image</code>属性值中至少必须指定五个参数，其中第一个参数为边框所使用的图片文件的路径，后面四个参数表示当浏览器自动把边框所使用到的图像进行分隔时的上边距、右边距、下边距及左边距。</p><h4 id="1-指定边框宽度"><a href="#1-指定边框宽度" class="headerlink" title="1. 指定边框宽度"></a>1. 指定边框宽度</h4><p>在css3中，除了可以使用<code>border</code>属性或<code>border-width</code>属性来指定边框的宽度外，使用<code>border-image</code>属性同样可以指定边框的宽度。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image: url(图像文件的路径) A B C D / border-width</span><br></pre></td></tr></table></figure><p>下面代码中，指定了上边距、右边距、下边距和左边距为18px，4条边分别为5px、10px、15px、20px。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: solid;</span><br><span class="line">    <span class="attribute">border-image</span>: <span class="built_in">url</span>(borderimage.png) <span class="number">18</span> / <span class="number">5px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-中央图像的自动拉伸"><a href="#2-中央图像的自动拉伸" class="headerlink" title="2. 中央图像的自动拉伸"></a>2. 中央图像的自动拉伸</h4><p>浏览器将边框所用图像自动分割为9部分后，除了将<code>border-top-image</code>、<code>border-left-image</code>、<code>border-right-image</code>、<code>border-bottom-image</code>这四部分自动分配为四条边所用的图像之外，将位于中间部分的图像分配给元素边框所包围的中间区域，随着<code>div</code>元素内容变化的同时，或者在样式代码中修改div元素的宽度或高度的同时，中间部分的图像也会自动进行伸缩，以填满该中间区域。</p><h4 id="3-指定四条边中图像的显示方法"><a href="#3-指定四条边中图像的显示方法" class="headerlink" title="3. 指定四条边中图像的显示方法"></a>3. 指定四条边中图像的显示方法</h4><p>可以在<code>border-image</code>属性中指定元素四条边中的图像是以拉伸的方式显示，还是以平铺的方式显示</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image: url(文件路径) A B C D / border-width topbottom leftright</span><br></pre></td></tr></table></figure><p>其中，<code>topbottom</code>表示元素的上下两条边中图像的显示方法，<code>leftright</code>表示元素的左右两条边中的显示方法，显示方法中可以指定的值为<code>repeat</code>、<code>stretch</code>与<code>round</code>三种。</p><ul><li><p><code>repeat</code>：图像以平铺的方式进行显示</p></li><li><p><code>stretch</code>：图像以拉伸的方式进行显示</p></li><li><p><code>repeat+stretch</code>：将上下两条边中的图像的显示方式指定为平铺显示，左右两条边中的图像的显示方式指定为拉伸显示，或者上下两条边中的图像的显示方式指定为拉伸显示，左右两条边中的图像的显示方式指定为平铺显示。</p></li><li><p><code>round</code>：与<code>repeat</code>类似，都是将图像进行平铺显示，区别在于如果最后显示的衣服图像不能被完全显示，且能够现实的部分不到图像的一半，就不显示最后的图像，然后扩大前面的图像，使显示区域正好完整平铺全部图像；如果能够显示的部分超过图像的一半，就显示最后的图像，但是将全部显示的图像缩小，使显示区域正好完整平铺全部图像。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍CSS3中的背景和边框相关的一些样式，其中包括与背景相关的几个属性，如何在一个元素的背景中使用多个图像文件；如何绘制圆角边框；如何给元素添加图像边框。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="background样式" scheme="http://www.xiaoleon.cn/tags/background%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="border样式" scheme="http://www.xiaoleon.cn/tags/border%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(4) 盒相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-4/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-4/</id>
    <published>2018-01-22T13:44:04.000Z</published>
    <updated>2018-01-27T09:00:36.114Z</updated>
    
    <content type="html"><![CDATA[<p>在css中，使用<code>display</code>属性来定义盒的类型。总体上来说，css的盒分为<code>block</code>类型与<code>inline</code>类型。</p> <a id="more"></a><h3 id="一、inline-block"><a href="#一、inline-block" class="headerlink" title="一、inline-block"></a>一、inline-block</h3><p><code>inline-block</code>是在css2.1中追加的一个盒类型，属于<code>block</code>类型盒的一种，但是在显示时具有<code>inline</code>类型盒的特点。</p><p>默认情况下使用<code>inline-block</code>类型时并列显示的元素的垂直对齐方式是底部对其，为了将垂直对齐方式改为顶部对齐，还需要在<code>div</code>元素的样式中加入<code>vertical-align</code>属性。</p><hr><h3 id="二、inline-table"><a href="#二、inline-table" class="headerlink" title="二、inline-table"></a>二、inline-table</h3><p>由于<code>table</code>元素属于<code>block</code>类型，所以不能与其他文字处于同一行中，但是如果将<code>table</code>元素修改wei<code>inline-table</code>类型，就可以让表格与其他文字处于同一行中了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-table;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#00aaff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在样式中利用<code>vertical-align</code>属性显示指定表格与文字的对齐方式。</p><hr><h3 id="三、list-item"><a href="#三、list-item" class="headerlink" title="三、list-item"></a>三、list-item</h3><p>如果在<code>display</code>中将元素的类型设定为<code>list-item</code>类型，可以将多个元素作为列表来显示，同时在元素的开头加上列表的标记。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: list-item;</span><br><span class="line">    <span class="attribute">list-style-type</span>: circle;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、run-in、compact"><a href="#四、run-in、compact" class="headerlink" title="四、run-in、compact"></a>四、run-in、compact</h3><p>将元素指定为<code>run-in</code>类型或者<code>compact</code>类型的时候，如果元素后面还有block类型的元素，<code>run-in</code>类型的元素将被包含在<code>block</code>类型的元素内部，而<code>compact</code>类型的元素将被放置在<code>block</code>类型的元素左边。</p><hr><h3 id="五、超出盒容纳的内容"><a href="#五、超出盒容纳的内容" class="headerlink" title="五、超出盒容纳的内容"></a>五、超出盒容纳的内容</h3><p>如果在样式中指定了盒的宽度与高度，就有可能出现某些内容在盒中容纳不下的情况，可以使用<code>overflow</code>属性来指定如何显示这些内容。</p><ul><li><p>overflow: hidden</p><p>  超出容纳范围的文字被隐藏</p></li><li><p>overflow: scroll</p><p>  元素中出现固定的水平滚动条与垂直滚动条</p></li><li><p>overflow: auto</p><p>  文字超出div元素的容纳范围时，根据需要出现水平滚动条或垂直滚动条</p></li><li><p>overflow: visible</p><p>  显示效果与不使用overflow属性时一样</p></li><li><p>text-overflow</p><p>  当通过把<code>overflow</code>属性设定为<code>ellipsis</code>，将盒中容纳不下的内容隐藏起来时，如果使用<code>text-overflow</code>属性，可以在盒的末尾显示一个代表省略的符号<code>“...”</code>。但是，<code>text-overflow</code>属性只在当盒中的内容在水平方向上超出盒的容纳范围时有效。通过将<code>white-space</code>属性设定为<code>nowrap</code>，使得盒右端的内容不能换行显示。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="attribute">-webkit-text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="attribute">-o-text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="六、对盒使用阴影"><a href="#六、对盒使用阴影" class="headerlink" title="六、对盒使用阴影"></a>六、对盒使用阴影</h3><p>在css3中，可以使用<code>box-shadow</code>属性让盒在显示时产生阴影特效</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">length</span> <span class="selector-tag">length</span> <span class="selector-tag">length</span> <span class="selector-tag">color</span>;</span><br><span class="line">-webkit-box-shadow: length length length color; // safari</span><br><span class="line">-moz-box-shadow: length length length color; // firefox</span><br></pre></td></tr></table></figure><p>前面三个<code>length</code>分别指阴影离开文字的 <strong>横向距离</strong>、<strong>纵向距离</strong>、<strong>模糊半径</strong>，color指阴影的 <strong>颜色</strong></p><p><strong>对第一个文字或第一行使用阴影</strong></p><p>可以使用<code>first-letter</code>选择器或<code>first-line</code>选择器来只让第一个文字或第一行具有阴影效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:first-letter</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">22px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:first-line</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="七、盒的宽度和高度"><a href="#七、盒的宽度和高度" class="headerlink" title="七、盒的宽度和高度"></a>七、盒的宽度和高度</h3><p>在css3中，使用<code>box-sizing</code>属性来指定针对元素的宽度和高度的计算方法，是否包含元素内部的补白区域，以及边框的宽度和高度。</p><h4 id="1-content-box"><a href="#1-content-box" class="headerlink" title="1. content-box"></a>1. content-box</h4><p>元素的宽度和高度不包括内容补白区域，以及边框的宽度和高度</p><h4 id="2-border-box"><a href="#2-border-box" class="headerlink" title="2. border-box"></a>2. border-box</h4><p>元素的宽度和高度包括内部补白区域，以及边框的宽度和高度</p><h4 id="3-为什么要使用box-sizing属性"><a href="#3-为什么要使用box-sizing属性" class="headerlink" title="3. 为什么要使用box-sizing属性"></a>3. 为什么要使用box-sizing属性</h4><p>使用<code>box-sizing</code>属性的目的是控制元素的总宽度，如果不使用该属性，样式中默认使用的是<code>content-box</code>属性值，它只对内容的宽度做了一个指定，却没有对元素的总宽度进行指定。有些场合下利用<code>border-box</code>属性值会使得页面布局更加方便。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在css中，使用&lt;code&gt;display&lt;/code&gt;属性来定义盒的类型。总体上来说，css的盒分为&lt;code&gt;block&lt;/code&gt;类型与&lt;code&gt;inline&lt;/code&gt;类型。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="盒模型" scheme="http://www.xiaoleon.cn/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="box-sizing" scheme="http://www.xiaoleon.cn/tags/box-sizing/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(3) 文字与字体相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-3/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-3/</id>
    <published>2018-01-22T13:40:32.000Z</published>
    <updated>2018-01-27T09:00:27.251Z</updated>
    
    <content type="html"><![CDATA[<p>本章针对css3中与文字、字体相关的一些属性做详细介绍，其中包括<code>text-shadow</code>属性、<code>word-break</code>属性、<code>word-wrap</code>属性、<code>Web Font</code>和<code>@font-face</code>属性，以及<code>font-size-adjust</code>属性。</p><a id="more"></a><h3 id="一、文字添加阴影"><a href="#一、文字添加阴影" class="headerlink" title="一、文字添加阴影"></a>一、文字添加阴影</h3><p><code>text-shadow</code>属性用于给页面上的文字添加阴影效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text-shadow</span>: <span class="selector-tag">length</span> <span class="selector-tag">length</span> <span class="selector-tag">length</span> <span class="selector-tag">color</span></span><br></pre></td></tr></table></figure><p>其中，前三个<code>length</code>分别指阴影离开文字的 <strong>横方向距离</strong>、<strong>纵方向距离</strong>、<strong>模糊半径</strong>，color指阴影的 <strong>颜色</strong>。</p><p><strong>指定多个阴影</strong></p><p>可以使用<code>text-shadow</code>属性给文字指定多个阴影，并且针对每个阴影使用不同颜色，指定多个阴影时使用逗号将多个阴影进行分隔。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">5px</span> <span class="number">#f39800</span>,</span><br><span class="line">                <span class="number">40px</span> <span class="number">35px</span> <span class="number">5px</span> <span class="number">#fff100</span>,</span><br><span class="line">                <span class="number">70px</span> <span class="number">60px</span> <span class="number">5px</span> <span class="number">#c0ff00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、文本自动换行"><a href="#二、文本自动换行" class="headerlink" title="二、文本自动换行"></a>二、文本自动换行</h3><p>在css3中，使用<code>word-break</code>属性来让文字自动换行</p><p>浏览器显示文本的时候，会让文本在浏览器或div元素的右端自动实现换行。对于西方文字来说，浏览器会在半角空格或连字符的地方自动换行，而不会在单词的当中突然换行。对于中文来说，可以在任何一个中文字后面进行换行。如果中文当中含有西方文字，浏览器也会在半角空格或连字符的地方进行换行，而不会在单词中强制换行。</p><p>当中文当中含有标点符号的时候，浏览器总是不可能让标点符号位于一行文字的行首，通常将标点符号以及它前面的一个文字作为一个整体来统一换行。</p><h4 id="1-指定自动换行"><a href="#1-指定自动换行" class="headerlink" title="1. 指定自动换行"></a>1. 指定自动换行</h4><p>在css3中，可以使用<code>word-break</code>属性来自己决定自动换行的处理方法。通过<code>word-break</code>属性的指定，不仅仅可以让浏览器实现半角空格或连字符后面的换行，而且可以让浏览器实现任意位置的换行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">word-break</span>: keep-all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>换行规则</th></tr></thead><tbody><tr><td>normal</td><td>使用浏览器默认换行规则</td></tr><tr><td>keep-all</td><td>只能在半角空格或连字符处换行</td></tr><tr><td>break-all</td><td>允许在单词内换行</td></tr></tbody></table><h4 id="2-长单词与URL地址自动换行"><a href="#2-长单词与URL地址自动换行" class="headerlink" title="2. 长单词与URL地址自动换行"></a>2. 长单词与URL地址自动换行</h4><p>对于西方文字来说，浏览器在半角空格或连字符的地方进行换行。因此，浏览器不能给较长的单词自动换行。当浏览器窗口比较窄的时候，文字会超出浏览器的窗口，浏览器下部出现滚动条，让用户通过拖动滚动条的方法来查看没有在当前窗口显示的文字。</p><p>在css3中，使用<code>word-wrap</code>属性来实现长单词与url地址的自动换行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>word-wrap</code>属性可以使用的属性值为<code>normal</code>与<code>break-word</code>两个。使用<code>normal</code>属性值时浏览器保持默认处理，只在半角空格或连字符的地方进行换行。使用<code>break-word</code>时浏览器可以在长单词或url地址内部进行换行。</p><hr><h3 id="三、使用服务器端字体"><a href="#三、使用服务器端字体" class="headerlink" title="三、使用服务器端字体"></a>三、使用服务器端字体</h3><p>在css3之前，页面文字所使用的字体必须已经在客户端中被安装才能正常显示，在样式表中允许指定当前字体不能正常显示时使用的替代字体，但是如果这个替代字体在客户端中也没有被安装时，使用这个字体的文字就不能正常显示了。</p><p>在css3中，使用<code>@font-face</code>属性来利用服务器端字体</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: WebFont;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'font/Fontin_Sans_R_45b.otf'</span>) <span class="built_in">format</span>(<span class="string">'opentype'</span>);</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>font-family</code>属性值用<code>WebFont</code>来声明使用服务器端的字体。<code>src</code>属性值指定服务器端字体的字体文件所在的路径。</p><p>在针对元素使用这个服务器端字体的时候，还需要在元素样式中将<code>font-family</code>属性值指定为<code>WebFont</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: WebFont;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@font-face</code>属性不仅可以用于显示服务器端的字体，也可以用来显示客户端本地的字体。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">local</span>(<span class="string">'Arial'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@font-face</code>属性显示客户端本地字体的好处是可以让浏览器在对字体进行显示时首先在客户端本地寻找是否存在该字体，当客户端寻找不到时在可使用服务器端的字体。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: MyHelvetica;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">local</span>(<span class="string">'Helvetica Neue'</span>) <span class="built_in">url</span>(MgOpenModernaRegular.ttf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、修改字体种类而保持字体尺寸不变"><a href="#四、修改字体种类而保持字体尺寸不变" class="headerlink" title="四、修改字体种类而保持字体尺寸不变"></a>四、修改字体种类而保持字体尺寸不变</h3><p>如果改变了字体的种类，则页面中所有使用改字体的文字大小都可能发生变化，从而使得原来安排好的页面布局产生混乱。</p><p>因此，在css3中增加了<code>font-size-adjust</code>属性，可以在保持文字大小不发生变化的情况下改变字体的种类。</p><p><code>font-size-adjust</code>属性的使用方法很简单，但是它需要使用每个字体种类自带的一个<code>aspect</code>值（比例值）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Times New Roman;</span><br><span class="line">    <span class="attribute">font-size-adjust</span>: <span class="number">0.46</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>aspect</code>值可以用来在将字体修改为其他字体时保持字体大小基本不变，这个<code>aspect</code>值的计算方法为<code>x-height</code>值除以该字体的尺寸，<code>x-height</code>值是指使用这个字体书写出来的小写<code>x</code>的高度（像素为单位）。如果某个字体的尺寸为100px时，<code>x-height</code>值为58px，则该字体的<code>aspect</code>为0.58，因为字体的<code>x-height</code>值总是随着字体的尺寸一起改变的，所以字体的<code>aspect</code>值都是一个常数。</p><p><strong>常用的西方字体aspect值</strong></p><table><thead><tr><th>字体种类</th><th>aspect值</th></tr></thead><tbody><tr><td>Verdana</td><td>0.58</td></tr><tr><td>Comic Sans MS</td><td>0.54</td></tr><tr><td>Trebuchet MS</td><td>0.53</td></tr><tr><td>Georgia</td><td>0.5</td></tr><tr><td>Myriad Web</td><td>0.48</td></tr><tr><td>Minion Web</td><td>0.47</td></tr><tr><td>Times New Roman</td><td>0.46</td></tr><tr><td>Gill Sans</td><td>0.46</td></tr><tr><td>Bernhard Modern</td><td>0.4</td></tr><tr><td>Caflisch Script Web</td><td>0.37</td></tr><tr><td>Fjemish Script</td><td>0.28</td></tr></tbody></table><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章针对css3中与文字、字体相关的一些属性做详细介绍，其中包括&lt;code&gt;text-shadow&lt;/code&gt;属性、&lt;code&gt;word-break&lt;/code&gt;属性、&lt;code&gt;word-wrap&lt;/code&gt;属性、&lt;code&gt;Web Font&lt;/code&gt;和&lt;code&gt;@font-face&lt;/code&gt;属性，以及&lt;code&gt;font-size-adjust&lt;/code&gt;属性。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="文字样式" scheme="http://www.xiaoleon.cn/tags/%E6%96%87%E5%AD%97%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="服务器端字体" scheme="http://www.xiaoleon.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(2) 巧用Content</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-2/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-2/</id>
    <published>2018-01-22T13:36:53.000Z</published>
    <updated>2018-01-27T09:00:09.432Z</updated>
    
    <content type="html"><![CDATA[<p><code>content</code>是<code>before</code>与<code>after</code>伪元素中的属性值，用于在伪元素中展示相关内容，我们可以利用这个属性实现一些小功能。</p><a id="more"></a><h3 id="一、读取元素属性"><a href="#一、读取元素属性" class="headerlink" title="一、读取元素属性"></a>一、读取元素属性</h3><p>可以将<code>alt</code>属性的值作为图像的标题来显示，如果在<code>content</code>属性中通过<code>“attr(属性名)”</code>这种形式来指定<code>attr</code>属性值，可以将某个属性的属性值显示出来。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">attr</span>(alt);</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"sky.jpg"</span> <span class="attr">alt</span>=<span class="string">"蓝天白云"</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="二、插入项目编号"><a href="#二、插入项目编号" class="headerlink" title="二、插入项目编号"></a>二、插入项目编号</h3><p>可以使用<code>content</code>属性来插入项目编号，在<code>content</code>属性中使用<code>counter</code>属性来针对多个项目追加连续编号。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(mycounter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'Part '</span><span class="built_in">counter</span>(mycounter)<span class="string">': '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>before</code>选择器或<code>after</code>选择器的<code>content</code>属性，不仅可以追加数字编号，还可以追加字母编号或罗马数字编号</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(mycounter, upper-alpha)<span class="string">'. '</span>;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">42px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>list-style-type</code>属性来指定编号的种类，例如，指定大写字母编号时，使用<code>upper-alpha</code>属性，指定大写罗马字母时，使用<code>upper-roman</code>属性。</p><h4 id="1-编号嵌套"><a href="#1-编号嵌套" class="headerlink" title="1. 编号嵌套"></a>1. 编号嵌套</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(mycounter)<span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(subcounter)<span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: subcounter;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要对编号进行重置，则需要使用 <code>counter-reset</code> 属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: mycounter;</span><br><span class="line">    <span class="attribute">counter-reset</span>: subcounter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-大编号嵌套中编号"><a href="#2-大编号嵌套中编号" class="headerlink" title="2. 大编号嵌套中编号"></a>2. 大编号嵌套中编号</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(mycounter) <span class="string">'-'</span> <span class="built_in">counter</span>(subcounter) <span class="string">'. '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、添加嵌套文字符号"><a href="#三、添加嵌套文字符号" class="headerlink" title="三、添加嵌套文字符号"></a>三、添加嵌套文字符号</h3><p>可以使用<code>content</code>属性的<code>open-quote</code>属性值与<code>close-quote</code>属性值在字符串两边添加诸如括号、单引号、双引号之类的嵌套文字符号。</p><p>另外，在元素的样式中使用<code>quotes</code>属性来指定使用什么嵌套文字符号。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: open-quote;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: close-quote;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">quotes</span>: <span class="string">"("</span> <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;content&lt;/code&gt;是&lt;code&gt;before&lt;/code&gt;与&lt;code&gt;after&lt;/code&gt;伪元素中的属性值，用于在伪元素中展示相关内容，我们可以利用这个属性实现一些小功能。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Content应用" scheme="http://www.xiaoleon.cn/tags/Content%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(1) 选择器</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-1/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-1/</id>
    <published>2018-01-22T13:29:23.000Z</published>
    <updated>2018-01-27T08:59:56.781Z</updated>
    
    <content type="html"><![CDATA[<p>选择器是CSS3中的一个重要内容，使用它可以大幅度提高开发人员书写或修改样式表时的工作效率。</p><a id="more"></a><p>通常我们会在元素上定义<code>class</code>属性，然后根据元素的<code>class</code>属性在css文件中定义相关的样式。使用<code>class</code>属性有两个缺点：</p><ul><li><p><code>class</code>属性本身没有语义，它纯粹时用来为css样式服务的，属于多余属性。</p></li><li><p>使用<code>class</code>属性的话，并没有把样式与元素绑定起来，针对同一个<code>class</code>属性，文本框也可以使用，下拉框也可以使用，甚至按钮也可以使用，这样其实是非常混乱的，修改样式的时候也很不方便。</p></li></ul><p>所以在CSS3中，提倡使用选择器来将样式与元素直接绑定起来，这样的话，在样式表中什么样式与什么元素相匹配变得一目了然，修改起来也很方便。不仅如此，通过选择器，我们还可以实现各种复杂的指定，同时也能大量减少样式表的代码书写量，最终书写出来的样式表也会变得简洁明了。</p><h3 id="一、属性选择器"><a href="#一、属性选择器" class="headerlink" title="一、属性选择器"></a>一、属性选择器</h3><p>html中，我们可以通过各种各样的属性，给元素增加很多附加信息。例如通过<code>width</code>属性，我们可以指定<code>div</code>元素的宽度；通过<code>id</code>属性，我们可以将不同的<code>div</code>元素进行区分。</p><p>css3中，增加了如下所示三种属性选择器，使得属性选择器有了通配符的概念</p><ul><li><p>[att*=val]</p><p>  如果元素用<code>att</code>表示的属性之属性值包含用<code>val</code>指定的字符的话，则该元素使用这个样式。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[id*=section]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id="section1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="section1-1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="hs-section"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="hs-section-1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><p>[att^=val]</p><p>  如果元素用<code>att</code>表示的属性之属性值的开头字符为用<code>val</code>指定的字符的话，则该元素使用这个样式。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[id^=section]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id="section1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="section1-1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><p>[att$=val]</p><p>  如果元素用<code>att</code>表示的属性之属性值的结尾字符为用<code>val</code>指定的字符的话，则该元素使用这个样式。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[id$=section]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id="hssection"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="hs-section"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>使用示例</strong>: 根据<code>a</code>标签的<code>href</code>中不同的文件扩展符，使用不同的样式，在超链接地址的末尾添加不同的文字</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=\/]</span><span class="selector-pseudo">:after</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$=htm]</span><span class="selector-pseudo">:after</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$=html]</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'web网页'</span>;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=jpg]</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'jpg图片'</span>;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、伪类选择器"><a href="#二、伪类选择器" class="headerlink" title="二、伪类选择器"></a>二、伪类选择器</h3><p>所谓伪类选择器，是指并不是针对真正的元素使用的选择器，而针对CSS中已经定义号的伪元素使用的选择器。CSS中主要有四个伪元素选择器：</p><ul><li><p><code>first-line</code>伪元素选择器</p><p>  用于为某个元素中的第一行文字使用样式</p></li><li><p><code>first-letter</code>伪元素选择器</p><p>  用于为某个元素中的文字的首字母或第一个字使用样式</p></li><li><p><code>before</code>伪元素选择器</p><p>  用于在某个元素之前插入一些内容</p></li><li><p><code>after</code>伪元素选择器</p><p>  用于在某个元素之后插入一些内容</p></li></ul><hr><h3 id="三、root、not、empty、target"><a href="#三、root、not、empty、target" class="headerlink" title="三、root、not、empty、target"></a>三、root、not、empty、target</h3><h4 id="1-root选择器"><a href="#1-root选择器" class="headerlink" title="1. root选择器"></a>1. root选择器</h4><p><code>root</code>选择器将样式绑定到页面的根元素中。所谓根元素，是指位于文档树中最顶层结构的元素，在HTML页面中就是指包含着整个页面的<code>“&lt;html&gt;”</code>部分。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: limegreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-not"><a href="#2-not" class="headerlink" title="2. not"></a>2. not</h4><p>如果相对某个结构元素使用样式，但是想排除这个结构元素下面的子结构元素，让它不使用这个样式时，可以使用<code>not</code>选择器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> *<span class="selector-pseudo">:not(h1)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-empty"><a href="#3-empty" class="headerlink" title="3. empty"></a>3. empty</h4><p>使用<code>empty</code>选择器来指定当元素内容为空白时使用的样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:empty</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-target"><a href="#4-target" class="headerlink" title="4. target"></a>4. target</h4><p>使用<code>target</code>选择器来对页面中的某个<code>target</code>元素（该元素的<code>id</code>被当作页面中的超链接来使用）指定样式，该样式只在用户点击了页面中的超链接，并且跳转到<code>target</code>元素后起作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:target</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、first-child、last-child、nth-child、nth-last-child"><a href="#四、first-child、last-child、nth-child、nth-last-child" class="headerlink" title="四、first-child、last-child、nth-child、nth-last-child"></a>四、first-child、last-child、nth-child、nth-last-child</h3><p>利用这几个选择器，能够特殊针对父元素的第一个子元素、最后一个子元素、指定序号的子元素、甚至第偶数个、第奇数个子元素进行样式的指定。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(n)</span> &#123;</span><br><span class="line">    <span class="comment">/* css中的n从1开始计数 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(even)</span> &#123;</span><br><span class="line">    <span class="comment">/* 所有正数下来的第偶数个子元素 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(odd)</span> &#123;</span><br><span class="line">    <span class="comment">/* 所有正数下来的第奇数个子元素 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-last-child(odd)</span> &#123;</span><br><span class="line">    <span class="comment">/* 所有倒数上去的第奇数个子元素 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="五、nth-of-type、nth-last-of-type"><a href="#五、nth-of-type、nth-last-of-type" class="headerlink" title="五、nth-of-type、nth-last-of-type"></a>五、nth-of-type、nth-last-of-type</h3><p>在css3中，使用<code>nth-of-type</code>选择器与<code>nth-last-of-type</code>选择器可以避免父元素下不同类型子元素的序号选择问题。使用这两个选择器的时候，css3在计算子元素是第奇数个还是第偶数个的时候，就只针对同类型的子元素进行计算。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:nth-of-type(odd)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:nth-of-type(even)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="六、循环使用样式"><a href="#六、循环使用样式" class="headerlink" title="六、循环使用样式"></a>六、循环使用样式</h3><p>如果我们有100个列表项目，需要重复使用前四种样式的设置，可以采用循环指定的方式，只要在 <code>nth-child(n)</code> 语句中，把参数 <code>n</code> 改成可循环的 <code>an + b</code> 的形式就可以，<code>a</code> 表示每次循环中共包括几种样式， <code>b</code> 表示指定的样式在循环中的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(4n+1)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(4n+2)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: limegreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(4n+3)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(4n)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="七、only-child"><a href="#七、only-child" class="headerlink" title="七、only-child"></a>七、only-child</h3><p>如果采用如下琐事的方法结合运用<code>nth-child</code>选择器与<code>nth-last-child</code>选择器的话，可以指定当某个父元素中只有一个子元素时才使用的样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span><span class="selector-pseudo">:nth-last-child(1)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外也可以使用<code>only-child</code>选择器来替代上面的实现方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:only-child</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="八、UI元素状态伪类选择器"><a href="#八、UI元素状态伪类选择器" class="headerlink" title="八、UI元素状态伪类选择器"></a>八、UI元素状态伪类选择器</h3><p>在CSS3的选择器中，除了结构性伪类选择器外，还有一种UI元素状态伪类选择器。这些选择器的共同特征是：指定的样式只有当元素处于某种状态下时才起作用，在默认状态下不起作用。</p><p>在CSS3中，共有11种UI元素状态伪类选择器，分别是</p><p><code>E:hover  E:active  E:focus  E:enabled  E:disabled  E:read-only  E:read-write  E:checked  E:default  E:indeterminate  E::selection</code></p><h4 id="1-E-hover"><a href="#1-E-hover" class="headerlink" title="1. E:hover"></a>1. E:hover</h4><p>指定当鼠标指针移动到元素上面时元素所使用的样式</p><h4 id="2-E-active"><a href="#2-E-active" class="headerlink" title="2. E:active"></a>2. E:active</h4><p>指定元素被激活（鼠标在元素上按下还没有松开）时使用的样式</p><h4 id="3-E-focus"><a href="#3-E-focus" class="headerlink" title="3. E:focus"></a>3. E:focus</h4><p>指定元素获得光标焦点时使用的样式，主要是在文本框控件获得焦点并进行文字输入的时候使用</p><h4 id="4-E-enabled"><a href="#4-E-enabled" class="headerlink" title="4. E:enabled"></a>4. E:enabled</h4><p>指定当元素处于可用状态时的样式</p><h4 id="5-E-disabled"><a href="#5-E-disabled" class="headerlink" title="5. E:disabled"></a>5. E:disabled</h4><p>指定当元素处于不可用状态时的样式</p><h4 id="6-E-read-only"><a href="#6-E-read-only" class="headerlink" title="6. E:read-only"></a>6. E:read-only</h4><p>指定当元素处于只读状态时的样式</p><h4 id="7-E-read-write"><a href="#7-E-read-write" class="headerlink" title="7. E:read-write"></a>7. E:read-write</h4><p>指定当元素处于非只读状态时的样式</p><h4 id="8-E-checked"><a href="#8-E-checked" class="headerlink" title="8. E:checked"></a>8. E:checked</h4><p>指定当表单中的<code>radio</code>或<code>checkbox</code>处于选取状态时的样式，在firefox浏览器中，需要写成 <code>-moz-checked</code> 的形式</p><h4 id="9-E-default"><a href="#9-E-default" class="headerlink" title="9. E:default"></a>9. E:default</h4><p>指定当页面打开默认处于选取状态的单选框或复选框控件的样式</p><h4 id="10-E-indeterminate"><a href="#10-E-indeterminate" class="headerlink" title="10. E:indeterminate"></a>10. E:indeterminate</h4><p>指定当页面打开时，如果一组单选框中任何一个单选框都没有被设定为选取状态时整组单选框的样式，如果用户选取了对其中任何一个单选框，则该样式被取消指定</p><h4 id="11-E-selection"><a href="#11-E-selection" class="headerlink" title="11. E::selection"></a>11. E::selection</h4><p>指定当元素处于选中状态时的样式</p><hr><h3 id="九、通用兄弟元素选择器"><a href="#九、通用兄弟元素选择器" class="headerlink" title="九、通用兄弟元素选择器"></a>九、通用兄弟元素选择器</h3><p>通用兄弟元素选择器，用来指定位于同一个父元素之中的某个元素之后的所有其他某个种类的兄弟元素所使用的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;子元素&gt;~&lt;子元素之后的同级兄弟元素&gt; &#123;</span><br><span class="line">    // 指定样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;选择器是CSS3中的一个重要内容，使用它可以大幅度提高开发人员书写或修改样式表时的工作效率。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS选择器" scheme="http://www.xiaoleon.cn/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>H5(13) Geolocation</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/html5-13/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/html5-13/</id>
    <published>2018-01-22T13:23:54.000Z</published>
    <updated>2018-01-27T09:03:18.531Z</updated>
    
    <content type="html"><![CDATA[<p>在HTML5中，为<code>window.navigator</code>对象新增了一个<code>geolocation</code>属性，可以使用<code>Geolocation API</code>来对该属性进行访问。</p><a id="more"></a><h3 id="一、获取当前位置"><a href="#一、获取当前位置" class="headerlink" title="一、获取当前位置"></a>一、获取当前位置</h3><p>可以使用<code>getCurrentPosition</code>方法来取得用户当前的地理位置信息，该方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> getCurrentPosition(onSuccess, onError, options);</span><br></pre></td></tr></table></figure><p>第一个参数为获取当前地理位置信息成功时所执行的回调函数</p><p>第二个参数为获取当前地理位置信息失败时所执行的回调函数（可选）</p><p>第三个参数为一些可选属性的列表（可选）</p><p><code>onSuccess</code>回调函数中，用到了一个参数<code>position</code>，它代表一个<code>position</code>对象，我们在后面对这个对象进行介绍</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(<span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取成功时的处理</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>onError</code>回调函数中，用到了一个<code>error</code>对象，该对象具有以下两个属性：</p><ul><li><p><code>code</code>属性。<code>code</code>属性为以下三个值其中之一：</p><ul><li><p>用户拒绝了位置服务（数字值为1）</p></li><li><p>获取不到位置信息（数字值为2）</p></li><li><p>获取信息超时错误（数字值为3）</p></li></ul></li><li><p><code>message</code>属性。</p><p>  <code>message</code>属性为一个字符串，在该字符串中包含了错误信息。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> coords = position.coords;</span><br><span class="line">        showMap(coords.latitude, coords.longitude, coords.accuracy);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> errorTypes = &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="string">'位置服务被拒绝'</span>,</span><br><span class="line">            <span class="number">2</span>: <span class="string">'获取不到位置信息'</span>,</span><br><span class="line">            <span class="number">3</span>: <span class="string">'获取信息超时'</span></span><br><span class="line">        &#125;;</span><br><span class="line">        alert(errorTypes[error.code] + <span class="string">': 不能确定你的当前地理位置'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>options</code>是一些可选属性的列表，包含如下：</p><ul><li><p>enableHighAccuracy</p><p>  是否要求高精度的地理位置信息，这个参数在很多设备上设置了都没用，因为使用在设备上时要结合设备电量、具体地理情况来综合考虑</p></li><li><p>timeout</p><p>  对地理位置信息的获取操作做一个超时限制（单位为毫秒）。如果在改时间内未获取到地理位置信息，则返回错误</p></li><li><p>maximumAge</p><p>  对地理位置信息进行缓存的有效时间（单位为毫秒）。如果该值指定为0，则无条件重新获取新的地理位置信息</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        maximumAge: <span class="number">60</span> * <span class="number">1000</span> * <span class="number">2</span>,</span><br><span class="line">        timeout: <span class="number">5000</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h3 id="二、持续监视当前地理位置信息"><a href="#二、持续监视当前地理位置信息" class="headerlink" title="二、持续监视当前地理位置信息"></a>二、持续监视当前地理位置信息</h3><p>使用<code>watchPosition</code>方法来持续获取用户当前地理位置信息，它会定期地自动获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int watchCurrentPosition(onSuccess, onError, options);</span><br></pre></td></tr></table></figure><p>该方法与<code>getCurrentPosition</code>方法的参数说明与使用方法相同，该方法返回一个数字，这个数字的使用与<code>setInterval</code>的返回参数值类似，可以被<code>clearWatch</code>方法使用，停止对当前地理位置信息的监视。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> clearWatch(watchId)</span><br></pre></td></tr></table></figure><hr><h3 id="三、position对象"><a href="#三、position对象" class="headerlink" title="三、position对象"></a>三、position对象</h3><p>通过访问<code>position</code>对象，可以得到地理位置信息</p><ul><li><p>latitude</p><p>  当前地理位置的纬度</p></li><li><p>longitude</p><p>  当前地理位置的精度</p></li><li><p>altitude</p><p>  当前位置的海拔高度</p></li><li><p>accuracy</p><p>  获取到的纬度或经度的精度（单位为米）</p></li><li><p>altitudeAccurancy</p><p>  获取到的海拔高度的精度（单位为米）</p></li><li><p>heading</p><p>  设备的前进方向，以面朝正北方向的顺时针旋转角度来表示</p></li><li><p>speed</p><p>  设备的前进速度（单位为米/秒）</p></li><li><p>timestamp</p><p>  获取地理位置信息时的时间</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在HTML5中，为&lt;code&gt;window.navigator&lt;/code&gt;对象新增了一个&lt;code&gt;geolocation&lt;/code&gt;属性，可以使用&lt;code&gt;Geolocation API&lt;/code&gt;来对该属性进行访问。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5抄书笔记" scheme="http://www.xiaoleon.cn/categories/HTML5%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Geolocation" scheme="http://www.xiaoleon.cn/tags/Geolocation/"/>
    
  </entry>
  
  <entry>
    <title>H5(12) Web Workers</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/html5-12/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/html5-12/</id>
    <published>2018-01-22T13:19:17.000Z</published>
    <updated>2018-01-27T09:03:09.203Z</updated>
    
    <content type="html"><![CDATA[<p><code>Web Workers</code>是HTML5中新增的，用来在Web应用程序中实现后台处理的一项技术。</p><p>在使用HTML4与Javascript创建出来的Web程序中，因为所有的处理都是在单线程内执行的，所以如果花费的事件比较长的话，程序界面会处于长时间没有响应的状态。最恶劣的是，当时间长到一定程度的话，浏览器还会跳出一个提示脚本运行时间过长的提示框，使用户不得不中断正在执行的处理。</p><a id="more"></a><h3 id="一、Web-Worker介绍"><a href="#一、Web-Worker介绍" class="headerlink" title="一、Web Worker介绍"></a>一、Web Worker介绍</h3><p>为了解决这个问题，HTML5新增了一个<code>Web Workers API</code>。使用这个API，用户可以很容易地创建在后台运行的线程（在HTML5中被称为<code>worker</code>），如果将可能耗费较长时间的处理交给后台去执行的话，对用户在前台页面中执行的操作就完全没有影响了。</p><p>创建后台线程的步骤十分简单。只要在<code>Worker</code>类的构造器中，将需要在后台线程中执行的脚本文件的url地址作为参数，然后创建<code>Worker</code>对象就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>要注意在后台线程中是不能访问页面或窗口对象的。如果在后台线程的脚本文件中使用到<code>window</code>对象或<code>document</code>对象，则会引起错误的发生。</p></blockquote><p>另外，可以通过发送和接收消息来与后台线程互相传递数据。通过对<code>Worker</code>对象的<code>onmessage</code>事件句柄的获取可以在后台线程之中接收消息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理收到的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>Worker</code>对象的<code>postMessage</code>方法来对后台线程发送消息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(message);</span><br></pre></td></tr></table></figure><p>另外，同样可以通过获取<code>Worker</code>对象的<code>onmessage</code>事件句柄及<code>Worker</code>对象的<code>postMessage</code>方法在后台线程内部进行消息的接收和发送。</p><p>使用示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>从1到给定数值的求和示例<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    输入数值：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">id</span>=<span class="string">"num"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"calculate()"</span>&gt;</span>计算<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'calculate.js'</span>);</span></span><br><span class="line"><span class="javascript">        worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">`合计值：<span class="subst">$&#123;event.data&#125;</span>`</span>);</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="built_in">document</span>.getElementById(<span class="string">'num'</span>).value, <span class="number">10</span>);</span></span><br><span class="line"><span class="undefined">            worker.postMessage(num);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate.js</span></span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = event.data;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        result += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向线程创建源送回消息</span></span><br><span class="line">    postMessage(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、线程嵌套"><a href="#二、线程嵌套" class="headerlink" title="二、线程嵌套"></a>二、线程嵌套</h3><p>线程中可以嵌套子线程，这样的话我们可以把一个较大的后台线程切分成几个子线程，在每个子线程中各自完成相对独立的一部分工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker1.js</span></span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> intArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        intArray[i] = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> worker;</span><br><span class="line">    worker = <span class="keyword">new</span> Worker(<span class="string">'worker2.js'</span>);</span><br><span class="line">    worker.postMessage(<span class="built_in">JSON</span>.stringify(intArray));</span><br><span class="line">    worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        postMessage(event.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker2.js</span></span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> intArray = <span class="built_in">JSON</span>.parse(event.data);</span><br><span class="line">    <span class="keyword">var</span> returnStr = <span class="string">''</span>;</span><br><span class="line">    ...</span><br><span class="line">    postMessage(returnStr);</span><br><span class="line">    close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：在子线程中向发送源发送回消息后，最好使用<code>close</code>语句关闭子线程，如果该子线程不再使用的话。</p></blockquote><hr><h3 id="三、线程中可用的变量、函数与类"><a href="#三、线程中可用的变量、函数与类" class="headerlink" title="三、线程中可用的变量、函数与类"></a>三、线程中可用的变量、函数与类</h3><p>我们总体看一下在线程用的Javascript中所有可用的变量、函数与类</p><h4 id="1-self"><a href="#1-self" class="headerlink" title="1. self"></a>1. self</h4><p><code>self</code>关键词用来表示本线程范围内的作用域</p><h4 id="2-postMessage-message"><a href="#2-postMessage-message" class="headerlink" title="2. postMessage(message)"></a>2. postMessage(message)</h4><p>向创建线程的源窗口发送消息</p><h4 id="3-onmessage"><a href="#3-onmessage" class="headerlink" title="3. onmessage"></a>3. onmessage</h4><p>获取接收消息的事件句柄</p><h4 id="4-importScripts-urls"><a href="#4-importScripts-urls" class="headerlink" title="4. importScripts(urls)"></a>4. importScripts(urls)</h4><p>导入其他Javascript文件，参数为该文件的url地址，可以导入多个文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importScripts(<span class="string">'script1.js'</span>, <span class="string">'scripts\script2.js'</span>, <span class="string">'script\script3.js'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>导入的文件必须与使用该线程的文件的页面在同一个域中，并在同一个端口中</p></blockquote><h4 id="5-navigator对象"><a href="#5-navigator对象" class="headerlink" title="5. navigator对象"></a>5. navigator对象</h4><p>与<code>window.navigator</code>对象相似，具有<code>appName</code>、<code>platform</code>、<code>userAgent</code>、<code>appVersion</code>属性</p><h4 id="6-sessionStorage-localStorage"><a href="#6-sessionStorage-localStorage" class="headerlink" title="6. sessionStorage/localStorage"></a>6. sessionStorage/localStorage</h4><p>可以在线程中使用<code>Web Storage</code></p><h4 id="7-XMLHttpRequest"><a href="#7-XMLHttpRequest" class="headerlink" title="7. XMLHttpRequest"></a>7. XMLHttpRequest</h4><p>可以在线程中处理<code>Ajax</code>请求</p><h4 id="8-Web-Workers"><a href="#8-Web-Workers" class="headerlink" title="8. Web Workers"></a>8. Web Workers</h4><p>可以在线程中嵌套线程</p><h4 id="9-setTimeout-setInterval"><a href="#9-setTimeout-setInterval" class="headerlink" title="9. setTimeout()/setInterval()"></a>9. setTimeout()/setInterval()</h4><p>可以在线程中实现定时处理</p><h4 id="10-close"><a href="#10-close" class="headerlink" title="10. close"></a>10. close</h4><p>可以结束本线程</p><h4 id="11-eval-、isNaN-、escape-等"><a href="#11-eval-、isNaN-、escape-等" class="headerlink" title="11. eval()、isNaN()、escape()等"></a>11. eval()、isNaN()、escape()等</h4><p>可以使用所有的Javascript核心函数</p><h4 id="12-object"><a href="#12-object" class="headerlink" title="12. object"></a>12. object</h4><p>可以创建和使用本地对象</p><h4 id="13-WebSockets"><a href="#13-WebSockets" class="headerlink" title="13. WebSockets"></a>13. WebSockets</h4><p>可以使用<code>WebSockets API</code>来向服务器发送和接收消息</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Web Workers&lt;/code&gt;是HTML5中新增的，用来在Web应用程序中实现后台处理的一项技术。&lt;/p&gt;
&lt;p&gt;在使用HTML4与Javascript创建出来的Web程序中，因为所有的处理都是在单线程内执行的，所以如果花费的事件比较长的话，程序界面会处于长时间没有响应的状态。最恶劣的是，当时间长到一定程度的话，浏览器还会跳出一个提示脚本运行时间过长的提示框，使用户不得不中断正在执行的处理。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5抄书笔记" scheme="http://www.xiaoleon.cn/categories/HTML5%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Web Workers" scheme="http://www.xiaoleon.cn/tags/Web-Workers/"/>
    
  </entry>
  
  <entry>
    <title>H5(11) Web Sockets</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/html5-11/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/html5-11/</id>
    <published>2018-01-22T13:14:50.000Z</published>
    <updated>2018-01-27T09:03:02.027Z</updated>
    
    <content type="html"><![CDATA[<p><code>Web Sockets</code>是HTML5提供的在Web应用程序客户端与服务器端之间进行的非HTTP的通信机制。它实现了用HTTP不容易实现的服务器端的数据推送等智能通信技术，因此受到了高度关注。</p><p>使用<code>Web Sockets API</code>可以在服务器与客户端之间建立一个非HTTP的双向连接。这个连接时实时的，也是永久的，除非被显式关闭。这意味着当服务器想向客户端发送数据时，可以立即将数据推送到客户端的浏览器中，无须重新建立连接。只要客户端有一个被打开的<code>socket</code>（套接字）并且与服务器建立了连接，服务器就可以把数据推送到这个<code>socket</code>上，服务器不再需要轮训客户端的请求，从被动转为了主动。</p><a id="more"></a><p><code>Web Sockets</code>的API本身非常简单，将url字符串作为参数，然后调用<code>WebSocket</code>对象的构造器来建立与服务器之间的通信连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webSocket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost/socket'</span>);</span><br></pre></td></tr></table></figure><p>url字符串必须以<code>“ws”</code>或<code>“wss”</code>（加密通信时）文字作为开头。这个url字符串被设定好之后，在JS脚本中可以通过访问<code>WebSocket</code>对象的<code>url</code>属性来重新获取。</p><p>通信建立好之后，就可以进行客户端与服务器端的双向通信了。使用<code>WebSocket</code>对象的<code>send</code>方法对服务器发送数据，只能发送文本数据，但是可以使用JSON对象把任何Javascript对象转换成文本数据后进行发送</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webSocket.send(<span class="string">'data'</span>);</span><br></pre></td></tr></table></figure><p>通过获取<code>onmessage</code>事件的句柄来接收服务器传过来的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webSocket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.data;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过获取<code>onopen</code>事件句柄来监听<code>socket</code>的打开事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webSocket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 开始通信时的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过获取<code>onclose</code>事件句柄来监听<code>socket</code>的关闭事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webSocket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通信结束时的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>close</code>方法来关闭<code>socket</code>，切断通信连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webSocket.close();</span><br></pre></td></tr></table></figure><p>另外，可以通过读取<code>readyState</code>的属性值来获取<code>WebSocket</code>对象的状态，<code>readyState</code>属性存在以下几种值：</p><ul><li><p><code>CONNECTING</code>（数字值为0） —— 正在连接</p></li><li><p><code>OPEN</code>（数字值为1） —— 已建立连接</p></li><li><p><code>CLOSING</code>（数字值为2） —— 正在关闭连接</p></li><li><p><code>CLOSED</code>（数字值为3） —— 已关闭连接</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Web Sockets&lt;/code&gt;是HTML5提供的在Web应用程序客户端与服务器端之间进行的非HTTP的通信机制。它实现了用HTTP不容易实现的服务器端的数据推送等智能通信技术，因此受到了高度关注。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;Web Sockets API&lt;/code&gt;可以在服务器与客户端之间建立一个非HTTP的双向连接。这个连接时实时的，也是永久的，除非被显式关闭。这意味着当服务器想向客户端发送数据时，可以立即将数据推送到客户端的浏览器中，无须重新建立连接。只要客户端有一个被打开的&lt;code&gt;socket&lt;/code&gt;（套接字）并且与服务器建立了连接，服务器就可以把数据推送到这个&lt;code&gt;socket&lt;/code&gt;上，服务器不再需要轮训客户端的请求，从被动转为了主动。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5抄书笔记" scheme="http://www.xiaoleon.cn/categories/HTML5%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Web Sockets" scheme="http://www.xiaoleon.cn/tags/Web-Sockets/"/>
    
  </entry>
  
  <entry>
    <title>H5(10) 跨文档消息传输</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/html5-10/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/html5-10/</id>
    <published>2018-01-22T13:10:17.000Z</published>
    <updated>2018-01-27T09:02:50.852Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5提供了在网页文档之间相互接收与发送信息的功能。使用这个功能，只要获取到网页所在窗口对象的实例，不仅同源（域+端口号）的Web网页之间可以互相通信，甚至可以实现跨域通信。</p><a id="more"></a><p>首先，想要接受从其他的窗口那里发过来的消息，就必须对窗口对象的<code>message</code>事件进行监视，代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>使用<code>window</code>对象的<code>postMessage</code>方法向其他窗口发送消息，该方法的定义如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin);</span><br></pre></td></tr></table></figure><p>otherWindow为要发送窗口对象的引用，可以通过<code>window.open</code>返回该对象，或通过对<code>window.frames</code>数组指定序号或名字的方式来返回单个frame所属的窗口对象。</p><p>第一个参数为所发送的消息文本，或JSON转换后的文本。</p><p>第二个参数为接收消息的对象窗口的url地址。可以在url地址字符串中使用通配符<code>“*”</code>指定全部地址，不过建议使用准确的url地址。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.html  http://localhost:8100/html/parent.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        div &#123;</span></span><br><span class="line"><span class="undefined">            margin: 10px;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Parent Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line">            Message Content</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"postMessage()"</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Child Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:8111/html/child.html"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (ev.origin != <span class="string">'http://localhost:8111'</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'msg'</span>).innerHTML = <span class="string">`</span></span></span><br><span class="line"><span class="undefined">                从$&#123;ev.origin&#125;那里传过来的消息：$&#123;ev.data&#125;</span></span><br><span class="line"><span class="undefined">            `</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">postMessage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> msg = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).value;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> iframe = <span class="built_in">window</span>.frames[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">            iframe.postMessage(msg, <span class="string">'http://localhost:8111/html/child.html'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- child.html  http://localhost:8111/html/child.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        div &#123;</span></span><br><span class="line"><span class="undefined">            margin: 10px;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line">        Message Content</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"postMessage()"</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> source, origin;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (ev.origin != <span class="string">'http://localhost:8100'</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            source = ev.source;</span></span><br><span class="line"><span class="undefined">            origin = ev.origin;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'msg'</span>).innerHTML = <span class="string">`</span></span></span><br><span class="line"><span class="undefined">                从$&#123;ev.origin&#125;那里来的消息：$&#123;ev.data&#125;</span></span><br><span class="line"><span class="undefined">            `;</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">postMessage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> msg = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).value;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (source &amp;&amp; origin) &#123;</span></span><br><span class="line"><span class="undefined">                source.postMessage(msg, origin);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>本示例中的几个关键之处：</p><ol><li><p>通过对<code>window</code>对象的<code>message</code>事件进行监听，可以接收消息。</p></li><li><p>通过访问<code>message</code>事件的<code>origin</code>属性，可以获取消息的发送源。</p><blockquote><p>发送源与网站的url地址不是同一概念，发送源只包含域名和端口号，为了不接收从其他源恶意发送过来的消息，最好对发送源做个检查。</p></blockquote></li><li><p>通过访问<code>message</code>事件的<code>data</code>属性，可以获取消息内容</p></li><li><p>使用<code>postMessage</code>方法发送消息</p></li><li><p>通过访问<code>message</code>事件的<code>source</code>属性，可以获取消息发送源的窗口对象（准确的说，应该时窗口的代理对象）</p></li></ol><p>通过这种方式，可以实现网页文档与网页文档之间、端口与端口之间、域与域之间互相传递消息。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML5提供了在网页文档之间相互接收与发送信息的功能。使用这个功能，只要获取到网页所在窗口对象的实例，不仅同源（域+端口号）的Web网页之间可以互相通信，甚至可以实现跨域通信。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5抄书笔记" scheme="http://www.xiaoleon.cn/categories/HTML5%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="文档通信" scheme="http://www.xiaoleon.cn/tags/%E6%96%87%E6%A1%A3%E9%80%9A%E4%BF%A1/"/>
    
      <category term="跨域通信" scheme="http://www.xiaoleon.cn/tags/%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>H5(9) 离线Web应用程序</title>
    <link href="http://www.xiaoleon.cn/2018/01/21/html5-9/"/>
    <id>http://www.xiaoleon.cn/2018/01/21/html5-9/</id>
    <published>2018-01-21T14:00:12.000Z</published>
    <updated>2018-01-27T09:02:44.315Z</updated>
    
    <content type="html"><![CDATA[<p>Web应用程序已经变得越来越复杂，越来越成熟了，很多领域都在利用着Web应用程序。但是，它有一个致命的缺点：如果用户没有和Internet建立连接，他就不能利用这个Web应用程序了。</p><a id="more"></a><p>因此，HTML5中新增了一个API，它使用一个本地缓存机制很好地解决了这个问题，为离线Web应用程序的开发提供了可能性。</p><p>为了让Web应用程序在离线状态时候也能正常工作，就必须要把所有构成Web应用程序的资源文件，诸如HTML文件、CSS文件、Javascript脚本文件等放在本地缓存中，当服务器没有和Internet建立连接的时候，也可以利用本地缓存中的资源文件来正常运行Web应用程序。</p><h3 id="一、本地缓存与浏览器网页缓存的区别"><a href="#一、本地缓存与浏览器网页缓存的区别" class="headerlink" title="一、本地缓存与浏览器网页缓存的区别"></a>一、本地缓存与浏览器网页缓存的区别</h3><p>本地缓存是为整个Web应用程序服务的，而浏览器的网页缓存只服务于单个网页。任何网页都具有网页缓存，而本地缓存只缓存那些你指定缓存的网页。</p><p>网页缓存是不安全、不可靠的，因为我们不知道在网站中到底缓存了哪些网页，以及缓存了网页上的哪些资源。而本地缓存是可靠的，我们可以控制对哪些内容进行缓存，不对哪些内容进行缓存，开发人员还可以用编程的手段来控制缓存的更新，利用缓存对象的各种属性、状态和事件来开发出更为强大的离线应用程序。</p><hr><h3 id="二、manifest文件"><a href="#二、manifest文件" class="headerlink" title="二、manifest文件"></a>二、manifest文件</h3><p>Web应用程序的本地缓存是通过每个页面的<code>manifest</code>文件来管理的。<code>manifest</code>文件是一个简单文本文件，在该文件中以清单的形式列举了需要被缓存或不需要被缓存的资源文件的文件名称，以及这些资源文件的访问路径。</p><p>可以为每一个页面单独指定一个<code>manifest</code>文件，也可以对整个Web应用程序指定一个总的<code>manifest</code>文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#version 7</span><br><span class="line">CACHE:</span><br><span class="line">other.html</span><br><span class="line">hello.js</span><br><span class="line">images/myphoto.jpg</span><br><span class="line">NETWORK:</span><br><span class="line">http://lulingniu/NotOffline</span><br><span class="line">NotOffline.asp</span><br><span class="line">*</span><br><span class="line">FALLBACK:</span><br><span class="line">online.js locale.js</span><br><span class="line">CACHE:</span><br><span class="line">newhello.html</span><br><span class="line">newhello.js</span><br></pre></td></tr></table></figure><p>在manifest文件中，第一行必须是“<code>CACHE MANIFEST</code>”文字，以把本文件的作用告知给浏览器，即对本地缓存中的资源文件进行具体设置。同时，真正运行或测试离线Web应用程序的时候，需要对服务器进行配置，让服务器支持<code>text/cache-manifest</code>这个MIME类型。</p><p>例如对Apache服务器进行配置的时候，需要找到<code>{apache_home}/conf/mime.types</code>这个文件，并在文件最后添加代码<code>text/cache-manifest   manifest</code></p><p>在指定资源文件的时候，可以把资源文件分为三类，分别是<code>CACHE</code>、<code>NETWORK</code>、<code>FALLBACK</code>：</p><ul><li><p><code>CACHE</code>类别中指定需要被缓存在本地的资源文件。为某个页面指定需要本地缓存的资源文件时，不需要把这个页面本身指定在<code>CACHE</code>类别中，因为如果一个页面具有<code>manifest</code>文件，浏览器会自动对这个页面进行本地缓存</p></li><li><p><code>NETWORK</code>类别为显式指定不进行本地缓存的资源文件，这些资源文件只有当客户端与服务器端建立连接的时候才能访问。本示例中该类别的<code>“*”</code>为通配符，表示没有在本<code>manifest</code>文件中指定的资源文件都不进行本地缓存</p></li><li><p><code>FALLBACK</code>类别中的每行中指定两个资源文件，第一个资源文件为能够在线访问时使用的资源文件，第二个资源文件为不能在线访问时使用的备用资源文件。</p></li></ul><p>每个类别都是可选的，但是如果文件开头没有指定类别而直接书写资源文件时，浏览器把这些资源文件视为<code>CACHE</code>类别，直到看见文件中第一个被书写出来的类别为止。</p><p>为了让浏览器能够正常阅读该文本文件，需要在Web应用程序页面上的html标签的<code>manifest</code>属性中指定<code>manifest</code>文件的url地址。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可以为每个页面单独指定一个manifest文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"hello.manifest"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 也可以为整个Web应用程序指定一个总的manifest文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"global.manifest"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过这些步骤，将资源文件保存到本地缓存去的基本操作就完成了。当需要对本地缓存去的内容进行修改时，只需要修改<code>manifest</code>文件就可以了。文件被修改后，浏览器可以自动检查<code>manifest</code>文件，并自动更新本地缓存区的内容。</p><hr><h3 id="三、浏览器与服务器的交互过程"><a href="#三、浏览器与服务器的交互过程" class="headerlink" title="三、浏览器与服务器的交互过程"></a>三、浏览器与服务器的交互过程</h3><p>当使用离线Web应用程序进行工作的时候，有必要理解一下浏览器与服务器的交互过程。</p><p>例如一个<code>http://lulingniu</code>网站，以<code>index.html</code>为主页，<code>index.manifest</code>文件为<code>manifest</code>文件，在该文件中请求本地缓存<code>index.html</code>、<code>hello.js</code>、<code>hello1.jpg</code>、<code>hello2.jpg</code>这几个资源文件。</p><p><strong>交互过程</strong>：</p><h4 id="1-首次访问"><a href="#1-首次访问" class="headerlink" title="1. 首次访问"></a>1. 首次访问</h4><ul><li><p>1) 浏览器请求访问<code>http://lulingniu</code></p></li><li><p>2) 服务器返回<code>index.html</code>网页</p></li><li><p>3) 浏览器解析<code>index.html</code>网页，请求页面上所有资源文件，包括HTML文件、图像文件、CSS文件、JS文件，以及<code>manifest</code>文件</p></li><li><p>4) 服务器返回所有资源文件</p></li><li><p>5) 浏览器处理<code>manifest</code>文件，请求<code>manifest</code>中所有要求本地缓存的文件，包括<code>index.html</code>。如果要求本地缓存所有文件，这将是一个比较大的重复的请求过程</p></li><li><p>6) 服务器返回所有要求本地缓存的文件</p></li><li><p>7) 浏览器对本地缓存进行更新，存入包括页面本身在内的所有要求本地缓存的资源文件，并且触发一个事件，通知本地缓存被更新</p></li></ul><h4 id="2-再次访问（manifest文件未更新）"><a href="#2-再次访问（manifest文件未更新）" class="headerlink" title="2. 再次访问（manifest文件未更新）"></a>2. 再次访问（manifest文件未更新）</h4><ul><li><p>1) 浏览器再次请求访问<code>http://lulingniu</code></p></li><li><p>2) 浏览器发现这个页面被本地缓存，于是使用本地缓存中的<code>index.html</code>页面</p></li><li><p>3) 浏览器解析<code>index.html</code>页面，使用所有本地缓存中的资源文件</p></li><li><p>4) 浏览器向服务器请求<code>manifest</code>文件</p></li><li><p>5) 服务器返回一个304代码，通知浏览器<code>manifest</code>没有发生变化</p></li></ul><h4 id="3-再次访问（manifest文件已更新）"><a href="#3-再次访问（manifest文件已更新）" class="headerlink" title="3. 再次访问（manifest文件已更新）"></a>3. 再次访问（manifest文件已更新）</h4><ul><li><p>1) 浏览器再次请求访问<code>http://lulingniu</code></p></li><li><p>2) 浏览器发现这个页面被本地缓存，于是使用本地缓存中的<code>index.html</code>页面</p></li><li><p>3) 浏览器解析<code>index.html</code>页面，使用所有本地缓存中的资源文件</p></li><li><p>4) 浏览器向服务器请求<code>manifest</code>文件</p></li><li><p>5) 服务器返回更新过的<code>manifest</code>文件</p></li><li><p>6) 浏览器处理<code>manifest</code>文件，发现该文件已被更新，于是请求所有要求进行本地缓存的资源文件，包括<code>index.html</code>页面本身</p></li><li><p>7) 浏览器返回要求进行本地缓存的资源文件</p></li><li><p>8) 浏览器对本地缓存进行更新，存入所有新的资源文件。并且触发一个事件，通知本地缓存被更新。</p></li></ul><p>需要注意的时，即使资源文件被修改过了，上面的第3步中已装入的资源文件是不会发生变化的，譬如图片不会突然变成新的图片，脚本文件也不会突然使用新的脚本文件，也就是说，这时更新的本地缓存中的内容还不能被使用，只有重新打开这个页面的时候才会使用更新过后的资源文件。</p><p>另外，如果不想修改<code>manifest</code>文件中对于资源文件的设置，但是对服务器上请求缓存的资源文件进行了修改，那么可以通过修改版本号的方式让浏览器认为<code>manifest</code>文件已经被更新过了，以便重新下载修改过的资源文件。</p><hr><h3 id="四、applicationCache对象"><a href="#四、applicationCache对象" class="headerlink" title="四、applicationCache对象"></a>四、applicationCache对象</h3><p><code>applicationCache</code>对象代表了本地缓存，可以用它来通知本地缓存中已经被更新，也允许用户手工更新本地缓存。</p><p>当浏览器对本地缓存进行更新，装入新的资源文件时，会触发<code>applicationCache</code>对象的<code>updateready</code>事件，通知本地缓存已被更新。我们可以利用这个事件告诉用户本地缓存已经被更新，用户需要手工刷新页面来得到最新版本的应用程序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">applicationCache.onUpdateReady = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 本地缓存已被更新，通知用户</span></span><br><span class="line">    alert(<span class="string">'本地缓存已被更新，您可以刷新页面来得到本程序的最新版本。'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-swapCache方法"><a href="#1-swapCache方法" class="headerlink" title="1. swapCache方法"></a>1. swapCache方法</h4><p><code>swapCache</code>方法用来手工执行本地缓存的更新，它只能在<code>applicationCache</code>对象的<code>updateReady</code>事件被触发时调用，<code>updateReady</code>事件只有在服务器的<code>manifest</code>文件被更新，并且把<code>manifest</code>文件中所要求的资源文件下载到本地后触发。顾名思义，这个事件的含义是“本地缓存准备被更新”。</p><p>当这个事件被触发后，我们可以用<code>swapCache</code>方法来手工进行本地缓存的更新。</p><p>例如，如果本地缓存的容量非常大（譬如超过100M），本地缓存的更新工作将需要相对较长的时间，而且还会把浏览器给锁住。这时最好有一个提示，告诉用户正在进行本地缓存的更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">applicationCache.onUpdateReady = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 本地缓存已被更新，通知用户</span></span><br><span class="line">    alert(<span class="string">'正在更新本地缓存...'</span>);</span><br><span class="line">    applicationCache.swapCache();</span><br><span class="line">    alert(<span class="string">'本地缓存已被更新，您可以刷新页面来得到本程序的最新版本。'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如果我们不调用<code>swapCache</code>方法会怎么样？本地缓存就不会被更新了吗？答案时否定的，但是更新的时间不一样。如果不调用<code>swapCache</code>方法，本地缓存将在下一次打开本页面时被更新；如果调用<code>swapCache</code>方法的话，本地缓存将会立刻更新。因此，我们可以使用<code>confirm</code>方法让用户自己选择更新的时机——是立刻更新，还是在下次打开画面时再更新，特别是当他们有可能正在页面上执行一个较大的操作的时候。</p><p>另外，尽管使用<code>swapCache</code>方法立刻更新了本地缓存，但是并不意味着我们页面上的图像和脚本文件也会立刻更新，它们都是在重新打开本页面时才会生效。</p><h4 id="2-update方法"><a href="#2-update方法" class="headerlink" title="2. update方法"></a>2. update方法</h4><p><code>applicationCache</code>的<code>update</code>方法，作用是检查服务器上的<code>manifest</code>文件是否有更新，如果有更新，浏览器会自动下载<code>manifest</code>文件中所有请求本地缓存的资源文件，当这些资源文件下载完毕时，会触发<code>updateReady</code>事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!doctype HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"swapCache.manifest"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">'utf-8'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>swapCache方法实例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>swapCache方法示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 手工检查manifest是否有更新</span></span><br><span class="line">        applicationCache.update();</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    applicationCache.addEventListener(<span class="string">'updateready'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (confirm(<span class="string">'本地缓存已被更新，需要刷新画面来获取应用程序最新版本，是否刷新？'</span>)) &#123;</span><br><span class="line">            applicationCache.swapCache();</span><br><span class="line">            location.reload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># swapCache.manifest</span><br><span class="line"></span><br><span class="line">CACHE MANIFEST</span><br><span class="line">#version 1.20</span><br><span class="line">CACHE:</span><br><span class="line">script.js</span><br></pre></td></tr></table></figure><hr><h3 id="五、applicationCache对象的事件"><a href="#五、applicationCache对象的事件" class="headerlink" title="五、applicationCache对象的事件"></a>五、applicationCache对象的事件</h3><h4 id="1-首次访问-1"><a href="#1-首次访问-1" class="headerlink" title="1. 首次访问"></a>1. 首次访问</h4><ul><li><p>1) 浏览器请求访问<code>http://lilingniu</code></p></li><li><p>2) 服务器返回<code>index.html</code>网页</p></li><li><p>3) 浏览器发现该网页具有<code>manifest</code>属性，触发<code>checking</code>事件，检查<code>manifest</code>文件是否存在。不存在时，触发<code>error</code>事件，表示<code>manifest</code>文件未找到，不执行步骤6开始的交互过程</p></li><li><p>4) 浏览器解析<code>index.html</code>网页，请求页面上的所有资源文件</p></li><li><p>5) 服务器返回所有资源文件</p></li><li><p>6) 浏览器处理<code>manifest</code>文件，请求<code>manifest</code>中所有要求本地缓存的文件，包括<code>index.html</code>页面本身，即使刚才已经请求过该文件。如果要求本地缓存所有文件，这将是一个比较大的重复的请求过程</p></li><li><p>7) 服务器返回所有要求本地缓存的文件</p></li><li><p>8) 浏览器触发<code>downloading</code>事件，然后开始下载这些资源。在下载的同时，周期性地触发<code>progress</code>事件，开发人员可以用编程的手段获取多少文件已被下载，多少文件仍然处于下载队列等信息</p></li><li><p>9) 下载结束后触发<code>cached</code>事件，表示首次缓存成功，存入所有要求本地缓存的资源文件</p></li></ul><h4 id="2-再次访问"><a href="#2-再次访问" class="headerlink" title="2. 再次访问"></a>2. 再次访问</h4><ul><li><p>1) 步骤1-5同上，步骤5执行完之后，浏览器将核对<code>manifest</code>文件是否被更新。</p></li><li><p>2) 若没有被更新，触发<code>noupdate</code>事件，步骤6开始的交互过程不会被执行。</p></li><li><p>3) 若发生了更新，将继续执行后面的步骤，在步骤9中不触发<code>cached</code>事件，而是触发<code>updateready</code>事件，这表示下载结束，可以通过刷新页面来使用更新后的本地缓存，或调用<code>swapCache</code>方法来立刻使用更新后的本地缓存。</p></li><li><p>4) 另外，在访问缓存名单时如果返回一个HTTP 404错误，或者410错误，则触发<code>obsolete</code>事件。</p></li><li><p>5) 在整个过程中，如果任何与本地缓存有关的处理中发生错误的话，都会触发<code>error</code>事件。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#version 1.0</span><br><span class="line">CACHE:</span><br><span class="line">index.html</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">manifest</span>=<span class="string">"applicationCacheEvent.manifest"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> msg = <span class="built_in">document</span>.getElementById(<span class="string">'msg'</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'checking'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'checking &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'noupdate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'noupdate &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'downloading'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'downloading &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'progress'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'progress &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'updateready'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'updateready &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'cached'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'cached &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'error &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>applicationCache事件流程示例<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web应用程序已经变得越来越复杂，越来越成熟了，很多领域都在利用着Web应用程序。但是，它有一个致命的缺点：如果用户没有和Internet建立连接，他就不能利用这个Web应用程序了。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5抄书笔记" scheme="http://www.xiaoleon.cn/categories/HTML5%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="本地缓存" scheme="http://www.xiaoleon.cn/tags/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/"/>
    
      <category term="离线Web应用程序" scheme="http://www.xiaoleon.cn/tags/%E7%A6%BB%E7%BA%BFWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>
