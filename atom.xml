<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张啸</title>
  
  <subtitle>世界上最快乐的事，莫过于为理想而奋斗。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaoleon.cn/"/>
  <updated>2018-05-15T15:00:03.929Z</updated>
  <id>http://www.xiaoleon.cn/</id>
  
  <author>
    <name>Leon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6(1) let和const命令</title>
    <link href="http://www.xiaoleon.cn/2018/05/15/es6-1/"/>
    <id>http://www.xiaoleon.cn/2018/05/15/es6-1/</id>
    <published>2018-05-15T13:31:08.000Z</published>
    <updated>2018-05-15T15:00:03.929Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍ES6新标准中添加的<code>let</code>和<code>const</code>指令。</p><a id="more"></a><h3 id="一、let命令"><a href="#一、let命令" class="headerlink" title="一、let命令"></a>一、let命令</h3><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><p><code>let</code>命令用来声明变量，它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a       <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">b       <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量，然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p><p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);     <span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>];     <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面的代码中，使用<code>var</code>声明的变量<code>i</code>，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是10。</p><p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是6。</p><p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>上面代码运行正确，输出了3次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p><h4 id="2-不存在变量提升"><a href="#2-不存在变量提升" class="headerlink" title="2. 不存在变量提升"></a>2. 不存在变量提升</h4><p><code>var</code>命令会发生“变量提升”现象，即变量可以再声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p><p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明之后使用，否则报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);     <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar);     <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表明在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p><h4 id="3-暂时性死区"><a href="#3-暂时性死区" class="headerlink" title="3. 暂时性死区"></a>3. 暂时性死区</h4><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就绑定（binding）这个区域，不再受外部的影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>;      <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p><p>ES6明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，被称为“暂时性死区”（temporal dead zone, TDZ）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ start</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>;          <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp);     <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp;              <span class="comment">// TDZ end</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp);     <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);     <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p><p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x;         <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>x</code>使用<code>let</code>命令声明，所以在声明之前，都属于<code>x</code>的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个<code>ReferenceError</code>。</p><p>作为比较，如果一个变量根本没有声明，使用<code>typeof</code>反而不会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable;   <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><p>有些“死区”比较隐蔽，不太容易发现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();        <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>bar</code>函数之所以报错，是因为参数<code>x</code>默认值等于另一个参数<code>y</code>，而此时<code>y</code>还没有声明，属于“死区”。如果<code>y</code>的默认值是<code>x</code>，就不会报错，因为此时<code>x</code>已经声明了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = <span class="number">2</span>, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();        <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure><p>另外，下面的代码也会报错，与<code>var</code>的行为不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> x = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> x = x;</span><br></pre></td></tr></table></figure><p>上面代码报错，也是因为暂时性死区。使用<code>let</code>声明变量时，只要变量在还没有声明完成之前使用，就会报错。</p><p>ES6规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><h4 id="4-不允许重复声明"><a href="#4-不允许重复声明" class="headerlink" title="4. 不允许重复声明"></a>4. 不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，不能在函数内部重新声明参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg;    <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg;    <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、块级作用域"><a href="#二、块级作用域" class="headerlink" title="二、块级作用域"></a>二、块级作用域</h3><h4 id="1-为什么需要块级作用域"><a href="#1-为什么需要块级作用域" class="headerlink" title="1. 为什么需要块级作用域"></a>1. 为什么需要块级作用域</h4><p>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p><p>第一种场景，内层变量可能会覆盖外层变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">"hello world"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();        <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);       <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>只能用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><h4 id="2-ES6的块级作用域"><a href="#2-ES6的块级作用域" class="headerlink" title="2. ES6的块级作用域"></a>2. ES6的块级作用域</h4><p><code>let</code>实际上为JavaScript新增了块级作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n);     <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是10。</p><p>ES6允许块级作用域的任意嵌套。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;&#123;<span class="keyword">let</span> insane = <span class="string">'hello world'</span>&#125;&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>外层作用域无法读取内层作用域的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'hello world'</span>&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(insane);        <span class="comment">// 报错</span></span><br><span class="line">&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>内层作用域可以定义外层作用域的同名变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  <span class="keyword">let</span> insane = <span class="string">'hello world'</span>;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'hello world'</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-块级作用域与函数声明"><a href="#3-块级作用域与函数声明" class="headerlink" title="3. 块级作用域与函数声明"></a>3. 块级作用域与函数声明</h4><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p><p>ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种函数声明，根据ES5的规定都是非法的。</p><p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p><p>ES6引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>);&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>上面代码在ES5中运行，会得到<code>I am inside!</code>，因为<code>if</code>内声明的函数<code>f</code>会被提升到函数头部，实际运行的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>);&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>);&#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>ES6就完全不一样了，理论上会得到<code>I am outside!</code>。因为块级作用域内声明的函数类似于<code>let</code>，对作用域之外没有影响。但是，如果真的在ES6浏览器中运行，会报错。</p><p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p><ul><li><p>允许在块级作用域内声明函数</p></li><li><p>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部</p></li><li><p>同时，函数声明还会提升到所在的块级作用域的头部。</p></li></ul><p>注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作<code>let</code>处理。</p><p>根据这三条规则，在浏览器的ES6环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的ES6环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>);&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;())</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>上面的代码在ES6的浏览器中，都会报错，因为实际运行的是下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的ES6环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;consoel.log(<span class="string">'I am outside!'</span>);&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;())</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明语句</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、const命令"><a href="#三、const命令" class="headerlink" title="三、const命令"></a>三、const命令</h3><h4 id="1-基本用法-1"><a href="#1-基本用法-1" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">PI            <span class="comment">// 3.1415</span></span><br><span class="line"></span><br><span class="line">PI = <span class="number">3</span>;       <span class="comment">// TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo;      <span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(MAX);   <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">const</span> MAX = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两行都会报错</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">'Goodbye'</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h4 id="2-本质"><a href="#2-本质" class="headerlink" title="2. 本质"></a>2. 本质</h4><p><code>const</code>实际上保证的，并不是变量的值不得改变，而是变量指向的那个内存地址不得改变。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于符合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，<code>const</code>只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，讲一个对象声明为常量必须非常小心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为foo添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop            <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将foo指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;;           <span class="comment">// TypeError: "foo" is read-only</span></span><br></pre></td></tr></table></figure><p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>);      <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;         <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];         <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p><p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通模式下，下面一行不起作用</span></span><br><span class="line"><span class="comment">// 严格模式下，下面一行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">      constanize(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-ES6声明变量的六种方法"><a href="#3-ES6声明变量的六种方法" class="headerlink" title="3. ES6声明变量的六种方法"></a>3. ES6声明变量的六种方法</h4><p>ES5只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6除了添加<code>let</code>和<code>const</code>命令，还增加了两种方法：<code>import</code>和<code>class</code>。所以，ES6一共有6种声明变量的方法。</p><hr><h3 id="四、顶层对象的属性"><a href="#四、顶层对象的属性" class="headerlink" title="四、顶层对象的属性"></a>四、顶层对象的属性</h3><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在Node指的是<code>global</code>对象。ES5之中，顶层对象的属性与全局变量是等价的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a                 <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a          <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p><p>顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序猿很容易不知不觉就创建了全局变量；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在node的repl环境，可以写成global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成this.a</span></span><br><span class="line"><span class="built_in">window</span>.a      <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b      <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p><hr><h3 id="五、global对象"><a href="#五、global对象" class="headerlink" title="五、global对象"></a>五、global对象</h3><p>ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p><ul><li><p>浏览器里面，顶层对象是<code>window</code>，但Node和Web Worker没有<code>window</code></p></li><li><p>浏览器和Web Worker里面，<code>self</code>也指向顶层对象，但是Node没有<code>self</code></p></li><li><p>Node里面，顶层对象是<code>global</code>，但其他环境都不支持</p></li></ul><p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>变量，但是有局限性。</p><ul><li><p>全局环境中，<code>this</code>会返回顶层对象。但是，Node模块和ES6模块中，<code>this</code>返回的是当前模块</p></li><li><p>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code></p></li><li><p>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器使用了CSP（Content Security Policy，内容安全政策），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</p></li></ul><p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line">  ? <span class="built_in">window</span></span><br><span class="line">  : (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">     <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">     <span class="keyword">typeof</span> global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有一个提案，在语言标准的层面，引入<code>global</code>作为顶层对象。也就是说，在所有环境下，<code>global</code>都是存在的，都可以从它拿到顶层对象。</p><p>垫片库<code>system.global</code>模拟了这个提案，可以再所有环境拿到<code>global</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS的写法</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'system.global/shim'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6模块的写法</span></span><br><span class="line"><span class="keyword">import</span> shim <span class="keyword">from</span> <span class="string">'system.global'</span>;</span><br><span class="line">shim();</span><br></pre></td></tr></table></figure><p>上面代码可以保证各种环境里面，<code>global</code>对象都是存在的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS写法</span></span><br><span class="line"><span class="keyword">var</span> global = <span class="built_in">require</span>(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6模块写法</span></span><br><span class="line"><span class="keyword">import</span> getGlobal <span class="keyword">from</span> <span class="string">'system.global'</span>;</span><br><span class="line"><span class="keyword">const</span> global = getGlobal();</span><br></pre></td></tr></table></figure><p>上面代码将顶层对象放入变量<code>global</code>。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">ESMAScript 6 入门 —— 阮一峰</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍ES6新标准中添加的&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;指令。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6抄书笔记" scheme="http://www.xiaoleon.cn/categories/ES6%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://www.xiaoleon.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>React(4) 模块化React和Redux应用</title>
    <link href="http://www.xiaoleon.cn/2018/03/13/react-4/"/>
    <id>http://www.xiaoleon.cn/2018/03/13/react-4/</id>
    <published>2018-03-13T15:02:05.000Z</published>
    <updated>2018-03-19T13:15:53.831Z</updated>
    
    <content type="html"><![CDATA[<p>在第一部分中，我们已经了解了React的基本工作方式，也知道了Redux在组合React组件中的作用，但是更多的只是了解其基本原理和使用方法，上手练习的也是一个简单的例子。</p><a id="more"></a><p>实际工作中我们要创建的应用无论结构和大小都要复杂得多，在这一章中，我们要介绍创建一个复杂一点的应用应该如何做，包含以下内容：</p><ul><li><p>模块化应用的要点</p></li><li><p>代码文件的组织方式</p></li><li><p>状态树的设计</p></li><li><p>开发辅助工具</p></li></ul><h3 id="一、模块化应用要点"><a href="#一、模块化应用要点" class="headerlink" title="一、模块化应用要点"></a>一、模块化应用要点</h3><p>在本书中，我们探讨的是如何用React和Redux来构建前端网页应用，这两者都奉行这样一个公式<code>UI=render(state)</code>来产生用户界面。React适合于视图层面的东西，但是不能指望靠React来管理应用的状态，Redux才适合担当应用状态的管理工作。</p><p>从架构出发，当我们开始一个新的应用的时候，有几件事情是一定要考虑清楚的：</p><ul><li><p>代码文件的组织结构</p></li><li><p>确定模块的边界</p></li><li><p>Store的状态树设计</p></li></ul><p>这三件事情，是构建一个应用的基础。如果我们在一开始深入思考这三件事，并做出合乎需要的判断，可以在后面的路上省去很多麻烦。</p><p>从本章开始，我们将构造一个“待办事项”（Todo）应用，逐步完善这个应用，增加新的功能，在这个Todo应用的进化过程中来学习各个层次的知识。</p><p>在这个各种JavaScript框架层出不穷的时代，Todo应用几乎就代替了传统Hello World应用的作用，每个框架问世的时候都会用一个Todo应用来展示自己的不同，不要小看了这样一个Todo应用，它非常适合用于做技术展示，首先，这个应用的复杂度刚刚好，没有复杂到可能要很多篇幅才能解释清楚做什么，也没有简单到只需要几行代码就能够搞定；其次，这样的功能非常利于理解，恰好能够考验一个JavaScript框架的表达能力。</p><p>确定了我们的应用要做什么之后，不要上来就开始写代码，磨刀不误砍柴工，先要思考上面提到的三个问题。让我们从第一个问题开始。</p><hr><h3 id="二、代码文件的组织方式"><a href="#二、代码文件的组织方式" class="headerlink" title="二、代码文件的组织方式"></a>二、代码文件的组织方式</h3><h4 id="1-按角色组织"><a href="#1-按角色组织" class="headerlink" title="1. 按角色组织"></a>1. 按角色组织</h4><p>如果读者之前曾用MVC框架开发过应用程序，应该知道MVC框架之下，通常有这样一种代码的组织方式，文件目录列表如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">controllers/</span><br><span class="line">  todoController.js</span><br><span class="line">  filterController.js</span><br><span class="line">models/</span><br><span class="line">  todoModel.js</span><br><span class="line">  filterModel.js</span><br><span class="line">views/</span><br><span class="line">  todo.js</span><br><span class="line">  todoItem.js</span><br><span class="line">  filter.js</span><br></pre></td></tr></table></figure><p>在MVC中，应用代码分为Controller、Model和View，分别代表三种模块角色，就是把所有的Controller代码放在controllers目录下，把所有的Model代码方法在models目录下，把View代码放在views目录下。这种组织代码的方式，叫做“按角色组织”（Organized by Roles）。</p><p>我们当然不会使用MVC，在上一章中我们介绍过MVC框架的缺点。和众多前端开发者一样，我们选择Flux和Redux就是为了克服这些缺点的，但是因为MVC框架的影响非常深远，一些风格依然影响了前端开发人员的思维方式。</p><p>因为MVC这种“按角色组织”代码文件的影响，在Redux应用的构建中，就有这样一种代码组织方法，文件目录列表如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">reducers/</span><br><span class="line">  todoReducer.js</span><br><span class="line">  filterReducer.js</span><br><span class="line">actions/</span><br><span class="line">  todoActions.js</span><br><span class="line">  filterActions.js</span><br><span class="line">components/</span><br><span class="line">  todoList.js</span><br><span class="line">  todoItem.js</span><br><span class="line">  filter.js</span><br><span class="line">containers/</span><br><span class="line">  todoListContainer.js</span><br><span class="line">  todoItemContainer.js</span><br><span class="line">  filterContainer.js</span><br></pre></td></tr></table></figure><p>和MVC的代码组织方式不同，只不过是把controller、models和views目录换成了reducers、actions、components和containers，各个目录下代码文件的角色如下：</p><ul><li><p>reducer目录包含所有Redux的reducer</p></li><li><p>actions目录包含所有action构造函数</p></li><li><p>components目录包含所有的傻瓜组件</p></li><li><p>containers目录包含所有的容器组件</p></li></ul><p>这种组织方式看起来还不错，把一个类型的代码文件放在了一个目录下，至少比把所有代码全放在一个目录下要有道理。</p><p>实际上，在前面章节的所有ControlPanel例子中，我们采用的也是类似的方法，当我们发现代码文件变多，全都直接放在一个src目录下不合理时，首先想到的就是建一个views目录，把所有视图相关的目录移到views目录里面去。我们没有移动action相关和reducer相关的文件，只因为ControlPanel应用实在太简单，因为只有一个组件Counter可能发出动作，所以只有一个Action文件，也只有一个对应的Reducer文件，所以到最后我们都没有觉得有必要把它们移动到代表各自角色的目录里面去。</p><p>有过MVC框架开发经历的朋友可以回忆一下，当你需要对一个功能进行修改，虽然这个功能只是针对某一个具体的应用模块，但是却牵扯到MVC中的三个角色Controller、Model和View，不管你用的是什么样的编辑器，你都得费点劲才能在这三个目录之间跳转，或者需要滚动文件列表跳过无关的分发器文件才能找到你想要修改的那一个分发器文件。</p><p>如果说MVC框架下，因为三个角色之间的交叉关系，也只能默默接受，那么在Redux框架下，我们已经有机会实现严格模块化的思想，就应该想一想更好的组织文件的方式。</p><h4 id="2-按功能组织"><a href="#2-按功能组织" class="headerlink" title="2. 按功能组织"></a>2. 按功能组织</h4><p>Redux应用适合于“按功能组织”（Organzied by Feature），也就是完成同一应用功能的代码放在一个目录下，一个应用功能包含多个角色的代码。在Redux中，不同的角色就是reducer、actions和视图，而应用功能对应的就是用户界面上的交互模块。</p><p>拿Todo应用为例子，这个应用的两个基本功能就是TodoList和Filter，所以代码就这样组织，文件目录列表如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">todoList/</span><br><span class="line">  actions.js</span><br><span class="line">  actionTypes.js</span><br><span class="line">  index.js</span><br><span class="line">  reducer.js</span><br><span class="line">  views/</span><br><span class="line">    component.js</span><br><span class="line">    container.js</span><br><span class="line">filter/</span><br><span class="line">  actions.js</span><br><span class="line">  actionTypes.js</span><br><span class="line">  index.js</span><br><span class="line">  reducer.js</span><br><span class="line">  views/</span><br><span class="line">    component.js</span><br><span class="line">    container.js</span><br></pre></td></tr></table></figure><p>每个基本功能对应的其实就是一个模块，每个功能模块对应一个目录，这个例子中分别是todoList和filter，每个目录下包含同样名字的角色文件：</p><ul><li><p>actionTypes.js 定义action类型</p></li><li><p>actions.js 定义action构造函数，决定了这个功能模块可以接受的动作</p></li><li><p>reducer.js 定义这个功能模块如何响应actions.js中定义的动作</p></li><li><p>views目录，包含这个功能模块中所有的React组件，包括傻瓜组件和容器组件</p></li><li><p>index.js 这个文件把所有的角色导入，然后统一导出</p></li></ul><p>在这种组织方式下，当我们要修改某个功能模块的代码的时候，只要关注对应的目录就行了，所有需要修改的代码文件都能在这个目录下找到。</p><p>表面上看，“按照角色组织”还是“按照功能组织”只是一个审美的问题，也许你觉得自己已经习惯了MVC世界的“按照角色组织”方式，也许你已经有一套很厉害的代码编辑器可以完美解决在不同目录下寻找代码文件困难的问题。但是，开发Redux应用你依然应该用“按照功能组织”的方式，为什么呢？我们看看下一条“确定模块的边界”就明白了。</p><hr><h3 id="三、模块接口"><a href="#三、模块接口" class="headerlink" title="三、模块接口"></a>三、模块接口</h3><p>不同功能模块之间的依赖关系应该简单而且清晰，也就是所谓的保持模块之间低耦合性；一个模块应该把自己的功能封装得很好，让外界不要太依赖与自己内部的结构，这样不会因为内部变化而影响外部模块的功能，这就是所谓高内聚性。</p><p>React组件本身应该具有低耦合性和高内聚性的特点，不过在Redux的游乐场中，React组件扮演的就是一个视图的角色，还有reducer、actions这些角色参与这个游戏。对于整个Redux应用而言，整体由模块构成，但是模块不再是React组件，而是由React组件加上关于reducer和actions构成的小整体。</p><p>以我们将要实现的Todo应用为例，功能模块就是todoList和filter，这两个功能模块分别用各自的React组件、reducer和action定义。</p><p>可以预期每个模块之间会有依赖关系，比如filter模块想要使用todoList的action构造函数和视图，那么我们希望对方如何导入呢？一种写法是像下面的代码这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'../todoList/actions'</span>;</span><br><span class="line"><span class="keyword">import</span> container <span class="keyword">as</span> TodoList <span class="keyword">from</span> <span class="string">'../todoList/views/container'</span>;</span><br></pre></td></tr></table></figure><p>这种写法当然能够完成功能，但是却非常不合理，因为这让filter模块依赖于todoList模块的内部结构，而且直接伸手到todoList内部去导入想要的部分。</p><p>虽然我们在上面的例子中，todoList和filter中的文件名几乎一样，但是这毕竟是模块内部的事情，不应该硬性要求，更不应该假设所有的模块都应该按照这样的文件命名。在我们的例子中，存储视图代码文件的目录叫做views，但是有的开发者习惯把这个目录叫做components；我们把包含容器组件的文件名叫做container.js，根据开发者个人习惯也可能叫做TodoList，这些都没有必要而且也不应该有硬性规定。</p><p>现在既然我们把一个目录看作一个模块，那么我们要做的是明确这个模块对外的接口，而这个接口应该实现把内部封装起来。</p><p>请注意我们的todoList和filter模块目录下，都有一个index.js文件，这个文件就是我们的模块接口。</p><p>比如，在todoList/index.js中，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions.js'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer.js'</span>;</span><br><span class="line"><span class="keyword">import</span> view <span class="keyword">from</span> <span class="string">'./views/container.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;actions, reducer, view&#125;;</span><br></pre></td></tr></table></figure><p>如果filter中的组件想要使用todoList中的功能，应该导入todoList这个目录，因为导入一个目录的时候，默认导入的就是这个目录下的index.js文件，index.js文件中导出的内容，就是这个模块想要公开出来的接口。</p><blockquote><p>注意：虽然每个模块目录下都会有一个actionTypes.js文件定义action类型，但是通常不会把actionTypes中内容作为模块的接口之一导出，因为action类型只有两个部分依赖，一个是reducer，一个是action构造函数，而且只有当前模块的reducer和action构造函数才会直接使用action类型。模块之外，不会关心这个模块的action类型，如果模块之外要使用这个模块的动作，也只需要直接使用action构造函数就行。</p></blockquote><p>下面就是对应的导入todoList的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;actions, reducer, view <span class="keyword">as</span> TodoList&#125; <span class="keyword">from</span>  <span class="string">'../todoList'</span>;</span><br></pre></td></tr></table></figure><p>当我们想要修改todoList的内部代码结构，比如把views目录改名为components目录，或者把container.js改名为TodoListView.js时，所要做的只是修改todoList目录下的index.js内容，而这个文件export出来的内容不会有任何改变，也就是说对导入todoList的代码不用任何改变。这就是我们确定模块边界想要达到的目的。</p><p>还有一种导出模块接口的方式，是不以命名式export的方式导出模块接口，而是以export default的方式默认导出，就像这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions.js'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer.js'</span>;</span><br><span class="line"><span class="keyword">import</span> view <span class="keyword">from</span> <span class="string">'./views/container.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;actions, reducer, view&#125;</span><br></pre></td></tr></table></figure><p>如果像上面这样导出，那么导入时的代码会有一点区别，因为ES6语法中，export default和export两种导出方式的导入方式也会不同，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TodoListComponent <span class="keyword">from</span> <span class="string">'./actions.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = TodoListComponent.reducer;</span><br><span class="line"><span class="keyword">const</span> actions = TodoListComponent.actions;</span><br><span class="line"><span class="keyword">const</span> TodoList = TodoListComponent.view;</span><br></pre></td></tr></table></figure><p>无论使用哪种导出方式，都请在整个应用中只用一中模块导出方式，保持一致，避免混乱。</p><p>在本书中，全部使用export的方式，因为从上面的代码看得出来，如果使用export default的方式，在导入的时候不可避免要使用多行代码才能得到actions、reducer和view，而用导入命名式export只用一行就可以搞定，相对而言要更加简洁。</p><p>读者可能注意到了，上面接口代码中导入actions的语句和导入view和reducer不一样，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions.js'</span>;</span><br></pre></td></tr></table></figure><p>我们预期actions.js中是按照命名式export，原因和上面陈述的一样，actions.js可能会导出很多action构造函数，命名式导出是为了导入actions方便。对于view和reducer，一个功能模块绝对只有一个根视图模块，一个功能模块也只应该有一个导出的reducer，所以它们两个在各自代码文件中是以默认方式导出的。</p><hr><h3 id="四、状态树的设计"><a href="#四、状态树的设计" class="headerlink" title="四、状态树的设计"></a>四、状态树的设计</h3><p>上面说的“代码文件组织结构”和“确定模块的边界”更多的只是确定规矩，然后在每个应用中我们只要都遵循这个规矩就足够了，而要注意的第三点“Store上状态树的设计”，更像是一门技术，需要我们动一动脑子。</p><p>因为所有的状态都存在Store上，Store的状态树设计，直接决定了要写哪些reducer，还有action怎么写，所以是程序逻辑的源头。</p><p>我们认为状态树设计要遵循如下几个原则：</p><ul><li><p>一个模块控制一个状态节点</p></li><li><p>避免冗余数据</p></li><li><p>树形结构扁平</p></li></ul><h4 id="1-一个状态节点只属于一个模块"><a href="#1-一个状态节点只属于一个模块" class="headerlink" title="1. 一个状态节点只属于一个模块"></a>1. 一个状态节点只属于一个模块</h4><p>这个规则与其说是规则，不如说是Redux中模块必须遵守的限制，完全无法无视这个限制。</p><p>在Redux应用中，Store上的每个state都只能通过reducer来更改，而我们每个模块都有机会导出自己的reducer，这个导出的reducer只能最多更改Redux的状态树上一个节点下的数据，因为reducer之间对状态树上的修改权是互斥的，不可能让两个reducer都可以修改同一个状态树上的节点。</p><p>比如，如果A模块的reducer负责修改状态树上a字段下的数据，那么另一个模块B的reducer就不可能有机会修改a字段下的数据。</p><p>这里所说的“拥有权”指的是“修改权”，而不是“读取权”，实际上，Redux Store上的全部状态，在任何时候，对任何模块都是开放的，通过store.getState()总能够读取当前整个状态树的数据，但是只能更新自己相关那一部分模块的数据。</p><h4 id="2-避免冗余数据"><a href="#2-避免冗余数据" class="headerlink" title="2. 避免冗余数据"></a>2. 避免冗余数据</h4><p>冗余数据是一致性的大敌，如果在Store上存储冗余数据，那么维持不同部分数据一致就是一个大问题。</p><p>传统的关系型数据库中，对数据结构的各种“范式化”，其实就是在去除数据的冗余。而近年风生水起的NoSQL运动，提倡的就是在数据存储中“去范式化”，对数据结构的处理和关系型数据库正好相反，利用数据冗余来减少读取数据库时的数据关联工作。</p><p>面向用户的应用处于性能的考虑，倾向于直接使用“去范式化”的应用。但是带来的问题就是维持数据一致性就会困难。</p><p>不同的应用当然应该从自己的需要出发，在选择数据库的问题上，选择SQL关系型数据库或者NoSQL类型的数据库要根据应用特点，这个问题不是我们要在本书中讨论的。但是要强调的是，不管服务器端数据库用的是“范式化”还是“去范式化”的数据存储方式，在前段Redux的Store中，一定要避免数据冗余的出现。</p><p>并不是说Redux应用不需要考虑性能，而是相对于性能问题，数据一致性的问题才更加重要。</p><p>在后面的章节中我们会介绍，即使使用“范式化”的无冗余数据结构，我们借助reselector等工具一样可以获得很高的性能。</p><h4 id="3-树形结构扁平"><a href="#3-树形结构扁平" class="headerlink" title="3. 树形结构扁平"></a>3. 树形结构扁平</h4><p>理论上，一个树形结构可以有很深的层次，但是我们在设计Redux Store的状态树时，要尽量保持树形结构的扁平。</p><p>如果树形结构层次很深，往往意味着树形很复杂，一个很复杂的状态树是难以管理的，如果你曾不幸开发过Windows操作系统中依赖于“注册表”的应用，就一定深有体会，Windows中的注册表就是一个庞大而且层次很深的属性结果，看起来很灵活，实际上总让软件开发陷入麻烦的泥沼。</p><p>从代码的角度出发，深层次树形状态结构会让代码冗长。</p><p>假设，一个树形从上往下依次有A、B、C、D四个节点，为了访问节点D，就只能通过上面三层逐级访问，不过，谁也不敢保证A、B、C三个节点真的存在，为了防止运行时出错，代码就要考虑到所有的可能，最后为了访问D，代码不得不写成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> d = state.A &amp;&amp; state.A.B &amp;&amp; state.A.B.C &amp;&amp;&amp; state.A.B.C.D</span><br></pre></td></tr></table></figure><p>相信没有开发者会愿意写很多类似上面这样的代码。</p><hr><h3 id="五、Todo应用实例"><a href="#五、Todo应用实例" class="headerlink" title="五、Todo应用实例"></a>五、Todo应用实例</h3><p>了解上述创建应用的原则之后，我们现在终于可以开始构建Todo应用了。</p><p>Todo应用从界面上看应该由三部分组成：</p><ul><li><p>待办事项的列表</p></li><li><p>增加新待办事项的输入框和按钮</p></li><li><p>待办事项过滤器，可以选择过滤不同状态的待办事项</p></li></ul><p>看起来需要三个功能模块，但是第一部分和第二部分的关系密切，可以放在一个模块中，所以最后我们确定有两个功能模块todos和filter，其中todos包含第一部分和第二部分的功能。</p><p>我们遵循“按照功能组织”的原则来设计代码，创建三个目录来容纳各自的代码文件，每个目录下都有一个index.js文件，这是模块的边界。各个模块之间只能假设其他模块包含index.js文件，要引用模块只能导入index.js，不能够直接去导入其他文件，文件目录如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">todos/</span><br><span class="line">  index.js</span><br><span class="line">filter/</span><br><span class="line">  index.js</span><br></pre></td></tr></table></figure><h4 id="1-Todo状态设计"><a href="#1-Todo状态设计" class="headerlink" title="1. Todo状态设计"></a>1. Todo状态设计</h4><p>至于Todo应用状态，从界面上看，应用中可以有很多待办事项，并有先后顺序的关系，明显用一个数组很合适。所以，我们的状态树上应该有一个表示待办事项的数组。</p><p>至于每个待办事项，应该用一个对象代表，这个对象肯定要包含文字，记录待办事项的内容，因为我们可以把一个待办事项标记为“已完成”，所以还要有一个布尔字段记录是否完成的状态，当我们把一个待办事项标记位“已完成”或者“未完成”时，必须要能唯一确定一个待办事项对象，没有规则说一个待办事项的文字必须唯一，所以我们需要一个字段来唯一标识一个待办事项，所以一个待办事项的对象格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: //唯一标识</span><br><span class="line">  text: //待办事项内容</span><br><span class="line">  completed: //布尔值，标识待办事项是否已完成</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器选项设定界面上显示什么样状态的代表事项，我们已知过滤器有三种选择：</p><ul><li><p>全部待办事项</p></li><li><p>已完成待办事项</p></li><li><p>未完成待办事项</p></li></ul><p>看起来就是一个列举类型的结构，不过JavaScript里面并没有原生的enum类型支持，所以我们只能用类似常量标识符的方式来定义三种状态。在代码中，可以分别用体现语义的ALL、COMPLETED和UNCOMPLETED代表这三种状态，但是这三个标识符的实际值的选择，也值得商榷。</p><p>最简单的方式，就是让这三个状态标识符的值是整型，比如这样的代码形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ALL = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> COMPLETED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> UNCOMPLETED = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>但是，考虑到将来无论是debug还是产生log，一个数字在开发人员眼里不容易看出来代表什么意思，最后还需要对照代码才知道0代表ALL、1代表COMPLETED，这样很不方便。所以，开发中一个惯常的方法，就是把这些枚举型的常量定义为字符串，比如这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ALL = <span class="string">'all'</span>;</span><br><span class="line"><span class="keyword">const</span> COMPLETED = <span class="string">'completed'</span>;</span><br><span class="line"><span class="keyword">const</span> UNCOMPLETED = <span class="string">'uncompleted'</span>;</span><br></pre></td></tr></table></figure><p>综合起来看，我们知道Todo应用的Store状态树大概是这样一个样子，JavaScript对象的表示形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  todos: [</span><br><span class="line">    &#123;</span><br><span class="line">      text: <span class="string">'First todo'</span>,</span><br><span class="line">      completed: <span class="literal">false</span>,</span><br><span class="line">      id: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      text: <span class="string">'Second todo'</span>,</span><br><span class="line">      completed: <span class="literal">false</span>,</span><br><span class="line">      id: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  filter: <span class="string">'all'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当增加一个待办事项，就在数组类型的todos中增加一个元素，当药标记一个待办事项为“已完成”或者“未完成”，就更新对应待办事项的complete字段值，而哪些待办事项应该显示出来，则要根据todos和filter共同决定。</p><p>在应用的入口文件src/index.js中，我们和ControlPanel一样，用Provider包住最顶层的TodoApp模块，这样让store可以被所有组件访问到，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;TodoApp /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>而在顶层模块src/TodoApp.js中，所要做的只是把两个关键视图显示出来，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;view <span class="keyword">as</span> Todos&#125; <span class="keyword">from</span> <span class="string">'./todos/'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;view <span class="keyword">as</span> Filter&#125; <span class="keyword">from</span> <span class="string">'./filter/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Todos /&gt;</span><br><span class="line">      &lt;Filter /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default TodoApp;</span></span><br></pre></td></tr></table></figure><h4 id="2-action构造函数"><a href="#2-action构造函数" class="headerlink" title="2. action构造函数"></a>2. action构造函数</h4><p>确定好状态树的结构之后，接下来就可以写action构造函数了。</p><p>在todos和filter目录下，我们都要分别创造actionTypes.js和actions.js文件，这两个文件几乎每个功能模块都需要，文件如此命名是大家普遍接受的习惯。</p><p>在src/todos/actionTypes.js中，我们定义的是todos支持的action类型。在Todo应用中，支持对待办事项的增加、反转和删除三种action类型，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO = <span class="string">'TODO/ADD'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TOGGLE_TODO = <span class="string">'TODO/TOGGLE'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REMOVE_TODO = <span class="string">'TODO/REMOVE'</span>;</span><br></pre></td></tr></table></figure><p>和index.js中使用命名式导出而不用默认导出一样，在actionTypes中我们也使用命名式导出，这样，使用actionTypes的文件可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ADD_TODO, TOGGLE_TODO, REMOVE_TODO&#125; <span class="keyword">from</span> <span class="string">'./actionTypes.js'</span>;</span><br></pre></td></tr></table></figure><p>也同样是为了便于debug和输出到log里面查看清晰，所有的action类型的值都是字符串，字符串还有一个好处就是可以直接通过===来比较是否相等，而其他对象用===则要求必须引用同一个对象。</p><blockquote><p>提示：严格来说，使用Symbol来代替字符串表示这样的枚举值更合适，但是有的浏览器并不支持Symbol，我们在这里不作深入探讨。</p></blockquote><p>考虑到应用可以无限扩展，每个组件也要避免明明冲突。所以，最好是每个组件的action类型字符串都有一个唯一的前缀。在我们的例子中，所有todos的action类型字符串都有共同前缀“TODO/”，所有filter的action类型字符串前缀“FILTER/”。</p><p>在src/todos/actions.js中，我们定义todos相关的action构造函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ADD_TODO, TOGGLE_TODO, REMOVE_TODO&#125; <span class="keyword">from</span> <span class="string">'./actionTypes.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextTodoId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addTodo = <span class="function">(<span class="params">text</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: ADD_TODO,</span><br><span class="line">  completed: <span class="literal">false</span>,</span><br><span class="line">  id: nextTodoId++,</span><br><span class="line">  text: text</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toggleTodo = <span class="function">(<span class="params">id</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: TOGGLE_TODO,</span><br><span class="line">  id: id</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeTodo = <span class="function">(<span class="params">id</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: REMOVE_TODO,</span><br><span class="line">  id: id</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上一章中我们已经知道，Redux的action构造函数就是创造action对象的函数，返回的action对象中必须有一个type字段代表action类型，还可能有其他字段代表这个动作承载的数据。</p><p>在src/todos/actions.js文件中定义了一个文件级别的变量nextTodoId，每调用一次addTodo action构造函数就加一，实现为每个产生的待办事项赋予一个唯一id的目的。当然，这种方法非常简陋，我们在后面的章节中会改进唯一id的生成方法。</p><p>读者可能会注意到我们用了一种新的写法，虽然action构造函数应该是一个返回action对象的方法，我们却看不见return的字样。对于只return一个对象的函数体，ES6允许简写为省去return，直接用圆括号把返回的对象包起来就行，比如上面的toggleTodo对象构造器，实际上是下面方法的简写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toggleTodo = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: TOGGLE_TODO,</span><br><span class="line">    id: id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-组合reducer"><a href="#3-组合reducer" class="headerlink" title="3. 组合reducer"></a>3. 组合reducer</h4><p>在todos和filter目录下，各有一个reducer.js文件定义的两个功能模块reducer。</p><p>对于reducer我们并不陌生，在前面的ControlPanel例子中我们就创建过reducer。但是在那个例子中，整个应用只有一个reducer。而在Todo应用中，两个功能模块都有自己的reducer，而Redux的createStore函数只能接受一个reducer，那么怎么办？</p><p>这是Redux最有意思的部分，虽然Redux的createStore只接受一个reducer，却可以把多个reducer组合起来，成为一体，然后就可以被createStore函数接受。</p><p>在src/Store.js文件中，我们完成了reducer的组合，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore, combineReducer&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;reducer <span class="keyword">as</span> todoReducer&#125; <span class="keyword">from</span> <span class="string">'./todos'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;reducer <span class="keyword">as</span> filterReducer&#125; <span class="keyword">from</span> <span class="string">'./filter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducer(&#123;</span><br><span class="line">  todos: todoReducer,</span><br><span class="line">  filter: filterReducer</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(reducer);</span><br></pre></td></tr></table></figure><p>我们使用了Redux提供的一个函数combineReducers来把多个reducer函数合成为一个reducer函数。</p><p>combineReducers函数接受一个对象作为参数，参数对象的每个字段名对应了state状态上的字段名（在上面的例子中分别是todoReducer和filterReducer），combineReducers函数返回一个新的reducer函数，当这个新的reducer函数被执行时，会把传入的state参数对象拆开处理，todo字段下的子状态交给todoReducer，filter字段下的子状态交给filterReducer，然后再把这两个调用的返回结果合并成一个新的state，作为整体reducer函数的返回结果。</p><p>假设，当前State上的状态可以用currentState代表，这时候给Store派发一个action对象，combineReducers产生的这个reducer函数就会被调用，调用参数state就是currentState。这个reducer函数会分别调用todoReducer和filterReducer，不过传递过去的state参数有些变化，调用todoReducer的参数state值是currentStore.todos，调用filterReducer的state是currentState.filter，当todoReducer和filterReducer这两个函数返回结果之后，combineReducers产生的reducer函数就用这两个结果分别去更新Store上的todos和filter字段。</p><p>所以，现在我们来看功能模块的reducer，会发现state的值不是Redux上那个完整的状态，而是状态上对应自己的那一部分。</p><p>在src/todos/reducer.js中可以看到，state参数对应的是Store上todos字段的值，默认值是一个数组，reducer函数往往就是一个以action.type为条件的switch语句构成，代表模式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ADD_TODO, TOGGLE_TODO, REMOVE_TODO&#125; <span class="keyword">from</span> <span class="string">'./actionTypes.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = [], action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="comment">// 针对action.type所有可能值的case语句</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先看对于ADD_TODO这种action类型的处理，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ADD_TODO: &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      id: action.id,</span><br><span class="line">      text: action.text,</span><br><span class="line">      completed: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...state</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们使用了ES6的扩展操作符来简化reducer的代码，扩展操作符可以用来扩展一个对象，也可以用来扩展一个数组。</p><p>现在state是一个数组，我们想要返回一个增加了一个对象的数组，就这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [newObject, ...state];</span><br></pre></td></tr></table></figure><p>为什么我们不直接使用熟悉的数组push或者unshift操作呢？</p><p>绝对不能，因为push和unshift会改变原来的那个数组，还记得吗？reducer必须是一个纯函数，纯函数不能有任何副作用，包括不能修改参数对象。</p><p>对于TOGGLE_TODO这种action累i系那个的处理，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TOGGLE_TODO: &#123;</span><br><span class="line">    <span class="keyword">return</span> state.map(<span class="function">(<span class="params">todoItem</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (todoItem.id === action.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;...todoItem, <span class="attr">complated</span>: !todoItem.completed&#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> todoItem;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展操作符可以在一对{}符号中把一个对象展开，这样，在{}中后面的部分的字段值，可以覆盖展开的部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;...todoItem, <span class="attr">completed</span>: !todoItem.completed&#125;;</span><br></pre></td></tr></table></figure><p>像上面的代码中，返回了一个新的对象，所有字段都和todoItem一样，只是completed字段和todoItem中的completed布尔类型值正好相反。</p><p>对于REMOVE_TODO这种action类型的处理，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> REMOVE_TODO: &#123;</span><br><span class="line">  <span class="keyword">return</span> state.filter(<span class="function">(<span class="params">todoItem</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> todoItem.id !== action.id;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于删除操作，我们使用数组的filter方法，将id匹配的待办事项过滤掉，产生了一个新的数组。</p><p>最后，reducer中的switch语句一定不要漏掉了default的条件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为reducer函数会接收到任意action，包括它根本不感兴趣的action，这样就会执行default中的语句，应该将state原样返回，表示不需要更改state。</p><p>在src/filter/reducer.js中定义了filter模块的reducer，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;SET_FILTER&#125; <span class="keyword">from</span> <span class="string">'./actionTypes.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;FilterTypes&#125; <span class="keyword">from</span> <span class="string">'../constants.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = FilterTypes.ALL, action) = &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SET_FILTER: &#123;</span><br><span class="line">      <span class="keyword">return</span> action.filter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个reducer更加简单，所做的就是把Redux Store上filter字段的值设为action对象上的filter值。</p><p>我们来总结一下Redux的组合reducer功能，利用combineReducers可以把多个只针对局部状态的“小的”reducer合并为一个操纵整个状态树的“大的”reducer，更妙的事，没有两个“小的”reducer会发生冲突，因为无论怎么组合，状态树上一个子状态都只会被一个reducer处理，Redux就是用这种方法隔绝了各个模块。</p><p>很明显，无论我们有多少“小的”reducer，也无论如何组合，都不用在乎它们被因为调用的顺序，因为调用顺序和结果没有关系。</p><h4 id="4-Todo视图"><a href="#4-Todo视图" class="headerlink" title="4. Todo视图"></a>4. Todo视图</h4><p>对于一个功能模块，定义action类型、action构造函数和reducer基本上各用一个文件就行，约定俗成地分别放在模块目录下（actionTypes.js、actions.js和reducer.js文件中）。但是，一个模块涉及的视图文件往往包含多个，因为对于充当视图的React组件，我们往往会让一个React组件的功能精良、小，导致视图分布在多个文件之中。</p><p>既然有多个文件，那么也就没有太大必要保持统一的文件名，反正模块导出的只是一个view字段，在模块内部只要文件名能够表达视图的含义就行。</p><ul><li>1) todos视图</li></ul><p>对于todos模块，在index.js中被导出的view存在src/todos/views/todos.js中，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> AddTodo <span class="keyword">from</span> <span class="string">'./addTodo.js'</span>;</span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'./todoList.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"todos"</span>&gt;</span><br><span class="line">      &lt;AddTodo /&gt;</span><br><span class="line">      &lt;TodoList /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>很简单，就是把AddTodo组件和TodoList两个组件摆放在一个div中，这样的简单组合自然不需要什么状态，所以用一个函数表示成无状态组件就可以了。</p><p>在Todos的顶层div上添加了className属性，值为字符串todos，最后产生的DOM元素上就会有CSS类todos。这个类是为了将来定制样式而使用的，并不影响功能。</p><p>对于AddTodo组件，涉及处理用户的输入。当用户点击“增加”按钮或者在输入栏input中直接回车键的时候，要让JavaScript读取到input这个DOM元素的value值，React为了支持这种方法，提供了一个叫ref的功能。</p><p>在src/todos/views/addTodo.js中有对AddTodo组件的定义，我们先来看其中render函数对ref的用法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"add-todo"</span>&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.onSubmit&#125;&gt;</span><br><span class="line">        &lt;input className=<span class="string">"new-todo"</span> ref=&#123;<span class="keyword">this</span>.refInput&#125; /&gt;</span><br><span class="line">        &lt;button className=<span class="string">"add-btn"</span> type=<span class="string">"submit"</span>&gt;</span><br><span class="line">        添加</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>当一个包含ref属性的组件完成装载（mount）过程的时候，会看一看ref属性是不是一个函数，如果是，就会调用这个函数，参数就是这个组件代表的DOM元素，注意，是DOM元素，不是Virtual DOM元素，通过这种方法，我们的代码可以访问到实际的DOM元素。</p><p>AddTodo的render渲染出来了一个form，通过onSubmit属性把form被提交的事件挂在AddTodo组件的onSubmit函数上。</p><p>在上面的例子中，input元素的ref属性是AddTodo组件的一个成员函数refInput，所以当这个input元素完成装载之后，refInput会被调用。</p><p>refInput的函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refInput(node) &#123;</span><br><span class="line">  <span class="keyword">this</span>.input = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当refInput被调用时，参数node就是那个input元素，refInput把这个node记录在成员变量input中。</p><p>于是，当组件完成mount之后，就可以通过this.input来访问那个input元素。这是一个DOM元素，可以使用任何DOM API访问元素内容，通过访问this.input.value就可以直接读取当前的用户输入。</p><p>使用this.input的onSubmit函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onSubmit(ev) &#123;</span><br><span class="line">  ev.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> input = <span class="keyword">this</span>.input;</span><br><span class="line">  <span class="keyword">if</span> (!input.value.trim()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.props.onAdd(input.value);</span><br><span class="line">  input.value = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HTML中，一个form表单被提交的默认行为会引发网页跳转，在React应用中当然不希望网页跳转发生，所以我们首先通过调用参数ev的preventDefault函数取消掉浏览器的默认提交行为。</p><p>通过this.input.value，可以判断出当前输入框里的文字内容。如果是空白，就应该忽略，因为创建一个空白的待办事项没有意义。否则，就调用通过属性onAdd传递进来的函数。最后，我们把input清空，让用户知道创建成功，而且方便创建下一条待办事项。</p><p>文件中的AddTodo组件是一个内部组件，按说应该是一个傻瓜组件，但是和我们之前例子中的傻瓜组件不一样，AddTodo不是一个只有一个render函数的组件，AddTodo甚至有一个逻辑比较复杂的onSubmit函数，为什么不把这部分逻辑提取到外面的容器组件呢？</p><p>其实我们可以把onSubmit的逻辑提取到mapDispatchToProps中。但是，让AddTodo组件外面的mapDispatchToProps访问到AddTodo组件里面的ref很困难，得不偿失。</p><p>使用ref实际上就是直接触及了DOM元素，与我们想远离DOM是非之地的想法相悖，虽然React提供了这个功能，但是还是要谨慎使用，如果要用，我们进尽量让ref不要跨越组件的边界。</p><p>所以，我们把通过ref访问input.value放在内部的AddTodo中，但是把调用dispatch派发action对象的逻辑放在mapDispatchToProps中，两者一个主内一个主外，各司其职，不要混淆。</p><blockquote><p>注意：并不是只有ref一种方法才能够访问input元素的value，我们在这里使用ref主要是展示一下React的这个功能，在后面的章节中我们会介绍更加可控的方法。</p></blockquote><p>注意，对于AddTodo，没有任何需要从Redux Store的状态衍生的属性，所以最后一行的connect函数第一个参数mapStateToProps是null，只是用了第二个参数mapDispatchToProps。</p><p>在src/todos/views/addTodo.js中表示AddTodo标识符代表的组件和src/todos/views/todos.js中AddTodo标识符代表的组件不一样，后者是前者用react-redux包裹之后的容器组件。</p><p>接下来看看待办事项列表组件，定义在src/todos/view/todoList.js中，在渲染TodoList时，我们的todos属性是一个数组，而数组元素的个数是不确定的，这就涉及如何渲染数量不确定子组件的问题，TodoList作为无状态组件代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TodoList = <span class="function">(<span class="params">&#123;todos, onToogleTodo, onRemoveTodo&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul className=<span class="string">"todo-list"</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      todos.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">        &lt;TodoItem</span><br><span class="line">          key=&#123;item.id&#125;</span><br><span class="line">          text=&#123;item.text&#125;</span><br><span class="line">          completed=&#123;item.completed&#125;</span><br><span class="line">          onToggle=&#123;() =&gt; onToggleTodo(item.id)&#125;</span><br><span class="line">          onRemove=&#123;() =&gt; onRemoveTodo(item.id)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这段代码中的TodoList真的就只是一个无状态的傻瓜组件了，对于传递进来的todos属性，预期是一个数组，通过一个数组的map函数转化为一个TodoItem组件的数组，这是我们第一次在JSX代码片段中创建动态数量的元素。</p><p>因为todos这个数组的元素数量并不确定，所以很自然想到要用一个循环来产生同样数量的TodoItem组件实例。但是，并不能在JSX中使用for或者while这样的循环语句。因为，JSX中可以使用任何形式的JavaScript表达式，只要JavaScript表达式出现在符号{}之间，但是也只能是JavaScript“表达式”，for或者while产生的是“语句”而不是“表达式”，所以不能出现for或者while。</p><p>归根到底，JSX最终会被babel转译成一个嵌套的函数调用，在这个函数调用中自然无法插入一个语句进去，所以，当我们想要在JSX中根据数组产生动态数量的组件实例，就应该用数组的map方法。</p><p>还有一点很重要，对于动态数量的子组件，每个子组件都必须要带上一个key属性，而且这个key属性的值一定要是能够唯一标示这个子组件的值。</p><p>当我们完成Todo应用之后，会回过头来再解释key值的作用。</p><p>TodoList的mapStateToProps方法需要根据Store上的filter状态决定todos状态上取哪些元素来显示，这个过程涉及对filter的switch判断。为了防止mapStateToProps方法过长，我们将这个逻辑提取到selectVisibleTodos函数中，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectVisibleTodos = <span class="function">(<span class="params">todos, filter</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (filter) &#123;</span><br><span class="line">    <span class="keyword">case</span> FilterTypes.ALL:</span><br><span class="line">      <span class="keyword">return</span> todos;</span><br><span class="line">    <span class="keyword">case</span> FilterTypes.COMPLETED:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.completed);</span><br><span class="line">    <span class="keyword">case</span> FilterTypes.UNCOMPLETED:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">item</span> =&gt;</span> !item.completed);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unsupported filter'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    todos: selectVisibleTodos(state.todos, state.filter)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们看TodoList的mapDispatchToProps方法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onToggleTodo: <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">      dispatch(toggleTodo(id));</span><br><span class="line">    &#125;,</span><br><span class="line">    onRemoveTodo: <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">      dispatch(removeTodo(id));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在TodoList空间中，看mapDispatchToProps函数产生的练个新属性onToggleTodo和onRemoveTodo的代码遵循一样的模式，都是把接收到的参数作为参数传递给一个action构造函数，然后用dispatch方法把产生的action对象派发出去，这看起来是重复代码。</p><p>实际上，Redux已经提供了一个bindActionCreators方法来消除这样的重复代码，显而易见很多mapDispatchToProps要做的事情只是把action构造函数和prop关联起来，所以直接以prop名为字段名，以action构造函数为对应字段值，把这样的对象传递给bindActionCreators就可以了，上面的mapDispatchToProps可以简写为这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;bindActionCreators&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> bindActionCreators(&#123;</span><br><span class="line">  onToggleTodo: toggleTodo,</span><br><span class="line">  onRemoveTodo: removeTodo</span><br><span class="line">&#125;, dispatch);</span><br></pre></td></tr></table></figure><p>更进一步，可以直接让mapDispatchToProps是一个prop到action构造函数的映射，这样连bindActionCreators函数都不用，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  onToggleTodo: toggleTodo,</span><br><span class="line">  onRemoveTodo: removeTodo</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面定义的mapDispatchToProps传给connect函数，产生的效果和之前的写法完全一样。</p><p>我们再看定义了TodoItem的src/todos/views/todoItem.js文件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TodoItem = <span class="function">(<span class="params">&#123;onToggle, onRemove, completed, text&#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;li </span><br><span class="line">    className=<span class="string">"todo-item"</span> </span><br><span class="line">    style=&#123;&#123;</span><br><span class="line">      textDecoration: completed ? <span class="string">'line-through'</span>: <span class="string">'none'</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;input </span><br><span class="line">      className=<span class="string">"toggle"</span></span><br><span class="line">      type=<span class="string">"checkbox"</span></span><br><span class="line">      checked=&#123;completed ? <span class="string">"checked"</span>: <span class="string">""</span>&#125;</span><br><span class="line">      readOnly</span><br><span class="line">      onClick=&#123;onToggle&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;label className=<span class="string">"text"</span>&gt;&#123;text&#125;&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button className="remove" onClick=&#123;onRemove&#125;&gt;X&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>这里的TodoItem就是一个无状态的组件，把onToggle属性挂到checkbox的点击事件上，把onRemove属性挂到删除按钮的点击事件上。</p><p>每个待办事项都包含一个checkbox元素和一段文字内容，checkbox是否勾选并不依赖用户输入，而是根据completed属性来判断。同时，对于completed状态的待办事项，文字内容中间用横线代表完成。</p><ul><li>2) filter视图</li></ul><p>对于过滤器，我们有三个功能类似的链接，很自然就会想到把链接相关的功能提取出来，放在一个叫Link的组件中。</p><p>在src/filter/views/filter.js中，我们定义被导出的filter主视图，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Filter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;p className=<span class="string">"filters"</span>&gt;</span><br><span class="line">      &lt;Link filter=&#123;FilterTypes.ALL&#125;&gt;&#123;FilterTypes.ALL&#125;&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Link filter=&#123;FilterTypes.COMPLETED&#125;&gt;&#123;FilterTypes.COMPLETED&#125;&lt;/</span>Link&gt;</span><br><span class="line">      &lt;Link filter=&#123;FilterTypes.UNCOMPLETED&#125;&gt;&#123;FilterTypes.UNCOMPLETED&#125;&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>p&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个filter主视图很简单，是一个无状态的函数，列出了三个过滤器，把实际工作都交给了Link组件。</p><p>我们在src/filter/views/link.js中添加Link组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Link = <span class="function">(<span class="params">&#123;active, children, onClick&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (active) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;b className=<span class="string">"filter selected"</span>&gt;&#123;children&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">  &#125; else (</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;a href="#" className="filter no-selected" onClick=&#123;(ev) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        ev.preventDefault();</span></span><br><span class="line"><span class="regexp">        onClick();</span></span><br><span class="line"><span class="regexp">      &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &#123;children&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>a&gt;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为傻瓜组件的Link，当传入属性active为true时表示当前实例就是被选中的过滤器，不该被再次选择，所以不应该渲染超链接标签a。若否，则渲染一个超链接标签。</p><p>一个超链接标签的默认行为是跳转，即href属性是#，所以超链接标签的onClick事件处理器第一件事就是用preventDefault函数取消默认行为。实际上，我们把href设为“#”唯一的目的就是让浏览器给超链接显示出下划线，代表这是一个链接。</p><p>我们使用了一个特殊的属性children，对于任何一个React组件都可以访问这样一个属性，代表的是被包裹住的子组件，比如，对于下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Foo&gt;</span><br><span class="line">  &lt;Bar&gt;WhatEver&lt;<span class="regexp">/Bar&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Foo&gt;</span><br></pre></td></tr></table></figure><p>Foo组件实例的children就是<code>&lt;Bar&gt;WhatEver&lt;/Bar&gt;</code>，而Bar组件实例的children就是<code>WhatEver</code>。在render函数中把children属性渲染出来，是惯常的组合React组件的方法。</p><p>Link的mapStateToProps和mapDispatchToProps函数都很简单，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, ownProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    active: state.filter === ownProps.filter</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch, ownProps</span>) =&gt;</span> &#123;</span><br><span class="line">  onClick: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch(setFilter(ownProps.filter));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-样式"><a href="#5-样式" class="headerlink" title="5. 样式"></a>5. 样式</h4><p>我们终于完成了Todo应用，在浏览器中可以看到最终效果。</p><p><img src="/images/react-4/1.png" alt="无定制样式的Todo应用界面"></p><p>这个Todo应用功能已经完成，但是并没有定制样式，还是需要通过CSS来添加样式。我们在定义视图部分代码时，一些元素上通过className属性添加了CSS类，现在我们就利用这些类来定义CSS规则。</p><p>在src/todos/views/style.css中，我们定义了Todo空间中所有的样式，为了让定义的样式产生效果，在Todos组件的最顶层视图文件src/todos/views/todos.js中添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span>;</span><br></pre></td></tr></table></figure><p>在React应用中，通常使用webpack来完成对JavaScript的打包，create-react-app产生的应用也不例外，不过webpack不知能够处理JavaScript文件，它还能够处理css、scss甚至图片文件，因为在webpack眼里，一切文件都是“模块”，通过文件中的import语句或者require函数调用就可以找到文件之间的使用关系，只要被import就会被纳入最终打包的文件中，即使被import的是一个css文件。</p><p>如下图所示，Todo应用拥有样式了。</p><p><img src="/images/react-4/2.png" alt="完成定制样式的Todo应用界面"></p><p>把css文件用import语句导入，webpack默认的处理方式是将css文件的内容嵌入最终的打包文件bundle.js中，这毫无疑问会让打包文件变得更大，但是应用所有的逻辑都被包含在一个文件中了，便于部署。</p><p>当然，如果不希望将css和JavaScript混在一起，也可以在webpack中通过配置完成，在webpack的loader中使用extract-text-webpack-plugin，就可以让css文件在build时被放在独立的css文件中。</p><p>有意思的是，选择css和JavaScript打包在一起还是分开打包，和代码怎么写没有任何关系，这就是React的妙处。代码中只需要描述“想要什么”，至于最终“怎么做”，可以通过配置webpack获得多重选择。</p><p>如果使用scss语法，可以简化上面的样式代码，但是create-react-app产生的应用默认不支持scss，有兴趣的话可以通过eject方法直接编辑webpack配置，应用上scss加载器。</p><h4 id="6-不使用ref"><a href="#6-不使用ref" class="headerlink" title="6. 不使用ref"></a>6. 不使用ref</h4><p>在前面的例子中，代码通过React的ref功能来访问DOM元素，这种功能的需求往往来自于提交表单的操作，在提交表单的时候，需要读取当前表单中input元素的值。</p><p>毫无疑问，ref的用法非常脆弱，因为React的产生就是为了避免直接操作DOM元素，因为直接访问DOM元素很容易产生失控的情况，现在为了读取某个DOM元素的值，通过ref取得对元素的直接引用，不得不说，干的并不漂亮。</p><p>有没有更好的方法呢？</p><p>有，可以利用组件状态来同步记录DOM元素的值，这种方法可以控制住组件不使用ref。</p><p>Todo应用中的addTodo.js文件可以这样修改，首先是render函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"add-todo"</span>&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.onSubmit&#125;&gt;</span><br><span class="line">        &lt;input </span><br><span class="line">          className=<span class="string">"new-todo"</span> </span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.onInputChange&#125; </span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.value&#125; /&gt;</span><br><span class="line">        &lt;button className=<span class="string">"add-btn"</span> type=<span class="string">"submit"</span>&gt;</span><br><span class="line">          添加</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在这里我们不再使用ref来获取对input元素的直接访问，而是利用input元素上的onChange属性挂上一个事件处理函数onInputChange，这样每当input的值发生变化时，onInputChange函数就会被调用，这样我们总有机会记录下最新的input元素内容。</p><p>onInputChange函数的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onInputChange(event) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    value: event.target.value</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onInputChange函数中，通过传入的事件参数event可以访问事件发生的目标，读取到当前值，并把内容存在组件状态的value字段上。这样，组件状态上总能够获取最新的input元素内容。</p><p>然后看onSubmit函数的改变，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onSubmit(ev) &#123;</span><br><span class="line">  ev.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> inputValue = <span class="keyword">this</span>.state.value;</span><br><span class="line">  <span class="keyword">if</span> (!inputValue.trim()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.props.onAdd(inputValue);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="string">''</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要提交表单的时候，onSubmit函数被调用，只需要直接从组件状态上读取value字段的值就够了。</p><p>在产品开发中，应该尽量避免ref的使用，而换用这种状态绑定的方法来获取元素的值。</p><hr><h3 id="六、开发辅助工具"><a href="#六、开发辅助工具" class="headerlink" title="六、开发辅助工具"></a>六、开发辅助工具</h3><p>我们已经写了一个比较复杂的基于React和Redux的应用，将来还会遇到更复杂的应用，是时候引入一些开发辅助工具了，毕竟没有人能够一次把复杂代码写对，必要的工具能够大大提高我们的工作效率。</p><h4 id="1-Chrome扩展包"><a href="#1-Chrome扩展包" class="headerlink" title="1. Chrome扩展包"></a>1. Chrome扩展包</h4><p>Chrome是网页应用开发者群体最喜爱的浏览器，因为Chrome浏览器有丰富的扩展库来帮助网页开发，这里我们介绍三款Chrome扩展包，可以说是React和Redux应用开发必备之物。</p><ul><li><p>React Devtools，可以检视React组件的树形结构</p></li><li><p>Redux Devtools，可以检视Redux数据流，可以将Store状态跳跃到任何一个历史状态，也就是所谓的“时间旅行”功能</p></li><li><p>React Perf，可以发现React组件渲染的性能问题</p></li></ul><h4 id="2-redux-immutable-state-invariant辅助包"><a href="#2-redux-immutable-state-invariant辅助包" class="headerlink" title="2. redux-immutable-state-invariant辅助包"></a>2. redux-immutable-state-invariant辅助包</h4><p>我们曾经反复强调过，每一个reducer函数都必须是一个纯函数，不能修改传入的参数state和action，否则会让应用重新陷入状态不可预料的境地。</p><p>禁止reducer函数修改参数，这是一个规则，规则总是会被无心违反的，但是怎么避免开发者不小心违反这个规则呢？</p><p>有一个redux-immutable-state-invariant包，提供了一个Redux的中间件，能够让Redux在每次派发动作之后做一个检查。如果发现某个reducer违反了作为一个纯函数的规定擅自修改了参数state，就会给一个大大的错误警告，从而让开发者意识到自己犯了一个错误，必须要修正。</p><p>什么是Redux的中间件？我们在后面的章节会详细介绍，在这里我们只要理解中间件是可以增强Redux的Store实例功能的一种方法就可以。</p><p>很明显，对于redux-immutable-state-invariant的这种检查，在开发环境下很有用。但是在产品环境下，这样的出错提示意义不大，只是徒耗计算资源和增大JavaScript代码提及，所以我们通常在产品环境中不启用redux-immutable-state-invariant。</p><h4 id="3-工具应用"><a href="#3-工具应用" class="headerlink" title="3. 工具应用"></a>3. 工具应用</h4><p>上面我们介绍了辅助开发的Chrome扩展包和redux-immutable-state-variant库，对于React Devtools来说，启用只是安装一个Chrome扩展包的事，但是对于其余几个工具，我们的代码需要做一些修改才能配合浏览器使用。</p><p>因为Store是Redux应用的核心，所以所有的代码修改都集中在src/Store.js中。</p><p>首先需要从Redux引入多个函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore, combineReducers, applyMiddleware, compose&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br></pre></td></tr></table></figure><p>为了使用React Perf插件，需要添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Perf <span class="keyword">from</span> <span class="string">'react-addons-perf'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> win = <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">win.Perf - Perf;</span><br></pre></td></tr></table></figure><p>在这里把window赋值给模块级别变量win，是为了帮助代码缩小器（minifer），在webpack中缩小代码的插件叫UglifyJsPlugin，能够将局部变量名改成很短的变量名，这样功能不受影响但是代码的大小大大缩减。</p><p>不过，和所有的代码缩小器一样，UglifyJsPlugin不敢去改变全局变量名，因为改了就会影响程序的功能。所以当多次引用window这样的全局变量时，最好在模块开始将window赋值给一个变量，比如win，然后在代码其它部分只使用win，这样最终经过UglifyJsPlugin产生的缩小代码就只包含一个无法缩小的window变量。</p><p>我们给win上的Perf赋值了从react-addons-perf上导入的内容，这是为了帮助React Perf扩展包的使用，做了这个代码修改之后，React Perf上的Start按钮和Stop按钮才会起作用。</p><p>为了应用redux-immutable-state-invariant中间件和Redux Devtools，需要使用Redux的Store Enhancer功能，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  todos: todoReducer,</span><br><span class="line">  filter: filterReducer</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewares = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  middlewares.push(<span class="built_in">require</span>(<span class="string">'redux-immutable-state-invariant'</span>)());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storeEnhancers = compose(</span><br><span class="line">  applyMiddleware(...middlewares),</span><br><span class="line">  (win &amp;&amp; win.devToolsExtension) ? win.devToolExtension() : <span class="function">(<span class="params">f</span>) =&gt;</span> f</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(reducer, &#123;&#125;, storeEnhancers);</span><br></pre></td></tr></table></figure><p>代码修改的关键在于给createStore函数增加了第三个参数storeEnhancers，这个参数代表Store Enhancer的意思，能够让createStore函数产生的Store对象具有更多更强的功能。</p><p>因为Store Enhancer可能有多个，在我们的例子中就有两个，所以Redux提供了一个compose函数，用于把多个Store Enhancer组合在一起，我们分别来看这两个Store Enhancer是什么。</p><p>第一个Store Enhancer是一个函数applyMiddleware的执行结果，这个函数接受一个数组作为参数，每个元素都是一个Redux的中间件。虽然目前我们只应用了一个中间件，但是考虑到将来会扩展更多，所以我们用数组变量middlewares来存储所有的中间件，将来要扩展新的中间件只需要往这个数组中push新的元素就可以了。</p><p>目前，往middlewares中push的唯一一个中间件就是redux-immutable-state-invariant。如同上面解释过的，redux-immutable-state-invariant只有在开发环境下使用才有意义，所以只有当process.env.NODE_ENV不等于production时才加入这个中间件。</p><p>我们一直按照ES6的语法导入模块，也就是用import关键字导入模块，但是在这里却用了Node传统风格require，是因为import语句不能够存在于条件语句之中，只能出现在模块语句的顶层位置。</p><p>第二个Store Enhancer就是Redux Devtools，因为Redux Devtools的工作原理是截获所有应用中Redux Store的动作和状态变化，所以必须通过Store Enhancer在Redux Store中加入钩子。</p><p>如果浏览器中安装了Redux Devtools，在全局window对象上就有一个devToolsExtension代表Redux Devtools。但是，我们也要让没有安装这个扩展包的浏览器也能正常使用我们的应用，所以要根据window.devToolsExtension是否存在做一个判断，如果有就用，如果没有就插入一个什么都不做的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(win &amp;&amp; win.devToolsExtension) ? win.devToolsExtension() : <span class="function">(<span class="params">f</span>) =&gt;</span> f</span><br></pre></td></tr></table></figure><p>当所有的代码修改完毕，重新启动Todo应用，在浏览器的开发者工具中就可以使用所有关于React和Redux的工具了。</p><hr><h3 id="七、本章小结"><a href="#七、本章小结" class="headerlink" title="七、本章小结"></a>七、本章小结</h3><p>在这一章，我们学习了构建一个完整Redux应用的步骤和需要考虑的方面。</p><p>首先，要考虑代码文件的组织方式，对于可以高度模块化的Redux应用，使用“按功能组织”的方式要优于传统MVC框架下“按角色组织”的方式。</p><p>之后，要考虑Store上状态树的设计，因为状态树的结构直接决定了模块的划分，以及action类型、action构造函数和reducer的设计。可以说，开始写Redux应用第一行代码之前，首先要想好Store的状态树长得什么样子。</p><p>然后，我们实际构建了一个Todo应用，这个应用要比之前的ControlPanel应用复杂，利用划分模块的方法解决才是正道，从中我们也学习了React的ref功能，以及动态数量的子空间必须要包含key属性。</p><p>最后，我们了解了开发React和Redux应用必备的几样辅助工具，有了这几样工具，开发React和Redux应用就会如虎添翼。</p><p>这只是个起点，在接下来的章节中，我们会进一步深入了解React和Redux的精髓。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="/resources/深入浅出React和Redux.pdf">《深入浅出React和Redux —— 程墨》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在第一部分中，我们已经了解了React的基本工作方式，也知道了Redux在组合React组件中的作用，但是更多的只是了解其基本原理和使用方法，上手练习的也是一个简单的例子。&lt;/p&gt;
    
    </summary>
    
      <category term="React抄书笔记" scheme="http://www.xiaoleon.cn/categories/React%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.xiaoleon.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Web(7) 前端路由实现方法</title>
    <link href="http://www.xiaoleon.cn/2018/03/13/web-7/"/>
    <id>http://www.xiaoleon.cn/2018/03/13/web-7/</id>
    <published>2018-03-13T07:45:47.000Z</published>
    <updated>2018-03-13T14:27:42.743Z</updated>
    
    <content type="html"><![CDATA[<p>什么是路由？简单的来说，路由是 <strong><em>URL –&gt; 函数</em></strong> 的映射关系。</p><p>大部分复杂的网站，都会把业务解耦为模块进行处理。这些网站中又有很多的网站会把适合的部分应用Ajax进行数据交互，展现给用户，很明显处理这样的数据通信交互，不可避免的会涉及到跟URL打交道，让数据交互的变化反映到URL的变化上，进而可以给用户机会去通过保存的URL链接，还原刚才的页面内容板块的布局，这其中包括Ajax局部刷新的变化。</p><a id="more"></a><h3 id="一、router和route的区别"><a href="#一、router和route的区别" class="headerlink" title="一、router和route的区别"></a>一、<code>router</code>和<code>route</code>的区别</h3><p><code>route</code>是一条路由，它将一个 <strong><em>URL</em></strong> 路径和一个 <strong><em>函数</em></strong> 进行映射，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/users          --&gt;     getAllUsers()  </span><br><span class="line">/users/count    --&gt;     getUsersCount()</span><br></pre></td></tr></table></figure><p><code>router</code>可以理解为一个容器，或者一种机制，它管理了一组<code>route</code>。</p><p><code>router</code>是<code>route</code>的一组Map映射表，接收到一个URL后，由<code>router</code>来从映射表中查找相应的函数。</p><hr><h3 id="二、服务端路由"><a href="#二、服务端路由" class="headerlink" title="二、服务端路由"></a>二、服务端路由</h3><p>对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。</p><ul><li><p>静态资源，可以认为，URL的映射函数就是一个文件的读取操作。 </p></li><li><p>动态资源，映射函数可能是一个数据库的读取操作，也可能是一些数据处理等等。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.sendFile(<span class="string">'index'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/users'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = db.queryAllUsers();</span><br><span class="line">    res.send(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>router</code>匹配<code>route</code>的过程中，不仅会根据URL来匹配，还会根据请求的方法来匹配，如<code>POST</code>、<code>GET</code>、<code>PUT</code>、<code>DELETE</code>等等。</p><hr><h3 id="三、客户端路由"><a href="#三、客户端路由" class="headerlink" title="三、客户端路由"></a>三、客户端路由</h3><p>对于客户端来说，路由的映射函数通常是进行一些DOM元素的<strong>显示和隐藏</strong>操作。这样，当访问不同的路径的时候，会显示不同的页面组件。</p><p>客户端路由最常见的是下面两种实现方案：</p><h4 id="1-基于Hash（锚点）"><a href="#1-基于Hash（锚点）" class="headerlink" title="1. 基于Hash（锚点）"></a>1. 基于Hash（锚点）</h4><p>URL中 <code>#</code> 或者 <code>#!</code> 及其后面的部分为hash，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"><span class="keyword">var</span> a = url.parse(<span class="string">'http://example.com/a/b/#/foo/bar'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.has)</span><br><span class="line"><span class="comment">// =&gt; #/foo/bar</span></span><br></pre></td></tr></table></figure><p>H5中对has有一个<code>hashchange</code>事件，当页面的<code>hash</code>变化时，即会出发<code>hashchange</code>。</p><p>锚点<code>Hash</code>起到引导浏览器将这次记录推入<strong>历史记录栈顶</strong>的作用，<code>window.location</code>对象处理 <code>#</code> 的改变并不会重新加载页面，而是将之当成新页面，放入历史栈里。</p><p>当<code>前进(-&gt;)</code>或者<code>后退(&lt;-)</code>或者触发<code>hashchange</code>事件时，我们可以在对应的事件处理函数里注册ajax等操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash = <span class="built_in">window</span>.location.hash;</span><br><span class="line">    <span class="keyword">var</span> path = hash.substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (path) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            showHome();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/users'</span>:</span><br><span class="line">            showUsersList();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            show404NotFound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是hashchange这个事件并不是每个浏览器都有，地基浏览器需要用轮询检测URL是否在变化，来检测锚点的变化。  </p><p>当锚点内容 <code>location.hash</code> 被操作时，如果锚点内容发生改变浏览器才会将其放入历史栈中；否则历史栈并不会增加，并且也不会触发<code>hashchange</code>事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果浏览器不支持原生实现的事件，则开始模拟，否则退出。</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="string">"onhashchange"</span> <span class="keyword">in</span> <span class="built_in">window</span>.document.body ) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> location = <span class="built_in">window</span>.location,</span><br><span class="line">    oldURL = location.href,</span><br><span class="line">    oldHash = location.hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每隔100ms检查hash是否发生变化</span></span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newURL = location.href,</span><br><span class="line">        newHash = location.hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash发生变化且全局注册有onhashchange方法（这个名字是为了和模拟的事件名保持统一）；</span></span><br><span class="line">        <span class="keyword">if</span> ( newHash != oldHash &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span>.onhashchange === <span class="string">"function"</span>  ) &#123;</span><br><span class="line">            <span class="comment">// 执行方法</span></span><br><span class="line">            <span class="built_in">window</span>.onhashchange(&#123;</span><br><span class="line">                type: <span class="string">"hashchange"</span>,</span><br><span class="line">                oldURL: oldURL,</span><br><span class="line">                newURL: newURL</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            oldURL = newURL;</span><br><span class="line">            oldHash = newHash;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><h4 id="2-基于History"><a href="#2-基于History" class="headerlink" title="2. 基于History"></a>2. 基于History</h4><p>我们首先熟悉几个H5的 <code>History Api</code>，下面是<code>Mozilla</code>在H5中实现的<code>History Api</code>的官方文档描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Returns the number of entries in the joint session history.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.length</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Returns the current state object.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.state</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Goes back or forward the specified number of steps in the joint session history.A zero delta will reload the current page.If the delta is out of range, does nothing.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.go([delta])</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Goes back one step in the joint session history.If there is no previous page, does nothing.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.back()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Goes forward one step in the joint session history.If there is no next page, does nothing.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.forward()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Pushes the given data onto the session history, with the given title, and, if provided and not null, the given URL.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.pushState(data, title[url])</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Updates the current entry in the session history to have the given data, title, and,if provided and not null, URL.*/</span></span><br><span class="line"><span class="built_in">window</span>.history.replaceState(data, title[url])</span><br></pre></td></tr></table></figure><p>其中最后的两个方法<code>history.pushState</code>和<code>history.replaceState</code>，为前端操控浏览器历史栈提供了可能性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*parameters</span></span><br><span class="line"><span class="comment">*@data &#123;object&#125; state对象，这是一个javascript对象，一般是JSON格式的对象</span></span><br><span class="line"><span class="comment">*字面量。</span></span><br><span class="line"><span class="comment">*@title &#123;string&#125; 可以理解为document.title，在这里是作为新页面传入参数的。</span></span><br><span class="line"><span class="comment">*@url &#123;string&#125; 增加或改变的记录，对应的url，可以是相对路径或者绝对路径，</span></span><br><span class="line"><span class="comment">*url的具体格式可以自定。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">history.pushState(data, title, url) <span class="comment">//向浏览器历史栈中增加一条记录。</span></span><br><span class="line">history.replaceState(data, title, url) <span class="comment">//替换历史栈中的当前记录。</span></span><br></pre></td></tr></table></figure><p>这两个Api都会操作浏览器的历史栈，而不会引起页面的刷新。不同的是，<code>pushState</code>会增加一条新的历史记录，而<code>replaceState</code>则会替换当前的历史记录。</p><p>在将新的历史记录存入栈后，会把传入的<code>data(即state对象)</code>同时存入，方便以后调用，存在用户的本地硬盘上，最大支持到640k。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentState = history.state; <span class="comment">//如果没有则为null</span></span><br></pre></td></tr></table></figure><p>同时，这俩api都会更新或者覆盖当前浏览器的title和url为对应传入的参数。</p><p>URL参数可以为绝对路径，也可以为相对路径，但是不能跨域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设当前网页URL为：http://tonylee.pw</span></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"http://tonylee.pw?name=tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw?name=tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"http://tonylee.pw/name/tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"?name=tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw?name=tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"name=tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name=tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"/name/tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"name/tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的用法：</span></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"http://www.tonylee.pw?name=tonylee"</span>);</span><br><span class="line"><span class="comment">//error: 由于跨域将产生错误</span></span><br></pre></td></tr></table></figure><p>可以看到，URL作为一个改变当前浏览器地址的参数，用法是非常灵活的。传入的URL默认以“<code>/</code>”相隔，也可以自己指定为“<code>?</code>”等。</p><p><strong><em>根据URL的变化 –&gt; 页面板块变化 –&gt; 页面发出XHR请求 –&gt; 页面没有reload</em></strong></p><p>这里我们可以看一下<code>mozilla</code>提供的一个<code>pushState</code>和<code>replaceState</code>的小demo，已经接近一个前端路由的雏形。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;!-- <span class="keyword">this</span> starts off <span class="keyword">as</span> http:<span class="comment">//example.com/line?x=5 --&gt;</span></span><br><span class="line">&lt;title&gt;Line Game - <span class="number">5</span>&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;You are at coordinate &lt;span id="coord"&gt;5&lt;/</span>span&gt; on the line.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;</span></span><br><span class="line"><span class="regexp">&lt;a href="?x=6" onclick="go(1); return false;"&gt;Advance to 6&lt;/</span>a&gt; or</span><br><span class="line">&lt;a href=<span class="string">"?x=4"</span> onclick=<span class="string">"go(-1); return false;"</span>&gt;retreat to <span class="number">4</span>&lt;<span class="regexp">/a&gt;?</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> currentPage = <span class="number">5</span>; <span class="comment">// prefilled by server！！！！</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    setupPage(currentPage + d);</span><br><span class="line">    history.pushState(currentPage, <span class="built_in">document</span>.title, <span class="string">'?x='</span> + currentPage);</span><br><span class="line">&#125;</span><br><span class="line">onpopstate = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    setupPage(event.state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupPage</span>(<span class="params">page</span>) </span>&#123;</span><br><span class="line">    currentPage = page;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">'Line Game - '</span> + currentPage;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'coord'</span>).textContent = currentPage;</span><br><span class="line">    <span class="built_in">document</span>.links[<span class="number">0</span>].href = <span class="string">'?x='</span> + (currentPage+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">document</span>.links[<span class="number">0</span>].textContent = <span class="string">'Advance to '</span> + (currentPage+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">document</span>.links[<span class="number">1</span>].href = <span class="string">'?x='</span> + (currentPage<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">document</span>.links[<span class="number">1</span>].textContent = <span class="string">'retreat to '</span> + (currentPage<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>从例子中我们看到一个<code>popstate</code>的事件，这里也看看<code>mozalla</code>官方文档</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">An event handler <span class="keyword">for</span> the popstate event on the window.</span><br><span class="line"></span><br><span class="line">A popstate event is dispatched to the window every <span class="built_in">time</span> the active history entry changes between two history entries <span class="keyword">for</span> the same document. <span class="keyword">If</span> the history entry being activated was created by a <span class="keyword">call</span> to history.pushState() or was affected by a <span class="keyword">call</span> to history.replaceState(), the popstateevent's state property contains a <span class="built_in">copy</span> of the history entry's state object.</span><br><span class="line"></span><br><span class="line">Note that just calling history.pushState() or history.replaceState() won't trigger apopstate event. The popstate event is only triggered by doing a browser action such as clicking on the back button (or calling history.back() <span class="keyword">in</span> JavaScript). And the event is only triggered when the user navigates between two history entries <span class="keyword">for</span> the same document.</span><br><span class="line"></span><br><span class="line">Browsers tend to handle the popstate event differently on page load. Chrome (prior to v34) and Safari always emit a popstate event on page load, but Firefox doesn't.</span><br><span class="line"></span><br><span class="line">Syntax</span><br><span class="line">    window.onpopstate = funcRef;</span><br><span class="line">    //funcRef is a handler function.</span><br></pre></td></tr></table></figure><p>简单来说，当同一个页面在历史记录间切换时，就会派发<code>popstate</code>事件。</p><p>正常情况下，用户点击后退按钮或者调用<code>history.back() or history.go()</code>，页面根本没有处理事件的机会，因为这些操作会使得页面<code>reload</code>，所以<code>popstate</code>只在不会让浏览器页面刷新的历史记录之间切换才能触发，这些历史记录一般由<code>pushState/replaceState</code>或者是由<code>hash</code>锚点等操作产生，并且在事件的句柄中可以访问state对象的引用副本！</p><p>单纯的调用<code>pushState/replaceState</code>并不会触发<code>popstate</code>事件。</p><p>页面初次加载时，是否会主动触发<code>popstate</code>事件，不同的浏览器实现不一样。下面是一个官方demo。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"location: "</span> + <span class="built_in">document</span>.location + <span class="string">", state: "</span> +   <span class="built_in">JSON</span>.stringify(event.state));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">1</span>&#125;, <span class="string">"title 1"</span>, <span class="string">"?page=1"</span>);</span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">2</span>&#125;, <span class="string">"title 2"</span>, <span class="string">"?page=2"</span>);</span><br><span class="line">history.replaceState(&#123;<span class="attr">page</span>: <span class="number">3</span>&#125;, <span class="string">"title 3"</span>, <span class="string">"?page=3"</span>);</span><br><span class="line">history.back(); <span class="comment">// alerts "location: http://example.com/example.html?page=1, state: &#123;"page":1&#125;"</span></span><br><span class="line">history.back(); <span class="comment">// alerts "location: http://example.com/example.html, state: null</span></span><br><span class="line">history.go(<span class="number">2</span>); <span class="comment">// alerts "location: http://example.com/example.html?page=3, state: &#123;"page":3&#125;</span></span><br></pre></td></tr></table></figure><p>兼容性测试脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"node_modules/jquery/dist/jquery.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(history &amp;&amp; history.pushState) &#123;</span><br><span class="line">        alert(<span class="string">"true"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">"false"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    $(<span class="built_in">window</span>).on(<span class="string">"hashchange"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"hashchange"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>兼容性概览：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">history &amp;&amp; history.pushState兼容如下：</span><br><span class="line">    chrome true；</span><br><span class="line">    Firefox true；</span><br><span class="line">    IE10 true;</span><br><span class="line">    IE &lt;= <span class="number">9</span> false;  </span><br><span class="line"><span class="function">    PS:<span class="title">IE</span> &lt;= 9既然不支持这些<span class="title">api</span>那就只能采用<span class="title">hash</span>方案，来实现路由系统的兼容了。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">hashchange</span>兼容如下：</span></span><br><span class="line"><span class="function">    <span class="title">IE9</span> <span class="title">true</span>;</span></span><br><span class="line"><span class="function">    <span class="title">IE8</span> <span class="title">true</span>;</span></span><br><span class="line"><span class="function">    <span class="title">IE7</span> <span class="title">false</span>;</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">页面<span class="title">load</span>时，<span class="title">onhashchange</span>默认触发情况：</span></span><br><span class="line"><span class="function">    <span class="title">chrome</span> 需主动<span class="title">trigger</span>才能触发</span></span><br><span class="line"><span class="function">    <span class="title">FF</span> 需主动<span class="title">trigger</span>才能触发</span></span><br><span class="line"><span class="function">    <span class="title">IE</span> 需主动<span class="title">trigger</span>才能触发</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">页面<span class="title">load</span>时，<span class="title">onpopstate</span>默认触发情况：</span></span><br><span class="line"><span class="function">    <span class="title">chrome</span> &lt; 34版本之前的默认触发 </span></span><br><span class="line"><span class="function">    <span class="title">FF</span> 默认不触发</span></span><br><span class="line"><span class="function">    <span class="title">IE</span> 默认不触发</span></span><br></pre></td></tr></table></figure><p>只有webkit内核浏览器才会默认触发<code>popstate</code>。</p><h4 id="3-两种实现的比较"><a href="#3-两种实现的比较" class="headerlink" title="3. 两种实现的比较"></a>3. 两种实现的比较</h4><ul><li><p>基于<code>Hash</code>的路由，兼容性更好</p></li><li><p>基于<code>History API</code>的路由，更加直观和正式</p></li></ul><p>有一点很大的区别是，基于<code>Hash</code>的路由不需要对服务器做改动，基于<code>History API</code>的路由需要对服务器做一些改造。</p><p>浏览器第一次打开某个链接时，首先会定向到<code>server</code>端进行路由解析。上边所说的前端路由系统，都是建立在页面已经打开的前提下，前端才可以通过<code>History API</code>进行URL拦截，确保这些URL变化不会发送给<code>server</code>端返回新页面。</p><p>但是需要考虑这种情况，链接时在一个新的浏览器tab中打开的，那么这个时候就无法拦截下这个URL，所以，这就要求server和前端制定好一个规则，区分URL中<strong><em>前端解析的部分</em></strong>和<strong><em>后端解析的部分</em></strong>，<code>server</code>端判断出这个URL的某个部分不属于自己的范围时，就应该把这部分URL定向到前端路由页面的<code>javascript</code>代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodejs</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req.path.indexOf(<span class="string">'/routeForServer'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        res.send(<span class="string">'这里返回的都是server端处理的路由'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.sendfile(<span class="string">'这里返回配置好路由的页面'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>正常情况下，URL中的“/”一般是server端路由采用的标记，而“?”或者“#”再或者“#!”，则一般是前端路由采用的开始标记，我们可以在这些符号后边，通过键值对的形式，描述一个页面具有哪些板块配置信息。也不乏有的网站为了美观，前后端共用“/”进行路由索引。</p><p>URL中采用“#”或者“#!”进行前后端的区分，是为了照顾到更多浏览器，因为利用hash方案，IE对这套路由系统有很好的支持性。</p><hr><h3 id="四、动态路由"><a href="#四、动态路由" class="headerlink" title="四、动态路由"></a>四、动态路由</h3><p>上面提到的例子都是静态路由，即路径都是固定的。但是我们经常会需要在路径中传入参数，例如或者某个用户的信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodejs</span></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">百度：</span><br><span class="line"><span class="function">    https://<span class="title">wenku.baidu.com</span>/<span class="title">album</span>/<span class="title">list</span>?<span class="title">cid</span>=197</span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">zhidao.baidu.com</span>/<span class="title">daily</span>/<span class="title">view</span>?<span class="title">id</span>=47009</span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新浪：</span><br><span class="line"><span class="function">    http://<span class="title">sz.sina.com.cn</span>/<span class="title">news</span>/<span class="title">yz</span>/2016-09-02/<span class="title">detail</span>-<span class="title">ifxvqcts9207231.shtml</span>?<span class="title">from</span>=<span class="title">sz_tttj</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">京东：</span><br><span class="line"><span class="function">    https://<span class="title">item.jd.com</span>/3995645.<span class="title">html</span>#<span class="title">crumb</span>-<span class="title">wrap</span></span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">list.jd.com</span>/<span class="title">list.html</span>?<span class="title">cat</span>=9987,653,655&amp;<span class="title">ev</span>=%40<span class="title">exbrand_14026</span>&amp;<span class="title">go</span>=0</span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Google Gmail</span><br><span class="line"><span class="function">    https://<span class="title">mail.google.com</span>/<span class="title">mail</span>/<span class="title">u</span>/1/#<span class="title">inbox</span></span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">mail.google.com</span>/<span class="title">mail</span>/<span class="title">u</span>/1/#<span class="title">starred</span></span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">mail.google.com</span>/<span class="title">mail</span>/<span class="title">u</span>/1/#<span class="title">sent</span></span></span><br><span class="line"><span class="function">    <span class="title">https</span>://<span class="title">mail.google.com</span>/<span class="title">mail</span>/<span class="title">u</span>/1/#<span class="title">drafts</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate" target="_blank" rel="noopener">MDN官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是路由？简单的来说，路由是 &lt;strong&gt;&lt;em&gt;URL –&amp;gt; 函数&lt;/em&gt;&lt;/strong&gt; 的映射关系。&lt;/p&gt;
&lt;p&gt;大部分复杂的网站，都会把业务解耦为模块进行处理。这些网站中又有很多的网站会把适合的部分应用Ajax进行数据交互，展现给用户，很明显处理这样的数据通信交互，不可避免的会涉及到跟URL打交道，让数据交互的变化反映到URL的变化上，进而可以给用户机会去通过保存的URL链接，还原刚才的页面内容板块的布局，这其中包括Ajax局部刷新的变化。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="前端路由" scheme="http://www.xiaoleon.cn/tags/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
    
      <category term="Hash" scheme="http://www.xiaoleon.cn/tags/Hash/"/>
    
      <category term="History" scheme="http://www.xiaoleon.cn/tags/History/"/>
    
  </entry>
  
  <entry>
    <title>Web(6) 浏览器页面的渲染过程</title>
    <link href="http://www.xiaoleon.cn/2018/03/12/web-6/"/>
    <id>http://www.xiaoleon.cn/2018/03/12/web-6/</id>
    <published>2018-03-12T02:52:44.000Z</published>
    <updated>2018-03-12T14:01:55.037Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器在下载好HTML、CSS、JS等文件后，是如何将这些内容组装成绚丽的页面呈现给用户呢？不同的浏览器渲染过程实际上并不相同，但是依旧存在相一致的部分。</p><a id="more"></a><h3 id="一、浏览器渲染页面"><a href="#一、浏览器渲染页面" class="headerlink" title="一、浏览器渲染页面"></a>一、浏览器渲染页面</h3><p>从浏览器地址栏的请求链接开始，浏览器通过DNS解析查到域名映射的IP地址，成功之后浏览器端向此IP地址取得连接。成功连接之后，浏览器端将请求头信息通过HTTP协议向此IP地址所在服务器发起请求。服务器接收到请求之后等待处理，最后向浏览器端发回响应，此时在HTTP协议下，浏览器从服务器接收到text/html类型的代码，浏览器开始显示此HTML，并获取其中内嵌资源文件，然后浏览器再发起请求来获取这些资源，并在浏览器的html中显示。</p><p>浏览器解析的大概的工作流程可以分为以下几个步骤：</p><ul><li><p>1) 用户输入网址（假设是HTML页面，第一次访问，无缓存情况），浏览器向服务器发出HTTP请求，服务器返回HTML文件</p><p>  优化方案：善用缓存，减少HTTP请求，减轻服务器压力</p></li><li><p>2) 浏览器载入HTML代码，发现head内有一个link引用外部css文件，则浏览器立即发送css文件请求，获取浏览器返回的css文件</p><p>  优化方案：css文件合并，减少HTTP请求</p></li><li><p>3) 浏览器继续载入HTML中body部分的代码，并且css文件已经拿到手了，可以开始渲染页面了</p><p>  优化方案：css文件要放在最上面，避免网页重新渲染</p></li><li><p>4) 浏览器在代码中发现一个img标签引用了一张图片，向服务器发出请求，此时浏览器不会等到图片下载完，而是继续渲染后面的代码</p><p>  优化方案：图片文件合并，减少HTTP请求</p></li><li><p>5) 服务器返回图片文件，由于占用了一定面积，影响后面段落的布局，因此浏览器需要回过头来重新渲染这部分代码</p><p>  优化方案：最好图片都设置尺寸，避免重新渲染</p></li><li><p>6) 浏览器发现一个包含一行JavaScript的script标签，会立即运行该js代码</p><p>  优化方案：script最好放在页面最下面</p></li><li><p>7) js脚本执行了语句，它令浏览器隐藏掉代码中的某个div，突然就少了一个元素，浏览器不得不重新渲染这部分代码</p><p>  优化方案：页面初始化样式不要使用js控制</p></li><li><p>8) 浏览器完成渲染，展示HTML页面</p></li></ul><hr><h3 id="二、重绘和回流"><a href="#二、重绘和回流" class="headerlink" title="二、重绘和回流"></a>二、重绘和回流</h3><h4 id="1-什么是重绘和回流"><a href="#1-什么是重绘和回流" class="headerlink" title="1. 什么是重绘和回流"></a>1. 什么是重绘和回流</h4><p>为什么页面会慢？那是因为浏览器需要花时间去渲染，尤其是当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，该过程称为回流（<code>reflow</code>）。</p><p><code>reflow</code>几乎是无法避免的，现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的<code>reflow</code>。鼠标滑过、点击等等，只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会<code>reflow</code>哪一部分的代码，它们都彼此相互影响着。</p><p>如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器的重绘（<code>repaint</code>）。</p><p><code>repaint</code>的速度明显快于<code>reflow</code>（在IE下需要换一下说法，<code>reflow</code>要比<code>repaint</code>更缓慢）。</p><p><code>repaint操</code>作触发时，元素的外观被改变，且在没有改变布局的情况下发生，如改变<code>outline</code>、<code>visibility</code>、<code>background-color</code>，不会影响到dom结构渲染。</p><p><code>reflow</code>与<code>repaint</code>区别就是它会影响到dom的结构渲染，同时它会触发<code>repaint</code>，它会改变它本身与所有父辈元素，这种开销是非常昂贵的，导致性能下降是必然的，页面元素越多效果越明显。</p><p>注意：回流必将引起重绘，重绘不一定引起回流。</p><h4 id="2-如何减少重绘和回流"><a href="#2-如何减少重绘和回流" class="headerlink" title="2. 如何减少重绘和回流"></a>2. 如何减少重绘和回流</h4><p><code>reflow</code>是不可避免的，只能将<code>reflow</code>对性能的影响减少到最小</p><ul><li><p>1) 不要一条一条地修改DOM样式，通过设置<code>style</code>属性改变节点样式的话，每设置一次都会导致一次<code>reflow</code>。所以最好通过设置<code>class</code>的方式，这样可以将多次改变样式属性的操作合并成一次操作</p></li><li><p>2) 让要操作的元素进行“离线处理”，处理完后一起更新</p><ul><li><p>使用<code>DocumentFragment</code>进行缓存操作，引发一次重绘与回流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">fragment.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Hello Zhang Xiao!'</span>));</span><br><span class="line"></span><br><span class="line">fragment.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'br'</span>));</span><br><span class="line"></span><br><span class="line">fragment.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Hello Leon!'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(fragment);</span><br></pre></td></tr></table></figure></li><li><p>使用<code>display: none</code>技术，只引发两次重绘与回流</p><p>原理：由于<code>display</code>属性为<code>none</code>的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样在隐藏和显示时触发2次重排。</p></li></ul></li><li><p>3) 设置元素的<code>position</code>为<code>absolute</code>或<code>fixed</code></p></li></ul><p>元素脱离标准文档流，也从DOM树结构中脱离出来，在需要<code>reflow</code>时只需要<code>reflow</code>自身与下级元素。</p><ul><li>4) 不要使用table布局</li></ul><p>table中某个元素一旦触发<code>reflow</code>就会导致table里所有的其他元素<code>reflow</code>。在适合用table的场合，可以设置<code>table-layout</code>为<code>auto</code>或<code>fixed</code>，这样可以让table一行一行的渲染，这种做法也是为了限制<code>reflow</code>的影响范围。</p><ul><li>5) 避免使用css的JavaScript表达式，如果css里有<code>expression</code>，每次都会重新计算一次。</li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://www.jianshu.com/p/7fbd239ca0e2?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">浏览器如何渲染页面</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器在下载好HTML、CSS、JS等文件后，是如何将这些内容组装成绚丽的页面呈现给用户呢？不同的浏览器渲染过程实际上并不相同，但是依旧存在相一致的部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="页面渲染" scheme="http://www.xiaoleon.cn/tags/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93/"/>
    
      <category term="重绘" scheme="http://www.xiaoleon.cn/tags/%E9%87%8D%E7%BB%98/"/>
    
      <category term="回流" scheme="http://www.xiaoleon.cn/tags/%E5%9B%9E%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>React(3) 从Flux到Redux</title>
    <link href="http://www.xiaoleon.cn/2018/03/06/react-3/"/>
    <id>http://www.xiaoleon.cn/2018/03/06/react-3/</id>
    <published>2018-03-06T15:05:43.000Z</published>
    <updated>2018-03-19T13:15:53.841Z</updated>
    
    <content type="html"><![CDATA[<p>在前一章中我们已经感受到完全用React来管理应用数据的麻烦，在这一章中，我们将介绍Redux这种管理应用状态的框架</p><a id="more"></a><p>本章包含以下内容：</p><ul><li><p>单向数据流框架的始祖Flux</p></li><li><p>Flux理念的一个更强实现Redux</p></li><li><p>结合React和Redux</p></li></ul><h3 id="一、Flux"><a href="#一、Flux" class="headerlink" title="一、Flux"></a>一、Flux</h3><p>要了解Redux，首先要从Flux说起，可以认为Redux是Flux思想的另一种实现方式，通过了解Flux，我们可以知道Flux一族框架（其中就包括Redux）贯彻的最重要的观点——单向数据流，更重要的是，我们可以发现Flux框架的缺点，从而深刻地认识到Redux相对于Flux的改进之处。</p><p>让我们来看看Flux的历史，实际上，Flux是和React同时面世的，在2013年，Facebook公司让React亮相的同时，也推出了Flux框架，React和Flux相辅相成，Facebook认为两者结合在一起才能构建大型的JavaScript应用。</p><p>做一个容易理解的对比，React是用来替换jQuery的，那么Flux就是以替换Backbone.js、Ember.js等MVC一族框架为目的。</p><p>在MVC（Model-View-Controller）的世界里，React相当于V（View）的部分，只涉及页面的渲染，一旦涉及应用的数据管理部分，还是交给Model和Controller，不过，Flux并不是一个MVC框架，事实上，Flux认为MVC框架存在很大问题，它推翻了MVC框架，并用一个新的思维来管理数据流转。</p><h4 id="1-MVC框架的缺陷"><a href="#1-MVC框架的缺陷" class="headerlink" title="1. MVC框架的缺陷"></a>1. MVC框架的缺陷</h4><p>MVC框架是业界广泛接受的一种前端应用框架类型，这种框架把应用分成三个部分：</p><ul><li><p>Model（模型）：负责管理数据，大部分业务逻辑也应该放在Model中</p></li><li><p>View（视图）：负责渲染用户界面，应该避免在View中涉及业务逻辑</p></li><li><p>Controller（控制器）：负责接受用户输入，根据用户输入调用对应的Model部分逻辑，把产生的数据结果交给View部分，让View渲染出必要的输出。</p></li></ul><p>MVC框架的几个组成部分和请求的关系如图所示</p><p><img src="/images/react-3/1.png" alt="MVC框架"></p><p>这样的逻辑划分，实质上与把以一个应用划分为多个组件一样，就是“分而治之”。毫无疑问，相比把业务逻辑和界面渲染逻辑混在一起，MVC框架要先进得多。这种方式得到了广泛的认可，连Facebook最初也是用这种框架。</p><p>但是，Facebook的工程部门逐渐发现，对于非常巨大的代码库和庞大的组织，按照他们的原话说就是“MVC真的很快就变得非常复杂”。每当工程师想要增加一个新的功能时，对代码的修改很容易引入新的bug，因为不同模块之间的依赖关系让系统变得“脆弱而且不可预测”。对于刚刚加入团队的新手，更是举步维艰，因为不知道修改代码会造成什么样的后果。如果要保险，就会发现寸步难移；如果放手去干，就可能引发很多bug。</p><p>一句话，MVC根本不适合Facebook的需求。</p><p>为何被业界普遍认可的MVC框架在Facebook眼里却沦落到如此地步呢？</p><p>下图是Facebook描述的MVC框架，在图中我们可以看到，Model和View之间缠绕着蜘蛛网一样复杂的依赖关系，根据箭头的方向，我们知道有的是Model调用了View，有的是View调用了Model，很乱。</p><p><img src="/images/react-3/2.png" alt="MVC的缺点"></p><p>MVC框架提出的数据流很理想，用户请求先到达Controller，由Controller调用Model获得数据，然后把数据交给View，但是，在实际框架实现中，总是允许View和Model可以直接通信，从而出现上图的情况。越来越多的同行发现，在MVC中让View和Model直接对话就是灾难。</p><p>当我向以前没接触过Flux的朋友介绍Flux的时候，发现了一个有意思的现象。凡是只在服务器端使用过MVC框架的朋友，就很容易理解和接受Flux。而对于已经有很多浏览器端MVC框架经验的朋友，往往还要费一点劲才能明白MVC和Flux的差异。</p><p>造成这种认知差别的主要原因，就是服务器端MVC框架往往就是每个请求就只在Controller-Model-View三者之间走一圈，结果就返回给浏览器去渲染或者其他处理了，然后这个请求生命周期的Controller-Model-View就可以回收销毁了，这是一个严格意义的单向数据流；对于浏览器端MVC框架，存在用户的交互处理，界面渲染出来之后，Model和View依然处在于浏览器中，这时候就会诱惑开发者为了简便，让现存的Model和View直接对话。</p><p>对于MVC框架，为了让数据流可控，Controller应该是中心，当View要传递消息给Model时，应该调用Controller的方法，同样，当Model要更新View时，也应该通过Controller引发新的渲染。</p><p>当Facebook推出Flux时，招致了很多质疑。很多人都说，Flux只不过是一个对数据流管理更加严格的MVC框架而已。这种说法不完全准确，但是一定意义上也说明了Flux的一个特点：更严格的数据流控制。</p><p>Facebook无心在MVC框架上纠缠，他们用Flux框架来代替原有的MVC框架，他们提出的Flux框架大致结构如图所示</p><p><img src="/images/react-3/3.png" alt="Flux的单向数据流"></p><p>一个Flux应用包含四个部分，我们先粗略了解一下：</p><ul><li><p>Dispatcher：处理动作分发，维持Store之间的依赖关系</p></li><li><p>Store：负责存储数据和处理数据相关逻辑</p></li><li><p>Action：驱动Dispatcher的JavaScript对象</p></li><li><p>View：视图部分，负责显示用户界面</p></li></ul><p>如果非要把Flux和MVC做一个结构对比，那么，Flux的Dispatcher相当于MVC的Controller，Flux的Store相当于MVC的Model，Flux的View当然就对应MVC的View，至于多出来的这个Action，可以理解为对应MVC框架的用户请求。</p><p>在MVC框架中，系统能够提供什么样的服务，通过Controller暴露函数来实现。每增加一个功能，Controller往往就要增加一个函数；在Flux的世界里，新增加功能并不需要Dispatcher增加新的函数，实际上，Dispatcher自始至终只需要暴露一个函数Dispatch，当需要增加新的功能时，要做的是增加一种新的Action类型，Dispatcher的对外接口并不用改变。</p><p>当需要扩充应用所能处理的“请求”时，MVC方法就需要增加新的Controller，而对于Flux则只是增加新的Action。</p><p>下面我们看看怎么用Flux改进我们的React应用。</p><p><em>**</em> 2. Flux应用</p><p>让我们改进一下前面创造的ControlPanel应用，Flux提供了一些辅助工具类和函数，能够帮助创建Flux应用，但是需要一些学习曲线。在这里，我们只用Facebook官方的基本功能，目的是为了更清晰地看一看Flux的工作原理。</p><p>首先通过命令行在项目目录下安装Flux。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save flux</span><br></pre></td></tr></table></figure><p>利用Flux实现ControlPanel应用后的界面效果与前面创造的应用完全一样，通过同一界面不同实现方式的比对，我们可以体会每个方式的优劣。</p><ul><li>1) Dispatcher</li></ul><p>首先，我们要创造一个Dispatcher，几乎所有应用都只需要拥有一个Dispatcher，对于我们这个简单的应用更不例外。在src/AppDispatcher.js中，我们创造这个唯一的Dispatcher对象，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Dispatcher&#125; <span class="keyword">from</span> <span class="string">'flux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Dispatcher();</span><br></pre></td></tr></table></figure><p>非常简单，我们引入flux库中的Dispatcher类，然后创造一个新的对象作为这个文件的默认输出就足够了。在其他代码中，将会引用这个全局唯一的Dispatcher对象。</p><p>Dispatcher存在的作用，就是用来派发action，接下来我们就来定义应用中涉及的action。</p><ul><li>2) action</li></ul><p>action顾名思义代表一个“动作”，不过这个动作只是一个普通的JavaScript对象，代表一个动作的纯数据，类似于DOM API中的事件（event）。甚至，和事件相比，action其实还是更加纯粹的数据对象，因为事件往往还包含一些方法，比如点击事件就有preventDefault方法，但是action对象不自带方法，就是纯粹的数据。</p><p>作为管理，action对象必须有一个名为type的字段，代表这个action对象的类型，为了记录日志和debug方便，这个type应该是字符串类型。</p><p>定义action通常需要两个文件，一个定义action的类型，一个定义action的构造函数（也称为action creator）。分成两个文件的主要原因是Store中会根据action类型做不同操作，也就有单独导入action类型的需要。</p><p>在src/ActionTypes.js中，我们定义action的类型，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">'increment'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT = <span class="string">'decrement'</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，用户只能做两个动作，一个是点击“<code>+</code>”按钮，一个是点击“<code>-</code>”按钮，所以我们只有两个action类型INCREMENT和DECREMENT。</p><p>现在我们在src/Actions.js文件中定义action构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ActionTypes <span class="keyword">from</span> <span class="string">'./ActionTypes.js'</span>;</span><br><span class="line"><span class="keyword">import</span> AppDispatcher <span class="keyword">from</span> <span class="string">'./AppDispatcher.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function">(<span class="params">counterCaption</span>) =&gt;</span> &#123;</span><br><span class="line">  AppDispatcher.dispatch(&#123;</span><br><span class="line">    type: ActionTypes.INCREMENT,</span><br><span class="line">    counterCaption: counterCaption</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function">(<span class="params">counterCaption</span>) =&gt;</span> &#123;</span><br><span class="line">  AppDispatcher.dispatch(&#123;</span><br><span class="line">    type: ActionTypes.DECREMENT,</span><br><span class="line">    counterCaption: counterCaption</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然出于业界习惯，这个文件被命名为Actions.js，但是要注意里面定义的并不是action对象本身，而是能够产生并派发action对象的函数。</p><p>在Actions.js文件中，引入了ActionTypes和AppDispatcher，看得出来是要直接使用Dispatcher。</p><p>这个Actions.js导出了两个action构造函数increment和decrement，当这两个函数被调用的时候，创造了对应的action对象，并立即通过AppDispatcher.dispatch函数派发出去。</p><p>派发出去的action对象最后怎么样了呢？下面关于Store的部分可以看到。</p><ul><li>3) Store</li></ul><p>一个Store也是一个对象，这个对象存储应用状态，同时还要接受Dispatcher派发的动作，根据动作来决定是否要更新应用状态。</p><p>接下来我们创造Store相关的代码，因为使用Flux之后代码文件数量会增多，再把所有源代码文件都放在src目录下就不容易管理了。所以我们在src下创建一个子目录stores，在这个子目录里放置所有的Store代码。</p><p>在前面章节的ControlPanel应用例子里，有三个Counter组件，还有一个统计三个Counter计数值之和的功能，我们遇到的麻烦就是这两者之间的状态如何同步的问题，现在，我们创造两个Store，一个是为Counter组件服务的CounterStore，另一个就是为总数服务的SummaryStore。</p><p>我们首先添加CounterStore，放在src/stores/CounterStore.js文件中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterValues = &#123;</span><br><span class="line">  <span class="string">'First'</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">'Second'</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="string">'Third'</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CounterStore = <span class="built_in">Object</span>.assign(&#123;&#125;, EventEmitter.prototype, &#123;</span><br><span class="line">  getCounterValues: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> counterValues;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  emitChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.emit(CHANGE_EVENT);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addChangeListener: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.on(CHANGE_EVENT, callback);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  removeChangeListener: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.removeListener(CHANGE_EVENT, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当Store的状态发生变化的时候，需要通知应用的其它部分做必要的响应。在我们的应用中，做出响应的部分当然就是View部分，但是我们不应该硬编码这种联系，应该用消息的方式建立Store和View的联系。这就是为什么我们让CounterStore扩展了EventEmitter.prototype，等于让CounterStore成了EventEmitter对象，一个EventEmitter实例对象支持下列相关函数。</p><ul><li><p>emit函数，可以广播一个特定事件，第一个参数是字符串类型的事件名称</p></li><li><p>on函数，可以增加一个挂在这个EventEmitter对象特定事件上的处理函数，第一个参数是字符串类型的事件名称，第二个参数是处理函数</p></li><li><p>removeListener函数，和on函数做的事情相反，删除挂在这个EventEmitter对象特定事件上的处理函数，和on函数一样，第一个参数是事件名称，第二个参数是处理函数。要注意，如果要调用removeListener函数，就一定要保留对处理函数的引用</p></li></ul><p>对于CounterStore对象，emitChange、addChangeListener和removeChangeListener函数就是利用EventEmitter上述的三个函数完成对CounterStore状态更新的广播、添加监听函数和删除监听函数等操作。</p><p>CounterStore函数还提供一个getCounterValues函数，用于让应用中其他模块可以读取当前的计数值，当前的计数值存储在文件模块级的变量counterValues中。</p><p>上面实现的Store只有注册到Dispatcher实例上才能真正发挥作用，所以还需要增加下列代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AppDispatcher <span class="keyword">from</span> <span class="string">'../AppDispatcher.js'</span>;</span><br><span class="line"></span><br><span class="line">CounterStore.dispatchToken = AppDispatcher.register(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ActionTypes.INCREMENT) &#123;</span><br><span class="line">    counterValues[action.counterCaption]++;</span><br><span class="line">    CounterStore.emitChange();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === ActionTypes.DECREMENT) &#123;</span><br><span class="line">    counterValues[action.counterCaption]--;</span><br><span class="line">    CounterStore.emitChange();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是最重要的一个步骤，要把CounterStore注册到全局唯一的Dispatcher上去。Dispatcher有一个函数叫做register，接受一个回调函数作为参数。返回值是一个token，这个token可以用于Store之间的同步，我们在CounterStore中还用不上这个返回值，在稍后的SummaryStore中会用到，现在我们只是把register函数的返回值保存在CounterStore对象的dispatchToken字段上，待会就会用得到。</p><p>现在我们来仔细看看register接受的这个回调函数参数，这是Flux流程中最核心的部分，当通过register函数把一个回调函数注册到Dispatcher之后，所有派发给Dispatcher的action对象，都会传递到这个回调函数中来。</p><p>比如通过Dispatcher派发一个动作，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AppDispatcher.dispatch(&#123;</span><br><span class="line">  type: ActionTypes.INCREMENT,</span><br><span class="line">  counterCaption: <span class="string">'First'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那在CounterStore注册的回调函数就会被调用，唯一的一个参数就是那个action对象，回调函数要做的，就是根据action对象来决定如何更新自己的状态。</p><p>作为一个普遍接受的传统，action对象中必须要有一个type字段，类型是字符串，用于表示这个action对象是什么类型，比如上面派发的action对象，type为“increment”，表示是一个计数器“加一”的动作；如果有必要，一个action对象还可以包含其他的字段。上面的action对象中还有一个counterCaption字段值为“First”，标识名字为“First”的计数器。</p><p>在我们的例子中，action对象的type和counterCaption字段结合在一起，可以确定是哪个计数器应该做加一或者减一的动作，上面例子中的动作含义就是：“名字为First的计数器要做加一动作。”</p><p>根据不同的type，会有不同的操作，所以注册的回调函数很自然有一个模式，就是函数体是一串if-else条件语句或者switch条件语句，而条件语句的跳转条件，都是针对参数action对象的type字段:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CounterStore.dispatchToken = AppDispatcher.register(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ActionTypes.INCREMENT) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === ActionTypes.DECREMENT) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>无论是加一还是减一，最后都要调用counterStore.emitChange函数，假如有调用者通过Counter.addChangeListener关注了CounterStore的状态变化，这个emitChange函数调用就会引发监听函数的执行。</p><p>目前，CounterStore只关注INCREMENT和DECREMENT动作，所以if-else判断也只关注了这两种类型的动作，除此之外，其他action对象一律忽略。</p><p>接下来，我们再来看看另一个Store，也就是代表所有计数器计数值综合的Store，在src/stores/SummaryStore.js中。</p><p>SummaryStore也有emitChange、addChangeListener还有removeChangeListener函数，功能一样也是用于通知监听者状态变化，这几个函数的代码和CounterStore中完全重复，不同点是对获取状态函数的定义，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeSummary</span>(<span class="params">counterValues</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> summary = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> counterValues) &#123;</span><br><span class="line">    <span class="keyword">if</span> (counterValues.hasOwnProperty(key)) &#123;</span><br><span class="line">      summary += counterValues[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> summary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SummaryStore = <span class="built_in">Object</span>.assign(&#123;&#125;, EventEmitter.prototype, &#123;</span><br><span class="line">  getSummary: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> computeSummary(CounterStore.getCounterValues());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以注意到，SummaryStore并没有存储自己的状态，当getSummary被调用时，它是直接从CounterStore里获取状态计算的。</p><p>CounterStore提供了getCounterValues函数让其他模块能够获得所有计数器的值，SummaryStore也提供了getSummary让其他模块可以获得所有计数器当前的总和。不过，既然总可以通过CounterStore.getCounterValues函数获取最新鲜的数据，SummaryStore似乎也就没有必要把计数器总和存储到某个变量里。事实上，可以看到SummaryStore并不像CounterStore一样用一个变量counterValues存储数据，SummaryStore不存储数据，而是每次对getSummary的调用，都实时读取CounterStore.getCounterValues，然后实时计算总和返回给调用者。</p><p>可见，虽然名为Store，但并不表示一个Store必须要存储什么东西，Store只是提供获取数据的方法，而Store提供的数据完全可以另一个Store计算得来。</p><p>SummaryStore在Dispatcher上注册的回调函数也和CounterStore很不一样，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SummaryStore.dispatchToken = AppDispatcher.register(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((action.type === ActionTypes.INCREMENT) ||</span><br><span class="line">      (action.type === ActionTypes.DECREMENT)) &#123;</span><br><span class="line">        AppDispatcher.waitFor([CounterStore.dispatchToken]);</span><br><span class="line">        SummaryStore.emitChange();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>SummaryStore同样也通过AppDispatcher.register函数注册了一个回调函数，用于接受派发的action对象。在回调函数中，也只关注了INCREMENT和DECREMENT类型的action对象，并通过emitChange通知监听者，注意在这里使用了waitFor函数，这个函数解决的是下面描述的问题。</p><p>既然一个action对象会被派发给所有回调函数，这就产生了一个问题，到底是按照什么顺序调用各个回调函数呢？</p><p>即使Flux按照register调用的顺序去调用各个回调函数，我们也完全无法把握各个Store哪个先装载从而调用register函数。所以，可以认为Dispatcher调用回调函数的顺序完全是无法预期的，不要假设它会按照我们期望的顺序逐个调用。</p><p>怎么解决这个问题呢？这就要靠Dispatcher的waitFor函数了。在SummaryStore的回调函数中，之前在CounterStore中注册回调函数时保存下来的dispatchToken终于派上用场了。</p><p>Dispatcher的waitFor可以接受一个数组作为参数，数组中的每个元素都是一个Dispatcher.register函数的返回结果，也就是所谓的dispatchToken。这个waitFor函数告诉Dispatcher，当前的处理必须要暂停，直到dispatchToken代表的那些已注册回调函数执行结束才能继续。</p><p>我们知道，JavaScript是单线程语言，不可能有线程之间的等待这回事，这个waitFor函数当然不是用多线程实现的，只是在调用waitFor的时候，把控制权交给Dispatcher，让Dispatcher检查一下dispatchToken代表的回调函数有没有被执行，如果已经执行，那就直接继续，如果还没有执行，那就调用dispatchToken代表的回调函数之后waitFor才返回。</p><p>回到我们上面的例子，即使SummaryStore比CounterStore提前接收到了action对象，在emitChange中调用waitFor，也就能够保证emitChange函数被调用的时候，CounterStore也已经处理过这个action对象。</p><p>这里要注意一个事实，Dispatcher的register函数，只提供了一个回调函数的功能，但却不能让调用者在register时选择只监听某些action，换句话说，每个register的调用者只能这样请求：“当有任何动作被派发时，请调用我。”但不能够这么请求：“当这种类型还有那种类型的动作被派发的时候，请调用我。”</p><p>当一个动作被派发的时候，Dispatcher就是简单地把所有注册的回调函数全都调用一遍，至于这个动作是不是对方关心的，Flux的Dispatcher不关心，要求每个回调函数去鉴别。</p><p>看起来，这似乎是一种浪费，但是这个设计让Flux的Dispatcher逻辑最简单化，Dispatcher的责任越简单，就越不会出现问题。毕竟，由回调函数全权决定如何处理action对象，也是非常合理的。</p><ul><li>4) View</li></ul><p>首先要说明，Flux框架下，View并不是说必须要使用React，View本身是一个独立的部分，可以用任何一种UI库来实现。</p><p>不过，话说回来，既然我们都使用上Flux了，除非项目有大量历史遗留代码，否则实在没有理由不用React来实现View。</p><p>存在于Flux框架中的React组件需要实现以下几个功能：</p><ul><li><p>创建时要读取Store上状态来初始化组件内部状态</p></li><li><p>当Store上状态发生变化时，组件要立刻同步更新内部状态保持一致</p></li><li><p>View如果要改变Store状态，必须且只能派发action</p></li></ul><p>最后让我们来看看例子中的View部分，为了方便管理，所有View文件都放在src/views目录里。</p><p>先看src/views/ControlPanel.js中的ControlPanel组件，其中render函数的实现和上一章很不一样，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;style&#125;&gt;</span><br><span class="line">      &lt;Counter caption=<span class="string">'First'</span> /&gt;</span><br><span class="line">      &lt;Counter caption=<span class="string">'Second'</span> /&gt;</span><br><span class="line">      &lt;Counter caption=<span class="string">'Third'</span> /&gt;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &lt;Summary /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>可以注意到，和前面章节中的ControlPanel不同，Counter组件实例只有caption属性，没有initValue属性。因为我们把计数值包括初始值全都放到CounterStore中去了，所以在创造Counter组件实例的时候就没必要指定initValue了。</p><p>接着看src/views/Counter.js中定义的Counter组件，构造函数中初始化this.state的方式有了变化，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.onChange = <span class="keyword">this</span>.onChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.onClickIncrementButton = <span class="keyword">this</span>.onClickIncrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.onClickDecrementButton = <span class="keyword">this</span>.onClickDecrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    count: CounterStore.getCounterValues()[props.cpation]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中，CounterStore.getCounterValues函数获得了所有计数器的当前值，然后把this.state初始化为对应caption字段的值，也就是说Counter组件的store来源不再是prop，而是Flux的Store。</p><p>Counter组件中的state应该成为Flux Store上状态的一个同步镜像，为了保持两者一致，除了在构造函数中的初始化之外，在之后当CounterStore上状态变化时，Counter组件也要对应变化，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  CounterStore.addChangeListener(<span class="keyword">this</span>.onChange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  CounterStore.removeChangeListener(<span class="keyword">this</span>.onChange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onChange() &#123;</span><br><span class="line">  <span class="keyword">const</span> newCount = CounterStore.getCounterValues()[<span class="keyword">this</span>.props.caption];</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: newCount &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码所示，在componentDidMount函数中通过CounterStore.addChangeListener函数监听了CounterStore的变化之后，只要CounterStore发生变化，Counter组件的onChange函数就会被调用。与componentDidMount函数中监听事件对应，在componentWillUnmount函数中删除了这个监听。</p><p>接下来，要看React组件如何派发action，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">onClickIncrementButton() &#123;</span><br><span class="line">  Actions.increment(<span class="keyword">this</span>.props.action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onClickDecrementButton() &#123;</span><br><span class="line">  Actions.decrement(<span class="keyword">this</span>.props.action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;caption&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onClickIncrementButton&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onClickDecrementButton&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;caption&#125; count: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，在Counter组件中有两处用到CounterStore的getCounterValues函数的地方，第一处在构造函数中初始化this.state的时候，第二处是在响应CounterStore状态变化的onChange函数中，同样一个Store的状态，为了转换为React组件的状态，有两次重复的调用，这看起来似乎不是很好。但是，React组件的状态就是这样，在构造函数中要对this.state初始化，要更新它就要调用this.setState函数。</p><p>有没有更简洁的办法？比如说只使用CounterStore.getCounterValues一次？可惜，只要我们想用组件的状态来驱动组件的渲染，就不可避免要有这两步。那么如果我们不利用组件的状态呢？</p><p>如果不使用组件的状态，那么我们就可以逃出这个必须在代码中使用Store两次的宿命，在接下来的章节里，我们会遇到这种“无状态”组件。</p><p>Summary组件，存在于src/views/Summary.js中，和Counter类似，在constructor中初始化组件状态，通过在componentDidMount中添加对SummaryStore的监听来同步状态，因为这个View不会有任何交互功能，所以没有派发出任何action。</p><h4 id="3-Flux的优势"><a href="#3-Flux的优势" class="headerlink" title="3. Flux的优势"></a>3. Flux的优势</h4><p>本章的例子和上一章我们只用React的实现效果一样，但是工作方式有了大变化。</p><p>回顾一下完全只用React实现的版本，应用的状态数据只存在于React组件之中，每个组件都要维护驱动自己渲染的状态数据，单个组件的状态还好维护，但是如果多个组件之间的状态有关联，但就麻烦了。比如Counter组件和Summary组件，Summary组件就需要维护所有Counter组件计数值的总和，Counter组件和Summary组件分别维护自己的状态，如何同步Summary和Counter状态就成了问题，React只提供了props方法让组件之间通信，组件之间关系稍微复杂一点，这种方式就显得非常笨拙。</p><p>Flux架构下，应用的状态被放在了Store中，React组件只是扮演View的作用，被动根据Store的状态来渲染。在上面的例子中，React组件依然有自己的状态，但是已经完全沦为Store组件的一个映射，而不是主动变化的数据。</p><p>在完全只用React实现的版本里，用户的交互操作，比如点击“<code>+</code>”按钮，引发的事件处理函数直接通过this.setState改变组件的状态。在Flux的实现版本里，用户的操作引发的是一个“动作”的派发，这个派发的动作会发送给所有的Store对象，引起Store对象的状态改变，而不是直接引发组件的状态改变。因为组件的状态是Store状态的映射，所以改变了Store对象也就触发了React组件对象的状态改变，从而引发了界面的重新渲染。</p><p>Flux带来了哪些好处呢？最重要的就是“单向数据流”的管理方式。</p><p>在Flux的理念里，如果要改变界面，必须改变Store中的状态，如果要改变Store中的状态，就必须派发一个action对象，这就是规矩。在这个规矩之下，想要追溯一个应用的逻辑就变得非常容易。</p><p>我们已经讨论过MVC框架的缺点，MVC最大的问题就是无法禁绝View与Model之间的直接对话，对应于MVC中的View就是Flux中的View，对应于MVC中Model的就是Flux中的Store。在Flux中，Store只有get方法，没有set方法，根本不可能直接去修改其内部状态，View只能通过get方法获取Store的状态，无法直接去修改状态，如果View想要修改Store状态的话，只有派发一个action给Dispatcher。</p><p>这看起来是一个“限制”，但却是一个很好地“限制”，禁绝了数据流混乱的可能。</p><p>简单来说，Flux的体系下，驱动界面改变始于一个动作的派发，别无他法。</p><h4 id="4-Flux的不足"><a href="#4-Flux的不足" class="headerlink" title="4. Flux的不足"></a>4. Flux的不足</h4><p>任何工具不可能只有优点没有缺点，接下来让我们看看Flux的不足之处，只有了解了Flux的不足之处，才能理解为什么会出现Flux的改进框架Redux。</p><ul><li>1) Store之间的依赖关系</li></ul><p>在Flux的体系中，如果两个Store之间有逻辑依赖关系，就必须用上Dispatcher的waitFor函数。在上面的例子中我们已经使用过waitFor函数，SummaryStore对action的处理，依赖于CounterStore已经处理过了。所以，必须要通过waitFor函数告诉Dispatcher，先让CounterStore处理这些action对象，只有CounterStore搞定之后SummaryStore才继续。</p><p>那么，SummaryStore如何标识CounterStore呢？靠的是register函数的返回值dispatchToken，而dispatchToken的产生，当然是CounterStore控制的，换句话说，要这样设计：</p><ul><li><p>CounterStore必须要把注册回调函数时产生的dispatchToken公之于众</p></li><li><p>SummaryStore必须要在代码里建立对CounterStore的dispatchToken的依赖</p></li></ul><p>虽然Flux这个设计的确解决了Store之间的依赖关系，但是，这样明显的模块之间的一来，看着还是让人感觉不太舒服，毕竟最好的依赖管理是根本不让依赖产生。</p><ul><li>2) 难以进行服务器端渲染</li></ul><p>关于服务器端渲染，我们在后面会详细介绍，在这里，我们只需要知道，如果要在服务器端渲染，输出不是一个DOM树，而是一个字符串，准确来说就是一个全是HTML的字符串。</p><p>在Flux的体系中，有一个全局的Dispatcher，然后每一个Store都是一个全局唯一的对象，这对于浏览器端应用完全没有问题，但是如果放在服务器端，就会有大问题。</p><p>和一个浏览器网页只服务于一个用户不同，在服务器端要同时接受很多用户的请求，如果每个Store都是全局唯一对象，那不同请求的状态肯定就乱套了。</p><p>并不是说Flux不能做服务器端渲染，只是说让Flux做服务器端渲染很困难，实际上，Facebook也说得很清楚，Flux不是设计用作服务器端渲染的，他们也从来没有尝试过把Flux应用于服务器端。</p><ul><li>3) Store混杂了逻辑和状态</li></ul><p>Store封装了数据和处理数据的逻辑，用面向对象的思维来看，这是一件好事，毕竟对象就是这样定义的。但是，当我们需要动态替换一个Store的逻辑时，只能把这个Store整体替换掉，那也就无法保持Store中存储的状态。</p><p>在开发模式下，开发人员要不停地对代码进行修改，如果Store在某个状态下引发了bug，如果能在不毁掉状态的情况下替换Store的逻辑，那就最好了，开发人员就可以不断地改进逻辑来验证这个状态下bug是否被修复了。</p><p>还有一些应用，在生产环节下就要根据用户属性来动态加载不同的模块，而且动态加载模块还希望不要网页重新加载，这时候也希望能够在不修改应用状态的前提下重新加载应用逻辑，这就是热加载，后面章节会介绍如何实现热加载。</p><hr><h3 id="二、Redux"><a href="#二、Redux" class="headerlink" title="二、Redux"></a>二、Redux</h3><p>我们把Flux看作一个框架理念的话，Redux是Flux的一种实现，除了Redux之外，还有很多实现Flux的框架，比如Reflux、Fluxible等，毫无疑问Redux获得的关注最多，这不是偶然的，因为Redux有很多其他框架无法比拟的优势。</p><h4 id="1-Redux的基本原则"><a href="#1-Redux的基本原则" class="headerlink" title="1. Redux的基本原则"></a>1. Redux的基本原则</h4><p>2013年问世的Flux饱受争议，而2015年Dan Abramov提出了在Flux基础上的改进框架Redux，则是一鸣惊人，在所有Flux的变体中算是最受关注的框架，没有之一。</p><p>Flux的基本原则是“单向数据流”，Redux在此基础上强调三个原则：</p><ul><li><p>唯一数据源（Single Source of Truth）</p></li><li><p>保持状态只读（State is read-only）</p></li><li><p>数据改变只能通过纯函数完成（Changes are made with pure functions）</p></li></ul><p>让我们逐一解释这三条基本原则</p><ul><li>1) 唯一数据源</li></ul><p>唯一数据源指的是应用的状态数据应该只存储在唯一的一个Store上。</p><p>我们已经知道，在Flux中，应用可以拥有多个Store，往往根据功能把应用的状态数据划分给若干个Store分别存储管理。比如，在上面的ControlPanel中，我们创造了CounterStore和SummaryStore。</p><p>如果状态数据分散在多个Store中，容易造成数据冗余，这样数据一致性方面就会出问题。虽然利用Dispatcher的waitFor方法可以保证多个Store之间的更新顺序，但是这又产生了不同Store之间的显示依赖关系，这种依赖关系的存在增加了应用的复杂度，容易带来新的问题。</p><p>Redux对这个问题的解决方法就是，整个应用只保持一个Store，所有组件的数据源就是这个Store上的状态。</p><p>这个唯一Store上的状态，是一个树形的结构，每个组件往往只是用树形对象上一部分的数据，而如何设计Store上状态的结构，就是Redux应用的核心问题，我们接下来会描述细节。</p><ul><li>2) 保持状态只读</li></ul><p>保持状态只读，就是说不能去直接修改状态，要修改Store的状态，必须要通过派发一个action对象完成，这一点，和Flux的要求并没有什么区别。</p><p>如果只看这个原则的字面意思，可能会让我们有些费解，还记得那个公式吗？<code>UI=render(state)</code>，我们已经能够说过驱动用户界面更改的是状态，如果状态都是只读的不能修改，怎么可能引起用户界面的变化呢？</p><p>当然，要驱动用户界面渲染，就要改变应用的状态，但是改变状态的方法不是去修改状态的值，而是创建一个新的状态对象返回给Redux，由Redux完成新的状态的组装。</p><p>这就引出了下面的第三条原则。</p><ul><li>3) 数据改变只能通过纯函数完成</li></ul><p>这里所说的纯函数就是Reducer，Redux这个名字的前三个字母Red代表的就是Reducer。按照创作者Dan Abramov的说法，Redux名字的含义是Reducer+Flux。</p><p>Reducer不是一个Redux特定的术语，而是一个计算机科学中的通用概念，很多语言和框架都有对Reducer函数的支持。以JavaScript为例，数组类型就有reduce函数，接受的参数就是一个reducer，reduce做的事情就是把数组所有元素依次做“规约”，对每个元素都调用一次reducer，通过reducer函数完成规约所有元素的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">accumulation, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulation + item;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>上面的代码中，reducer函数接受两个参数，第一个参数是上一次规约的结果，第二个参数是这一次规约的元素，函数体是返回两者之和，所以这个规约的结果就是所有元素之和。</p><p>在Redux中，每个reducer的函数签名如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reducer(state, action)</span><br></pre></td></tr></table></figure><p>第一个参数state是当前的状态，第二个参数是接收到的action对象，而reducer函数要做的事情，就是根据state和action的值产生一个新的对象返回，注意reducer必须是纯函数，也就是说函数的返回结果必须完全由参数state和action决定，而且不产生任何副作用，也不能修改参数state和action对象。</p><p>让我们回顾一下Flux中的Store是如何处理函数的，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CounterStore.dispatchToken = AppDispatcher.register(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === ActionTypes.INCREMENT) &#123;</span><br><span class="line">    counterValues[action.counterCaption]++;</span><br><span class="line">    CounterStore.emitChange();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === ActionTypes.DECREMENT) &#123;</span><br><span class="line">    counterValues[action.counterCaption]--;</span><br><span class="line">    CounterStore.emitChange();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Flux更新状态的函数只有一个参数action，因为状态是由Store直接管理的，所以处理函数中会看到代码直接更新state；在Redux中，一个实现同样功能的reducer代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) =&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;counterCaption&#125; = action;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.INCREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.DECREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到reducer函数不光接受action为参数，还接受state为参数。也就是说，Redux的reducer只负责计算状态，却并不负责存储状态。</p><p>我们在后面的实例中会详细解释这个reducer的构造。</p><p>读到这里，读者可能会有一个疑问，从Redux的基本原则来看，Redux并没有赋予我们强大的功能，反而是给开发者增加了很多限制，开发者丧失了想怎么写就怎么写的灵活度。</p><blockquote><p>“如果你愿意限制做事方式的灵活度，你几乎总会发现可以做得更好。” —— John Carmark</p></blockquote><p>作为制作出《Doom》《Quake》这样游戏的杰出开发者，John Carmark这句话道出了软件开发中的一个真谛。</p><p>在计算机编程的世界里，完成任何一件任务，可能都有一百种以上的方法，但是无节制的灵活度反而让软件难以维护，增加限制是提高软件质量的法门。</p><h4 id="2-Redux实例"><a href="#2-Redux实例" class="headerlink" title="2. Redux实例"></a>2. Redux实例</h4><p>前面我们用Flux实现了一个ControlPanel的应用，接下来让我们用Redux来重新实现一遍同样的功能，通过对比就能看出二者的差异。</p><p>React和Redux事实上是两个独立的产品，一个应用可以使用React而不是用Redux，也可以使用Redux而不是用React，但是，如果两者结合使用，没有理由不使用一个名叫react-redux的库，这个库能够大大简化代码的书写。</p><p>不过，如果一开始就使用react-redux，可能对其设计思路完全一头雾水，所以，我们的实例先不采用react-redux库，从最简单的Redux使用方法开始，初步改进，循序渐进地过渡到使用react-redux。</p><p>最基本的Redux实现，存在与本书对应Github的chapter-03/redux_basic目录中，在这里我们只关注使用Redux实现和使用Flux不同的地方。</p><p>首先看关于action对象的定义，和Flux一样，Redux应用习惯上把action类型和action构造函数分成两个文件定义，其中定义action类型的src/ActionTypes.js和Flux版本没有任何差别，但是src/Actions.js文件就不大一样了，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ActionTypes <span class="keyword">from</span> <span class="string">'./ActionTypes.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function">(<span class="params">counterCaption</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ActionTypes.INCREMENT,</span><br><span class="line">    counterCaption: counterCaption</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function">(<span class="params">counterCaption</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ActionTypes.DECREMENT,</span><br><span class="line">    counterCaption: counterCaption</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和Flux的src/Actions.js文件对比就会发现，Redux中每个action构造函数都返回一个action对象，而Flux版本中action构造函数并不返回什么，而是把构造的动作函数立刻通过调用Dispatcher的dispatch函数派发出去。</p><p>这是一个习惯上的差别，接下来我们会发现，在Redux中，很多函数都是这样不做什么产生副作用的动作，而是返回一个对象，把如何处理这个对象的工作交给调用者。</p><p>在Flux中我们要用到一个Dispatcher对象，但是在Redux中，就没有Dispatcher这个对象了，Dispatcher存在的作用就是把一个action对象分发给了多个注册了的Store，既然Redux让全局只有一个Store，那么再创造一个Dispatcher也的确意义不大。所以，Redux中“分发”这个功能，从一个Dispatcher对象简化为Store对象上的一个函数dispatch，毕竟只有一个Store，要分发也是分发给这个Store，就调用Store上一个表示分发的函数，合情合理。</p><p>我们创造一个src/Store.js文件，这个文件输出全局唯一的那个Store，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./Reducer.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initValues = &#123;</span><br><span class="line">  <span class="string">'First'</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">'Second'</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">'Third'</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, initValues);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p>在这里，我们接触到了Redux库提供的createStore函数，这个函数第一个参数代表更新状态的reducer，第二个参数是状态的初始值，第三个参数可选，代表Store Enhancer，在这个例子中用不上，后面章节会详细介绍。</p><p>确定Store状态，是设计好Redux应用的关键。从Store状态的初始值看得出来，我们的状态是这样一个格式：状态上每个字段名代表Counter组件的名（caption），字段的值就是这个组件当前的计数值，根据这些状态字段，足够支撑三个Counter组件。</p><p>那么，为什么没有状态来支持Summary组件呢？因为Summary组件的状态，完全可以通过把Counter状态数值加在一起得到，没有必要制造冗余数据存储，这也符合Redux“唯一数据源”的基本原则。记住：Redux的Store状态设计的一个主要原则：避免冗余数据。</p><p>接下来看src/Reducer.js中定义的reducer函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ActionTypes <span class="keyword">from</span> <span class="string">'./ActionTypes.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;counterCaption&#125; = action;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.INCREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.DECREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和Flux应用中每个Store注册的回调函数一样，reducer函数中往往包含以action.type为判断条件的if-else或者switch语句。</p><p>和Flux不同的是，多了一个参数state。在Flux的回调函数中，没有这个参数，因为state是由Store管理的，而不是由Flux管理的。Redux中把存储state的工作抽取出来交给Redux框架本身，让reducer只用关心如何更新state，而不要管state怎么存。</p><p>代码中使用了三个句号组成的扩展操作符，表示把state中所有字段扩展开，而后面对counterCaption值对应的字段会赋上新值，像下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;...state, [counterCaption]: state[counterCaption] + <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>逻辑上等同于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newState = <span class="built_in">Object</span>.assign(&#123;&#125;, state);</span><br><span class="line">newState[counterCaption]++;</span><br><span class="line"><span class="keyword">return</span> newState;</span><br></pre></td></tr></table></figure><p>和Flux很不一样的是，在reducer中，绝对不能去修改参数中的state，如果我们直接修改state并返回false，代码如下，注意这不是正确写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;counterCaption&#125; = action;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.INCREMENT:</span><br><span class="line">      state[counterCaption]++;</span><br><span class="line">    <span class="keyword">case</span> ActionTypes.DECREMENT:</span><br><span class="line">      state[counterCaption]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这样写，似乎更简单直接，但实际上犯了大错，因为reducer应该是一个纯函数，纯函数不应该产生任何副作用。</p><p>接下来，我们看View部分，View部分代码都在src/views目录下。看看src/views/ControlPanel.js，作为这个应用最顶层的组件ControlPanel，内容和Flux例子中没有任何区别。然后是Counter组件，存在于src/views/Counter.js中，这就和Flux不大一样了，首先是构造函数中初始化this.state的来源不同，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../Store.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">this</span>.getOwnState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getOwnState() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: store.getState()[<span class="keyword">this</span>.props.caption]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和Flux例子一样，在这个视图文件中我们要引入Store，只不过这次我们引入的Store不叫CounterStore，而是一个唯一的Redux Store，所以名字就叫store，通过store.getState()能够获得store上存储的所有状态，不过每个组件往往只需要使用返回状态的一部分数据。为了避免重复代码，我们把从store获得状态的逻辑放在getOwnState函数中，这样任何关联Store状态的地方都可以重用这个函数。</p><p>和Flux实现的例子一样，仅仅在构造函数时根据store来初始化this.state还不够，要保持store上状态和this.state的同步，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onChange() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="keyword">this</span>.getOwnState());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  store.subscribe(<span class="keyword">this</span>.onChange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  store.unsubscribe(<span class="keyword">this</span>.onChange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在componentDidMount函数中，我们通过Store的subscribe监听其变化，只要Store状态发生变化，就会调用这个组件的onChange方法；在componentWillUnmount函数中，我们把这个监听注销掉，这个清理动作和componentDidMount中的动作对应。</p><p>其实，这个增加监听函数的语句也可以写在构造函数里，但是为了让mount和unmount的对应看起来更清晰，在所有的例子中我们都把加载监听的函数放在componentDidMount中。</p><p>除了从store同步状态，视图中可能会想要改变store中的状态，和Flux一样，改变store中状态唯一的方法就是派发action，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onIncrement() &#123;</span><br><span class="line">  store.dispatch(Actions.increment(<span class="keyword">this</span>.props.caption));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onDecrement() &#123;</span><br><span class="line">  store.dispatch(Actions.decrement(<span class="keyword">this</span>.props.caption));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了onIncrement和onDecrement方法，在render函数中的JSX中需要使用这两种函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">this</span>.state.value;</span><br><span class="line">  <span class="keyword">const</span> &#123;caption&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onIncrement&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onDecrement&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;caption&#125; count: &#123;value&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在render函数中，对于点击“<code>+</code>”按钮和“<code>-</code>”按钮的onClick事件，被分别挂上了onIncrement函数和onDecrement函数，所做的事情就是派发对应的action对象出去。注意和Flux例子的区别，在Redux中，action构造函数只负责创建对象，要派发action就需要调用store.dispatch函数。</p><p>组件的render函数所显示的动态内容，要么来自于props，要么来自于自身状态。</p><p>然后再来看看src/views/Summary.js中的Summary组件，其中getOwnState函数的实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getOwnState() &#123;</span><br><span class="line">  <span class="keyword">const</span> state = store.getState();</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> state) &#123;</span><br><span class="line">    sum += state[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">sum</span>: sum &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Summary组件的套路和Counter组件差不多，唯一值得一提的就是getOwnState函数的实现。因为Store的状态中只记录了各个Counter组件的计数值，所以需要在getOwnState状态中自己计算出所有计数值总和出来。</p><h4 id="3-容器组件和傻瓜组件"><a href="#3-容器组件和傻瓜组件" class="headerlink" title="3. 容器组件和傻瓜组件"></a>3. 容器组件和傻瓜组件</h4><p>分析一下上面的Redux例子中的Counter组件和Summary组件部分，可以发现一个规律，在Redux框架下，一个React组件基本上就是要完成以下两个功能：</p><ul><li><p>和Redux Store打交道，读取Store的状态，用于初始化组件的状态，同时还要监听Store的状态改变；当Store状态发生变化时，需要更新组件状态，从而驱动组件重新渲染；当需要更新Store状态时，就要派发action对象</p></li><li><p>根据当前props和state，渲染出用户界面</p></li></ul><p>还记得那句话吗？让一个组件只专注做一件事，如果发现一个组件做的事情太多了，就可以把这个组件拆分成多个组件，让每个组件依然只专注于一件事。</p><p>如果React组件都是要包办上面说的两个任务，似乎做的事情也的确稍微多了一点。我们可以考虑拆分，拆分为两个组件，分别承担一个任务，然后把两个组件嵌套起来，完成原本一个组件完成的所有任务。</p><p>这样的关系里，两个组件是父子组件的关系。业界对于这样的拆分有多种叫法，承担第一个任务的组件，也就是负责和Redux Store打交道的组件，处于外层，所以被称为容器组件（Container Component）；对于承担第二个任务的组件，也就是只专心负责渲染界面的组件，处于内层，叫做展示组件（Presentational Component）。</p><p>外层的容器组件又叫聪明组件（Smart Component），内层的展示组件又叫傻瓜组件（Dumb Component），所谓“聪明”还是“傻瓜”只是相对而言，并没有褒贬的含义。</p><p><img src="/images/react-3/4.png" alt="容器组件和傻瓜组件的分工"></p><p>傻瓜组件就是一个纯函数，根据props产生结果。说是“傻瓜”，这种纯函数实现反而体现了计算机编程中的大智慧，大智若愚。</p><p>而容器组件，只是做的事情涉及一些状态转换，虽然名字里有“聪明”，其实做的事情都有套路，我们很容易就能抽取出共同之处，复用代码完成任务，并不需要开发者极其聪明才能掌握。</p><p>在我们把一个组件拆分为容器组件和傻瓜组件的时候，不只是功能分离，还有一个比较大的变化，那就是傻瓜组件不再需要有状态了。</p><p>实际上，让傻瓜组件无状态，是我们拆分的主要目的之一，傻瓜组件只需要根据props来渲染结果，不需要state。</p><p>那么，状态哪里去了呢？全都交给容器组件去打点，这是它的责任。容器组件如何把状态传递给傻瓜组件呢？通过props。</p><p>值得一提的是，拆分容器组件和傻瓜组件，是设计React组件的一种模式，和Redux没有直接关系。在Flux或者任何一种其他框架下都可以使用这种模式，只不过为了引出后面的react-redux，我们才在这里开始介绍罢了。</p><p>我们还是通过例子来感受一下容器组件和傻瓜组件如何协同工作，对应的代码在chapter-03/redux_smart_dumb目录下，是前面chapter-03/redux_basic的改进，只有视图部分代码有改变。</p><p>在视图代码src/views/Counter.js中定义了两个组件，一个是Counter，这是傻瓜组件，另一个是CounterContainer，这是容器组件。</p><p>傻瓜组件Counter代码的逻辑前所未有的简单，只有一个render函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;caption, onIncrement, onDecrement, value&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button style=&#123;buttonStyle&#125; onClick=&#123;onIncrement&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;button style=&#123;buttonStyle&#125; onClick=&#123;onDecrement&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;span&gt;&#123;caption&#125; count: &#123;value&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Counter组件完全没有state，只有一个render方法，所有的数据都来自于props，这种组件叫做“无状态”组件。</p><p>而CounterContainer组件承担了所有的和Store关联的工作，它的render函数所做的就是渲染傻瓜组件Counter而已，只负责传递必要的prop，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> <span class="attr">caption</span>=<span class="string">&#123;this.props.caption&#125;</span> </span></span></span><br><span class="line"><span class="xml">            onIncrement=&#123;this.onIncrement&#125;</span></span><br><span class="line"><span class="xml">            onDecrement=&#123;this.onDecrement&#125;</span></span><br><span class="line"><span class="xml">            value=&#123;this.state.value&#125; /&gt;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default CounterContainer;</span></span><br></pre></td></tr></table></figure><p>可以看到，这个文件export导出的不再是Counter组件，而是CounterContainer组件，也就是对于使用这个视图的模块来说，根本不会感受到傻瓜组件的存在，从外部看到的就只是容器组件。</p><p>对于无状态组件，其实我们可以进一步缩减代码，React支持只用一个函数代表的无状态组件，所以，Counter组件可以进一步简化，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;caption, onIncrement, onDecrement, value&#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;onIncrement&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;onDecrement&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;caption&#125; count: &#123;value&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为没有状态，不需要用对象表示，所以连类都不要了，对于一个只有render方法的组件，缩略为一个函数足矣。</p><p>注意，改为这种写法，获取props就不能用this.props，而是通过函数的参数props获得，无状态组件的props参数和有状态组件的this.props内容和结构完全一样。</p><p>还有一种惯常写法，就是把解构赋值直接放在参数部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;caption, onIncrement, onDecrement, value&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数体中可以直接使用caption、onIncrement等变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看src/views/Summary.js中，内容也被分解为了傻瓜组件Summary和SummaryContainer，方式和Counter差不多，不再赘述。</p><p>重新审阅代码，我们可以看到CounterContainer和SummaryContainer代码有很多相同之处，写两份实在是重复，既然都是套路，完全可以抽取出来，后面的章节会讲如何应用react-redux来减少重复代码。</p><h4 id="4-组件Context"><a href="#4-组件Context" class="headerlink" title="4. 组件Context"></a>4. 组件Context</h4><p>在介绍react-redux之前，我们重新看一看现在的Counter和Summary组件文件，发现它们都直接导入Redux Store。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./Store.js'</span>;</span><br></pre></td></tr></table></figure><p>虽然Redux应用全局就一个Store，这样的直接导入依然有问题。</p><p>在实际工作中，一个应用的规模会很大，不会所有的组件都放在一个代码库里，有时候还要通过npm方式引入第三方的组件。想想看，当开发一个独立的组件的时候，都不知道自己这个组件会存在于哪个应用中，当然不可能预先知道定义唯一Redux Store的文件位置了，所以，在组件中直接导入Store是非常不利于组件复用的。</p><p>一个应用中，最好只有一个地方需要直接导入Store，这个位置当然应该是在调用最顶层React组件的位置。在我们的ControlPanel例子中，就是应用的入口文件src/index.js中，其余组件应该避免直接导入Store。</p><p>不让组件直接导入Store，那就只能让组件的上层组件把Store传递下来了。首先想到的当然是用props，毕竟，React组件就是用props来传递父子组件之间的数据的。不过，这种方法有一个很大的缺陷，就是从上到下，所有的组件都要帮助传递这个props。</p><p>设想在一个嵌套多层的组件结构中，只有最里层的组件才需要使用Store，但是为了把Store从外层传递到最里层，就要求中间所有的组件都需要增加对这个store prop的支持，即使根本不使用它，这无疑很麻烦。</p><p>还是来看ControlPanel这个例子，最顶层的组件ControlPanel根本就不使用Store，如果仅仅为了让它传递一个prop给子组件Counter和Summary就要求它支持state prop，显然非常不合理。所以，用prop传递store不是一个好方法。</p><p>React提供了一个叫Context的功能，能够完美地解决这个问题。</p><p><img src="/images/react-3/5.png" alt="React的Context"></p><p>所谓Context，就是“上下文环境”，让一个树状组件上所有组件都能访问一个共同的对象，为了完成这个任务，需要上级组件和下级组件配合。</p><p>首先，上级组件要宣称自己支持context，并且提供一个函数来返回代表Context的对象。</p><p>然后，这个上级组件之下的所有下级组件，只要宣称自己需要这个Context，就可以通过this.context访问到这个共同的环境对象。</p><p>我们尝试给ControlPanel程序加上context功能来优化，相关代码在chapter-3/redux_with_context目录中，这个应用是对前面redux_smart_dumb的改进。</p><p>因为Redux应用中只有一个Store，因此所有组件如果要使用Store的话，只能访问这唯一的Store。很自然，希望顶层的组件来扮演这个Context提供者的角色，只要顶层组件提供包含store的context，那就覆盖了整个应用的所有组件，简单而且够用。</p><p>不过，每个应用的顶层组件不同，在我们的ControlPanel例子里顶层组件是ControlPanel，在另一个应用里会有另一个组件。而且，ControlPanel有它自己的职责，我们没有理由把它复杂化，没必要非要让它扮演context提供者的功能。</p><p>我们来创建一个特殊的React组件，它将是一个通用的context提供者，可以应用在任何一个应用中，我们把这个组件叫做Provider。在src/Provider.js中，首先定义一个名为Provider的React组件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;PropTypes, Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      store: <span class="keyword">this</span>.props.store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Provider也是一个React组件，不过它的render函数就是简单地把子组件渲染出来，在渲染上，Provider不做任何附加的事情。</p><p>每个React组件的props中都可以包含一个特殊属性children，代表的是子组件，比如这样的代码，在Provider的render函数中this.props.children就是两个Provider标签之间的<code>&lt;ControlPanel /&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider&gt;</span><br><span class="line">  &lt;ControlPanel /&gt;</span><br><span class="line">&lt;<span class="regexp">/Provider&gt;</span></span><br></pre></td></tr></table></figure><p>除了把渲染工作完全交给子组件，Provider还要提供一个函数getChildContext，这个函数返回的就是代表Context的对象。我们的Context中只有一个字段store，而且我们也希望Provider足够通用，所以并不在这个文件中导入store，而是要求Provider的使用者通过prop传递进来store。</p><p>为了让Provider能够被React认可为一个Context的提供者，还需要指定Provider的childContextTypes属性，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Provider.childContextTypes = &#123;</span><br><span class="line">  store: ProTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Provider还需要定义类的childContextTypes，必须和getChildContext对应，只有这两者都齐备，Provider的子组件才有可能访问到context。</p><p>有了Provider，我们就可以改进一下应用的入口src/index.js文件了，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./Store.js'</span>;</span><br><span class="line"><span class="keyword">import</span> Provider <span class="keyword">from</span> <span class="string">'./Provider.js'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;ControlPanel /&gt;</span><br><span class="line">  &lt;<span class="regexp">/provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>在前面所有的例子中，React.render的第一个参数就是顶层组件ControlPanel。现在，这个ControlPanel作为子组件被Provider包住了，Provider成为了顶层组件。当然，如同我们上面看到的，Provider只是把渲染工作完全交给子组件，它扮演的角色只是提供Context，包住了最顶层的ControlPanel，也就让context覆盖了整个应用中的所有组件。</p><p>至此，我们完成了提供Context的工作，接下来我们看底层组件如何使用Context。</p><p>我们可以顺便看一眼src/views/ControlPanel.js，这个文件和前面的例子没有任何变化，它做的工作只是搭建应用框架，把子组件Counter和Summary渲染出来，和Store一点关系都没有，这个文件既没有导入Store，也没有支持关于store的props。</p><p>在src/views/Counter.js中，我们可以看到对context的使用。作为傻瓜组件的Counter是一个无状态组件，它也不需要和Store牵扯什么关系，和之前的代码一模一样，有变化的是CounterContainer部分。</p><p>为了让CounterContainer能够访问context，必须给CounterContainer类的contextTypes赋值和Provider.childContextTypes一样的值，两者必须一致，不然就无法访问到context，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CounterContainer.contextTypes = &#123;</span><br><span class="line">  store: PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CounterContainer中，所有对store的访问，都是通过this.context.store完成的，因为this.context就是Provider提供的context对象，所以getOwnState函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getOwnState() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: <span class="keyword">this</span>.context.store.getState()[<span class="keyword">this</span>.props.caption]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一点，因为我们自己定义了构造函数，所以要用上第二个参数context，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props, context);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用super的时候，一定要带上context参数，这样才能让React组件初始化实例中的context，不然组件的其它部分就无法使用this.context。</p><p>要求constructor显式声明props和context两个参数然后又传递给super看起来很麻烦，我们的代码似乎只是一个参数的搬运工，而且将来可能有新的参数出现那样又要修改这部分代码，我们可以用下面的方法一劳永逸地解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">  <span class="keyword">super</span>(...arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不能直接使用arguments，因为在JavaScript中arguments表现得像是一个数组而不是分开的一个个参数，但是我们通过扩展标识符就能把arguments彻底变成传递给super的参数。</p><p>在结束之前，让我们重新审视一下Context这个功能，Context这个功能相当于提供了一个全局可以访问的对象，但是全局对象或者说全局变量肯定是我们应该避免的用法，只要有一个地方改变了全局对象的值，应用中其它部分就会受影响，那样整个程序的运行结果就完全不可预测了。</p><p>所以，单纯来看React的这个Context功能的话，必须强调这个功能要谨慎使用，只有对那些每个组件都可能使用，但是中间组件又可能不使用的对象才有必要使用Context，千万不要滥用。</p><p>对于Redux，因为Redux的Store封装得很好，没有提供直接修改状态的功能，就是说一个组件虽然能够访问全局唯一的Store，却不可能直接修改Store中的状态，这样部分克服了作为全局对象的缺点。而且，一个应用只有一个Store，这个Store是Context里唯一需要的东西，并不算滥用，所以，使用Context来传递Store是一个不错的选择。</p><h4 id="5-React-Redux"><a href="#5-React-Redux" class="headerlink" title="5. React-Redux"></a>5. React-Redux</h4><p>在上面两节中，我们了解了改进React应用的两个方法，第一是把一个组件拆分为容器组件和傻瓜组件，第二是使用React的Context来提供一个所有组件都可以直接访问的Context，也不难发现，这两种方法都有套路，完全可以把套路部分抽取出来复用，这样每个组件的开发只需要关注于不同的部分就可以了。</p><p>实际上，已经有这样的一个库来完成这些工作了，这个库就是react-redux。</p><p>在本书的chapter-03/react-redux目录下，可以看到利用react-redux实现的ControlPanel版本，因为使用了react-redux，所以它是所有实现方式中代码最精简的一个例子。</p><p>我们只看不同的部分，在src/index.js中，代码几乎和react_with_context一模一样，唯一的区别就是我们不再使用自己实现的Provider，而是从react-redux库导入Provider，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br></pre></td></tr></table></figure><p>有了react-redux，视图文件src/views/Counter.js和src/Summary.js中的代码可以变得相当简洁。</p><p>在前面的redux_smart_dumb和redux_with_context例子中，我们实际上分别实现了react-redux的两个最主要的功能：</p><ul><li><p>connect：连接容器组件和傻瓜组件</p></li><li><p>Provider：提供包含store的context</p></li></ul><p>现在我们直接使用react-redux提供的这两个功能了，让我们分别来详细介绍。</p><ul><li>1) connect</li></ul><p>以Counter组件为例，和redux_with_context中的代码不同，react-redux的例子中没有定义CounterContainer这样命名的容器组件，而是直接导出了这样一个语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Counter);</span><br></pre></td></tr></table></figure><p>第一眼看去，会让人觉得这不是正常的JavaScript语法。其实，connect是react-redux提供的一个方法，这个方法接收两个参数mapStateToProps和mapDispatchToProps，执行结果依然是一个函数，所以才可以在后面又加一个圆括号，把connect函数执行的结果立刻执行，这一次参数是Counter这个傻瓜组件。</p><p>这里有两次函数执行，第一次是connect函数的执行，第二次是把connect函数返回的函数再次执行，最后产生的就是容器组件，功能相当于redux_smart_dumb中的CounterContainer。</p><p>当然，我们也可以把connect的结果赋值给一个变量CounterContainer，然后再export这个CounterContainer，只是connect已经大大简化了代码，习惯上可以直接导出函数执行结果，也不用纠结如何命名这个变量。</p><p>这个connect函数具体做了什么工作呢？</p><p>作为容器组件，要做的工作无外乎两件事：</p><ul><li><p>把Store上的状态转化为内层傻瓜组件的props</p></li><li><p>把内层傻瓜组件中的用户动作转化为派送给store的动作</p></li></ul><p>这两个工作一个是内层傻瓜对象的输入，一个是内层傻瓜对象的输出。</p><p>这两个工作的套路也很明显，把Store上的状态转化为内层组件的props，其实就是一个映射关系，去掉框架，最后就是一个mapStateToProps函数该做的事情。这个函数命名是业界习惯，因为它只是一个模块内的函数，所以实际上叫什么函数都行，如果觉得mapStateToProps这个函数名太长，也可以叫mapState，也是业界惯常的做法。</p><p>Counter组件对应的mapStateToProps函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state, ownProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: state[ownProps.caption]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把内层傻瓜组件中用户动作转化为派送给Store的动作，也就是把内层傻瓜组件暴露出来的函数类型的prop关联上dispatch函数的调用，每个prop代表的回调函数的主要区别就是dispatch函数的参数不同，这就是mapDispatchToProps函数做的事情，和mapStateToProps一样，这么长的函数名只是习惯问题，mapDispatchToProps也可以叫作mapDispatch。</p><p>Counter组件对应的mapDispathToProps函数代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch, ownProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onIncrement: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(Actions.increment(ownProps.caption));</span><br><span class="line">    &#125;,</span><br><span class="line">    onDecrement: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(Actions.decrement(ownProps.caption));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapStateToProps和mapDispatchToProps都可以包含第二个参数，代表ownProps，也就是直接传递给外层容器组件的props，在ControlPanel的例子中没有用到，我们在后续章节中会有详细介绍。</p><ul><li>2) Provider</li></ul><p>我们在redux_with_context中已经完整实现了一个Provider，react-redux和我们例子中的Provider几乎一样，但是更加严谨，比如我们只要求store属性是一个object，而react-redux要求store不光是一个object，而且是必须包含三个函数的object，这三个函数分别是：</p><ul><li><p>subscribe</p></li><li><p>dispatch</p></li><li><p>getState</p></li></ul><p>拥有上述三个函数的对象，才能称之为一个Redux的store。</p><p>另外，react-redux定义了Provider的componentWillReceiveProps函数，在React组件的生命周期中，componentWillReceiveProps函数在每次重新渲染时都会调用到，react-redux在componentWillReceiveProps函数中会检查这一次渲染时代表store的prop和上一次的是否一样。如果不一样，就会给出警告，这样做是为了避免多次渲染用了不同的Redux Store。每个Redux应用只能有一个Redux Store，在整个Redux的生命周期中都应该保持Store的唯一性。</p><hr><h3 id="三、本章小结"><a href="#三、本章小结" class="headerlink" title="三、本章小结"></a>三、本章小结</h3><p>在这一章中，我们首先从Redux的鼻祖Flux框架出发，通过创造一个ControlPanel的例子，了解了Flux“单向数据流”的原则。如果只由React来管理数据流，就很难管理拥有很多组件的大型应用，传统的MVC框架也有其缺陷，很容易写乱套，所以Flux是应用架构的一个巨大改进，但是Flux也有其缺点。</p><p>Redux是Flux框架的一个巨大改进，Redux强调单一数据源、保持状态只读和数据改变只能通过纯函数完成的基本原则，和React的<code>UI=render(state)</code>思想完全契合。我们在这一章中用不同方法，循序渐进的改进了ControlPanel这个应用的例子，为的就是更清晰地理解每个改进背后的动因，最后，我们终于通过react-redux完成了React和Redux的融合。</p><p>但是，这只是一个开始。接下来，我们将看到更加深入的React和Redux实践知识。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="/resources/深入浅出React和Redux.pdf">《深入浅出React和Redux —— 程墨》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前一章中我们已经感受到完全用React来管理应用数据的麻烦，在这一章中，我们将介绍Redux这种管理应用状态的框架&lt;/p&gt;
    
    </summary>
    
      <category term="React抄书笔记" scheme="http://www.xiaoleon.cn/categories/React%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.xiaoleon.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(2) 设计高质量的React组件</title>
    <link href="http://www.xiaoleon.cn/2018/03/04/react-2/"/>
    <id>http://www.xiaoleon.cn/2018/03/04/react-2/</id>
    <published>2018-03-04T13:29:25.000Z</published>
    <updated>2018-03-19T13:15:53.841Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个合格的开发者，不能只满足于编写出可以运行的代码，而要了解代码背后的工作原理；不能只满足于自己编写的程序能够运行，还要让自己的代码可读而且易于维护。这样才能开发出高质量的软件。</p><a id="more"></a><p>本文中，我们将深入介绍构建高质量React组件的原则和方法，包括以下内容</p><ul><li><p>划分组件边界的原则</p></li><li><p>React组件的数据种类</p></li><li><p>React组件的生命周期</p></li></ul><h3 id="一、易于维护组件的设计要素"><a href="#一、易于维护组件的设计要素" class="headerlink" title="一、易于维护组件的设计要素"></a>一、易于维护组件的设计要素</h3><p>任何一个复杂的应用，都是由一个简单的应用发展而来的，当应用还很简单的时候，因为功能很少，可能只有一个组件就足够了，但是，随着功能的增加，把越来越多的功能放在一个组件里就会显得臃肿和难以管理。</p><p>就和一个人最好一次只专注做一件事一样，也应该尽量保持一个组件只做一件事。当开发者发现一个组件功能太多代码量太大的时候，就要考虑拆分这个组件，用多个小的组件来代替。每个小的组件只关注实现单个功能，但是这些功能组合起来，也能满足复杂的实际需求。</p><p>这就是“分而治之”的策略，把问题分解为多个小问题，这样极容易解决也方便维护，虽然“分而治之”是一个好策略，但是不要滥用，只有必要的时候才去拆分组件，不然可能得不偿失。</p><p>拆分组件最关键的就是确定组件的边界，每个组件都应该是可以独立存在的，如果两个组件逻辑太紧密，无法清晰定义各自的责任，那也许这两个组件本身就不该被拆开，作为同一个组件也许更合理。</p><p>虽然组件是应该独立存在的，但是并不是说组件就是孤岛一样的存在，不同组件之间总会有通信交流，这样才可能组合起来完成更大的功能。</p><p>作为软件设计的通则，组件的划分要满足<strong>高内聚（High Cohesion）</strong>和<strong>低耦合（Low Coupling）</strong>的原则。</p><p><strong>高内聚</strong>指的是把逻辑紧密相关的内容放在一个组件中。用户界面无外乎内容、交互行为和样式。传统上，内容由HTML表示，交互行为放在JavaScript代码文件中，样式放在CSS文件中定义。这虽然满足一个功能模块的需要，却要放在三个不同的文件中，这其实不满足高内聚的原则，React却不是这样，展示内容的JSX、定义行为的JavaScript，甚至定义样式的CSS，都可以放在一个JavaScript文件中，因为它们本来就是为了实现一个目的而存在的，所以说React天生具有高内聚的特点。</p><p><strong>低耦合</strong>指的是不同组件之间的依赖关系要尽量弱化，也就是每个组件要尽量独立。保持整个系统的低耦合度，需要对系统中的功能有充分的认识，然后根据功能点划分模块，让不同的组件去实现不同的功能，这个功夫还在开发者身上，不过，React组件的对外结构非常规范，方便开发者设计低耦合的系统。</p><hr><h3 id="二、React组件的数据"><a href="#二、React组件的数据" class="headerlink" title="二、React组件的数据"></a>二、React组件的数据</h3><p>毫无疑问，如何组织数据是程序的最重要问题。</p><p>React组件的数据分为两种，prop和state，无论prop或者state的改变，都可能引发组件的重新渲染，那么，设计一个组件的时候，什么时候选择用prop什么时候选择用state呢？其实原则很简单，prop是组件的对外接口，state是组件的内部状态，对外用prop，内部用state。</p><p>为了演示属性的使用，我们构造一个应用包含两个组件，Counter组件和ControlPanel组件，其中ControlPanel组件是父组件，包含若干个Counter组件。</p><p><img src="/images/react-2/1.png" alt="ControlPanel应用效果图"></p><p>可以看到三个Counter组件有了不同的初始计数值，点击网页中的“<code>+</code>”按钮可以看到对应一行的计数增加，点击“<code>-</code>”按钮可以看到对应一行的计数减少。</p><h4 id="1-React的prop"><a href="#1-React的prop" class="headerlink" title="1. React的prop"></a>1. React的prop</h4><p>在React中，prop（property的简写）是从外部传递给组件的数据，一个React组件通过定义自己能够接受的prop就定义了自己的对外公共接口。</p><p>每个React组件都是独立存在的模块，组件之外的一切都是外部世界，外部世界就是通过prop来和组件对话的。</p><ul><li>1) 给prop赋值</li></ul><p>我们先从外部世界来看，prop是如何使用的，在下面的JSX代码片段中，就使用了prop</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SampleButton id=<span class="string">"sample"</span> borderWidgh=&#123;<span class="number">2</span>&#125; onClick=&#123;onButtonClick&#125; style=&#123;&#123;<span class="attr">color</span>: <span class="string">"red"</span>&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>在上面的例子中，创建了名为SampleButton的组件实例，使用了名字分别为id、borderWidth、onClick和style的prop，看起来，React组件的prop很像是HTML元素的属性，不过，HTML组件属性的值都是字符串类型，即使是内嵌JavaScript，也依然是字符串形式表示代码。React组件的prop所能支持的类型则丰富得多，除了字符串，可以是任何一种JavaScript语言支持的数据类型。</p><p>比如在上面的SampleButton中，borderWidth就是数字类型，onClick是函数类型，style的值是一个包含color字段的对象，当prop的类型不是字符串类型时，在JSX中必须用花括号<code>{}</code>把prop值包住，所以style的值有两层花括号，外层花括号代表的是JSX的语法，内层的花括号代表这是一个对象常量。</p><p>当外部世界要传递一些数据给React组件，一个最直接的方式就是通过prop；同样，React组件要反馈数据给外部世界，也可以用prop，因为prop的类型不限于纯数据，也可以是函数，函数类型的prop等于让父组件交给了子组件一个回调函数，子组件在恰当的时机调用函数类型的prop，可以带上必要的参数，这样就可以反过来把信息传递给外部世界。</p><p>对于Counter组件，父组件的ControlPanel就是外部世界，我们看ControlPanel是如何用prop传递信息给Counter的，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ControlPanel</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Counter caption=<span class="string">"First"</span> initValue=&#123;<span class="number">0</span>&#125; /&gt;</span><br><span class="line">        &lt;Counter caption=<span class="string">"Second"</span> initValue=&#123;<span class="number">10</span>&#125; /&gt;</span><br><span class="line">        &lt;Counter caption=<span class="string">"Third"</span> initValue=&#123;<span class="number">20</span>&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>ControlPanel组件包含三个Counter组件实例，在ControlPanel的render函数中将这三个子组件实例用div包起来，因为React要求render函数只能返回一个元素。</p><p>在每个Counter组件实例中，都使用了caption和initValue这两个prop。通过名为caption的prop，ControlPanel传递给Counter组件实例说明文字。通过initValue的prop传递给Counter组件一个初始的计数值。</p><ul><li>2) 读取prop值</li></ul><p>我们再来看Counter组件内部是如何接收传入的prop的，首先是构造函数，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.onClickIncrementButton = <span class="keyword">this</span>.onClickIncrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.onClickDecrementButton = <span class="keyword">this</span>.onClickDecrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: props.initValue || <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个组件需要定义自己的构造函数，一定要记得在构造函数的第一行通过super调用父类也就是React.Component的构造函数。如果在构造函数中没有调用super(props)，那么组件实例被构造之后，类实例的所有成员函数就无法通过this.props访问到父组件传递过来的props值。很明显，给this.props赋值是React.Component构造函数的工作之一。</p><p>在Counter的构造函数中还给两个成员函数绑定了当前this的执行环境，因为ES6方法创造的React组建类并不自动给我们绑定this到当前实例对象。</p><p>在构造函数的最后，我们可以看到读取传入prop的方法，在构造函数中可以通过参数props获得传入的prop值，在其他函数中则可以通过this.props访问传入的prop的值，比如在Counter组件的render函数中，我们就是通过this.props获得传入的caption，render代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; caption &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onClickIncrementButton&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button style=&#123;buttonStyle&#125; onClick=&#123;<span class="keyword">this</span>.onClickDecrementButton&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;caption&#125; count: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用了ES6的解构赋值（destructuring assignment）语法从this.props中获得了名为caption的prop值。</p><ul><li>3) propTypes检查</li></ul><p>既然prop是组件的对外接口，那么就应该有某种方式让组件声明自己的接口规范。简单说，一个组件应该可以规范以下这些方面：</p><ul><li><p>这个组件支持哪些prop</p></li><li><p>每个prop应该是什么样的格式</p></li></ul><p>React通过propTypes来支持这些功能。</p><p>在ES6方法定义的组件类中，可以通过增加类的propTypes属性来定义prop规格，这不只是声明，而且是一种限制，在运行时和静态代码检查时，都可以根据propTypes判断外部世界是否正确地使用了组件的属性。</p><p>比如，对于Counter组件的propTypes定义代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Counter.propTypes = &#123;</span><br><span class="line">  caption: PropTypes.string.isRequired,</span><br><span class="line">  initValue: PropTypes.number</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中要求caption必须是string类型，initValue必须是number类型。可以看到，两者除了类型不同之外，还有一个区别：caption带上了isRequired，这表示使用Counter组件必须要指定caption；而initValue因为没有isRequired，则表示如果没有也没关系。</p><p>为了验证propTypes的作用，可以尝试故意违反propTypes的规定使用Counter实例，比如在ControlPanel的render函数中增加下列的代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Counter caption=&#123;<span class="number">123</span>&#125; initValue=&#123;<span class="number">20</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>我们在Chrome浏览器中，可以看到console中的红色警告</p><p><img src="/images/react-2/2.png" alt="错误prop类型的错误提示"></p><p>这段出错的含义是，caption属性预期是字符串类型，得到的却是一个数字类型。我们尝试删掉这个Counter实例的caption属性，代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Counter initValue=&#123;<span class="number">20</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>这是可以看到Console中依然有红色警告信息</p><p><img src="/images/react-2/3.png" alt="缺失必须存在prop的错误提示"></p><p>提示的含义是，caption是Counter必需的属性，但是却没有赋值。</p><p>很明显，有了propTypes的检查，可以很容易发现对prop的不正确使用方法，可尽早发现代码中的错误。</p><p>如果组件根本没有定义propTypes会怎么样呢？可以尝试在<code>src/Counter.js</code>文件中删除掉propTypes赋值的语句，在浏览器Console中红色警告不再出现。可见，没有propTypes定义，组件依然能够正常工作，而且，即使在上面propTypes检查出错的情况下，组件依旧能够工作。也就是说propTypes检查只是一个辅助开发的功能，并不会改变组件的行为。</p><p>propTypes虽然能够在开发阶段发现代码中的问题，但是放在产品环境中就不大合适了。</p><p>首先，定义类的propTypes属性，无疑是要占用一些代码空间，而且propTypes检查也是要消耗CPU计算资源的。其次，在产品环境下做propTypes检查没有什么帮助，毕竟，propTypes产生的这些错误信息只有开发者才能看得懂，放在产品环境下，在最终用户的浏览器Console中输出这些错误信息没什么意义。</p><p>所以，最好的方式是，开发者在代码中定义propTypes，在开发过程中避免犯错，但是在发布产品代码时，用一种自动的方式将propTypes去掉，这样最终部署到产品环境的代码就会更优。现有的babel-react-optimize就具有这个功能，可以通过npm安装，但是应该确保只在发布产品时使用它。</p><h4 id="2-React的state"><a href="#2-React的state" class="headerlink" title="2. React的state"></a>2. React的state</h4><p>驱动组件渲染过程的除了prop，还有state，state代表组件的内部状态。由于React组件不能修改传入的prop，所以需要记录自身数据变化，就要使用state。</p><p>在Counter组件中，最初显示初始计数，可以通过initValue这个prop来定制，在Counter已经被显示之后，用户会点击“<code>+</code>”和“<code>-</code>”按钮改变这个计数，这个变化的数据就要Counter组件自己通过state来存储了。</p><ul><li>1) 初始化state</li></ul><p>通常在组件类的构造函数结尾处初始化state，在Counter构造函数中，通过对this.state的赋值完成了对组件state的初始化，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    count: props.initValue || <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为initValue是一个可选的props，要考虑到父组件没有指定这个props值的情况，我们优先使用传入属性的initValue，如果没有，就是用默认值0。</p><p>组件的state必须是一个JavaScript对象，不能是string或者number这样的简单数据类型，即使我们需要存储的只是一个数字类型的数据，也只能把它存作state某个字段对应的值，Counter组件里，我们的唯一数据就存在count字段里。</p><p>由于在PropType声明中没有用isRequired要求必须有值的prop，例如上面的initValue，我们需要在代码中判断所给的prop值是否存在，如果不存在，就给一个默认的初始值。不过，让这样的判断逻辑充斥在我们组件的构造函数之中并不是一件美观的事情，而且容易有遗漏。我们可以用React的defaultProps功能，让代码更加容易读懂。</p><p>给Counter组件添加defaultProps代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Counter.defaultProps = &#123;</span><br><span class="line">  initValue: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了这样的设定，Counter构造函数中的this.state初始化中可以省去判断条件，可以认为代码执行到这里，必有initValue属性值，代码可以简化为这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  count: props.initValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，即使Counter的使用者没有指定initValue，在组件中就会收到一个默认的属性值0。</p><ul><li>2) 读取和更新state</li></ul><p>通过给button的onClick属性挂载点击事件处理函数，我们可以改变组件的state，以点击“<code>+</code>”按钮的响应函数为例，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onClickIncrementButton() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，通过this.state可以读取到组件的当前state。值得注意的是，我们改变组件state必须要使用this.setState函数，而不能直接去修改this.state。</p><p>直接修改this.state的值，虽然事实上改变了组件的内部状态，但只是野蛮地修改了state，却没有驱动组件进行重新渲染，既然组件没有重新渲染，当然不会反应this.state值的变化；而this.setState()函数所做的事情，首先是改变this.state的值，然后驱动组件经历更新过程，这样才有机会让this.state里新的值出现在界面上。</p><h4 id="3-prop和state的对比"><a href="#3-prop和state的对比" class="headerlink" title="3. prop和state的对比"></a>3. prop和state的对比</h4><p>总结一下prop和state的区别：</p><ul><li><p>prop用于定义外部接口，state用于记录内部状态</p></li><li><p>prop的赋值在外部世界使用组件时，state的赋值在组件内部</p></li><li><p>组件不应该改变prop的值，而state存在的目的就是让组件来改变的</p></li></ul><p>组件的state，就相当于组件的记忆，其存在意义就是被修改，每一次通过this.setState函数修改state就改变了组件的状态，然后通过渲染过程把这种变化体现出来。</p><p>但是，组件是绝不应该去修改传入的props值的，我们设想一下，假如父组件包含多个子组件，然后把一个JavaScript对象作为props值传给这几个子组件，而某个子组件居然改变了这个对象的内部值，那么，接下来其他子组件读取这个对象会得到什么值呢？当时读取了修改过的值，但是其他子组件是每次渲染都读取这个props的值呢？还是只读一次以后就用那个最初值呢？一切皆有可能，完全不可预料。也就是说，一个子组件去修改props中的值，可能让程序陷入一团混乱之中，这就完全违背了React设计的初衷。</p><p>严格来说，React并没有办法阻止我们去修改传入的props对象。所以，每个开发者就把这当做一个规矩，在编码中一定不要踩这道红线，不然最后可能遇到不可预料的bug。</p><hr><h3 id="三、组件的生命周期"><a href="#三、组件的生命周期" class="headerlink" title="三、组件的生命周期"></a>三、组件的生命周期</h3><p>为了理解React的工作过程，我们就必须要了解React组件的生命周期，如同人有生老病死，自然界有日月更替，每个组件在网页中也会被创建、更新和删除，如同有生命的机体一样。</p><p>React严格定义了组件的生命周期，会经理如下三个过程：</p><ul><li><p>装载过程（Mount），也就是把组件第一次在DOM树中渲染的过程</p></li><li><p>更新过程（Update），当组件被重新渲染的过程</p></li><li><p>卸载过程（Unmount），组件从DOM中删除的过程</p></li></ul><p>三种不同的过程，React库会依次调用组件的一些成员函数，这些函数称为生命周期函数。所以，要定制一个React组件，实际上就是定制这些生命周期函数。</p><h4 id="1-装载过程"><a href="#1-装载过程" class="headerlink" title="1. 装载过程"></a>1. 装载过程</h4><p>我们先来看装载过程，当组件第一次被渲染的时候，依次调用的函数是如下这些：</p><ul><li><p>constructor</p></li><li><p>getInitialState</p></li><li><p>getDefaultProps</p></li><li><p>componentWillMount</p></li><li><p>render</p></li><li><p>componentDidMount</p></li></ul><p>我们逐个详细解释这些函数的功能</p><ul><li>1) constructor</li></ul><p>我们先来看constructor，也就是ES6中每个类的构造函数，要创造一个组件类的实例，当然会调用对应的构造函数。</p><p>要注意，并不是每个组件都需要定义自己的构造函数。在后文中我们可以看到，无状态的React组件往往就不需要定义构造函数，一个React组件需要构造函数，往往是为了下面的目的：</p><ul><li><p>初始化state，因为组件生命周期中任何函数都可能要访问state，那么整个生命周期中第一个被调用的构造函数自然是初始化state最理想的地方</p></li><li><p>绑定成员函数的this环境</p></li></ul><p>在ES6语法下，类的每个成员函数在执行时的this并不是和类实例自动绑定的。而在构造函数中，this就是当前组件实例，所以，为了方便将来的调用，往往在构造函数中将这个实例的特定函数绑定this为当前实例。</p><p>以Counter组件为例，我们的构造函数有这样如下的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.onClickIncrementButton = <span class="keyword">this</span>.onClickIncrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.onClickDecrementButton = <span class="keyword">this</span>.onClickDecrementButton.bind(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这两句的作用，就是通过bind方法让当前实例中onClickIncrementButton和onClickDecrementButton函数被调用时，this始终是指向当前组件实例。</p><ul><li>2) getInitialState和getDefaultProps</li></ul><p>getInitialState这个函数的返回值用来初始化组件的this.state，但是，这个方法只有用React.createClass方法创造的组件类才会发生作用，本文中使用ES6语法，所以这个函数根本不会产生作用。</p><p>getDefaultProps函数的返回值可以作为props的初始值，和getInitialState一样，这个函数不会产生作用。</p><ul><li>3) render</li></ul><p>render函数无疑是React组件中最重要的函数，一个React组件可以忽略其他所有函数都不实现，但是一定要实现render函数，因为所有React组件的父类React.Component类对除render之外的生命周期函数都有默认实现。</p><p>通常一个组件要发挥作用，总是要渲染一些东西，render函数并不做实际的渲染动作，它只是返回一个JSX描述的结构，最终由React来操作渲染过程。</p><p>当然，某些特殊组件的作用不是渲染界面，或者，组件在某些情况下选择没有东西可画，那就让render函数返回一个null或者false，等于告诉React，这个组件这次不需要渲染任何DOM元素。</p><p>需要注意的时，render函数应该是一个纯函数，是完全根据this.state和this.props来决定返回的结果，而且不要产生任何副作用。在render函数中去调用this.setState毫无疑问是错误的，因为一个纯函数不应该引起状态的改变。</p><ul><li>4) componentWillMount和componentDidMount</li></ul><p>在装在过程中，componentWillMount会在调用render函数之前被调用，componentDidMount会在调用render函数之后被调用，这两个函数就像是render函数的前哨和后卫，一前一后，把render函数夹住，正好分别做render前后必要的工作。</p><p>不过，我们通常不用定义componentWillMount函数，顾名思义，componentWillMount发生在“将要装载”的时候，这个时候没有任何渲染出来的结果，即使调用this.setState修改状态也不会引发重新绘制，一切都迟了。换句话说，所有可以在这个componentWillMount中做的事情，都可以提前到constructor中去做，可以认为这个函数存在的主要目的就是为了和componentDidMount对称。</p><p>而componentDidMount作用就大了，需要注意的是，render函数被调用完之后，componentDidMount函数并不是会被立刻调用，componentDidMount被调用的时候，render函数返回的东西已经引发了渲染，组件已经被装载到了DOM树上。</p><p>我们还是以ControlPanel为例，在ControlPanel中有三个Counter组件，我们稍微修改Counter的代码，让装在过程中所有生命周期函数都用console.log输出函数名和caption的值，比如，componentWillMount函数的内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'enter componentWillMount '</span> + <span class="keyword">this</span>.props.caption);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器的console里我们能够看见：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enter constructor: First</span><br><span class="line">enter componentWillMount First</span><br><span class="line">enter render First</span><br><span class="line">enter constructor: Second</span><br><span class="line">enter componentWillMount Second</span><br><span class="line">enter render Second</span><br><span class="line">enter constructor: Third</span><br><span class="line">enter componentWillMount Third</span><br><span class="line">enter render Third</span><br><span class="line">enter componentDidMount First</span><br><span class="line">enter componentDidMount Second</span><br><span class="line">enter componentDidMount Third</span><br></pre></td></tr></table></figure><p>可以清楚的看到，虽然componentWillMount都是紧贴着自己组件的render函数之前被调用，componentDidMount可不是紧跟着render函数被调用，当所有三个组建的render函数都被调用之后，三个组件的componentDidMount才连在一起被调用。</p><p>之所以会有上面的现象，是因为render函数本身并不往DOM树上渲染或者装载内容，它只是返回一个JSX表示的对象，然后由React库来根据返回对象决定如何渲染。而React库肯定是要把所有的组件返回的结果综合起来，才能知道如何产生对应的DOM修改。所以，只有React库调用三个Counter组件的render函数之后，才有可能完成装载，这时候才会依次调用各个组件的componentDidMount函数作为装载过程的收尾。</p><p>componentWillMount和componentDidMount这对兄弟函数还有一个区别，就是componentWillMount可以在服务器端被调用，也可以在浏览器端被调用；而componentDidMount只能在浏览器端被调用，在服务器端使用React的时候不会被调用。</p><p>目前为止，我们构造的React应用例子都只是在浏览器端使用React，所以看不出区别，在后面关于“同构”应用的介绍时，我们会探讨在服务器端使用React的情况。</p><p>至于为什么只有componentDidMount仅在浏览器端执行，这是一个实现上的决定，而不是设计时刻有意而为之。不过，如果非要有个解释的话，可以这么说，既然“装载”是一个创建组件并放到DOM树上的过程，那么，真正的“装载”是不可能在服务器端完成的，因为服务器端渲染并不会产生DOM树，通过React组件产生的只是一个纯粹的字符串而已。</p><p>不管怎样，componentDidMount只在浏览器端执行，倒是给了我们开发者一个很好地位置去做只有浏览器端才做的逻辑，比如通过Ajax获取数据来填充组件的内容。</p><p>在componentDidMount被调用的时候，组件已经被装载到DOM树上了，可以放心获取渲染出来的任何DOM。</p><p>在实际开发过程中，可能会需要让React和其他UI库配合使用，比如，因为项目前期已经用jQuery开发了很多功能，需要继续使用这些基于jQuery的代码，有时候其他的UI库做某些功能比React更合适，比如d3.js已经支持了丰富的绘制图表的功能，在这些情况下，我们不得不考虑如何让React和其他UI库和平共处。</p><p>以和jQuery配合为例，我们知道，React是用来取代jQuery的，但如果真的要让React和jQuery配合，就需要利用componentDidMount函数，当componentDidMount被执行时，React组件对应的DOM已经存在，所有的事件处理函数也已经设置好，这时候就可以调用jQuery的代码，让jQuery在已经绘制的DOM基础上增强新的功能。</p><p>在componentDidMount中调用jQuery代码只处理了装载过程，要和jQuery完全结合，又要考虑React的更新过程，就需要使用下面要讲的componentDidUpdate函数。</p><h4 id="2-更新过程"><a href="#2-更新过程" class="headerlink" title="2. 更新过程"></a>2. 更新过程</h4><p>当组件被装载到DOM树上之后，用户在网页上可以看到组件的第一印象，但是要提供更好的交互体验，就要让该组件可以随着用户操作改变展现的内容，当props或者state修改的时候，就会引发组件的更新过程。</p><p>更新过程会依次调用下面的生命周期函数，其中render函数和装载过程一样，没有差别。</p><ul><li><p>componentWillReceiveProps</p></li><li><p>shouldComponentUpdate</p></li><li><p>componentWillUpdate</p></li><li><p>render</p></li><li><p>componentDidUpdate</p></li></ul><p>有意思的是，并不是所有的更新过程都会执行全部函数，下面会介绍到各种特例。</p><ul><li>1) componentWillReceiveProps(nextProps)</li></ul><p>关于这个componentWillReceiveProps存在一些误解。在网上有些教材声称这个函数只有当组件的props发生改变的时候才会被调用，其实是不正确的。实际上，只要是父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程，不管父组件传给子组件的props有没有改变，都会触发子组件的componentWillReceiveProps函数。</p><p>注意，通过this.setState方法触发的更新过程不会调用这个函数，这是因为这个函数适合根据新的props值（也就是参数nextProps）来计算出是不是要更新内部状态state。更新组件内部状态的方法就是this.setState，如果this.setState的调用导致componentWillReceiveProps再一次被调用，那就是一个死循环了。</p><p>让我们对ControlPanel做一些小的改进，来体会一下上面提到的规则。</p><p>我们首先在Counter组件类里增加函数定义，让这个函数componentWillReceiveProps在console上输出一些文字，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'enter componentWillReceiveProps '</span> + <span class="keyword">this</span>.props.caption);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ControlPanel组件的render函数中，我们也做如下修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'enter ControlPanel render'</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;style&#125;&gt;</span><br><span class="line">      ...</span><br><span class="line">      &lt;button onClick=&#123; () =&gt; <span class="keyword">this</span>.forceUpdate() &#125;&gt;</span><br><span class="line">        Click me to repaint!</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了在ControlPanel的render函数入口处增加console输出，我们还增加了一个按钮，这个按钮的onClick事件引发了一个匿名函数，当这个函数被点击的时候，调用this.forceUpdate，每个React组件都可以通过forceUpdate函数强行引发一次重新绘制。</p><p>在网页中，我们去点击那个新增加的按钮，可以看到浏览器的console中有如下输出：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enter ControlPanel render</span><br><span class="line">enter componentWillReceiveProps First</span><br><span class="line">enter render First</span><br><span class="line">enter componentWillReceiveProps Second</span><br><span class="line">enter render Second</span><br><span class="line">enter componentWillReceiveProps Third</span><br><span class="line">enter render Third</span><br></pre></td></tr></table></figure><p>可以看到，引发forceUpdate之后，首先是ControlPanel的render函数被调用，随后第一个Counter组件的componentWillReceiveProps函数被调用，然后Counter组件的render函数被调用，随后第二个第三个组件的这两个函数也依次被调用。</p><p>然而，ControlPanel在渲染三个子组件的时候，提供的props值一直就没有变化，可见componentWillReceiveProps并不是当props值变化的时候才被调用，所以，这个函数有必要把传入参数nextProps和this.props做必要对比。nextProps代表的是这一次渲染传入的props值，this.props代表的上一次渲染时的props值，只有两者有变化的时候才有必要调用this.setState更新内部状态。</p><p>在网页中，我们再次尝试点击第一个Counter组件的“<code>+</code>”按钮，可以看到浏览器的console输出如下：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enter render First</span><br></pre></td></tr></table></figure><p>明显，只有第一个组件的Counter的render函数被调用，函数componentWillReceiveProps没有被调用。因为点击“<code>+</code>”按钮引发的是第一个Counter组件的this.setState函数的调用，就像上面说过的一样，this.setState不会引发这个函数componentWillReceiveProps被调用。</p><p>从这个例子我们也会发现，在React的组件组合中，完全可以只渲染一个子组件，而其它组件完全不需要渲染，这是提高React性能的重要方式。</p><ul><li>2) shouldComponentUpdate(nextProps, nextState)</li></ul><p>除了render函数，shouldComponentUpdate可能是React组件生命周期中最重要的一个函数了。</p><p>说render函数重要，是因为render函数决定了该渲染什么，而说shouldComponentUpdate函数重要，是因为它决定了一个组件什么时候不需要渲染。</p><p>render和shouldComponentUpdate函数，也是React生命周期函数中唯二两个要求有返回结果的函数。render函数的返回结果将用于构造DOM对象，而shouldComponentUpdate函数返回一个布尔值，告诉React库这个组件在这次更新过程中是否要继续。</p><p>在更新过程中，React库首先调用shouldComponentUpdate函数，如果这个函数返回true，那就会继续更新过程，接下来调用render函数；反之，如果得到一个false，那就立刻停止更新过程，也就不会引发后续的渲染了。</p><p>说shouldComponentUpdate重要，就是因为只要使用恰当，它就能够大大提高React组件的性能，虽然React的渲染性能已经很不错了，但是，不管渲染有多快，如果发现没必要重新渲染，那就干脆不用渲染好了，速度会更快。</p><p>我们知道render函数应该是一个纯函数，这个纯函数的逻辑输入就是组件的props和state。所以，shouldComponentUpdate的参数就是接下来的props和state值。如果我们要定义shouldComponentUpdate，那就根据这两个参数，外加this.props和this.state来判断出返回true还是返回false。</p><p>如果我们给组件添加shouldComponentUpdate函数，那就沿用所有React组件父类React.Component中的默认实现方式，默认实现方式就是简单地返回true，也就是每次更新过程都要重新渲染。当然，这是最稳妥的方式，大不了浪费一点，但是绝对不会出错。不过若我们要追求更高的性能，就不能满足于默认实现，需要定制这个函数shouldComponentUpdate。</p><p>让我们尝试来给Counter组件增加一个shouldComponentUpdate函数。先来看看props，Counter组件支持两个props，一个叫caption，一个叫initValue。很明显，只有caption这个prop改变的时候，才有必要重新渲染。对于initValue，只是创建Counter组件实例时用于初始化计数值，在组件实例创建之后，无论怎么改，都不应该让Counter组件重新渲染。</p><p>再来看看state，Counter组件的state只有一个值count，如果count发生了变化，那肯定应该重新渲染，如果count没变化，那就没必要了。</p><p>现在，让我们给Counter组件类增加shouldComponentUpdate函数的定义，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="keyword">return</span> (nextProps.caption !== <span class="keyword">this</span>.props.caption) ||</span><br><span class="line">    (nextState.count !== <span class="keyword">this</span>.state.count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，只有当caption改变，或者state中的count值改变，shouldComponentUpdate才会返回true。</p><p>值得一提的是，通过this.setState函数引发更新过程，并不是立刻更新组件的state值，在执行到函数shouldComponentUpdate的时候，this.state依然是this.setState函数执行之前的值，所以我们要做的实际上就是在nextProps、nextState、this.props和this.state中互相比对。</p><p>我们在网页中引发一次ControlPanel的重新绘制，可以看到浏览器的console中输出这样：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enter ControlPanel render</span><br><span class="line">enter componentWillReceiveProps First</span><br><span class="line">enter componentWillReceiveProps Second</span><br><span class="line">enter componentWillReceiveProps Third</span><br></pre></td></tr></table></figure><p>可以看到，三个Counter组件的render函数都没有被调用，因为这个刷新没有改变caption的值，更没有引发组件内状态的改变，所以完全没有必要重新绘制counter。</p><p>对于Counter这个简单的组件，我们无法感觉到性能的提高，但是，实际开发中会遇到更复杂更庞大的组件，这种情况下避免没必要的重新渲染，就会大大提高性能。</p><ul><li>3) componentWillUpdate和componentDidUpdate</li></ul><p>如果组件的shouldComponentUpdate函数返回true，React接下来就会依次调用对应组件的componentWillUpdate、render和componentDidUpdate函数。</p><p>componentWillMount和componentDidMount，componentWillUpdate和componentDidUpdate，这两对函数一前一后地把render函数夹在中间。</p><p>和装载过程不同的是，当在服务器端使用React渲染时，这一对函数中的Did函数，也就是componentDidUpdate函数，并不是只在浏览器端才执行的，无论更新过程发生在服务器端还是浏览器端，该函数都会被调用。</p><p>在介绍componentDidMount函数时，我们说到可以利用componentDidMount函数执行其他UI库的代码，比如jQuery代码。当React组件被更新时，原有的内容被重新绘制，这时候就需要在componentDidUpdate函数再次调用jQuery代码。</p><p>那么，componentDidUpdate函数不是可能会在服务器端也被执行吗？在服务器端怎么能够使用jQuery呢？实际上，使用React做服务器端渲染时，基本不会经历更新过程，因为服务器端只需要产出HTML字符串，一个装载过程就足够产出HTML了，所以正常情况下服务器端不会调用componentDidUpdate函数，如果调用了，说明我们的程序有错误，需要改进。</p><h4 id="3-卸载过程"><a href="#3-卸载过程" class="headerlink" title="3. 卸载过程"></a>3. 卸载过程</h4><p>React组件的卸载过程只涉及一个函数componentWillUnmount，当React组件要从DOM树上删除掉之前，对应的componentWillUnmount函数会被调用，所以这个函数适合做一些清理性的工作。</p><p>和装载过程和更新过程不一样，这个函数没有配对的Did函数，就一个函数，因为卸载完就完了，没有“卸载完再做的事情”。</p><p>不过，componentWillUnmount中的工作往往和componentDidMount有关，比如，在componentDidMount中用非React的方法创造一些DOM元素，如果撒手不管可能会造成内存的泄漏，那就需要在componentWillUnmount中把这些创造的DOM元素清理掉。</p><hr><h3 id="四、组件向外传递数据"><a href="#四、组件向外传递数据" class="headerlink" title="四、组件向外传递数据"></a>四、组件向外传递数据</h3><p>通过构造ControlPanel和Counter，现在我们已经知道了如何通过props从父组件传递数据给子组件，但是，组件之间的交流是相互的，子组件某些情况下也需要把数据传递给父组件，我们接下来看看在React中如何实现这个功能。</p><p>在ControlPanel中，包含三个Control子组件实例，每个Counter都有一个可以动态改变的计数值，我们希望ControlPanel能够即时显示出这三个子组件当前计数值之和。</p><p>这个功能看起来很简单，但是要解决一个问题，就是要让ControlPanel“知道”三个子组件当前的计数值，而且是每次改变都要立刻知道，而Counter组件的当前值是组件的内部状态，如何让外部世界知道这个值呢？</p><p>解决这个问题的方法，依然是利用prop。组件的prop可以是任何JavaScript对象，而在JavaScript中，函数是一等公民，函数本身就可以被看作一种对象，既可以像其他对象一样作为prop的值从父组件传递给子组件，又可以被子组件作为函数调用，这样事情就好办了。</p><h4 id="1-应用实例"><a href="#1-应用实例" class="headerlink" title="1. 应用实例"></a>1. 应用实例</h4><p>我们看到修改后的功能图如图所示</p><p><img src="/images/react-2/5.png" alt="包含总数的ControlPanel应用效果图"></p><p>点击任何一个Counter的“<code>+</code>”按钮或者“<code>-</code>”按钮，可以看见除了所属Counter的计数变化，底部的总计数也会随之变化，这是因为Counter能够把自己状态改变的信息传递给外层的组件。</p><p>接下来看实现这个功能的关键代码。</p><p>在Counter组件中，对于点击“<code>+</code>”和“<code>-</code>”按钮的事件处理方法做了改动，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">onClickIncrementButton() &#123;</span><br><span class="line">  <span class="keyword">this</span>.updateCount(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onCLickDecrementButton() &#123;</span><br><span class="line">  <span class="keyword">this</span>.updateCount(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateCount(isIncrement) &#123;</span><br><span class="line">  <span class="keyword">const</span> previousValue = <span class="keyword">this</span>.state.count;</span><br><span class="line">  <span class="keyword">const</span> newValue = isIncrement ? previousValue + <span class="number">1</span> : previousValue - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: newValue &#125;);</span><br><span class="line">  <span class="keyword">this</span>.props.onUpdate(newValue, previousValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，onClickIncrementButton函数和onClickDecrementButton函数的任务除了调用this.setState改变内部状态，还要调用this.props.onUpdate这个函数，为了避免重复代码，我们对原有代码做一下重构，提取了共同部分到updateCount函数里。</p><p>对应的，Counter组件的propTypes和defaultProps就要增加onUpdate的定义，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Counter.propTypes = &#123;</span><br><span class="line">  caption: PropTypes.string.isRequires,</span><br><span class="line">  initValue: PropTypes.number,</span><br><span class="line">  onUpdate: PropTypes.func</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Counter.defaultProps = &#123;</span><br><span class="line">  initValue: <span class="number">0</span>,</span><br><span class="line">  onUpdate: <span class="function"><span class="params">f</span> =&gt;</span> f</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>新增加的prop叫做onUpdate，类型是一个函数，当Counter的状态改变的时候，就会调用这个给定的函数，从而达到通知父组件的作用。</p><p>这样，Counter的onUpdate就成了作为子组件的Counter向父组件ControlPanel传递数据的渠道，我们先约定这个函数的第一个参数是Counter更新之后的值，第二个参数是更新之前的值，至于如何使用这两个参数的值，是父组件ControlPanel的逻辑，Counter不用操心，而且根据两个参数的值足够推导出数值是增加还是减少。</p><p>从使用Counter组件的角度，在ControlPanel组件中也要做一些修改，现在ControlPanel需要包含自己的state，首先是构造函数部分，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.onCounterUpdate = <span class="keyword">this</span>.onCounterUpdate.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.initValues = [<span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line">  <span class="keyword">const</span> initSum = <span class="keyword">this</span>.initValues.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    sum: initSum</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ControlPanel组件被第一次渲染的时候，就需要显示三个计数器数值的综合，所以我们在构造函数中使用initValues数组记录所有的Counter的初始值，在初始化this.state之前，将initValues数组中所有值加在一起，作为this.state中sum字段的初始值。</p><p>ControlPanel传递给Counter组件的onUpdate这个prop的值是onCounterUpdate函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onCounterUpdate(newValue, previousValue) &#123;</span><br><span class="line">  <span class="keyword">const</span> valueChange = newValue - previousValue;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    sum: <span class="keyword">this</span>.state.sum + valueChange</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onCounterUpdate函数的参数和Counter中调用的onUpdate prop的参数规格一致，第一个参数为新值，第二个参数为之前的值，两者之差就是改变值，将这个改变作用到this.state.sum上就是sum的新状态。</p><p>遗憾的是，React虽然有PropType能够检查prop的类型，却没有任何机制来限制prop的参数规格，参数的一致性只能靠开发者来保证。</p><p>ControlPanel组件的render函数中需要增加对this.state.sum和onCountUpdate的使用，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;style&#125;&gt;</span><br><span class="line">      &lt;Counter onUpdate=&#123;<span class="keyword">this</span>.onCountUpdate&#125; caption=<span class="string">"First"</span> /&gt;</span><br><span class="line">      &lt;Count onUpdate=&#123;<span class="keyword">this</span>.onCountUpdate&#125; caption=<span class="string">"Second"</span> initValue=&#123;<span class="keyword">this</span>.initValues[<span class="number">1</span>]&#125; /&gt;</span><br><span class="line">      &lt;Count onUpdate=&#123;<span class="keyword">this</span>.onCountUpdate&#125; caption=<span class="string">"Third"</span> initValue=&#123;<span class="keyword">this</span>.initValues[<span class="number">2</span>]&#125; /&gt;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &lt;div&gt;Total Count: &#123;<span class="keyword">this</span>.state.sum&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="五、React组件state和prop的局限"><a href="#五、React组件state和prop的局限" class="headerlink" title="五、React组件state和prop的局限"></a>五、React组件state和prop的局限</h3><p>是时候重新思考一下多个组件之间的数据管理问题了。在上面修改的代码中，不难发现其实实现得并不精妙，每个Count组件有自己的状态记录当前计数，而父组件ControlPanel也有一个状态来存储所有Counter计数总和，也就是说，数据发生了重复。</p><p>数据如果出现重复，带来的一个问题就是如何保证重复的数据一致，如果数据存多份而且不一致，那就很难决定到底使用哪个数据作为正确结果了。</p><p>在上面的例子中，ControlPanel通过onUpdate回调函数传递的新值和旧值来计算新的计数总和，设想一下，由于某种bug的原因，某个按钮的点击更新没有通知到ControlPanel，就会让ControlPanel中的sum状态和所有子组件Counter的count状态之和不一致，这时候，是应该相信ControlPanel还是Count呢？</p><p>如图所示，逻辑上应该相同的状态，分别存放在不同组件中，就会导致这种困局。</p><p><img src="/images/react-2/6.png" alt="组件状态不一致的困惑"></p><p>对于上面所说的问题，一个直观的解决方法是以某一个组件的状态为准，这个组件是状态的“领头羊”，其余组件都保持和“领头羊”的状态同步，但是在实际情况下这种方法可能很难实施。比如上面的例子中，每个Counter记录自己的计数值是很自然的，但是有三个Counter组件，也就有三只“领头羊”，让ControlPanel跟着三只“领头羊”走，似乎不是一个好主意。</p><p>另一种思路，就是干脆不要让任何一个React组件扮演“领头羊”的角色，把数据源放在React组件之外形成全局状态，如下图所示，让各个组件保持和全局状态的一致，这样更容易控制。</p><p><img src="/images/react-2/7.png" alt="React中提取出来"></p><p>图中全局状态就是唯一可靠的数据源，下一章我们会介绍，这就是Flux和Redux中Store的概念。</p><p>除了state，利用prop在组件之间传递信息也会遇到问题。设想一下，在一个应用中，包含三级或者三级以上的组件结构，顶层的祖父级组件想要传递一个数据给最底层的子组件，用prop的方式，就只能通过父组件中转，而中间那一层父组件可能根本用不上这个prop，但是依然要支持这个prop，扮演好搬运工的角色，只因为子组件用得上，这明显违反了低耦合的设计要求。</p><p><img src="/images/react-2/8.png" alt="跨级传递prop的困局"></p><hr><h3 id="六、本章小结"><a href="#六、本章小结" class="headerlink" title="六、本章小结"></a>六、本章小结</h3><p>本章中，我们学习了构建高质量组件的原则，应用React一样要以构建高内聚低耦合的组件为目标，而保证组件高质量的一个重要工作就是保持组件对外接口清晰简洁。</p><p>React利用prop来定义组件的对外接口，用state来代表内部的状态，某个数据选择用prop还是用state表示，取决于这个数据是对内还是对外。</p><p>我们还介绍了React的生命周期，了解了装载过程、更新过程和卸载过程涉及的所有生命周期函数。</p><p>在本章中我们利用ControlPanel和Counter两个组件演示了组件之间的通信方式，包括子组件向父组件传递信息的方式，同时也看出了使用React的state来存储状态的一个缺点，那就是数据的冗余和重复，这就是我们接下来要解决的问题。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="/resources/深入浅出React和Redux.pdf">《深入浅出React和Redux —— 程墨》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个合格的开发者，不能只满足于编写出可以运行的代码，而要了解代码背后的工作原理；不能只满足于自己编写的程序能够运行，还要让自己的代码可读而且易于维护。这样才能开发出高质量的软件。&lt;/p&gt;
    
    </summary>
    
      <category term="React抄书笔记" scheme="http://www.xiaoleon.cn/categories/React%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.xiaoleon.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(1) 新的前端思维方式</title>
    <link href="http://www.xiaoleon.cn/2018/03/04/react-1/"/>
    <id>http://www.xiaoleon.cn/2018/03/04/react-1/</id>
    <published>2018-03-04T01:51:31.000Z</published>
    <updated>2018-03-19T13:15:53.821Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来只管认识React，对任何一种工具，只有使用才能够熟练掌握，React也不例外。通过对React快速上手，我们会解析React的工作原理，并通过与功能相同的jQuery程序对比，从而看出React的特点。</p><a id="more"></a><h3 id="一、初始化一个React项目"><a href="#一、初始化一个React项目" class="headerlink" title="一、初始化一个React项目"></a>一、初始化一个React项目</h3><p>React是一个JavaScript语言的工具库，我们需要安装Node.js，React本身并不依赖于Node.js，但是我们开发中用到的诸多工具需要Node.js的支持。</p><p>在Node.js的官网（<a href="https://nodejs.org" target="_blank" rel="noopener">https://nodejs.org</a>）可以找到合适的安装方式，安装Node.js的同时也就安装了npm，npm是Node.js的安装包管理工具，因为我们不可能自己开发所有功能，会大量使用现有的安装包，就需要npm的帮助。</p><h4 id="1-create-react-app工具"><a href="#1-create-react-app工具" class="headerlink" title="1. create-react-app工具"></a>1. create-react-app工具</h4><p>React技术依赖于一个很庞大的技术栈，比如，转译JavaScript代码需要使用Babel，模块打包工具又要使用Webpack，定制build过程需要grunt或者gulp，这些技术栈都需要各自的配置文件，还没有开始写一行React相关代码，我们就已经被各种技术名词淹没。</p><p>针对这种情况，React的创建者Facebook提供了一个快速开发React应用的工具，名叫<code>create-react-app</code>，这个工具的目的是将开发人员从配置工作中解脱出来，无需过早关注这些技术栈细节，通过创建一个已经完成基本配置的应用，让开发者快速开始React应用的开发。</p><p><code>create-react-app</code>是一个通过npm发布的安装包，在确认Node.js和npm安装好之后，命令行中执行下面的命令安装<code>create-react-app</code>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure><p>安装结束后，我们可以通过如下命令创建react项目：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app first_react_app</span><br></pre></td></tr></table></figure><p>这个命令会在当前目录创建一个名为first_react_app的目录，在这个目录中会自动添加一个应用的框架，随后我们只需要在这个框架的基础上修改文件就可以开发React应用，避免了大量的手工配置工作。</p><p>在<code>create-react-app</code>命令一大段文字输出之后，根据提示，输入下面的命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> first_react_app</span><br><span class="line">npm <span class="built_in">start</span></span><br></pre></td></tr></table></figure><p>这个命令会启动一个开发模式的服务器，同时也会让浏览器自动打开一个网页，指向本机地址<code>http://localhost:3000</code>。</p><p><img src="/images/react-1/1.png" alt="第一个React应用"></p><p>接下来，我们会用React开发一个简单的功能。</p><hr><h3 id="二、增加一个新的React组件"><a href="#二、增加一个新的React组件" class="headerlink" title="二、增加一个新的React组件"></a>二、增加一个新的React组件</h3><p>React的首要思想是通过组件（<code>Component</code>）来开发应用。所谓组件，简单说，指的是能完成某个特定功能的独立的、可重用的代码。</p><p>基于组件的应用开发是广泛使用的软件开发模式，用分而治之的方法，把一个大的应用分解成若干小的组件，每个组件只关注于某个小范围的特定功能，但是把组件组合起来，就能构成一个功能庞大的应用。如果分解功能的过程足够巧妙，那么每个组件可以在不同场景下重用，那么不光可以构建庞大的应用，还可以构建出灵活的应用。打个比方，每个组件是一块砖，而一个应用是一座楼，想要一次锻造就创建一座楼是不现实的。实际上，总是先锻造出很多砖，通过排列组合这些砖，才能构建伟大的建筑。</p><p>我们先看看<code>create-react-app</code>给我们自动产生的代码，在first_react_app目录下包含如下文件和目录。</p><p><img src="/images/react-1/2.png" alt="文件目录"></p><p>在开发过程中，我们主要关注src目录中的内容，这个目录中是所有的源代码。</p><p>create-react-app所创建的应用的入口是<code>src/index.js</code>文件，我们看看中间的内容，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个应用所做的事情，只是渲染一个名叫<code>App</code>的组件，<code>App</code>组件在同目录下的<code>App.js</code>文件中定义，渲染出来的效果就是在上图中看到的界面。</p><p>我们要定义一个新的能够计算点击数组件，名叫<code>ClickCounter</code>，所以我们修改<code>index.js</code>文件如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> ClickCounter <span class="keyword">from</span> <span class="string">'./ClickCounter'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ClickCounter /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>接下来我们会介绍代码的含义。现在我们先来看看如何添加一个新组件，在<code>src</code>目录下添加一个新的代码文件<code>ClickCounter.js</code>，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.onClickButton = <span class="keyword">this</span>.onClickButton.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onClickButton() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.onClickButton&#125;&gt;Click Me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          Click Count: &#123; this.state.count &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default ClickCounter;</span></span><br></pre></td></tr></table></figure><p>我们可以在网页中看到，其中内容已经发生改变，如下图所示</p><p><img src="/images/react-1/3.png" alt="ClickCounter组件界面效果"></p><p>点击“Click Me”按钮，可以看到“Click Count”后面的数字会随之增加，每点击一次加1.</p><p>现在让我们来逐步详细解释代码中各部分的要义。</p><p>在<code>index.js</code>文件中，使用<code>import</code>导入了<code>ClickCounter</code>组件，代替了之前的<code>App</code>组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ClickCounter <span class="keyword">from</span> <span class="string">'./ClickCounter'</span>;</span><br></pre></td></tr></table></figure><p><code>import</code>是ES6语法中导入文件模块的方式，ES6语法是一个大集合，大部分功能都被最新浏览器支持。不过这个<code>import</code>方法却不在广泛支持之列，这没有关系，ES6语法的JavaScript会被webpack和babel转译成所有浏览器支持的ES5语法，而这一切都无需开发人员配置，<code>create-react-app</code>已经替我们完成了这些工作。</p><p>在<code>ClickCounter.js</code>文件的第一行，我们从react库中引入了<code>React</code>和<code>Component</code>，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br></pre></td></tr></table></figure><p><code>Component</code>作为所有组件的基类，提供了很多组建共有的功能，下面这行代码，使用的是ES6语法来创建一个叫<code>ClickCounter</code>的组建类，<code>ClickCounter</code>的父类就是<code>Component</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>在React出现之初，使用的是<code>React.createClass</code>方式来创造组件类，这种方法已经被废弃了。在本文中，我们只使用ES6的语法来构建组件类。</p><p>虽然我们导入的<code>Component</code>类在<code>ClickCounter</code>组件定义中使用了，可是导入的React却没有被使用，难道这里引入React没有必要吗？</p><p>事实上，引入React非常必要，我们可以尝试删掉第一行中的React，在网页中立刻会出现错误信息。</p><p><img src="/images/react-1/4.png" alt="缺失React的错误"></p><p>这个错误的含义是：“在使用JSX的范围内必须要有React。”</p><p>也就是说，在使用JSX的代码文件中，即使代码中并没有直接使用React，也一定要导入React，这是因为JSX最终会被转译成依赖于React的表达式。</p><h4 id="1-JSX"><a href="#1-JSX" class="headerlink" title="1. JSX"></a>1. JSX</h4><p>所谓JSX，是JavaScript的语法扩展（eXtension），让我们在JavaScript中可以编写像HTML一样的代码。在<code>ClickCounter.js</code>的<code>render</code>函数中，就出现了类似这样的HTML代码，在<code>index.js</code>中，<code>ReactDOM.render</code>的第一个参数<code>&lt;App /&gt;</code>也是一段JSX代码。</p><p>JSX中的这几段代码看起来和HTML几乎一模一样，都可以使用<code>&lt;div&gt;</code>、<code>&lt;button&gt;</code>之类的元素，所以只要熟悉HTML，学习JSX完全不成问题，但是，我们一定要明白两者的不同之处。</p><p>首先，在JSX中使用的“元素”不局限于HTML元素，可以是任何一个React组件，在App.js中可以看到，我们创建的<code>ClickCounter</code>组件被直接应用在JSX中，使用方法和其他元素一样，这一点是传统的HTML做不到的。</p><p>React判断一个元素是HTML元素还是React元素的原则就是看第一个字母是否大写，如果在JSX中我们不用<code>ClickCounter</code>而是用<code>clickCounter</code>，那就得不到我们想要的结果。</p><p>其次，在JSX中可以通过<code>onClick</code>的方式给一个元素添加一个事件处理函数，当然，在HTML中也可以使用<code>onclick</code>（注意和<code>onClick</code>拼写有区别），但在HTML中直接书写<code>onclick</code>一直就是为人诟病的写法，网页应用开发界一直倡导的是用jQuery的方法添加事件处理函数，直接写<code>onclick</code>会带来代码混乱的问题。</p><p>这就带来一个问题，既然长期以来一直不提倡在HTML中使用<code>onclick</code>，为什么在React的JSX中我们却要使用<code>onClick</code>这样的方式来添加事件处理函数呢？</p><h4 id="2-JSX是进步还是倒退"><a href="#2-JSX是进步还是倒退" class="headerlink" title="2. JSX是进步还是倒退"></a>2. JSX是进步还是倒退</h4><p>在React出现之初，很多人对React这样的设计非常反感，因为React把类似HTML的标记语言和JavaScript混在一起了，但是，随着时间的推移，业界逐渐认可了这种方式，因为大家都发现，以前用HTML来代表内容，CSS代笔样式，Javascript来定义交互行为，这三种语言分在三种不同的文件里面，实际上是把不同技术分开管理了，而不是逻辑上的“分而治之”。</p><p>根据做同一件事的代码应该有高耦合性的设计原则，既然我们要实现一个<code>ClickCounter</code>，那为什么不把实现这个功能的所有代码集中在一个文件里呢？</p><p>那么，在JSX中使用<code>onClick</code>添加事件处理函数，是否代表网页应用开发兜了一个大圈，最终回到了起点呢？</p><p>不是这样，JSX的<code>onClick</code>事件处理方式和HTML的<code>onclick</code>有很大不同。</p><p>即使现在，我们还是要说在HTML中直接使用<code>onclick</code>很不专业，原因如下：</p><ul><li><p><code>onclick</code>添加的事件处理函数是在全局环境下执行的，这污染了全局环境，很容易产生意料不到的后果</p></li><li><p>给很多Dom元素添加<code>click</code>事件，可能会影响网页的性能，毕竟，网页需要的事件处理函数越多，性能就会越低</p></li><li><p>对于使用<code>onclick</code>的Dom元素，如果要动态地从DOM树中删掉的话，需要把对应的事件处理器注销，假如忘了注销，就可能造成内存泄漏，这样的bug很难被发现</p></li></ul><p>上面说的这些问题，在JSX中都不存在。</p><p>首先，<code>onClick</code>挂载的每个函数，都可以控制在组建范围内，不会污染全局空间。</p><p>我们在JSX中看到一个组件使用了<code>onClick</code>，但并没有产生直接使用<code>onclick</code>的HTML，而是使用了事件委托（event delegation）的方式处理点击事件，无论有多少个<code>onClick</code>出现，其实最后都只在DOM树上添加了一个事件处理函数，挂在最顶层的DOM节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组建分配给特定函数，使用事件委托的性能当然要比为每个<code>onClick</code>都挂载一个事件处理函数要高。</p><p>因为React控制了组件的生命周期，在<code>unmount</code>的时候自然能够清除相关的所有事件处理函数，内存泄漏也不再是一个问题。</p><p>除了在组件中定义交互行为，我们还可以在React组件中定义样式，我们可以修改<code>ClickCounter.js</code>中的<code>render</code>函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> counterStyle = &#123;</span><br><span class="line">    margin: <span class="string">'16px'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;counterStyle&#125;&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.onClickButton&#125;&gt;Click Me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      Click Count: &lt;span id="clickCount"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在JavaScript代码中定义一个<code>counterStyle</code>对象，然后在JSX中赋值给顶层div的style属性，可以在网页中看到这个部分的margin真的变大了。</p><p>这样，React的组件可以把JavaScript、HTML和CSS的功能写在一个文件中，实现真正的组件封装。</p><hr><h3 id="三、分解React应用"><a href="#三、分解React应用" class="headerlink" title="三、分解React应用"></a>三、分解React应用</h3><p>前面我们提到过，React应用实际上依赖于一个很大很复杂的技术栈，我们使用<code>create-react-app</code>避免在一开始就费太多精力配置技术栈，不过现在是时候了解一下这个技术栈了。</p><p>我们启动React应用的命令是<code>npm start</code>，看看<code>package.json</code>中对<code>start</code>脚本的定义。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "react-scripts start",</span><br><span class="line">  "build": "react-scripts build",</span><br><span class="line">  "test": "react-scripts test --env=jsdom",</span><br><span class="line">  "eject": "react-scripts eject"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，start命令实际上是调用了react-scripts命令，<code>react-scripts</code>是<code>create-react-app</code>添加的一个npm包，所有的配置文件都藏在<code>node_modules/react-scripts</code>目录下，我们当然可以钻进这个目录去一探究竟，但是也可以使用eject方法来看清楚背后的原理。</p><p>这个eject（弹射）命令做的事情，就是把潜藏在<code>react-scripts</code>中的一系列技术栈配置都“弹射”到应用的顶层，然后我们就可以研究这些配置细节了，而且可以更灵活地定制应用的配置。</p><blockquote><p>eject命令是不可逆的，就好像战斗机飞行员选择“弹射”出驾驶舱，等于是放弃了这架战斗机，是不可能再飞回驾驶舱的。所以，当你执行eject之前，最好做一下备份。</p></blockquote><p>我们在命令行下执行下面的命令，完成“弹射”操作：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run eject</span><br></pre></td></tr></table></figure><p>这个命令会改变一些文件，也会添加一些文件。</p><p>当前目录下会增加两个目录，一个是scripts，另一个是config，同时，<code>package.json</code>文件中的scripts部分也发生了变化：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "node scripts/start.js",</span><br><span class="line">  "build": "node scripts/build.js",</span><br><span class="line">  "test": "node scripts/test.js --env=jsdom"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从此以后，start脚本将使用scripts目录下的<code>start.js</code>，而不是node_modules目录下的<code>react-scripts</code>，弹射成功，再也回不去了。</p><p>在config目录下的<code>webpack.config.dev.js</code>文件，定制的就是npm start所做的构造过程，其中有一段关于babel的定义：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"test"</span>: /\.(js|jsx)$/,</span><br><span class="line">  <span class="attr">"include"</span>: paths.appSrc,</span><br><span class="line">  <span class="attr">"loader"</span>: <span class="string">"babel"</span>,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    // This is a feature of 'babel-loader' for webpack (not Babel itself).</span><br><span class="line">    // It enables caching results in ./node_modules/.cache/babel-loader/</span><br><span class="line">    // directory for faster rebuilds.</span><br><span class="line">    "cacheDirectory": true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的<code>paths.appSrc</code>的值就是<code>src</code>，所以这段配置的含义指的是所有以js或者jsx为扩展名的文件，都会由babel所处理。</p><p>并不是所有的浏览器都支持所有的ES6语法，但是有了babel，我们就可以不用顾忌太多，因为babel会把ES6语法的JavaScript代码转译为浏览器普遍支持的JavaScript代码，实际上，在React社区中，不使用ES6语法写代码才显得奇怪。</p><hr><h3 id="四、React的工作方式"><a href="#四、React的工作方式" class="headerlink" title="四、React的工作方式"></a>四、React的工作方式</h3><p>在继续深入学习React的其他知识之前，我们先就这个简单的<code>ClickCounter</code>组件思考一下React的工作方式，要了解一样东西的特点，最好的方法当然是拿这个东西和另一样东西做比较。我们就拿React和jQuery来比较。</p><h4 id="1-jQuery如何工作"><a href="#1-jQuery如何工作" class="headerlink" title="1. jQuery如何工作"></a>1. jQuery如何工作</h4><p>假设我们用jQuery来实现<code>ClickCounter</code>的功能，该怎么做呢？首先，我们要产生一个网页的HTML，写一个<code>index.html</code>文件如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"ClickMe"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        Click Count: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"clickCount"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./clickCounter.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实际产品中，产生这样的HTML可以用PHP、Java、Ruby或者任何一种服务器端语言和框架来做，也可以在浏览器中用Mustache、Hogan这样的模板来产生，这里我们只是把问题简化，直接书写HTML。</p><p>上面的HTML只是展示样式，并没有任何交互功能，现在我们用jQuery来实现交互功能，和jQuery的传统一样，我们把JavaScript写在一个独立的文件<code>clickCounter.js</code>中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#clickMe'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clickCounter = $(<span class="string">'#clickCount'</span>);</span><br><span class="line">    <span class="keyword">var</span> count = <span class="built_in">parseInt</span>(clickCounter.text(), <span class="number">10</span>);</span><br><span class="line">    clickCounter.text(count + <span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>用浏览器打开上面创造的<code>index.html</code>，可以看到实际效果和我们写的React应用一模一样，但是对比这两段程序可以看出差异。</p><p>在jQuery解决方案中，首先根据CSS规则找到id为<code>clickCount</code>的按钮，挂上一个匿名事件处理函数，在事件处理函数中，选中那个需要被修改的DOM元素，读取其中的文本值，加以修改，然后修改这个DOM元素。</p><p>选中一些DOM元素，然后对这些元素做一些操作，这是一种最容易理解的开发模式。jQuery的发明人John Resig就是发现了网页应用开发者的这种编程模式，才创造出了jQuery，其一问世就得到普遍认可，因为这种模式直观易懂。但是，对于庞大的项目，这种模式会造成代码结构复杂，难以维护，每个jQuery的使用者都会有这种体会。</p><h4 id="2-React的理念"><a href="#2-React的理念" class="headerlink" title="2. React的理念"></a>2. React的理念</h4><p>与jQuery不同，用React开发应用是另一种体验，我们回顾一下，用React开发的<code>ClickCounter</code>组件好像没有像jQuery那样做“选中一些DOM元素然后做一些事情”的动作。</p><p>打一个比方，React是一个聪明的建筑工人，而jQuery是一个比较傻的建筑工人，开发者你就是一个建筑的设计师，如果是jQuery这个建筑工人为你工作，你不得不事无巨细地告诉jQuery“如何去做”，要告诉他这面墙要拆掉重建，那面墙上要新开一个窗户。反之，如果是React这个建筑工人为你工作，你所要做的就是告诉这个工人“我想要什么样子”，只要把图纸递给React这个工人，他就会替你搞定一切，当然他不会把整个建筑拆掉重建，而是很聪明地把这次的图纸和上次的图纸做一个对比，发现不同之处，然后只去做适当的修改就完成任务了。</p><p>显而易见，React的工作方式把开发者从繁琐的操作中解放出来，开发者只需要着重“我想要显示什么”，而不用操心“怎样去做”。</p><p>这种新的思维方式，对于一个简单的例子也要编写不少代码，感觉像是用高射炮打蚊子，但是对于一个大型的项目，这种方式编写的代码会更容易管理，因为整个React应用要做的就是渲染，开发者关注的是渲染成什么样子，而不用关心如何实现增量渲染。</p><p>React的理念，归结为一个公式，就像下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UI = render(data)</span><br></pre></td></tr></table></figure><p>让我们来看看这个公示表达的含义，用户看到的界面（<code>UI</code>），应该是一个函数（在这里叫<code>render</code>）的执行结果，只接受数据（<code>data</code>）作为参数。这个函数是一个纯函数，所谓纯函数，指的是没有任何副作用，输出完全依赖于输入的函数，两次函数调用如果输入相同，得到的结果也绝对相同。如此一来，最终的用户界面，在<code>render</code>函数确定的情况下完全取决于输入数据。</p><p>对于开发者来说，重要的是区分开哪些属于<code>data</code>，哪些属于<code>render</code>，想要更新用户界面，要做的就是更新<code>data</code>，用户界面自然会做出响应，所以React实践的也是“响应式编程”（<code>Reactive Programming</code>）的思想，这也就是React为什么叫做React的原因。</p><h4 id="3-Virtual-DOM"><a href="#3-Virtual-DOM" class="headerlink" title="3. Virtual DOM"></a>3. Virtual DOM</h4><p>既然React应用就是通过重复渲染实现用户交互，我们可能会有一个疑虑：这样的重复渲染会不会效率太低了呢？毕竟，在jQuery的实现方式中，我们可以清楚地看到每次只有需要变化的那一个DOM元素被修改了；可是，在React的实现方式中，看起来每次render函数被调用，都要把整个组件重新绘制一次，这样看起来有点浪费。</p><p>事实并不是这样，React利用Virtual DOM，让每次渲染都重新渲染最少的DOM元素。</p><p>要了解Virtual DOM，就要先了解DOM，DOM是结构化文本的抽象表达形式，特定于Web环境中，这个结构化文本就是HTML文本，HTML中的每个元素都对应DOM中的某个节点，这样，因为HTML元素的逐级包含关系，DOM节点自然就构成了一个树形结构，称为DOM树。</p><p>浏览器为了渲染HTML格式的网页，会先将HTML文本解析以构建DOM树，然后根据DOM树渲染出用户看到的界面，当要改变界面内容的时候，就去改变DOM树上的节点。</p><p>Web前端开发关于性能优化有一个原则：尽量减少DOM操作。虽然DOM操作也只是一些简单的JavaScript语句，但是DOM操作会引起浏览器对网页进行重新布局，重新绘制，这就是一个比JavaScript语句执行慢很多的过程。</p><p>如果使用mustache或者hogan这样的模板工具，那就是生成HTML字符串塞到网页中，浏览器又要做一次解析产生新的DOM节点，然后替换DOM树上对应的子树部分，这个过程肯定效率不高。虽然JSX看起来很像是一个模板，但是最终会被Babel解析为一条条创建React组件或者HTML元素的语句，神奇之处在于，React并不是通过这些语句直接构建DOM树，而是首先构建Virtual DOM。</p><p>既然DOM树是对HTML的抽象，那Virtual DOM就是对DOM树的抽象。Virtual DOM不会触及浏览器的部分，只是存在于JavaScript空间的树形结构，每次自上而下渲染React组件时，会对比这一次产生的Virtual DOM和上一次渲染的Virtual DOM，对比就会发现差别，然后修改真正的DOM树时就只需要触及差别中的部分就行。</p><p>以<code>ClickCounter</code>为例，一开始点击计数为0，用户点击按钮让点击计数变成1，这一次重新渲染，React通过Virtual DOM的对比发现其实只是id为<code>clickCounter</code>的span元素中内容从0变成了1而已：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"clickCounter"</span>&gt;</span>&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React发现这次渲染要做的事情只是更换span元素的内容而已，其他DOM元素都不需要触及，于是执行类似下面的语句，就完成了任务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'clickCounter'</span>).innerHTML = <span class="string">"1"</span>;</span><br></pre></td></tr></table></figure><h4 id="4-React工作方式的优点"><a href="#4-React工作方式的优点" class="headerlink" title="4. React工作方式的优点"></a>4. React工作方式的优点</h4><p>毫无疑问，jQuery的方式直观易懂，对于初学者十分适用，但是当项目逐渐变得庞大时，用jQuery写出的代码往往互相纠缠，形成类似下图的状况，难以维护。</p><p><img src="/images/react-1/5.png" alt="jQuery方式造成的纠缠代码结构"></p><p>使用React的方式，就可以避免构建这样复杂的程序结构，无论何种事件，引发的都是React组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发者并不需要关心，程序的流程简化为如下方式。</p><p><img src="/images/react-1/6.png" alt="React的程序流程"></p><p>React利用函数式编程的思维来解决用户界面渲染的问题，最大的优势是开发者的效率会大大提高，开发出来的代码可维护性和可阅读性也大大增强。</p><p>React等于强制所有组件都按照这种由数据驱动渲染的模式来工作，无论应用的规模多大，都能让程序处于可控范围内。</p><hr><h3 id="五、本文小结"><a href="#五、本文小结" class="headerlink" title="五、本文小结"></a>五、本文小结</h3><p>在本文中，我们用<code>create-react-app</code>创造了一个简单的React应用，在一开始，我们就按照组件的思想来开发应用，React的主要理念之一就是基于组件来开发应用。</p><p>通过和同样功能的jQuery实现方式对比，我们了解了React的工作方式，React利用声明式的语法，让开发者专注于描述用户界面“显示成什么样子”，而不是重复思考“如何去显示”，这样可以大大提高开发效率，也让代码更加容易管理。</p><p>虽然React是通过重复渲染来实现动态更新效果，但是借助Virtual DOM技术，实际上这个过程并不牵涉太多的DOM操作，所以渲染效率很高。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="/resources/深入浅出React和Redux.pdf">《深入浅出React和Redux —— 程墨》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们先来只管认识React，对任何一种工具，只有使用才能够熟练掌握，React也不例外。通过对React快速上手，我们会解析React的工作原理，并通过与功能相同的jQuery程序对比，从而看出React的特点。&lt;/p&gt;
    
    </summary>
    
      <category term="React抄书笔记" scheme="http://www.xiaoleon.cn/categories/React%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://www.xiaoleon.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.xiaoleon.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Web(5) HTTP与HTTPS</title>
    <link href="http://www.xiaoleon.cn/2018/03/02/web-5/"/>
    <id>http://www.xiaoleon.cn/2018/03/02/web-5/</id>
    <published>2018-03-02T02:15:50.000Z</published>
    <updated>2018-03-12T14:04:54.242Z</updated>
    
    <content type="html"><![CDATA[<p>超文本传输协议HTTP被用于Web浏览器和网站服务器之间传递信息，HTTP以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><a id="more"></a><p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><h3 id="一、TCP-IP、HTTP、HTTPS"><a href="#一、TCP-IP、HTTP、HTTPS" class="headerlink" title="一、TCP/IP、HTTP、HTTPS"></a>一、TCP/IP、HTTP、HTTPS</h3><ul><li><p>TCP/IP：传输层协议，主要解决数据如何在网络中传输，Web服务器将HTTP封装好的文本信息，通过TCP/IP协议发送到网络上。</p></li><li><p>HTTP：应用层协议，用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p></li><li><p>HTTPS：以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p></li></ul><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><p>下面的图表显示OSI（Open System Interconnect）模型中的各项协议：</p><table><thead><tr><th>OSI层</th><th>协议名称</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP</td></tr><tr><td>表示层</td><td>XDR、ASN.1、SMB、AFP、NCP</td></tr><tr><td>会话层</td><td>ASAP、TLS、SSH、ISO 8327 / CCITT X.255、RPC、NetBIOS、ASP、Winsock、BSD sockets</td></tr><tr><td>传输层</td><td>TCP、UDP、RTP、SCTP、SPX、ATP、IL</td></tr><tr><td>网络层</td><td>IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25</td></tr><tr><td>数据链路层</td><td>以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP</td></tr><tr><td>物理层</td><td>线路、无线电、光钎、信鸽</td></tr></tbody></table><hr><h3 id="二、HTTP与HTTPS有什么区别"><a href="#二、HTTP与HTTPS有什么区别" class="headerlink" title="二、HTTP与HTTPS有什么区别"></a>二、HTTP与HTTPS有什么区别</h3><p>HTTP传输的数据都是未加密的，也就是明文的，因此使用HTTP传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTPS构建的可进行传输加密、身份认证的网络协议，要比HTTP安全。</p><p>HTTPS和HTTP的主要区别如下：</p><ul><li><p>1) HTTPS协议需要到CA申请证书，一般免费证书较少，因而需要一定费用</p></li><li><p>2) HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议</p></li><li><p>3) HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，HTTP是80，HTTPS是443</p></li><li><p>4) HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP构建的可进行加密传输、身份认证的网络协议，比HTTP更安全</p></li></ul><hr><h3 id="三、HTTP三次握手"><a href="#三、HTTP三次握手" class="headerlink" title="三、HTTP三次握手"></a>三、HTTP三次握手</h3><p><img src="/images/web-5/1.png" alt="HTTP三次握手时序图"></p><p>TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p><ul><li><p>1) 第一次握手：客户端发送syn包（syn=j）到服务器，并进入SYN_SEND状态，等待服务器确认</p></li><li><p>2) 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态</p></li><li><p>3) 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p></li></ul><hr><h3 id="四、HTTP四次挥手"><a href="#四、HTTP四次挥手" class="headerlink" title="四、HTTP四次挥手"></a>四、HTTP四次挥手</h3><p><img src="/images/web-5/2.png" alt="HTTP四次挥手时序图"></p><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>HTTP的关闭需要发送四个包，因此称为四次挥手（four-way handshake）。客户端或服务端均可主动发起挥手操作，在socket中，任何一方执行close()操作即可产生挥手操作。</p><ul><li><p>1) 客户端发送一个FIN，用来关闭客户端到服务端的数据传送</p></li><li><p>2) 服务端收到这个FIN，返回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号</p></li><li><p>3) 服务端关闭与客户端的连接，发送一个FIN到客户端</p></li><li><p>4) 客户端发挥ACK报文确认，并将确认序号设置为收到序号加1</p></li></ul><hr><h3 id="五、HTTPS的工作原理"><a href="#五、HTTPS的工作原理" class="headerlink" title="五、HTTPS的工作原理"></a>五、HTTPS的工作原理</h3><p><img src="/images/web-5/3.png" alt="HTTPS通信"></p><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><ul><li><p>1) 客户使用HTTPS的URL访问Web服务器，要求与Web服务器建立SSL连接</p></li><li><p>2) Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端</p></li><li><p>3) 客户端解析证书，首先验证公钥是否有效，比如颁发机构、过期时间等，如果发现异常，则会弹出警告框，提示证书存在问题</p></li><li><p>4) 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级</p></li><li><p>5) 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给Web服务器</p></li><li><p>6) Web服务器利用字迹的私钥解密出会话密钥</p></li><li><p>7) Web服务器利用会话密钥加密与客户端之间的通信</p></li></ul><p><img src="/images/web-5/4.png" alt="HTTPS连接时序图"></p><hr><h3 id="六、HTTPS的优点"><a href="#六、HTTPS的优点" class="headerlink" title="六、HTTPS的优点"></a>六、HTTPS的优点</h3><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是当前架构下最安全的解决方案，主要有以下几个好处：</p><ul><li><p>1) 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户端和服务器</p></li><li><p>2) HTTPS协议是由SSL+HTTP构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性</p></li><li><p>3) HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本</p></li><li><p>4) Google曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”</p></li></ul><hr><h3 id="七、HTTPS的缺点"><a href="#七、HTTPS的缺点" class="headerlink" title="七、HTTPS的缺点"></a>七、HTTPS的缺点</h3><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><ul><li><p>1) HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%-20%的耗电</p></li><li><p>2) HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响</p></li><li><p>3) SSL整数需要收费，功能越强大的整数费用越高，个人网站、小网站没有必要一般不会用</p></li><li><p>4) SSL整数通常需要绑定IP，不能再同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗</p></li><li><p>5) HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务供给、服务器劫持等方面几乎起不到什么作用。最关键的，SSL整数的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="https://www.cnblogs.com/wqhwe/p/5407468.html" target="_blank" rel="noopener">HTTP与HTTPS的区别</a></p></li><li><p><a href="https://www.cnblogs.com/lovesong/p/5186200.html" target="_blank" rel="noopener">HTTP与HTTPS握手的那些事</a></p></li><li><p><a href="https://www.cnblogs.com/Jessy/p/3535612.html" target="_blank" rel="noopener">TCP的三次握手（建立连接）和四次挥手（关闭连接）</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;超文本传输协议HTTP被用于Web浏览器和网站服务器之间传递信息，HTTP以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HTTP" scheme="http://www.xiaoleon.cn/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="http://www.xiaoleon.cn/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>其他(1) 软考论文经验</title>
    <link href="http://www.xiaoleon.cn/2018/03/01/ruankao-1/"/>
    <id>http://www.xiaoleon.cn/2018/03/01/ruankao-1/</id>
    <published>2018-03-01T05:43:29.000Z</published>
    <updated>2018-03-05T14:35:56.004Z</updated>
    
    <content type="html"><![CDATA[<p>17年下半年的信息系统项目管理师考试，前前后后间断复习了大概3个月，没想到最后一次过了，挺意外的。</p><a id="more"></a><p>由于上班比较忙，所以也没有很系统的进行相关复习，都是零碎时间看点真题，然后上信管网来看看案例分析。这里客观题和主观题就不作经验分享了，感觉自己能拿这个分数纯属巧合，主要介绍一下自己论文的一点经验。</p><h3 id="一、练字"><a href="#一、练字" class="headerlink" title="一、练字"></a>一、练字</h3><p>论文属于纯手写考试，评卷老师的第一感官便是我们的卷面整洁及清晰程度，我们至少应当做到字迹清晰工整，这样可以给评卷老师留下一个好的第一印象，同时节省评卷的时间。如果字迹优雅、布局工整，相信评卷老师也会从内心里当作是一副书法作品来阅读。</p><p>另外，我们需要做到在2个小时的考试时间内，保持字迹大体一致，减少评卷老师在字迹上的心理变化。从字迹的变化上能够很容易反映出考生的心理状态，比如没有提前做好论文的前期准备，就容易出现大量的划痕；或者后期时间不够了，容易出现心里焦躁，字迹越来越乱的情况。</p><p>我在写论文的时候，就出现了最后半小时发现时间不够用的情况，最后的500-600字由于时间特别赶，导致字迹开始越来越乱，最后写完大概只剩下了不到3分钟。从卷面上，能够很明显的感觉到我当时慌乱的心境，也是没有准备充分的体现。现在想想，如果提前有充足的准备，应该不至于在这方面出现差错，分数可能也会比当前的49要高一些吧。</p><hr><h3 id="二、提速"><a href="#二、提速" class="headerlink" title="二、提速"></a>二、提速</h3><p>论文考试是2个小时内，需要书写2500到3000字。如果没有经过提前练习，加上现在生活中提笔写字的机会接近于零，几乎是一个不可能完成的任务。因此，考前一定需要花上一段时间，每天练习写字速度，在保证文笔工整的前提下，尽量提高论文的行文速度。</p><p>这里给一个小建议，考前我们可以从网上下载一些模版论文，先完整地抄写几遍模板论文。这样可以计算出自己在完全不思考的情况下，写完一整篇论文的速度，然后再根据情况进行提速训练。</p><p>我考前大概抄写了9篇模板论文，取平均数的话，大概抄写完整篇文章需要1小时30分钟到1小时40分钟。也就是说，如果在考试过程中还需要构思，那思考时间最多只能控制在20分钟到30分钟内。这个时间可以说非常紧张，也正是因为在考试中，我还需要边写边思考后面的内容，所以才导致了最后的时间非常紧张。</p><hr><h3 id="三、模拟"><a href="#三、模拟" class="headerlink" title="三、模拟"></a>三、模拟</h3><p>由于论文考试需要书写在特定的答题纸上，因此我们可以利用这个答题纸的样式来进行提前练习。论文答题纸分为6页，摘要部分从第一页的中间到第二页的前几行，然后剩余的5页为正文部分。我们可以从信管网上下载答题纸模版pdf，然后打印出来，直接在上面抄写模板论文或书写准备的论文。</p><p>这样模拟练习后，我们就能够有个大概的概念，摘要第一部分应该写到哪一行，第二部分应该写到哪一行，总结的字数应该控制在多少。</p><p>我们把论文正文分为三大块：开头、正文、结尾。其中开头部分一般从第二页的前几行，书写到第三页的中间；正文部分从第三页的中间，书写到第五页的下方；结尾部分，从第五页的下方，书写到第六页的下方。</p><p>我们还可以划分时间节点，比如摘要大概花费20分钟，开头大概花费20分钟，正文大概花费60分钟，结尾大概花费20分钟。</p><p>这样经过模拟训练后，考场上我们就可以有条不紊的执行我们的考试规划，在指定时间和指定地点完整对应的书写工作。</p><hr><h3 id="四、模板"><a href="#四、模板" class="headerlink" title="四、模板"></a>四、模板</h3><p>由于信管考试论文的特殊性，9大类论点必考一题，使得我们可以针对这9项进行提前准备。</p><h4 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h4><p>摘要是整篇文章的内容浓缩，这里建议参考信管网或者各论坛的摘要写作指导，我建议在模拟练习中，将9大类的摘要都仔细思考并行文一遍，经过多次修改后，形成最后的模版。</p><p>考场上不太可能有足够的时间来思考摘要应该怎么写，时间是非常宝贵的，我们更应当花费时间去判断论题是否跟往年有所出入，如果题目要求与其他方面进行结合，应当怎么样在摘要模板中进行修改并点题。</p><p>可以说摘要是非常重要的，阅卷老师从摘要就能得出全文的第一印象，而且阅卷的特殊性，可能只有一两分钟的阅读时间，所以前期准备过程中需要好好斟酌。</p><p>我在考试过程中，发卷到开考前，思考了下论题是否和准备的模版有出入。开考后，直接落笔写摘要，大约10分钟写完摘要，把时间尽量多的留给正文部分。</p><h4 id="2-开头"><a href="#2-开头" class="headerlink" title="2. 开头"></a>2. 开头</h4><p>开头也是我们可以提前准备的部分，虽然9大类论题各不相同，但是论文要求我们与实际项目相结合，那么开头我们可以相对统一，比如介绍项目的背景、需求、技术等等，先提前准备好一个项目，把这个项目中涉及到的相关具体内容整理成文，同时借用一下网上模板论文中的一些好的语句进行串联，修改得到大约600-800字的开头。最后，多在准备过程中写几遍，把内容背下来，减少考试过程中的思考时间。</p><p>我在考试过程中，大约花了20分钟写论文开头，写到预先设计的第三页中间后，正好结束开头部分，开始写正文部分。</p><h4 id="3-正文"><a href="#3-正文" class="headerlink" title="3. 正文"></a>3. 正文</h4><p>正文是全文耗时最长，也最为重要的部分。这部分建议准备过程中，能够完整地把9大类论题，都思考成文一遍，考前再阅读记忆几次，这样考试过程中可以较为顺利的进行书写，从而减少构思的时间。</p><p>我在正文部分准备的不够充分，考前只思考和列举了9大类需要书写的提纲，以及能够用在这些提纲内的案例与项目结合点。在真正考试的时候，很明显的感觉到，有时候写完提纲要点，发现不知道具体的阐述内容应该如何落笔行文，还需要停下来花时间构思，这样非常浪费时间。</p><p>至于正文结构，建议采用如下格式（具体提纲忘了，请勿参考示例提纲）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">结合具体参与的项目，成本管理大概分为以下几点：</span><br><span class="line"></span><br><span class="line">1. 成本估算</span><br><span class="line"></span><br><span class="line">// 第一段，对成本估算的概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明是怎么完成成本估算过程的</span><br><span class="line"></span><br><span class="line">2. 成本预算</span><br><span class="line"></span><br><span class="line">// 第一段，对成本预算的概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明是怎么完成成本预算过程的</span><br><span class="line"></span><br><span class="line">3. 成本控制计划编制</span><br><span class="line"></span><br><span class="line">// 第一段，对成本控制计划编制进行概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明是怎么完成计划编制的</span><br><span class="line"></span><br><span class="line">4. 成本控制</span><br><span class="line"></span><br><span class="line">// 第一段，对成本控制进行概念解释及分析</span><br><span class="line"></span><br><span class="line">// 第二段，结合具体项目，说明成本控制过程中出现了哪些问题，是怎么处理的</span><br></pre></td></tr></table></figure><p>我们可以提前准备一些项目中出现的案例，在合适的时机插入到正文当中，比如</p><ul><li><p>项目某个里程碑阶段，对项目的EV、AC、PV、SPI、CPI等进行分析，得出当前项目处于成本超支/节约，进度超前/落后，然后怎么样进行管理变化，使项目正常运行</p></li><li><p>项目某个时间点，有突发情况发生（项目组成员离开等等），我们是怎么应变调节的</p></li><li><p>项目计划编制中，我们采用了头脑风暴，技术专家评审等等方式，完成编制过程等等</p></li><li><p>分析项目的最长路径、总时差、自由时差等等</p></li></ul><h4 id="4-结尾"><a href="#4-结尾" class="headerlink" title="4. 结尾"></a>4. 结尾</h4><p>结尾部分同样可以采用提前准备的方式，9大类采用统一风格，当正文部分写到预定的区域后，即可开始书写提前准备的结尾部分。基本上按照既定的思路，写到文章结尾的时候，如果时间还比较充裕，那基本上离论文合格也就不远了。</p><p><img src="/images/ruankao-1/信管征文.jpg" alt="信管网获奖"></p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;17年下半年的信息系统项目管理师考试，前前后后间断复习了大概3个月，没想到最后一次过了，挺意外的。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://www.xiaoleon.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="软考" scheme="http://www.xiaoleon.cn/tags/%E8%BD%AF%E8%80%83/"/>
    
      <category term="信息系统项目管理师" scheme="http://www.xiaoleon.cn/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(11) 用Transition实现过渡动画</title>
    <link href="http://www.xiaoleon.cn/2018/02/27/css3-11/"/>
    <id>http://www.xiaoleon.cn/2018/02/27/css3-11/</id>
    <published>2018-02-27T08:09:00.000Z</published>
    <updated>2018-02-28T13:32:42.299Z</updated>
    
    <content type="html"><![CDATA[<p><code>transition</code>是网页上的过渡动画，在CSS3出现之前，网页上的动画大多是用flash实现的，但flash动画会产生很大的弊端，比如操作不便等等。</p><a id="more"></a><h3 id="一、定义和用法"><a href="#一、定义和用法" class="headerlink" title="一、定义和用法"></a>一、定义和用法</h3><p><code>transition</code>属性是一个简写属性，用于设置四个过渡属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">property</span> <span class="selector-tag">duration</span> <span class="selector-tag">timing-function</span> <span class="selector-tag">delay</span>;</span><br></pre></td></tr></table></figure><h4 id="1-transition-property"><a href="#1-transition-property" class="headerlink" title="1. transition-property"></a>1. <code>transition-property</code></h4><p><code>transition-property</code>属性规定应用过渡效果的CSS属性的名称。（当指定的CSS属性改变时，过渡效果将开始）。</p><blockquote><p>过渡效果通常在用户将鼠标指针浮动到元素上时发生。</p></blockquote><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>none</code></td><td>没有属性会获得过渡效果</td></tr><tr><td><code>all</code></td><td>所有属性都将获得过渡效果</td></tr><tr><td><code>property</code></td><td>定义应用过渡效果的css属性名称列表，列表以逗号分隔</td></tr></tbody></table><h4 id="2-transition-duration"><a href="#2-transition-duration" class="headerlink" title="2. transition-duration"></a>2. <code>transition-duration</code></h4><p><code>transition-duration</code>属性规定完成过渡效果需要多少秒或毫秒。需要始终设置该属性，否则时长为0，就不会产生过渡效果。</p><h4 id="3-transition-timing-function"><a href="#3-transition-timing-function" class="headerlink" title="3. transition-timing-function"></a>3. <code>transition-timing-function</code></h4><p><code>transition-timing-function</code>属性规定过渡效果的速度曲线。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>linear</code></td><td>规定以相同速度开始至结束的过渡效果（等于<code>cubic-bezier(0, 0, 1, 1)</code>）</td></tr><tr><td><code>ease</code></td><td>规定慢速开始，然后变快，然后慢速结束的过渡效果（<code>cubic-bezier(0.25, 0.1, 0.25, 1)</code>）</td></tr><tr><td><code>ease-in</code></td><td>规定以慢速开始的过渡效果（等于<code>cubic-bezier(0.42, 0.1, 1)</code>）</td></tr><tr><td><code>ease-out</code></td><td>规定以慢速结束的过渡效果（等于<code>cubic-bezier(0, 0, 0.58, 1)</code>）</td></tr><tr><td><code>ease-in-out</code></td><td>规定以慢速开始和结束的过渡效果（等于<code>cubic-bezier(0.42, 0, 0.58, 1)</code>）</td></tr><tr><td><code>cubic-bezier(n, n, n, n)</code></td><td>在<code>cubic-bezier</code>函数中定义自己的值。可能的值是0至1之间的数值</td></tr></tbody></table><h4 id="4-transition-delay"><a href="#4-transition-delay" class="headerlink" title="4. transition-delay"></a>4. <code>transition-delay</code></h4><p><code>transition-delay</code>规定在过渡效果开始之前需要等待的时间，以秒或毫秒计。</p><hr><h3 id="二、使用案例"><a href="#二、使用案例" class="headerlink" title="二、使用案例"></a>二、使用案例</h3><p>首先我们写一个字体出来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    div &#123;</span></span><br><span class="line"><span class="undefined">        width: 300px;</span></span><br><span class="line"><span class="undefined">        height: 100px;</span></span><br><span class="line"><span class="undefined">        padding-top: 20px;</span></span><br><span class="line"><span class="undefined">        line-height: 100px;</span></span><br><span class="line"><span class="undefined">        margin: 200px auto 0;</span></span><br><span class="line"><span class="undefined">        text-align: center;</span></span><br><span class="line"><span class="undefined">        font-size: 40px;</span></span><br><span class="line"><span class="undefined">        font-weight: bold;</span></span><br><span class="line"><span class="undefined">        font-family: '华文行楷';</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#ff6600</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>超炫火焰字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如图</p><p><img src="/images/css3-11/1.png" alt="效果图"></p><p>然后，我们给div加上hover效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">text-shadow</span>: 0<span class="selector-tag">px</span> 0<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> <span class="selector-id">#fff</span>,</span></span><br><span class="line"><span class="css">                0<span class="selector-tag">px</span> <span class="selector-tag">-3px</span> 3<span class="selector-tag">px</span> <span class="selector-id">#1eb</span>,</span></span><br><span class="line"><span class="css">                0<span class="selector-tag">px</span> <span class="selector-tag">-6px</span> 4<span class="selector-tag">px</span> <span class="selector-id">#01defd</span>,</span></span><br><span class="line"><span class="css">                0<span class="selector-tag">px</span> <span class="selector-tag">-12px</span> 6<span class="selector-tag">px</span> <span class="selector-id">#08f</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们会发现当鼠标进入这个div时，文字阴影一瞬间出现</p><p><img src="/images/css3-11/2.png" alt="效果图"></p><p>接着，我们修改hover效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    div &#123;</span></span><br><span class="line"><span class="undefined">        transition: all 1s liner 0s;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，鼠标进入div时，背景阴影经过了1s的过渡过程。</p><p><img src="/images/css3-11/3.gif" alt="效果图"></p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://blog.csdn.net/JianXingDeFeng/article/details/78708274" target="_blank" rel="noopener">用css3的transition实现过渡动画</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;transition&lt;/code&gt;是网页上的过渡动画，在CSS3出现之前，网页上的动画大多是用flash实现的，但flash动画会产生很大的弊端，比如操作不便等等。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS小技巧" scheme="http://www.xiaoleon.cn/categories/CSS%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="transition" scheme="http://www.xiaoleon.cn/tags/transition/"/>
    
  </entry>
  
  <entry>
    <title>算法(1) 斐波那契数列</title>
    <link href="http://www.xiaoleon.cn/2018/02/09/algorithm-1/"/>
    <id>http://www.xiaoleon.cn/2018/02/09/algorithm-1/</id>
    <published>2018-02-09T06:22:54.000Z</published>
    <updated>2018-05-15T12:09:54.565Z</updated>
    
    <content type="html"><![CDATA[<p>本文针对斐波那契数列的求值方法，分别采用递归法、尾递归法和迭代法进行分析，并提供其相关的代码实现。</p><a id="more"></a><p>今天看到公司笔试的一道算法题，题目如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">存在如下斐波那契数列： </span><br><span class="line"></span><br><span class="line">0, 1, 1, 2, 3, 5, 8, 13, 21...</span><br><span class="line"></span><br><span class="line">请编写函数，计算数列中第n项的值。</span><br></pre></td></tr></table></figure><h3 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h3><p>经过简单思考后，我们可以很容易的想到，可以采用递归的方式进行代码编写，因为第<code>n</code>项的值等于第<code>n-1</code>项和第<code>n-2</code>项的和，实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fib(n - <span class="number">2</span>) + Fib(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>.callee(n - <span class="number">1</span>) + <span class="built_in">arguments</span>.callee(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、尾递归"><a href="#二、尾递归" class="headerlink" title="二、尾递归"></a>二、尾递归</h3><p>然而，这种方式进行<code>n</code>值较大的计算时，非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（<code>stack overflow</code>）。这时，我们可以考虑采用<strong>尾递归</strong>的模式，实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fib</span>(<span class="params">n, ret1 = <span class="number">0</span>, ret2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> ret1;</span><br><span class="line">    <span class="keyword">return</span> Fib(n - <span class="number">1</span>, ret2, ret1 + ret2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过尾递归的方式，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。前面的代码需要保存<code>2n</code>个数据记录，复杂度<code>O(n)</code>。如果改成尾递归，只保留<code>3</code>个数据记录，复杂度<code>O(1)</code>。</p><p>尾递归实现的方式，在思路上采用了从前往后计算的方法，等效于使用了一个正向的<code>while</code>循环。而前面的递归采用的是从后往前倒推的方式。</p><h3 id="三、迭代法"><a href="#三、迭代法" class="headerlink" title="三、迭代法"></a>三、迭代法</h3><p>我们还可以采用一个迭代的方法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> [num1, num2, num3] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        [num3, num1, num2] = [num1 + num2, num2, num1 + num2];</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代实现的方法其实与尾递归是一个道理，迭代法比较通俗易懂，而且和尾递归比较起来，因为不用开辟栈空间，所以相对而言，迭代法的效率是最高的。</p><h3 id="四、生成器"><a href="#四、生成器" class="headerlink" title="四、生成器"></a>四、生成器</h3><p>学习了Generator生成器后，发现还可以采用生成器的方案来完成，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Fib</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [pre, cur] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        [pre, cur] = [cur, pre + cur];</span><br><span class="line">        <span class="keyword">yield</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> Fib()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://es6.ruanyifeng.com/#docs/function#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%EF%BC%9F" target="_blank" rel="noopener">ESMAScript 6 入门 —— 阮一峰</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文针对斐波那契数列的求值方法，分别采用递归法、尾递归法和迭代法进行分析，并提供其相关的代码实现。&lt;/p&gt;
    
    </summary>
    
      <category term="算法分析" scheme="http://www.xiaoleon.cn/categories/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
    
      <category term="斐波那契数列" scheme="http://www.xiaoleon.cn/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    
      <category term="递归" scheme="http://www.xiaoleon.cn/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="尾递归" scheme="http://www.xiaoleon.cn/tags/%E5%B0%BE%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>微信(1) 小程序初体验</title>
    <link href="http://www.xiaoleon.cn/2018/02/01/wx-1/"/>
    <id>http://www.xiaoleon.cn/2018/02/01/wx-1/</id>
    <published>2018-02-01T07:50:13.000Z</published>
    <updated>2018-02-02T12:48:52.132Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开。这也体现了“用完即走”的理念，用户无需担心安装应用过多的问题。应用将无处不在，随时可用，但又无须安装卸载。</p><a id="more"></a><p>本文对微信小程序的架构进行了简要的介绍，让我们尽可能对小程序有个全局的认知，包括小程序的框架、目录结构、开发步骤等等。</p><p>小程序的开发实际上就是不同页面的展示（视图），以及实现“页面上用户交互事件”、“页面间切换逻辑”、“数据存储及网络调用”等事务和逻辑处理的过程。</p><hr><h3 id="一、小程序执行的生命周期"><a href="#一、小程序执行的生命周期" class="headerlink" title="一、小程序执行的生命周期"></a>一、小程序执行的生命周期</h3><p>一个完整的小程序执行的生命周期如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.onLaunch -&gt; app.onShow -&gt; page1.onLoad -&gt; page1.onShow -&gt; page1.onReady</span><br><span class="line">(打开程序，第一个页面page1加载完成)</span><br><span class="line">-&gt; page1.onHide -&gt; page2.onLoad -&gt; page2.onShow -&gt; page2.onReady</span><br><span class="line">(从第一个页面新打开page2)</span><br><span class="line">-&gt; page2.onUnload -&gt; page1.onShow -&gt; ... -&gt; app.onUnload</span><br><span class="line">(关闭page2，返回page1，...退出小程序)</span><br></pre></td></tr></table></figure><p>一个page的生命周期从<code>onLoad</code>开始，整个生命周期内<code>onLoad</code>、<code>onReady</code>、<code>onUnload</code>这三个事件仅执行一次，而<code>onHide</code>和<code>onShow</code>在每次页面隐藏和显示时都会触发。当用户手动触发退出时，小程序仅触发<code>app.onHide</code>，下次进入小程序时会触发<code>app.onShow</code>以及当前<code>page.onShow</code>。仅当小程序在后台运行超过一定时间未被唤醒、或者用户手动在小程序的控制栏里点击退出程序、或者小程序内存占用过大被关闭时，小程序将被销毁，会触发<code>app.onUnload</code>事件。</p><hr><h3 id="二、小程序的线程架构"><a href="#二、小程序的线程架构" class="headerlink" title="二、小程序的线程架构"></a>二、小程序的线程架构</h3><p>每个小程序分为两个线程，<code>view</code>和<code>appServer</code>。其中<code>view</code>负责解析渲染页面（<code>wxml</code>和<code>wxss</code>），而<code>appServer</code>线程负责运行<code>js</code>。<code>appServer</code>线程运行在<code>jsCore</code>中（安卓下运行在<code>X5</code>中，开发工具中运行在<code>nwjs</code>中）。由于js不跑在<code>web-view</code>里，就不能直接操纵DOM和BOM，这就是小程序没有window全局变量的原因。</p><ul><li><p>view线程</p><p>  wxss + wxml</p><p>  ios：safari</p><p>  Android：X5浏览器</p><p>  开发工具：chrome</p></li><li><p>appServer线程</p><p>  JS</p><p>  ios：JavaScriptCore</p><p>  Android：X5内核</p><p>  开发工具：nwjs</p></li></ul><hr><h3 id="三、小程序开发步骤"><a href="#三、小程序开发步骤" class="headerlink" title="三、小程序开发步骤"></a>三、小程序开发步骤</h3><p>理解小程序的线程架构后，我们可以归纳出一个小程序开发的主要步骤，涉及两大步骤：</p><ul><li><p>创建小程序实例（定义、配置及页面执行关联）。即编写3个app前缀的文件，它们共同描述了整个小程序主体逻辑、生命周期及页面构成、样式等。小程序实例将由<code>appServer</code>线程执行。</p></li><li><p>创建页面（页面结构和事务处理逻辑）。在小程序中一个完整的页面（page）是由<code>.js</code>、<code>.json</code>、<code>.wxml</code>、<code>.wxss</code>这四个文件组成，每个界面<code>.js</code>和<code>.wxml</code>是必选项，其他两项是可选项。小程序页面由<code>view</code>线程执行。</p></li></ul><hr><h3 id="四、MINA框架"><a href="#四、MINA框架" class="headerlink" title="四、MINA框架"></a>四、MINA框架</h3><p>微信团队为小程序提供的框架命名为MINA应用框架。MINA框架通过封装微信客户端提供的文件系统、网络通信、任务管理、数据安全等基础功能，对上层提供一整套JavaScript API，让开发者能够非常方便地使用微信客户端提供的各种基础功能与能力，快速构建一个应用。</p><p>小程序框架示意图如下</p><p><img src="/images/wx-1/mina.jpg" alt="小程序MINA框架示意图"></p><p>通过框架图我们可以看到两大部分：在页面视图层，wxml是MINA提供的一套类似html标签的语言以及一系列基础组件。开发者使用wxml文件来搭建页面的基本视图结构，使用wxss文件来控制页面的展现样式。AppService应用逻辑层时MINA的服务中心，由微信客户端启用异步线程单独加载运行。页面渲染所需的数据、页面交互处理逻辑都在AppService中实现。MINA框架中的AppService使用JavaScript来编写交互逻辑、网络请求、数据处理，但不能使用JavaScript中的DOM操作。小程序中的各个页面可以通过AppService实现数据管理、网络通信、应用生命周期管理和页面路由。</p><p>MINA框架为页面组件提供了<code>bindtap</code>、<code>bindtouchstart</code>等事件监听相关的属性，来与AppService中的事件处理函数绑定在一起，实现页面向AppService层同步用户交互数据。MINA框架同时提供了很多方法将AppService中的数据与页面进行单向绑定，当AppService中的数据变更时，会主动触发对应页面组件的重新渲染。MINA使用<code>virtual-dom</code>技术，加快了页面的渲染效率。</p><p>框架的核心是一个响应的数据绑定系统，它让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。我们通过下面的例子来看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- This is our View --&gt;</span><br><span class="line">&lt;view&gt; Hello &#123;&#123; name &#125;&#125;!&lt;/view&gt;</span><br><span class="line">&lt;button bindtap=&quot;changeName&quot;&gt;Click Me!&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">// This is out App Service</span><br><span class="line">// This is our data.</span><br><span class="line">var helloData = &#123;</span><br><span class="line">    name: &apos;WeChat&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">    data: helloData,</span><br><span class="line">    changeName: function(e) &#123;</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">            name: &apos;MINA&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>开发者通过框架将逻辑层数据中的<code>name</code>与视图层的<code>name</code>进行了绑定，所以在页面一打开的时候会显示“<code>Hello WeChat!</code>”。</p><p>当点击按钮的时候，视图层会发送<code>changeName</code>的事件给逻辑层，逻辑层找到对应的事件处理函数。</p><p>逻辑层执行了<code>setData</code>的操作，将<code>name</code>从<code>WeChat</code>变为<code>MINA</code>，因为该数据和视图层已经绑定了，从而视图层会自动改变为“<code>Hello MINA!</code>”。</p><p>微信小程序不仅在底层架构的运行机制上做了大量的优化，还在重功能（如page切换、tab切换、多媒体、网络连接等）上使用接近于native的组件承载。</p><p>综上所述，微信小程序MINA有着接近原生App的运行速度，做了大量的框架层面的优化设计，对Android端和IOS端做出了高度一致的呈现，并且准备了完备的开发和调试工具。</p><hr><h3 id="五、逻辑层"><a href="#五、逻辑层" class="headerlink" title="五、逻辑层"></a>五、逻辑层</h3><p>对于微信小程序而言，逻辑层就是所有<code>.js</code>脚本文件的集合。微信小程序在逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。</p><p>微信小程序开发框架的逻辑层是由JavaScript编写，在JavaScript的基础上，微信团队做了一些适当的修改，以便更高效地开发小程序。主要的修改包括：</p><ul><li><p>增加<code>app</code>和<code>page</code>方法，进行程序和页面的注册</p></li><li><p>提供丰富的API，如扫一扫、支付等微信特有能力</p></li><li><p>每个页面有独立的作用域，并提供模块化能力</p></li></ul><p>小程序逻辑层由js编写，但并非运行在浏览器中，所以JavaScript在Web中的一些能力都将无法使用，比如<code>document</code>、<code>window</code>等，这也给我们的开发带来相应的挑战。</p><p>开发者编写的所有代码最终将会打包成一份JavaScript，并在小程序启动时运行，直到小程序销毁。这类似于ServiceWorker或Webpack，所以逻辑层也称之为AppService。</p><hr><h3 id="六、视图层"><a href="#六、视图层" class="headerlink" title="六、视图层"></a>六、视图层</h3><p>框架的视图层由WXML（WeiXin Markup Language）与WXSS（WeiXin Style Sheet）编写，由组件来进行展示。对于微信小程序而言，视图层就是所有的<code>.wxml</code>文件与<code>.wxss</code>文件的集合：</p><ul><li><p><code>.wxml</code>文件用于描述页面的结构</p></li><li><p><code>.wxss</code>文件用于描述页面的样式</p></li></ul><p>微信小程序在逻辑层将数据进行处理后发送给视图层展现出来，同时接受视图层的事件反馈。</p><p>视图层以给定的样式展现数据并反馈给逻辑层，而数据展现是以组件来进行的。组件（Component）是视图的基本组成单元。</p><hr><h3 id="七、数据层"><a href="#七、数据层" class="headerlink" title="七、数据层"></a>七、数据层</h3><p>数据层包括临时数据或缓存、文件存储、网络存储与调用。</p><h4 id="1-页面临时数据或缓存"><a href="#1-页面临时数据或缓存" class="headerlink" title="1. 页面临时数据或缓存"></a>1. 页面临时数据或缓存</h4><p>在<code>Page()</code>中，我们要使用<code>setData</code>函数来将数据从逻辑层发送到视图层，同时改变对应的<code>this.data</code>的值。</p><p><strong>注意</strong></p><ul><li><p>直接修改<code>this.data</code>无效，无法改变页面的状态，还会造成数据不一致</p></li><li><p>单次设置的数据不能超过1024KB，请尽量避免一次设置过多的数据</p></li></ul><p><code>setData()</code>函数的参数接受一个对象。以<code>key</code>，<code>value</code>的形式表示将<code>this.data</code>中的<code>key</code>对应的值改变成<code>value</code>。其中<code>key</code>可以非常灵活，包括以数据路径的形式给出，如<code>array[2].message</code>，<code>a.b.c.d</code>，并且无须在<code>this.data</code>中预先定义。</p><h4 id="2-文件存储（本地存储）"><a href="#2-文件存储（本地存储）" class="headerlink" title="2. 文件存储（本地存储）"></a>2. 文件存储（本地存储）</h4><p>使用数据API接口，如下所示：</p><ul><li><p><code>wx.getStorage</code>：获取本地数据缓存</p></li><li><p><code>wx.setStorage</code>：设置本地数据缓存</p></li><li><p><code>wx.clearStorage</code>：清理本地数据缓存</p></li></ul><h4 id="3-网络存储或调用"><a href="#3-网络存储或调用" class="headerlink" title="3. 网络存储或调用"></a>3. 网络存储或调用</h4><p>上传或下载文件API接口如下：</p><ul><li><p><code>wx.request</code>：发起网络请求</p></li><li><p><code>wx.uploadFile</code>：上传文件</p></li><li><p><code>wx.downloadFile</code>：下载文件</p></li></ul><p>调用URL的API接口如下：</p><ul><li><p><code>wx.navigateTo</code>：新窗口打开页面</p></li><li><p><code>wx.redirectTo</code>：原窗口打开页面</p></li></ul><hr><h3 id="八、小程序加载运行"><a href="#八、小程序加载运行" class="headerlink" title="八、小程序加载运行"></a>八、小程序加载运行</h3><p>整个微信小程序、用户使用加载的流程示意图如下所示：</p><p><img src="/images/wx-1/1.png" alt="小程序发布与运行加载的流程"></p><p>小程序通过微信团队审核发布后，会同步到微信云端。最终用户通过某个入口，关注到该小程序。第一次运行时要经过短暂的代码下载过程（将所有资源下载到本地），即可在用户的微信中运行。</p><p>小程序在用户的微信中启动，相当于开启一个<code>webview</code>，这与HTML5不一样，在一定的时间内除非手动关闭，即使返回打开另一个小程序，原来的小程序也一直以后台的形式运行在内存里，即在后台运行。</p><p>小程序的版本更新将在启动时进行。首先与微信客户端版本进行对比是否有新版本，若有则小程序更新后再运行；否则，直接使用本地资源运行。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《小程序，巧应用（微信小程序开发实战）——熊普江 谢宇华》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开。这也体现了“用完即走”的理念，用户无需担心安装应用过多的问题。应用将无处不在，随时可用，但又无须安装卸载。&lt;/p&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="http://www.xiaoleon.cn/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://www.xiaoleon.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="MINA" scheme="http://www.xiaoleon.cn/tags/MINA/"/>
    
  </entry>
  
  <entry>
    <title>Web(4) Nginx设置动态Proxy_Pass</title>
    <link href="http://www.xiaoleon.cn/2018/02/01/web-4/"/>
    <id>http://www.xiaoleon.cn/2018/02/01/web-4/</id>
    <published>2018-02-01T02:48:29.000Z</published>
    <updated>2018-02-01T12:41:24.418Z</updated>
    
    <content type="html"><![CDATA[<p>前端开发过程中，我们为了避免与后端进行接口联调时反复修改请求地址，通常会采用服务器地址相对路径的方法，以<code>../rest/api/</code>的模式请求前端文件所在服务器的<code>http://192.168.1.100/rest/api</code>接口。这样可以规避开发阶段（<code>develop</code>）和生产阶段（<code>production</code>）代码不一致的问题，但是在接口联调阶段（<code>debug</code>），特别是前后端由不同的人开发的情况下，则需要使用代理服务器进行转发。</p><a id="more"></a><hr><h3 id="一、问题所在"><a href="#一、问题所在" class="headerlink" title="一、问题所在"></a>一、问题所在</h3><p>通常情况下我们的nginx配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest/api/ &#123;</span><br><span class="line">        proxy_pass  http://192.168.1.100/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接口复杂的情况下，我们的<code>location</code>匹配地址可能会出现较多个。而且因为工作需要，我们可能会同时与多个后台开发者进行接口联调，那么可能会出现如下的nginx配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest/api/ &#123;</span><br><span class="line">        proxy_pass  http://192.168.1.100/rest/api/;</span><br><span class="line">        #proxy_pass  http://192.168.1.101/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest2/api2/ &#123;</span><br><span class="line">        proxy_pass  http://192.168.1.100/rest2/api2/;</span><br><span class="line">        #proxy_pass  http://192.168.1.101/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest3/api3/ &#123;</span><br><span class="line">        proxy_pass  http://192.168.1.100/rest3/api3/;</span><br><span class="line">        #proxy_pass  http://192.168.1.101/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、修改方法"><a href="#二、修改方法" class="headerlink" title="二、修改方法"></a>二、修改方法</h3><p>为了工作方便，我们可能会将不同后台开发人员的地址以注释的方式记录在nginx配置文件内，需要切换后台服务器时，修改配置项中的注释内容，然后执行<code>nginx -s reload</code>来重启nginx服务。</p><p>那么，既然配置文件中有大量的重复地址信息，比如<code>http://192.168.1.100</code>，我们是不是可以把它提取出来作为nginx变量呢？然后<code>proxy_pass</code>读取它，这样在修改文件时只需要修改一个地方即可。</p><p>按照如下方式进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    set $host &apos;192.168.1.100&apos;;</span><br><span class="line">    #set $host &apos;192.168.1.101&apos;;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest/api/ &#123;</span><br><span class="line">        proxy_pass  http://$host/rest/api/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest2/api2/ &#123;</span><br><span class="line">        proxy_pass  http://$host/rest2/api2/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest3/api3/ &#123;</span><br><span class="line">        proxy_pass  http://$host/rest3/api3/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务后，<strong>nginx不报错，但是代理无效</strong>，无法访问。接着使用<code>geo</code>、<code>map</code>，<strong>均无法正常进行代理转发</strong>。</p><p>最后发现可以使用<code>upstream</code>模式实现此项功能，修改后的配置文件如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">upstream host &#123;</span><br><span class="line">    server  192.168.1.100;</span><br><span class="line">    #server  192.168.1.101;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest/api/ &#123;</span><br><span class="line">        proxy_pass  http://host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest2/api2/ &#123;</span><br><span class="line">        proxy_pass  http://host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /rest3/api3/ &#123;</span><br><span class="line">        proxy_pass  http://host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次精简一点，采用正则匹配的方式进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">upstream host &#123;</span><br><span class="line">    server  192.168.1.100;</span><br><span class="line">    #server  192.168.1.101;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root  D:\project\branch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ /rest(.*)/api(.*)/ &#123;</span><br><span class="line">        rewrite /rest(.*)/api(.*)/ /rest$1/api$2/ break;</span><br><span class="line">        proxy_pass  http://host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样采用正则匹配方式后，不仅可以匹配原有的<code>/rest1/api1/</code>、<code>/rest2/api2/</code>、<code>/rest3/api3/</code>，还可以匹配诸如<code>/project/rest1/api1/</code>等等前面含有项目文件路径的<code>location</code>。</p><p>等后期有时间，再研究一下nginx的<code>rewrite</code>、<code>upstream</code>详细使用方法。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="http://blog.csdn.net/a19860903/article/details/49914131" target="_blank" rel="noopener">proxy_set_header设置Host为$proxy_host，$host与$local_host的区别</a></p></li><li><p><a href="https://www.cnblogs.com/luxianghao/p/6807081.html" target="_blank" rel="noopener">Nginx中的proxy_pass和rewrite</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端开发过程中，我们为了避免与后端进行接口联调时反复修改请求地址，通常会采用服务器地址相对路径的方法，以&lt;code&gt;../rest/api/&lt;/code&gt;的模式请求前端文件所在服务器的&lt;code&gt;http://192.168.1.100/rest/api&lt;/code&gt;接口。这样可以规避开发阶段（&lt;code&gt;develop&lt;/code&gt;）和生产阶段（&lt;code&gt;production&lt;/code&gt;）代码不一致的问题，但是在接口联调阶段（&lt;code&gt;debug&lt;/code&gt;），特别是前后端由不同的人开发的情况下，则需要使用代理服务器进行转发。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Nginx配置" scheme="http://www.xiaoleon.cn/tags/Nginx%E9%85%8D%E7%BD%AE/"/>
    
      <category term="proxy_pass" scheme="http://www.xiaoleon.cn/tags/proxy-pass/"/>
    
  </entry>
  
  <entry>
    <title>Web(3) GraphQL深入理解</title>
    <link href="http://www.xiaoleon.cn/2018/01/31/web-3/"/>
    <id>http://www.xiaoleon.cn/2018/01/31/web-3/</id>
    <published>2018-01-31T03:44:38.000Z</published>
    <updated>2018-03-12T14:11:22.827Z</updated>
    
    <content type="html"><![CDATA[<p>在前一篇文章中我们对GraphQL有了基础的了解，我们直到GraphQL使用<code>Schema</code>来描述数据，并通过指定和实现GraphQL规范定义了支持<code>Schema</code>查询的<code>DSQL （Domain Specific Query Language，领域特定查询语言）</code>。<code>Schema</code>帮助将复杂的业务模型数据抽象拆分成细粒度的基础数据结构，而<code>DSQL</code>的实现则赋予了前端开发者自由组织和定制请求数据的能力。</p><a id="more"></a><p>如果以一张图来表示的话，可以将GraphQL看做一条以<strong>通用基础业务数据模型</strong>为基础、将传统后端服务和前端页面紧密且自由地联系在一起的纽带。</p><p><img src="/images/web-3/1.png" alt="GraphQL"></p><p>为什么GraphQL的<code>Schema</code>能够表示出服务器所支持的复杂业务模型数据，GraphQL的Query又是怎样赋予前端开发者对数据的定制能力，本文将通过分析和理解GraphQL的设计来解答这些问题。</p><hr><h3 id="一、GraphQL的设计"><a href="#一、GraphQL的设计" class="headerlink" title="一、GraphQL的设计"></a>一、GraphQL的设计</h3><p>GraphQL由以下组件构成</p><ul><li><p>类型系统（<code>Type System</code>）</p></li><li><p>查询语言（<code>Query Language</code>）</p></li><li><p>执行语义（<code>Execution Semantics</code>）</p></li><li><p>静态验证（<code>Static Validation</code>）</p></li><li><p>类型检查（<code>Type Introspection</code>）</p></li></ul><p>作为将数据模型和具体接口实现解耦的<code>DSL</code>，GraphQL的基础组件，也是它最重要的组件之一就是类型系统。</p><hr><h3 id="二、类型系统"><a href="#二、类型系统" class="headerlink" title="二、类型系统"></a>二、类型系统</h3><p>可以将GraphQL的类型系统分为标量类型（<code>Scalar Types</code>，标量类型）和其他高级数据类型，标量类型即可以表示最细粒度数据结构的数据类型，可以和JavaScript的原始类型对应。</p><p>GraphQL规范目前规定支持的标量类型有</p><ul><li><p><code>Int</code>：整数，对应JavaScript的<code>Number</code></p></li><li><p><code>Float</code>：浮点数，对应JavaScript的<code>Number</code></p></li><li><p><code>String</code>：字符串，对应JavaScript的<code>String</code></p></li><li><p><code>Boolean</code>：布尔值，对应JavaScript的<code>Boolean</code></p></li><li><p><code>ID</code>：ID值，是一个序列化后值唯一的字符串，可以视作对应ES6新增的<code>Symbol</code></p></li></ul><p>其他高级数据类型包括</p><h4 id="1-对象（Object）"><a href="#1-对象（Object）" class="headerlink" title="1. 对象（Object）"></a>1. 对象（Object）</h4><p>用于描述层级或者树形数据结构。对于树形数据结构来说，叶子字段的类型都是标量数据类型。几乎所有的GraphQL类型都是对象类型。<code>Object</code>类型有一个<code>name</code>字段，以及一个很重要的<code>fields</code>字段。<code>fields</code>字段可以描述出一个完整的数据结构。例如一个表示地址数据机构的GraphQL对象为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AddressType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'Address'</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">        street: &#123;</span><br><span class="line">            type: GraphQLString</span><br><span class="line">        &#125;,</span><br><span class="line">        number: &#123;</span><br><span class="line">            type: GraphQLInt</span><br><span class="line">        &#125;,</span><br><span class="line">        formatted: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            resolve(obj) &#123;</span><br><span class="line">                <span class="keyword">return</span> obj.name + <span class="string">' '</span> + obj.street;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-接口（Interface）"><a href="#2-接口（Interface）" class="headerlink" title="2. 接口（Interface）"></a>2. 接口（Interface）</h4><p>接口用于描述多个类型的通用字段，例如一个表示实体数据结构的GraphQL接口为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EntityType = <span class="keyword">new</span> GraphQLInterfaceType(&#123;</span><br><span class="line">    name: <span class="string">'Entity'</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">        name: &#123;</span><br><span class="line">            type: GraphQLString</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-联合（Union）"><a href="#3-联合（Union）" class="headerlink" title="3. 联合（Union）"></a>3. 联合（Union）</h4><p>联合类型用于描述某个字段能够支持的所有返回类型以及具体请求真正的返回类型，例如一个表示宠物（可以是猫或者狗）的GraphQL联合类型为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PetType = <span class="keyword">new</span> GraphQLUnionType(&#123;</span><br><span class="line">    name: <span class="string">'Pet'</span>,</span><br><span class="line">    types: [DogType, CatType],</span><br><span class="line">    resolveType(value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="keyword">return</span> DogType;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            <span class="keyword">return</span> CatType;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-枚举（Enum）"><a href="#4-枚举（Enum）" class="headerlink" title="4. 枚举（Enum）"></a>4. 枚举（Enum）</h4><p>用于表示可枚举数据结构的类型，例如表示RGB色值的GraphQL枚举类型为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RGBType = <span class="keyword">new</span> GraphQLEnumType(&#123;</span><br><span class="line">    name: <span class="string">'RGB'</span>,</span><br><span class="line">    values: &#123;</span><br><span class="line">        RED: &#123;</span><br><span class="line">            value: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        GREEN: &#123;</span><br><span class="line">            value: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        BLUE: &#123;</span><br><span class="line">            value: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="5-输入对象（Input-Object）"><a href="#5-输入对象（Input-Object）" class="headerlink" title="5. 输入对象（Input Object）"></a>5. 输入对象（Input Object）</h4><p>是为了查询（<code>query</code>）而定义的数据类型，不直接重用<code>Object</code>类型是因为<code>Object</code>的字段可能存在循环引用，或者字段引用了不能作为查询输入对象的接口和联合类型。参考实现中的<code>Input Object</code>的定义代码为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type GraphQLInputType = </span><br><span class="line">    GraphQLScalarType |</span><br><span class="line">    GraphQLEnumType |</span><br><span class="line">    GraphQLInputObjectType |</span><br><span class="line">    GraphQLList&lt;GraphQLInputType&gt; |</span><br><span class="line">    GraphQLNonNull&lt;</span><br><span class="line">        GraphQLScalarType |</span><br><span class="line">        GraphQLEnumType |</span><br><span class="line">        GraphQLInputObjectType |</span><br><span class="line">        GraphQLList&lt;GraphQLInputType&gt;</span><br><span class="line">    &gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isInputType</span>(<span class="params">type: ?GraphQLType</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> namedType = getNamedType(type);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        namedType <span class="keyword">instanceof</span> GraphQLScalarType ||</span><br><span class="line">        namedType <span class="keyword">instanceof</span> GraphQLEnumType ||</span><br><span class="line">        namedType <span class="keyword">instanceof</span> GraphQLInputObjectType</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>Object</code>、<code>Interface</code>和<code>Union</code>三种类型是不能作为输入对象类型的。</p><h4 id="6-列表（List）"><a href="#6-列表（List）" class="headerlink" title="6. 列表（List）"></a>6. 列表（List）</h4><p>列表是其它类型的封装，通常用于对象字段的描述。例如下面<code>PersonType</code>类型数据的<code>parents</code>和<code>children</code>字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PersonType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'Person'</span>,</span><br><span class="line">    fields: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">        parents: &#123;</span><br><span class="line">            type: <span class="keyword">new</span> GraphQLList(Person)</span><br><span class="line">        &#125;,</span><br><span class="line">        children: &#123;</span><br><span class="line">            type: <span class="keyword">new</span> GraphQLList(Person)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="7-不能为Null（Non-Null）"><a href="#7-不能为Null（Non-Null）" class="headerlink" title="7. 不能为Null（Non-Null）"></a>7. 不能为Null（Non-Null）</h4><p><code>Non-Null</code>强制类型的值不能为<code>null</code>，并且在请求出错时一定会报错。可以用于必须保证值不能为<code>null</code>的字段。例如数据库的id字段不能为<code>null</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RowType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'Row'</span>,</span><br><span class="line">    fields: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">        id: &#123;</span><br><span class="line">            type: <span class="keyword">new</span> GraphQLNonNull(GraphQLString)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>还有一种重要的数据类型，即<code>schema</code>类型，它描述了后端服务器能够提供的数据支持。</p><hr><h3 id="三、查询语言"><a href="#三、查询语言" class="headerlink" title="三、查询语言"></a>三、查询语言</h3><p>类型系统对应我们开头提到的<code>Schema</code>，是对服务器端数据的描述，而查询语言则解耦了前端开发者与后端接口的依赖。前端开发者利用查询语言可以自由地组织和定制系统能够提供的业务数据。</p><p>GraphQL的一个查询请求被称为一份<code>query</code>文档（<code>query document</code>），即GraphQL服务能够解析验证并执行的一串请求字符串。<code>query</code>由操作（<code>Operation</code>）和片段（<code>Fragments</code>）组成。一个<code>query</code>可以包含多个操作和片段。只有包含操作的<code>query</code>才会被GraphQL服务执行。但是不包含操作，只包含<code>query</code>也会被GraphQL服务解析验证，这样一份片段就可以在多个<code>query</code>文档内使用。</p><p>只包含一个操作的<code>query</code>可以不带操作名称或者使用简写形式（即<code>query</code>关键字加名）。<code>query</code>包含多个操作时，所有操作都必须带上名称。</p><h4 id="1-操作（Operation）"><a href="#1-操作（Operation）" class="headerlink" title="1. 操作（Operation）"></a>1. 操作（Operation）</h4><p>GraphQL规范支持两种操作</p><ul><li><p><code>query</code>：仅获取数据（<code>fetch</code>）的只读请求</p></li><li><p><code>mutation</code>：获取数据后还有写操作的请求</p></li></ul><p>在官方提供的参考实现中我们会发现还有一种操作<code>subscription</code>，这是为了处理订阅更新这种比较复杂的实时数据更新场景而设计的操作，不过目前这种操作还处于试验阶段，不建议在生产环境使用。</p><p>查询请求的模型可以用下面的图来表示</p><p><img src="/images/web-3/2.svg" alt="查询请求模型"></p><h4 id="2-选择集合（Selection-Sets）"><a href="#2-选择集合（Selection-Sets）" class="headerlink" title="2. 选择集合（Selection Sets）"></a>2. 选择集合（Selection Sets）</h4><p>选择集合表示当前选中的数据内容，格式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Field               // 字段名</span><br><span class="line">    FragmentSpread      // 片段展开</span><br><span class="line">    InlineFragment      // 内联片段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-字段（Field）"><a href="#3-字段（Field）" class="headerlink" title="3. 字段（Field）"></a>3. 字段（Field）</h4><p>字段格式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias:name(argument:value)</span><br></pre></td></tr></table></figure><p>其中<code>alias</code>是字段的别名，即结果中显示的字段名称。</p><p><code>name</code>为字段名称，对应<code>schema</code>中定义的<code>fields</code>字段名。</p><p><code>argument</code>为参数名称，对应<code>schema</code>中定义的<code>fields</code>字段的参数名称。</p><p><code>value</code>为参数值，值的类型对应标量类型的值。</p><p>例如这样的请求：<code>http://example.taobao.com/?query={banner{backgroundURL:bg,biaoti:slogan}}</code>，其中<code>backgroundURL</code>就是<code>bg</code>字段的别名。</p><h4 id="4-片段（Fragment）"><a href="#4-片段（Fragment）" class="headerlink" title="4. 片段（Fragment）"></a>4. 片段（Fragment）</h4><p>片段时GraphQL的主要组合数据结构，通过片段可以重用重复的字段选择，减少<code>query</code>中的重复内容。片段又分为<code>FragmentSpread</code>和<code>InlineFragment</code>。例如没有片段时需要这样编写<code>query</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">query noFragments &#123;</span><br><span class="line">    user(id: 4) &#123;</span><br><span class="line">        friends(first: 10) &#123;</span><br><span class="line">            id</span><br><span class="line">            name</span><br><span class="line">            profilePic(size: 50)</span><br><span class="line">        &#125;</span><br><span class="line">        mutualFriends(first: 10) &#123;</span><br><span class="line">            id</span><br><span class="line">            name</span><br><span class="line">            profilePic(size: 50)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>query</code>中存在下列重复的选择集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    profilePic(size: 50)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用片段化简为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">query withFragments &#123;</span><br><span class="line">    user(id: 4) &#123;</span><br><span class="line">        friends(first: 10) &#123;</span><br><span class="line">            ...friendFields</span><br><span class="line">        &#125;</span><br><span class="line">        mutualFriends(first: 10) &#123;</span><br><span class="line">            ...friendFields</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment friendFields on User &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    profilePic(size: 50)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用片段时需要加上<code>...</code>操作符表示展开片段内容。</p><p>内联片段示例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">query inlineFragmentTyping &#123;</span><br><span class="line">    profiles(handles: [&quot;zuck&quot;, &quot;cocacola&quot;]) &#123;</span><br><span class="line">        handle</span><br><span class="line">        ... on User &#123;</span><br><span class="line">            friends &#123;</span><br><span class="line">                count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ... on Page &#123;</span><br><span class="line">            likers &#123;</span><br><span class="line">                count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-指令（Directives）"><a href="#5-指令（Directives）" class="headerlink" title="5. 指令（Directives）"></a>5. 指令（Directives）</h4><p>指令要解决的是<code>query</code>执行时字段参数无法覆盖的情况，例如引入或者忽略某个字段。指令为GraphQL执行添加了更多的信息。</p><p>指令实例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query hasConditionalFragment($condition: Boolean) &#123;</span><br><span class="line">    ...maybeFragment @include(if: $condition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment maybeFragment on Query &#123;</span><br><span class="line">    me &#123;</span><br><span class="line">        name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>include</code>指令表示只有在<code>if</code>参数为true时才引入片段表示的字段。</p><p><code>skip</code>指令表示在<code>if</code>参数为true时忽略片段中的字段。</p><p>熟悉了<strong>类型系统</strong>和<strong>查询语言</strong>，我们就可以用GraphQL来实现应用层的数据请求了。</p><p>其他三个GraphQL组件更偏向于DSL的实现和原理，本文不再做详细介绍。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="http://graphql.cn/" target="_blank" rel="noopener">GraphQL | 一种为你的API而生的查询语言</a></p></li><li><p><a href="http://taobaofed.org/blog/2016/03/10/graphql-in-depth/" target="_blank" rel="noopener">深入理解GraphQL</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前一篇文章中我们对GraphQL有了基础的了解，我们直到GraphQL使用&lt;code&gt;Schema&lt;/code&gt;来描述数据，并通过指定和实现GraphQL规范定义了支持&lt;code&gt;Schema&lt;/code&gt;查询的&lt;code&gt;DSQL （Domain Specific Query Language，领域特定查询语言）&lt;/code&gt;。&lt;code&gt;Schema&lt;/code&gt;帮助将复杂的业务模型数据抽象拆分成细粒度的基础数据结构，而&lt;code&gt;DSQL&lt;/code&gt;的实现则赋予了前端开发者自由组织和定制请求数据的能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="GraphQL" scheme="http://www.xiaoleon.cn/tags/GraphQL/"/>
    
      <category term="网络接口" scheme="http://www.xiaoleon.cn/tags/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Web(2) GraphQL简要介绍</title>
    <link href="http://www.xiaoleon.cn/2018/01/31/web-2/"/>
    <id>http://www.xiaoleon.cn/2018/01/31/web-2/</id>
    <published>2018-01-31T01:27:52.000Z</published>
    <updated>2018-03-12T14:11:39.042Z</updated>
    
    <content type="html"><![CDATA[<p>GraphQL是什么？GraphQL是一种既用于API的查询语言，也满足数据查询的运行时语言。GraphQL对你的API中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获取它需要的数据，而且没有任何冗余，也让API更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p><a id="more"></a><p>GraphQL is a query language created by Facebook in 2012 which provides a common interface between the client and the server for data fetching and manipulations.</p><p>The client ask for various data from the GraphQL server via queries. The response format is described in the query and defined by the client instead of the server: they are called client-specified queries. The structure of the data is not hardcoded as in traditional REST APIs - this makes retrieving data from the server more efficient for the client.</p><hr><h3 id="一、场景分析"><a href="#一、场景分析" class="headerlink" title="一、场景分析"></a>一、场景分析</h3><p>现有的数据业务场景一般是这样的，业务方提出需求，然后寻找开发资源，由后端提供数据，让前端实现各种不同的业务视图。这样的做法存在很多的重复劳动，如果能够将其中通用的内容抽取出来提供给各个业务方反复使用，必然能够节省宝贵的开发时间和开发人力。</p><p>前端的解决方案时将视图组件化，各个业务线既可以是组件的使用者，也可以是组件的生产者。那么问题来了，前端通过组件实现了跨业务的复用，后端接口如何相应地提高开发效率呢？</p><p>我们假设某个业务需要以下数据内容a：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    user(id: 3500401) &#123;</span><br><span class="line">        id,</span><br><span class="line">        name,</span><br><span class="line">        isViewerFriend</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显这不是一个JSON，但是我们仍然可以看懂它表示的是查询<code>id</code>为3500401用户的<code>id</code>、<code>name</code>和<code>isViewerFriend</code>信息。用户信息对于各个业务都是通用的，假设另外一个业务需要这样的用户信息b：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    user(id: 3500401) &#123;</span><br><span class="line">        name,</span><br><span class="line">        profilePicture(size: 50) &#123;</span><br><span class="line">            uri,</span><br><span class="line">            width,</span><br><span class="line">            height</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下，我们发现只是少了两个字段，多了一个字段而已。如果要实现我们的目标，即复用同一个接口来支持这两种业务的话，会有以下几种做法：</p><ul><li><p>用同一个接口，这个接口提供了所有数据。这样做的好处是实现起来简单，但缺点是对业务做判断的逻辑会增多，而且对于业务来说，响应内容中有些数据根本用不到</p></li><li><p>使用参数来区分不同的业务方并返回相应的数据。好处仍然是实现简单，虽然不会有用不到的数据返回，但是仍然需要增加业务逻辑判断，会造成以后维护的困难。</p></li></ul><p>此外，这样还会造成不同业务之间的强依赖，每次发布都需要各个业务线一起测试和回归。不重用接口则没法提高开发效率，重用接口则会有这些问题。</p><hr><h3 id="二、GraphQL解决方案"><a href="#二、GraphQL解决方案" class="headerlink" title="二、GraphQL解决方案"></a>二、GraphQL解决方案</h3><p>我们知道，用户信息对应的数据模型是固定的，每次请求其实是对这些数据做了过滤和筛选。对应到数据库操作，就是数据的查询操作。如果客户端也能够像“查询”一样发送请求，那不就可以从后端接口这个大的“大数据库”去过滤筛选业务需要的数据了吗？</p><p>GraphQL就是基于这样的思想来设计的。上面提到的（a）和（b）类型的数据结构就是GraphQL的查询内容。使用上面的查询，GraphQL服务器会分别返回如下响应内容。</p><p>a查询对应的响应</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">3500401</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Jing Chen"</span>,</span><br><span class="line">        <span class="attr">"isViewerFriend"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b查询对应的响应</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Jing Chen"</span>,</span><br><span class="line">        <span class="attr">"profilePicture"</span>: &#123;</span><br><span class="line">            <span class="attr">"uri"</span>: <span class="string">"http://example/pic.jpg"</span>,</span><br><span class="line">            <span class="attr">"width"</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="attr">"height"</span>: <span class="number">50</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要改变查询内容，前端就能定制服务器返回的响应内容，这就是GraphQL的客户端制定查询（<code>Client Specified Queries</code>）。</p><hr><h3 id="三、使用NodeJS实现GraphQL服务器"><a href="#三、使用NodeJS实现GraphQL服务器" class="headerlink" title="三、使用NodeJS实现GraphQL服务器"></a>三、使用NodeJS实现GraphQL服务器</h3><p>我们先按照官方文档搭建一个GraphQL服务器</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> graphql-intro &amp;&amp; <span class="built_in">cd</span> ./graphql-intro</span><br><span class="line">npm init</span><br><span class="line">npm install express --save</span><br><span class="line">npm install babel --save</span><br><span class="line">npm install babel-register --save</span><br><span class="line"><span class="built_in">type</span> <span class="built_in">nul</span>&gt; ./server.js</span><br><span class="line"><span class="built_in">type</span> <span class="built_in">nul</span>&gt; ./index.js</span><br></pre></td></tr></table></figure><p><code>index.js</code>的内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel-register'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./server.js'</span>);</span><br></pre></td></tr></table></figure><p><code>server.js</code>的内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="keyword">let</span> PORT = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/graphql'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">'Hello'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = app.listen(PORT, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> host = server.address().address;</span><br><span class="line">    <span class="keyword">let</span> port = server.address().port;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`GraphQL listening at http:<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后执行代码</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon index.js</span><br></pre></td></tr></table></figure><p>测试是否有效</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:<span class="number">3000</span>/graphql           // =&gt; 'Hello'</span><br></pre></td></tr></table></figure><p>接着编写<code>GraphQL Schema</code>（<code>Schema</code>是GraphQL请求的入口，用户的GraphQL请求会对应到具体的<code>Schema</code>），首先回忆一下GraphQL请求是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query getHightScore &#123; score &#125;</span><br></pre></td></tr></table></figure><p>上面的请求是获取<code>getHightScore</code>的<code>score</code>值。也可以加上查询条件，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query getHightScore(limit: 10) &#123; score &#125;</span><br></pre></td></tr></table></figure><p>这样的请求格式就是GraphQL中的<code>schema</code>。通过<code>schema</code>可以定义服务器的响应内容。</p><p>接下来我们在项目中使用graphql</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install graphql --save</span><br><span class="line">npm install body-parser --save</span><br></pre></td></tr></table></figure><p>graphql的npm包会负责组装服务器<code>schema</code>并处理GraphQL请求。</p><h4 id="1-创建schema"><a href="#1-创建schema" class="headerlink" title="1. 创建schema"></a>1. 创建schema</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">nul</span>&gt; ./schema.js</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    GraphQLObjectType,</span><br><span class="line">    GraphQLSchema,</span><br><span class="line">    GraphQLInt</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'graphql'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> schema = <span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    query: <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">        name: <span class="string">'RootQueryType'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            count: &#123;</span><br><span class="line">                type: GraphQLInt,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> schema;</span><br></pre></td></tr></table></figure><p>这段代码创建了一个<code>GraphQL Schema</code>实例。这个<code>schema</code>的顶级查询对象会返回一个<code>RootQueryType</code>对象，这个<code>RootQueryType</code>对象有一个整数类型的<code>count</code>域。GraphQL除了支持整数（<code>Interger</code>），还支持字符串（<code>String</code>）、列表（<code>List</code>）等多种类型的数据。</p><h4 id="2-连接schema"><a href="#2-连接schema" class="headerlink" title="2. 连接schema"></a>2. 连接schema</h4><p>下面将<code>GraphQL Schema</code>和服务器连接起来，我们需要修改<code>server.js</code>为如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> schema <span class="keyword">from</span> <span class="string">'./schema'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">'graphql'</span>;</span><br><span class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">'body-parser'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="keyword">let</span> PORT = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.text(&#123; <span class="attr">text</span>: <span class="string">'application/graphql'</span> &#125;));</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/graphql'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    graphql(schema, req.body)</span><br><span class="line">        .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">            res.send(<span class="built_in">JSON</span>.stringify(result, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = app.listen(PORT, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> host = server.address().address;</span><br><span class="line">    <span class="keyword">let</span> port = server.address().port;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`GraphQL listening at http:<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>验证下效果</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "query RootQueryType &#123; count &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p>结果如下图所示</p><p><img src="/images/web-2/1.png" alt="验证效果"></p><p>GraphQL查询还可以省略掉<code>queryRootQueryType</code>前缀</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "&#123; count &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p><img src="/images/web-2/2.png" alt="验证效果"></p><h4 id="3-检查服务器"><a href="#3-检查服务器" class="headerlink" title="3. 检查服务器"></a>3. 检查服务器</h4><p>GraphQL最让人感兴趣的是可以编写GraphQL查询来让GraphQL服务器告诉我们它支持哪些查询，即官方文档提到的自检性（<code>introspection</code>）。</p><p>例如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "&#123; __schema &#123; queryType &#123; name, fields &#123; name, description &#125; &#125; &#125; &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p><img src="/images/web-2/3.png" alt="验证效果"></p><p>而我们实际的GraphQL查询请求内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    __schema &#123;</span><br><span class="line">        queryType &#123;</span><br><span class="line">            name,</span><br><span class="line">            fields &#123;</span><br><span class="line">                name,</span><br><span class="line">                description</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上每个GraphQL根域都会自动加上一个<code>__schema</code>域，这个域有一个子域叫<code>queryType</code>。我们可以通过查询这些域来了解GraphQL服务器支持哪些查询。我们可以修改<code>schema.js</code>来为<code>count</code>域加上<code>description</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> schema = <span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    query = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">        name: <span class="string">'RootQueryType'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            count: &#123;</span><br><span class="line">                type: GraphQLInt,</span><br><span class="line">                description: <span class="string">'The count!'</span>,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>验证一下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "&#123; __schema &#123; queryType &#123; name, fields &#123; name, description &#125; &#125; &#125; &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p><img src="/images/web-2/4.png" alt="验证效果"></p><h4 id="4-变异（mutation）"><a href="#4-变异（mutation）" class="headerlink" title="4. 变异（mutation）"></a>4. 变异（mutation）</h4><p>GraphQL中将对数据的修改操作称为<code>mutation</code>，在GraphQL Schema中按照如下形式来定义一个<code>mutation</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let schema = new GraphQLSchema(&#123;</span><br><span class="line">    query: ...</span><br><span class="line">    mutation: //TODO</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>mutation</code>查询和普通查询请求（<code>query</code>）的重要区别在于<code>mutation</code>操作是序列化执行的。例如GraphQL规范中给出的示例，服务器一定会序列化下面的<code>mutation</code>请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    first: changeTheNumber(newNumber: 1) &#123;</span><br><span class="line">        theNumber</span><br><span class="line">    &#125;,</span><br><span class="line">    second: changeTheNumber(newNumber: 3) &#123;</span><br><span class="line">        theNumber</span><br><span class="line">    &#125;,</span><br><span class="line">    third: changeTheNumber(newNumber: 2) &#123;</span><br><span class="line">        theNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求结束时<code>theNumber</code>的值会是<code>2</code>。下面为我们的服务器添加一个<code>mutation</code>查询，修改<code>schema.js</code>为如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    GraphQLObjectType,</span><br><span class="line">    GraphQLSchema,</span><br><span class="line">    GraphQLInt</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'graphql'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> schema = <span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    query: <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">        name: <span class="string">'RootQueryType'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            count: &#123;</span><br><span class="line">                type: GraphQLInt,</span><br><span class="line">                <span class="comment">// Add description</span></span><br><span class="line">                description: <span class="string">'The count!'</span>,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// Note: this is the newly added mutation query</span></span><br><span class="line">    mutation: <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">        name: <span class="string">'RootMutationType'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            updateCount: &#123;</span><br><span class="line">                type: GraphQLInt,</span><br><span class="line">                description: <span class="string">'Update the count'</span>,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> schema;</span><br></pre></td></tr></table></figure><p>验证一下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST -H "Content-<span class="built_in">Type</span>:application/graphql" -d "mutation RootMutationType &#123; updateCount &#125;" http://localhost:<span class="number">3000</span>/graphql</span><br></pre></td></tr></table></figure><p><img src="/images/web-2/5.png" alt="验证效果"></p><hr><h3 id="四、业务场景模拟"><a href="#四、业务场景模拟" class="headerlink" title="四、业务场景模拟"></a>四、业务场景模拟</h3><p>搭建好GraphQL服务器后，我们来模拟下业务场景的实际需求，对于电商平台来说，最常用的就是商品信息，假设目前的商品数据模型可以用下面的<code>GraphQLObject</code>来表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ItemType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'item'</span>,</span><br><span class="line">    descriptions: <span class="string">'item'</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">        id: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item id'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        title: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item title'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        price: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item price'</span>,</span><br><span class="line">            resolve: <span class="function"><span class="keyword">function</span>(<span class="params">root, param, context</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (root.price / <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        pic: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item pic url'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>查询商品的<code>schema</code>如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ItemSchema = <span class="keyword">new</span> GraphQLSchema(&#123;</span><br><span class="line">    query: &#123;</span><br><span class="line">        name: <span class="string">'ItemQuery'</span>,</span><br><span class="line">        description: <span class="string">'query item'</span>,</span><br><span class="line">        fields: &#123;</span><br><span class="line">            item: &#123;</span><br><span class="line">                type: ItemType,</span><br><span class="line">                description: <span class="string">'item'</span>,</span><br><span class="line">                args: &#123;</span><br><span class="line">                    id: &#123;</span><br><span class="line">                        type: GraphQLInt,</span><br><span class="line">                        required: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params">root, obj, ctx</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">yield</span> ItemService(obj[<span class="string">'id'</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过如下<code>query</code>可以查询id为12345的商品信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query ItemQuery(id: 12345) &#123;</span><br><span class="line">    id</span><br><span class="line">    title</span><br><span class="line">    price</span><br><span class="line">    pic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>商品详情页展示时需要加上优惠价格信息，我们可以修改<code>ItemType</code>，为它加上一个<code>promotion</code>字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ItemType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'item'</span>,</span><br><span class="line">    description: <span class="string">'item'</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">        id: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item id'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        title: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item title'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        price: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item price'</span>,</span><br><span class="line">            resolve: <span class="function"><span class="keyword">function</span>(<span class="params">root, param, context</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (root.price / <span class="number">100</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        pic: &#123;</span><br><span class="line">            type: GraphQLString,</span><br><span class="line">            description: <span class="string">'item pic url'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        promotion: &#123;</span><br><span class="line">            type: GraphQLInt,</span><br><span class="line">            description: <span class="string">'promotion price'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>商品详情页的查询为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query ItemQuery(id: 12345) &#123;</span><br><span class="line">    id</span><br><span class="line">    title</span><br><span class="line">    price</span><br><span class="line">    pic</span><br><span class="line">    promotion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ItemSchema</code>无需修改，只要在<code>ItemService</code>的返回结果中加上<code>promotion</code>就可以了。这样接口的修改对于原有业务是透明的，而新的业务也能基于已有的代码快速开发和迭代。</p><p>再假设有一个新的页面，只需要用到宝贝的图片信息，业务方可以使用下面的查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query ItemQuery(id: 12345) &#123;</span><br><span class="line">    id</span><br><span class="line">    pic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器代码不用做任何修改。</p><p>至此我们已经实现了一个GraphQL基础服务器。在实际业务中数据模型肯定会更加复杂，而GraphQL也提供了强大的类型系统（<code>Type System</code>）让我们能够轻松地描述各种数据类型，它提供的抽象层能够为依赖同一套数据模型的不同业务方提供灵活的数据支持。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="http://graphql.cn/" target="_blank" rel="noopener">GraphQL | 一种为你的API而生的查询语言</a></p></li><li><p><a href="https://www.jianshu.com/p/0343b83e0cbb" target="_blank" rel="noopener">GraphQL 初体验：GraphQL + Node.js</a></p></li><li><p><a href="http://taobaofed.org/blog/2015/11/26/graphql-basics-server-implementation/" target="_blank" rel="noopener">Node.js服务端实践之GraphQL初探</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GraphQL是什么？GraphQL是一种既用于API的查询语言，也满足数据查询的运行时语言。GraphQL对你的API中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获取它需要的数据，而且没有任何冗余，也让API更容易地随着时间推移而演进，还能用于构建强大的开发者工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Web知识学习" scheme="http://www.xiaoleon.cn/categories/Web%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="GraphQL" scheme="http://www.xiaoleon.cn/tags/GraphQL/"/>
    
      <category term="网络接口" scheme="http://www.xiaoleon.cn/tags/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>JS(12) 客户端存储</title>
    <link href="http://www.xiaoleon.cn/2018/01/30/js-12/"/>
    <id>http://www.xiaoleon.cn/2018/01/30/js-12/</id>
    <published>2018-01-30T14:55:14.000Z</published>
    <updated>2018-02-02T12:48:05.179Z</updated>
    
    <content type="html"><![CDATA[<p>Web应用允许使用浏览器提供的API实现将数据存储到用户的电脑上，这种客户端存储相当于赋予了Web浏览器记忆功能。比方说，Web应用就可以用这种方式来“记住”用户的偏好甚至是用户所有的状态信息，以便准确地“回忆”起用户上一次访问的位置。客户端存储遵循“同源策略”，因此不同站点的页面是无法互相读取对方存储的数据，而同一站点的不同页面之间是可以互相共享存储数据的，它为我们提供了一种通信机制，例如，一个页面上填写的表单数据可以显示在另外一个页面中。Web应用可以选择它们存储数据的有效期：比如采用临时存储可以让数据保存至当前窗口关闭或者浏览器退出；采用永久存储，可以将数据永久地存储到硬盘上，数年或者数月不失效。</p><a id="more"></a><p>客户端存储有以下几种形式：</p><ul><li><p>Web存储</p><p>Web存储最初作为HTML5的一部分被定义成API形式，但是后来被剥离出来作为独立的一份标准了。Web存储标准所描述的API包含localStorage对象和sessionStorage对象，这两个对象实际上是持久化关联数组，是名值对的映射表，“名”和“值”都是字符串。Web存储易于使用、支持大容量数据存储同时兼容当前所有的主流浏览器，但是不兼容早期浏览器。</p></li><li><p>cookie</p><p>cookie是一种早期的客户端存储机制，起初是针对服务器端脚本设计使用的。尽管在客户端提供了非常繁琐的JavaScript API来操作cookie，但它们难用至极，而且只适合存储少量文本数据。不仅如此，任何以cookie形式存储的数据，不论服务器端是否需要，每一次HTTP请求都会把这些数据传输到服务器端。cookie目前仍然被客户端程序员大量使用的一个重要原因是：所有新旧浏览器都支持它。但是，随着Web Storage的普及，cookie终将会回归到最初的形态：作为一种被服务器脚本使用的客户端存储机制。</p></li><li><p>IE User Data</p><p>微软在IE5及以后的IE浏览器中实现了它专属的客户端存储机制——“userData”。userData可以实现一定量的字符串数据存储，对于IE8以前的IE浏览器，可以将其用做是Web存储的替代方案。</p></li><li><p>离线Web应用</p><p>HTML5标准中定义了一组“离线Web应用”API，用以缓存Web页面以及相关资源（脚本、CSS文件、图像等）。它实现的是将Web应用整体存储在客户端，而不仅仅是存储数据。它能够让Web应用“安装”在客户端，这样一来，哪怕网络部可用的时候Web应用依然是可用的。</p></li><li><p>Web数据库</p><p>为了能够让开发者像使用数据库那样来操作大量数据，很多主流的浏览器纷纷在其中开始集成客户端数据库功能。Safari、Chrome和Opera都内置了SQL数据库的客户端API。遗憾的是，这类API的标准化工作以失败告终，并且Firefox和IE也都不打算实现这种API。目前还有一种正在标准化的数据库API，称为“索引数据库API”（indexed database API）。调用该API返回的是一个不包含查询语句的简单数据库对象。这两种客户端数据库API都是异步的，都是用了事件处理机制。</p></li></ul><hr><h3 id="一、localStorage和sessionStorage"><a href="#一、localStorage和sessionStorage" class="headerlink" title="一、localStorage和sessionStorage"></a>一、localStorage和sessionStorage</h3><p>实现了“Web存储”草案标准的浏览器在Window对象上定义了两个属性：localStorage和sessionStorage。这两个属性都代表同一个Storage对象——一个持久化关联数组，数组使用字符串来索引，存储的值也都是字符串形式的。Storage对象在使用上和一般的JavaScript对象没什么区别：设置对象的属性为字符串值，随后浏览器会将该值存储起来。localStorage和sessionStorage两者的区别在于存储的有效期和作用域的不同：数据可以存储多长时间以及谁拥有数据的访问权。</p><p>下面的代码使用的是localStorage，但是它对sessionStorage也同样适用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = localStorage.username;               <span class="comment">// 查询一个存储的值</span></span><br><span class="line">name = localStorage[<span class="string">'username'</span>];                <span class="comment">// 等价于数组表示法</span></span><br><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">    name = prompt(<span class="string">'What is your name?'</span>);        <span class="comment">// 询问客户一个问题</span></span><br><span class="line">    localStorage.username = name;               <span class="comment">// 存储用户的答案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代所有存储的name/value对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> localStorage) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = localStorage[name];             <span class="comment">// 查询每个名字对应的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Storage对象还定义了一些诸如存储、获取、遍历和删除的方法。“Web存储”草案标准指出，我们既可以存储结构化的数据（对象和数组），也可以存储原始类型数据，还可以存储诸如日期、正则表达式甚至文件对象在内的内置类型的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当存储一个数字的时候，会把它自动转换成一个字符串</span></span><br><span class="line"><span class="comment">// 但是，当获取该值的时候别忘记手动将其转换成数字类型</span></span><br><span class="line">localStorage.x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="built_in">parseInt</span>(localStorage.x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样地，存储一个日起类型数据的时候进行编码，获取的时候进行解码</span></span><br><span class="line">localStorage.lastRead = (<span class="keyword">new</span> <span class="built_in">Date</span>()).toUTCString();</span><br><span class="line"><span class="keyword">var</span> lastRead = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(localStorage.lastRead));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是哦那个JSON可以使得对基本数据类型编码的工作变得很方便</span></span><br><span class="line">localStorage.data = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(localStorage.data);</span><br></pre></td></tr></table></figure><h4 id="1-存储有效期和作用域"><a href="#1-存储有效期和作用域" class="headerlink" title="1. 存储有效期和作用域"></a>1. 存储有效期和作用域</h4><p>localStorage和sessionStorage的区别在于存储的有效期和作用域的不同。通过localStorage存储的数据是永久性的，除非Web应用可以删除存储的数据，或者用户通过设置浏览器配置来删除，否则数据将一直保存在用户的电脑上，永不过期。</p><p>localStorage的作用域是限定在文档源(document origin)级别的，文档源是通过协议、主机名以及端口三者来确定的，因此，下面每个url都拥有不同的文档源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com</span><br><span class="line">https://www.example.com</span><br><span class="line">http://static.example.com</span><br><span class="line">http://www.example.com:8000</span><br></pre></td></tr></table></figure><p>同源的文档间共享同样的localStorage数据（不论该源的脚本是否真正地访问localStorage）。它们可以互相读取对方的数据，甚至可以覆盖对方的数据。但是，非同源的文档间互相都不能读取或者覆盖对方的数据（即使它们运行的脚本是来自同一台第三方服务器也不行）。</p><p>需要注意的是localStorage的作用域也受浏览器供应商的限制。如果使用Firefox访问站点，那么下次用另一个浏览器（Chrome）再次访问的时候，那么本次是无法获取上次存储的数据的。</p><p>通过sessionStorage存储的数据和通过localStorage存储的数据的有效期也是不同的：前者的有效期和存储数据的脚本所在的最顶层的窗口或者是浏览器标签页是一样的。一旦窗口或者标签页被永久关闭了，那么所有通过sessionStorage存储的数据也都被删除了。（要注意的是，现代浏览器已经具备了重新打开最近关闭的标签页随后恢复上一次浏览的会话功能，因此，这些标签页以及与之相关的sessionStorage的有效期可能会更加长些）。</p><p>与localStorage一样，sessionStorage的作用域也是限定在文档中，因此非同源文档间都是无法共享sessionStorage的。不仅如此，sessionStorage的作用域还被限定在窗口中。如果同源的文档渲染在不同的浏览器标签页总，那么它们互相之间拥有的是各自的sessionStorage数据，无法共享；一个标签页中的脚本是无法读取或者覆盖由另一个标签页脚本写入的数据，哪怕这两个标签页渲染的是同一个页面，运行的是同一个脚本也不行。</p><p>要注意的是，这里提到的基于窗口作用域的sessionStorage指的窗口只是顶级窗口。如果一个浏览器标签页包含两个<code>&lt;iframe&gt;</code>元素，它们所包含的文档是同源的，那么这两者之间是可以共享sessionStorage的。</p><h4 id="2-存储API"><a href="#2-存储API" class="headerlink" title="2. 存储API"></a>2. 存储API</h4><p>localStorage和sessionStorage通常被当作普通的JavaScript对象使用：通过设置属性来存储字符串值，查询该属性来读取该值。除此之外，这两个对象还提供了更加正式的API。调用<code>setItem()</code>方法，将对应的名字和值传进去，可以实现数据存储。调用<code>getItem()</code>方法，将名字传进去，可以获取对应的值。调用<code>removeItem()</code>方法，将名字传进去，可以删除对应的数据。调用<code>clear()</code>方法，可以删除所有存储的数据。最后，使用<code>length</code>属性以及<code>key()</code>方法，传入<code>0 ~ length-1</code>的数字，可以枚举所有存储数据的名字。下面是一些使用localStorage的例子，这些代码对sessionStorage也适用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'x'</span>, <span class="number">1</span>);</span><br><span class="line">localStorage.getItem(<span class="string">'x'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; localStorage.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = localStorage.key(i);</span><br><span class="line">    <span class="keyword">var</span> name = localStorage.getItem(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">localStorage.removeItem(<span class="string">'x'</span>);</span><br><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure><p>尽管通过设置和查询属性能更加方便地存储和获取数据，但是有的时候还是不得不使用上面提到的这些方法的。比如说，其中<code>clear()</code>方法是唯一能删除存储对象中所有名值对的方法。同样的还有，removeItem()方法也是唯一通用的删除单个名值对的方式，因为IE8不支持delete操作符。</p><p>如果浏览器提供商完全实现了“Web存储”的标准，支持对象和数组类型的数据存储，那么就会又多了一个使用<code>setItem()</code>和<code>getItem()</code>这类方法的理由。对象和数组类型的值通常是可变的，因此存储对象要求存储它们的副本，以确保之后任何对这类对象的改变都不影响到存储的对象。同样的，在获取该对象的时候也要求获取的是该对象的副本，以确保以获取对象的改动不会影响到存储的对象。而这类操作如果使用基于属性的API就会令人困惑。考虑下面这段代码（假设浏览器已经支持了结构化数据的存储）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localStorage.o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;              <span class="comment">// 存储一个带有x属性的对象</span></span><br><span class="line">localStorage.o.x = <span class="number">2</span>;                   <span class="comment">// 试图去设置该对象的属性值</span></span><br><span class="line">localStorage.o.x;                       <span class="comment">// =&gt; 1: x没有变</span></span><br></pre></td></tr></table></figure><p>上述第二行代码想要设置存储的对象的属性值，但事实上，它获取到的只是存储的对象的副本，随后设置了该对象的属性值，然后就将该副本废弃了。真正存储的对象保持不变。像这样的情况，使用<code>getItem()</code>就不会这么让人困惑了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.getItem(<span class="string">'o'</span>).x = <span class="number">2</span>;        <span class="comment">// 我们并不想存储2</span></span><br></pre></td></tr></table></figure><p>最后，还有另外一个使用显式的机遇方法的存储API的理由就是：在还不支持“Web存储”标准的浏览器中，其他的存储机制的顶层API对其也是兼容的。下面这段代码使用cookie和IE userData来实现存储API。如果使用基于方法的API，当localStorage可用的时候就可以使用它编写代码，而当它在其他浏览器上不可用的时候依然可以依赖其他的存储机制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memory = <span class="built_in">window</span>.localStorage ||</span><br><span class="line">            (<span class="built_in">window</span>.UserDataStorage &amp;&amp; <span class="keyword">new</span> UserDataStorage()) ||</span><br><span class="line">            <span class="keyword">new</span> cookieStorage();</span><br><span class="line"><span class="keyword">var</span> username = memory.getItem(<span class="string">'username'</span>);</span><br></pre></td></tr></table></figure><h4 id="3-存储事件"><a href="#3-存储事件" class="headerlink" title="3. 存储事件"></a>3. 存储事件</h4><p>无论什么时候存储在localStorage和sessionStorage的数据发生改变，浏览器都会在其他对该数据可见的窗口对象上触发存储事件（但是，在对数据进行改变的窗口对象上是不会触发的）。如果浏览器有两个标签页都打开了来自同源的页面，其中一个页面在localStorage上存储了数据，那么另外一个标签页就会接收到一个存储事件。要记住的是sessionStorage的作用域是限制在顶层窗口的，因此对sessionStorage的改变只有当有相牵连的窗口的时候才会触发存储事件。还有要注意的是，只有当存储数据真正发生改变的时候才会触发存储事件。像给已经存在的存储项设置一个一模一样的值，亦或是删除一个本来就不存在的存储项都是不会触发存储事件的。</p><p>为存储事件注册处理程序可以通过<code>addEventListener()</code>方法（IE下使用<code>attachEvent()</code>方法）。在绝大多数浏览器下，还可以使用给window对象设置onstorage属性的方式。</p><p>与存储事件相关的事件对象有5个非常重要的属性（IE8不支持）：</p><ul><li><p>key</p><p>  被设置或者溢出的项的名字或者键名。如果调用的是clear()函数，那么该属性值为null。</p></li><li><p>newValue</p><p>  保存该项的新值；或者调用removeItem()时，该属性值为null。</p></li><li><p>oldValue</p><p>  改变或者删除该项前，保存该项原先的值；当插入一个新项的时候，该属性值为null。</p></li><li><p>storageArea</p><p>  这个属性值就好比是目标Window对象上的localStorage属性或者是sessionStorage属性。</p></li><li><p>url</p><p>  触发该存储变化脚本所在文档的url。</p></li></ul><p>最后要注意的是：localStorage和存储事件都是采用广播机制的，浏览器会对目前正在访问同样站点的所有窗口发送消息。举个例子，如果一个用户要求网站停止动画效果，那么站点可能会在localStorage中存储该用户的首选项，这样一来，以后再访问该站点的时候就自动停止动画效果了。因为存储了该首选项，导致了触发一个存储事件让其他展现统一站点的窗口也获得了这样的一个用户请求。再比如，一个基于Web的图片编辑应用，通常允许在其他的窗口中展示工作条。当用户选择一个工具的时候，应用就可以使用localStorage来存储当前的状态，然后通知其他窗口用户选择了新的工具。</p><hr><h3 id="二、cookie"><a href="#二、cookie" class="headerlink" title="二、cookie"></a>二、cookie</h3><p>cookie是指Web浏览器存储的少量数据，同时它是与具体的Web页面或者站点相关的。cookie最早是设计为被服务端所用的，从底层来看，作为HTTP协议的一种扩展实现它。cookie数据会自动在Web浏览器和Web服务器之间传输的，因此服务端脚本就可以读写存储在客户端的cookie值。</p><p>操作cookie的API很早就已经定义和实现了，因此该API的兼容性很好。但是，该API几乎形同虚设，根本没有提供诸如查询、设置、删除cookie的方法，所有这些操作都要通过以特殊格式的字符串形式读写Document对象的cookie属性来完成。每个cookie的有效期和作用域都可以通过cookie属性来分别指定。这些属性也是通过同一个cookie属性上以特殊格式的字符串来设定的。</p><h4 id="1-有效期和作用域"><a href="#1-有效期和作用域" class="headerlink" title="1. 有效期和作用域"></a>1. 有效期和作用域</h4><p>除了名和值，cookie还有一些可选的属性来控制cookie的有效期和作用域。cookie默认的有效期很短暂：它只能持续在Web浏览器的会话期间，一旦用户关闭浏览器，cookie保存的数据就丢失了。要注意的是：这与sessionStorage的有效期还是有区别的。cookie的作用域并不是局限在浏览器的单个窗口中，它的有效期和整个浏览器进程而不是单个浏览器窗口的有效期一致。要想延长cookie的有效期，可以通过设置<code>max-age</code>属性，但是必须要明确告诉浏览器cookie的有效期是多长（单位是秒）。一旦设置了有效期，浏览器就会将cookie数据存储在一个文件中，并且直到过了指定的有效期才会删除该文件。</p><p>和localStorage以及sessionStorage类似，cookie的作用域是通过文档源和文档路径来确定的。该作用域通过cookie的path和domain属性也是可配置的。默认情况下，cookie和创建它的Web页面有关，并对该Web页面以及和该Web页面同目录或者子目录的其他Web页面可见。比如，Web页面<code>http://www.example.com/catalog/index.html</code>页面创建了一个cookie，那么该cookie对<code>http://www.example.com/catalog/order.html</code>页面和<code>http://www.example.com/catalog/widgets/index.html</code>页面都是可见的，但它对<code>http://www.example.com/about.html</code>页面不可见。</p><p>默认的cookie的可见性行为满足了最常见的需求。不过，有的时候，我们可能希望让整个网站都能够使用cookie的值，而不管是哪个页面创建它的。比方说，当用户在一个页面表单中输入了它的邮件地址，我们想要将它保存下来，为了下次该用户回到这个页面填写表单，或者在网站其他页面的任何地方要求输入账单地址的时候，将其作为默认的邮件地址。要满足这样的需求，可以设置cookie的路径（设置cookie的path属性）。</p><p>这样一类，来自同一个Web服务器的Web页面，只要其url是以指定的路径前缀开始的，都可以共享cookie。例如，如果<code>http://www.example.com/catalog/widgets/index.html</code>页面创建了一个cookie，并且将改路径设置成“<code>/catalog</code>”，那么该cookie对于<code>http://www.example.com/catalog/order.html</code>页面也是可见的。或者，如果把路径设置成“<code>/</code>”，那么该cookie对任何<code>http://www.example.com</code>这台Web服务器上的页面都是可见的。</p><p>将cookie的路径设置成“<code>/</code>”等于是让cookie和localStorage拥有同样的作用域，同时当它请求该站点上任何一个Web页面的时候，浏览器都必须将cookie的名字和值传递给服务器。但是，要注意的是，cookie的path属性不能被用做访问控制机制。如果一个Web页面想要读取同一站点其他页面的cookie，只要简单地将其他页面以隐藏<code>&lt;iframe&gt;</code>的形式加在进来，随后读取对应文档的cookie就可以了。同源策略限制了跨站的cookie窥探，但是对于同一站点的文档它是完全合法的。</p><p>cookie的作用域默认由文档源限制。但是，有的大型网站想要子域之间能够互相共享cookie。比如，<code>order.example.com</code>域下的服务器想要读取<code>catalog.example.com</code>域下设置的cookie值。这个时候就需要通过设置cookie的domain属性来达到目的。如果<code>catalog.example.com</code>域下的一个页面创建了一个cookie，并将其path属性设置成“<code>/</code>”，其domain设置成“<code>.example.com</code>”，那么该cookie就对所有<code>catalog.example.com</code>、<code>orders.example.com</code>以及任何其他<code>example.com</code>域下的任何其他服务器都可见。如果没有为一个cookie设置域属性，那么domain属性的默认值是当前Web服务器的主机名。要注意的是，cookie的域只能设置为当前服务器的域。</p><p>最后要介绍的cookie属性是secure，它是一个布尔类型的属性，用来表明cookie的值以何种形式通过网络传递。cookie默认是以不安全的形式（通过普通的、不安全的HTTP连接）传递的。而一旦cookie被标识为“安全的”，那就只能当浏览器和服务器通过HTTPS或者其他的安全协议连接的时候才能传递它。</p><h4 id="2-保存cookie"><a href="#2-保存cookie" class="headerlink" title="2. 保存cookie"></a>2. 保存cookie</h4><p>要给当前文档设置默认有效期的cookie值，只须将cookie属性设置为一个字符串形式的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"version="</span> + <span class="built_in">encodeURIComponent</span>(<span class="built_in">document</span>.lastModified);</span><br></pre></td></tr></table></figure><p>下次读取cookie属性的时候，之前存储的名值对的数据就在文档的cookie列表中。由于cookie的名值中的值不允许包含分号、逗号和空白负，因此，在存储前一般可以采用<code>encodeURIComponent()</code>对值进行编码。相应的，读取cookie值的时候需要采用<code>decodeURIComponent()</code>函数解码。</p><p>以简单的名值对形式存储的cookie数据有效期只在当前Web浏览器的会话内，一旦用户关闭浏览器，cookie数据就丢失了。如果想要延长cookie的有效期，就需要设置<code>max-age</code>属性来指定cookie的有效期（单位是秒）。按照如下的字符串形式设置cookie属性即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=value; max-age=seconds</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setcookie</span>(<span class="params">name, value, daysToLive</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookie = name + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> daysToLive === <span class="string">'number'</span>)</span><br><span class="line">        cookie += <span class="string">"; max-age="</span> + (daysToLive * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">    <span class="built_in">document</span>.cookie = cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，如果要设置cookie的path、domain和secure属性，只须在存储cookie值前，以如下字符串形式追加在cookie值的后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; path=path</span><br><span class="line">; domain=domain</span><br><span class="line">; secure</span><br></pre></td></tr></table></figure><p>要改变cookie的值，就需要使用相同的名字、路径和域，但是新的值重新设置cookie的值。同样的，设置新的<code>max-age</code>属性就可以改变原来的cookie的有效期。</p><p>要删除一个cookie，需要使用相同的名字、路径和域，然后指定一个任意（非空）的值，并且将<code>max-age</code>属性指定为0，再次设置cookie。</p><h4 id="3-读取cookie"><a href="#3-读取cookie" class="headerlink" title="3. 读取cookie"></a>3. 读取cookie</h4><p>使用JavaScript表达式来读取cookie属性的时候，其返回的值是一个字符串，该字符串都是由一系列名值对组成，不同的名值对之间通过“分号和空格”分开，其内容包含了所有作用在当前文档的cookie。但是，它并不包含其他设置的cookie属性。通过<code>document.cookie</code>属性可以获取cookie的值，但是为了更好地查看cookie的值，一般会采用<code>split()</code>方法将cookie值中的名值对都分离出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getcookie</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookie = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> all = <span class="built_in">document</span>.cookie;</span><br><span class="line">    <span class="keyword">if</span> (all === <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> cookie;</span><br><span class="line">    <span class="keyword">var</span> list = all.split(<span class="string">'; '</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> cookie = list[i];</span><br><span class="line">        <span class="keyword">var</span> p = cookie.indexOf(<span class="string">'='</span>);</span><br><span class="line">        <span class="keyword">var</span> name = cookie.substring(<span class="number">0</span>, p);</span><br><span class="line">        <span class="keyword">var</span> value = cookie.substring(p + <span class="number">1</span>);</span><br><span class="line">        value = <span class="built_in">decodeURIComponent</span>(value);</span><br><span class="line">        cookie[name] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-cookie的局限性"><a href="#4-cookie的局限性" class="headerlink" title="4. cookie的局限性"></a>4. cookie的局限性</h4><p>cookie的设计初衷是给服务端脚本用来存储少量数据的，该数据会在每次请求一个相关的URL时传递到服务器中。RFC2965鼓励浏览器供应商对cookie的数目和大小不做限制。可是，要知道，该标准不允许浏览器保存超过300个cookie，为每个Web服务器保存的cookie数不能超过20个，而且，每个cookie保存的数据不能超过4KB。实际上，现代浏览器允许cookie总数超过300个，但是部分浏览器对单个cookie大小仍然有4KB的限制。</p><h4 id="5-cookie相关的存储"><a href="#5-cookie相关的存储" class="headerlink" title="5. cookie相关的存储"></a>5. cookie相关的存储</h4><p>下例展示了如何实现基于cookie的一系列存储API方法。该例定义了一个cookieStorage函数，通过将<code>max-age</code>和<code>path</code>属性传递给该构造函数，就会返回一个对象，然后就可以像使用localStorage和sessionStorage一样来使用这个对象了。但是要注意的是，该例并没有实现存储事件，因此，当设置和查询cookieStorage对象的属性的时候，不会实现自动保存和获取对应的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cookieStorage.js</span></span><br><span class="line"><span class="comment">本类实现像localStorage和sessionStorage一样的存储API，不同的是，基于HTTP cookie实现它</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cookieStorage</span>(<span class="params">maxage, path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookie = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> cookie = &#123;&#125;;</span><br><span class="line">        <span class="keyword">var</span> all = <span class="built_in">document</span>.cookie;</span><br><span class="line">        <span class="keyword">if</span> (all === <span class="string">''</span>)</span><br><span class="line">            <span class="keyword">return</span> cookie;</span><br><span class="line">        <span class="keyword">var</span> list = all.split(<span class="string">'; '</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> cookie = list[i];</span><br><span class="line">            <span class="keyword">var</span> p = cookie.indexOf(<span class="string">'='</span>);</span><br><span class="line">            <span class="keyword">var</span> name = cookie.substring(<span class="number">0</span>, p);</span><br><span class="line">            <span class="keyword">var</span> value = cookie.substring(p + <span class="number">1</span>);</span><br><span class="line">            value = <span class="built_in">decodeURIComponent</span>(value);</span><br><span class="line">            cookie[name] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cookie;</span><br><span class="line">    &#125; ());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> keys = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> cookie) </span><br><span class="line">        keys.push(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.length = keys.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.key = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span> || n &gt;= keys.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> keys[n];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getItem = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cookie[name] || <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setItem = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(key <span class="keyword">in</span> cookie)) &#123;</span><br><span class="line">            keys.push(key);</span><br><span class="line">            <span class="keyword">this</span>.length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cookie[key] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cookie = key + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxage)</span><br><span class="line">            cookie += <span class="string">'; max-age='</span> + maxage;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (path)</span><br><span class="line">            cookie += <span class="string">'; path='</span> + path;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.cookie = cookie;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.removeItem = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(key <span class="keyword">in</span> cookie))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> cookie[key];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys[i] === key) &#123;</span><br><span class="line">                keys.splice(i, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.length--;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.cookie = key + <span class="string">'=; max-age=0'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++)</span><br><span class="line">            <span class="built_in">document</span>.cookie = keys[i] + <span class="string">'=; max-age=0'</span>;</span><br><span class="line"></span><br><span class="line">        cookies = &#123;&#125;;</span><br><span class="line">        keys = [];</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、应用程序存储和离线Web应用"><a href="#三、应用程序存储和离线Web应用" class="headerlink" title="三、应用程序存储和离线Web应用"></a>三、应用程序存储和离线Web应用</h3><p>HTML5中新增了“应用程序缓存”，允许Web应用将应用程序自身本地保存到用户的浏览器中。不像localStorage和sessionStorage只是保存Web应用程序相关的数据，它是将应用程序自身保存起来——应用程序所需要运行的所有文件（HTML、CSS、JavaScript、图片等）。“应用程序缓存”和一般的浏览器缓存不同：它不会随着用户清除浏览器缓存而被清除。同时，换存起来的应用程序也不会像一般固定大小的缓存那样，老数据会被最近一次访问的新数据代替掉。它其实不是临时存储在缓存中：应用程序更像是被“安装”在那里，除非被用户“卸载”或者“删除”它们，否则它们就会一直“驻扎”在那里。所以，总的来说，“应用程序缓存”在真正意义上不是缓存，更好地说法应该称之为“应用程序存储”。</p><p>让Web应用能够实现“本地安装”的目的是要保证它们能够在离线状态（比如，当在飞机上或者手机没信号的时候）下依然可以访问。将自己“安装”到应用程序缓存中的Web应用，在离线状态下使用localStorage来保存应用相关的数据，同时还具备一套同步机制，在再次回到在线状态的时候，能够将存储的数据传输给服务器。我们先来结合扫下应用程序是如何将自己“安装”到应用程序缓存中的。</p><h4 id="1-应用程序缓存清单"><a href="#1-应用程序缓存清单" class="headerlink" title="1. 应用程序缓存清单"></a>1. 应用程序缓存清单</h4><p>想要将应用程序“安装”到应用程序缓存中，首先要创建一个清单：包含了所有应用程序依赖的所有URL列表。然后，通过在应用程序主HTML页面的<code>&lt;html&gt;</code>标签中设置manifest属性，指向该清单文件就可以了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"myapp.appcache"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>...<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>...<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>清单文件中的首行内容必须以“CACHE MANIFEST”字符串开始。其余就是要缓存的文件URL列表，一行一个URL。相对路径的URL都相对于清单文件的URL。会忽略内容中的空行，会作为注释而忽略以“#”开始的行。注释前面可以有空格，但是在同一行注视后面是不允许有非空字符的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"></span><br><span class="line">myapp.html</span><br><span class="line">myapp.js</span><br><span class="line">myapp.css</span><br><span class="line">images/background.png</span><br></pre></td></tr></table></figure><blockquote><p><strong>缓存清单的MIME类型</strong></p><p>应用程序缓存清单文件约定以.appcache作为文件扩展名。但是，这也仅仅只是个约定而已，Web服务器真正识别清单文件的方式是通过“text/cache-manifest”这个MIME类型的一个清单。如果服务器将清单文件的Content-Type的头信息设置成其他MIME类型，那么就不会缓存应用程序了。因此，可能需要对Web服务器做一定的配置来使用这个MIME类型，比如，在Web应用目录下创建Apache服务器的一个.htaccess文件。</p></blockquote><p>清单文件包含要缓存的应用的标识。如果一个Web应用有很多Web页面（用户可以访问多个HTML页面），那么每个HTML页面就需要设置<code>&lt;html manifest=&gt;</code>属性来指向清单文件。事实上，将这些不同的页面都指向同一个清单文件，可以很清楚地表达它们都是需要换存起来的，同时它们又是来自同一个Web应用的。如果一个应用只有少量的HTML页面，那么一般会把这些页面都显式地列在清单文件中。</p><p>像之前提到的，一个简单的清单必须列出Web应用依赖的所有资源。一旦一个Web应用首次下载下来并缓存，之后的任何加在请求就都来自缓存。从缓存中去载入一个应用资源的时候，就要求它请求的任何资源务必要在清单中。不会载入不在清单中的资源。这种政策有点离线的味道。如果一个简单的缓存起来的应用能够从缓存中载入并运行，那么它也可以在浏览器的离线状态下运行。通常情况下，很多复杂的Web应用无法将它们依赖的所有资源都缓存起来。但是，如果它们同时也有一个复杂的清单的话，它们仍然可以使用应用程序缓存。</p><h4 id="2-复杂的清单"><a href="#2-复杂的清单" class="headerlink" title="2. 复杂的清单"></a>2. 复杂的清单</h4><p>一个应用从应用程序缓存中载入的时候，只有其清单文件中列举出来的资源文件会载入。前面例子中的清单文件一次列举一个资源的URL。事实上，清单文件还有比这更复杂的语法，例句资源的方式也还有另外两种。在清单文件中可以使用特殊的区域头来标识该头信息之后清单项的类型。像该例中列举的简单缓存项事实上都属于“CACHE”区域，这也是默认的区域。另外两种区域是以“NETWORK”和“FALLBACK”头信息开始的。</p><p>“NETWORK”区域标识了该URL中的资源从不缓存，总要通过网络获取。通常，会将一些服务端的脚本资源放在“NETWORK”区域中，而实际上该区域中的资源的URL都只是URL前缀，用来表示以此URL前缀开头的资源都应该要通过网络加载。当然，如果浏览器处于离线状态，那么这些资源都将获取失败。“NETWORK”区域中的URL还支持“*”通配符。该通配符表示对任何不在清单中的资源，浏览器都将通过网络加载。这实际上违背了这样一条规则：缓存应用程序必须要在清单中列举的所有应用相关的资源！</p><p>“FALLBACK”区域中的清单项每行都包含两个URL。第二个URL是指需要加载和存储在缓存中的资源，第一个URL是一个前缀。任何能够匹配到该前缀的URL都不会换存起来，但是可能的话，它们会从网络中载入。如果从网络中载入这样一个URL失败的话，就会使用第二个URL指定的缓存资源来代替，从缓存中获取。想象一个Web应用包含一定数量的视频教程。这些视频都很大，显然把它们缓存到本地是不合适的。因此，在离线状态下，通过清单文件中的fallback区域，就可以使用一些基于文本的帮助文件来代替了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"></span><br><span class="line">CACHE:</span><br><span class="line">myapp.html</span><br><span class="line">myapp.css</span><br><span class="line">myapp.js</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">videos/ offline_help.html</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">cgi/</span><br></pre></td></tr></table></figure><h4 id="3-缓存的更新"><a href="#3-缓存的更新" class="headerlink" title="3. 缓存的更新"></a>3. 缓存的更新</h4><p>当一个Web应用从缓存中载入的时候，所有与之相关的文件也是直接从缓存中获取。在线状态下，浏览器会异步地检查清单文件是否有更新。如果有更新，新的清单文件以及清单中列举的所有文件都会下载下来重新保存到应用程序缓存中。但是，要注意的是，浏览器只是检查清单文件，而不会去检查缓存的文件是否有更新：只检查清单文件。比如，如果修改了一个缓存的JavaScript文件，并且要想让该文件生效，就必须去更新下清单文件。由于应用程序依赖的文件列表其实并没有变化，因此最简单的方式就是更新版本号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># myapp version 1</span><br><span class="line">myapp.html</span><br><span class="line">myapp.js</span><br></pre></td></tr></table></figure><p>同样，如果想要让Web应用从缓存中“卸载”，就要在服务器端删除清单文件，使得请求该文件的时候返回HTTP404无法找到的错误，同时，修改HTML文件以便它们与该清单列表断开链接。</p><p>要注意的是，浏览器检查清单文件以及更新缓存的操作是异步的，可能是在从缓存中载入应用之前，也有可能同时进行。因此，对于简单的Web应用而言，在更新清单文件之后，用户必须载入应用两次才能保证最新的版本生效：第一次是从缓存中载入老版本随后更新缓存；第二次才从缓存中载入最新的版本。</p><p>浏览器在更新缓存过程中会触发一系列事件，可以通过注册处理程序来跟踪这个过程同时提供反馈给用户。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">applicationCache.onupdateready = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reload = confirm(<span class="string">"A new version of this application is available\n"</span> +</span><br><span class="line">                        <span class="string">"and will be used the next time you reload.\n"</span> +</span><br><span class="line">                        <span class="string">"Do you want to reload now?"</span>);</span><br><span class="line">    <span class="keyword">if</span> (reload)</span><br><span class="line">        location.reload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，该事件处理程序是注册在ApplicationCache对象上的，该对象是Window的applicationCache属性的值。支持应用程序缓存的浏览器会定义该属性。此外，除了上面例子中的updateready事件之外，还有其他7种应用程序缓存事件可以监控。下面展示了一个简单的处理程序通过显示对应的消息来通知用户缓存更新的进度，以及当前缓存的状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面所有的事件处理程序都是用此函数来显示状态消息</span></span><br><span class="line"><span class="comment">// 由于都是通过调用status函数来显示状态，因此所有处理程序都返回false来阻止浏览器</span></span><br><span class="line"><span class="comment">// 显示其默认状态消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">status</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将消息输出到id为“statusline”的文档元素中</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'statusline'</span>).innerHTML = msg;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每当应用程序载入的时候，都会检查该清单文件</span></span><br><span class="line"><span class="comment">// 也总会首先触发“checking”事件</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onchecking = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'Check for a new version.'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果清单文件没有改动，同时应用程序也已经缓存了</span></span><br><span class="line"><span class="comment">// “noupdate”事件会被触发，整个过程结束</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onnoupdate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'This version is up-to-date.'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果还未缓存应用程序，或者清单文件有改动</span></span><br><span class="line"><span class="comment">// 那么浏览器会下载并缓存清单中的所有资源</span></span><br><span class="line"><span class="comment">// 触发“downloading”事件，同时意味着下载过程开始</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.ondownloading = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'Downloading new version.'</span>);</span><br><span class="line">    <span class="built_in">window</span>.progresscount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下载过程中会间断性地触发“progress”事件</span></span><br><span class="line"><span class="comment">// 通常是在每个文件下载完毕的时候</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 事件对象应当是“process”事件</span></span><br><span class="line">    <span class="comment">// 通过该对象可以计算出下载完成比例，但是，如果它不是“process”事件，</span></span><br><span class="line">    <span class="comment">// 我们统计调用的次数</span></span><br><span class="line">    <span class="keyword">var</span> progress = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> (e &amp;&amp; e.lengthComputable)</span><br><span class="line">        progress = <span class="string">' '</span> + <span class="built_in">Math</span>.round(<span class="number">100</span> * e.loaded / e.total) + <span class="string">'%'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        progress = <span class="string">' ('</span> + ++progresscount + <span class="string">')'</span>;</span><br><span class="line">    </span><br><span class="line">    status(<span class="string">'Downloading new version'</span> + progress);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当下载完成并且首次将应用程序下载到缓存中时，</span></span><br><span class="line"><span class="comment">// 浏览器会触发“cached”事件</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.oncached = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'This application is now cached locally'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当下载完成并将缓存中的应用程序更新后，浏览器会触发“updateready”事件</span></span><br><span class="line"><span class="comment">// 要注意的是：触发此事件的时候，用户仍然可以看到老版本的应用程序</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onupdateready = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'A new version has been download. Reload to run it'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果浏览器处于离线状态，检查清单列表失败，则会触发“error”事件</span></span><br><span class="line"><span class="comment">// 当一个未缓存的应用程序引用一个不存在的清单文件，也会触发此事件</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">"Coundn't load manifest or cache application"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个缓存的应用程序引用一个不存在的清单文件</span></span><br><span class="line"><span class="comment">// 会触发“obsolete”事件，同时会将应用从缓存中移除</span></span><br><span class="line"><span class="comment">// 之后都不会从缓存而是通过网络来加载资源</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onobsolete = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'This application is no longer cached. '</span> +</span><br><span class="line">            <span class="string">'Reload to get the latest version from the network.'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次载入了一个设置了manifest属性的HTML文件，浏览器都会触发“checking”事件，并通过网络载入该清单文件。不过之后，会随着不同的情况触发不同的事件。</p><ul><li><p>没有可用的更新</p><p>  如果应用程序已经缓存并且清单文件没有改动，则浏览器会触发“noupdate”事件。</p></li><li><p>有可用的更新</p><p>  如果应用程序已经缓存了并且清单文件发生了改动，则浏览器会触发“downloading”事件，并开始下载和缓存清单文件中列举的所有资源。随着下载过程的进行，浏览器还会触发“progress”事件，在下载完成后，会触发“updateready”事件。</p></li><li><p>首次载入新的应用程序</p><p>  如果还未缓存应用程序，“downloading”事件和“progress”事件都会触发。但是，当下载完成后，浏览器会触发“cached”事件而不是“updateready”事件。</p></li><li><p>浏览器处于离线状态</p><p>  如果浏览器处于离线状态，它无法检查清单文件，同时它会触发“error”事件。如果一个未缓存的应用程序引用一个不存在的清单文件，浏览器也会触发该事件。</p></li><li><p>清单文件不存在</p><p>  如果浏览器处于在线状态，应用程序也已经换存起来了，但是清单文件不存在（返回404无法找到错误），浏览器会触发“obsolete”事件，并将该应用程序从缓存中移除。</p></li></ul><p>除了使用事件处理程序之外，还可以使用<code>applicationCache.status</code>属性来查看当前缓存状态，该属性有6个可能的属性值：</p><ul><li><p><code>ApplicationCache.UNCACHED (0)</code></p><p>  应用程序没有设置manifest属性，未缓存</p></li><li><p><code>ApplicationCache.IDLE (1)</code></p><p>  清单文件已经检查完毕，并且已经缓存了最新的应用程序</p></li><li><p><code>ApplicationCache.CHECKING (2)</code></p><p>  浏览器正在检查清单文件</p></li><li><p><code>ApplicationCache.DOWNLOADING (3)</code></p><p>  浏览器正在下载并缓存清单中列举的所有文件</p></li><li><p><code>ApplicationCache.UPDATEREADY (4)</code></p><p>  已经下载和缓存了最新版的应用程序</p></li><li><p><code>ApplicationCache.OBSOLETE (5)</code></p><p>  清单文件不存在，缓存将被清除</p></li></ul><p>ApplicationCache对象还定义了两个方法：<code>update()</code>方法显式调用了更新缓存算法以检测是否有最新版本的应用程序。这导致浏览器检测同一个清单文件（并触发相同的事件），这和第一次载入应用程序时的效果是一样的。</p><p>还有一个方法是<code>swapCache()</code>，该方法更加巧妙。还记得当浏览器下载并缓存更新版本的应用时，用户仍然在运行老版本的应用吧。只有当用户再次载入应用时，才会访问到最新版本。但是如果用户没有重新载入，就必须要保证老版本的应用也要工作正常。同时要注意的时，老版本应用程序的相关资源可能是从缓存中加载的：比如，应用程序可能使用XMLHttpRequest去获取文件，而这些请求也务必要保证能够从老版本缓存中的文件获取到。因此，浏览器在用户再次载入应用前必须在缓存中保留老版本的应用。</p><p><code>swapCache()</code>方法告诉浏览器它可以弃用老的缓存，所有的请求都从新缓存中获取。要注意的是，这并不会重新载入应用程序：所有已经载入的HTML文件、图片、脚本等资源都不会改变。但是，之后的请求都将从最新的缓存中获取。这会导致“版本错乱”的问题，因此，一般不推荐使用，除非应用程序设计得很好，确保这样的方式没有问题。想象下，比方说，有这么个应用程序，它什么也不做，就只是在浏览器检查清单文件的整个过程中，显示过度画面。触发“noupdate”事件时，它继续“前进”并载入应用程序的首页。触发“downloading”事件，并且更新缓存后，它显示合适的反馈给用户。触发“updateready”事件时，它调用<code>swapCache()</code>方法，然后从最新的缓存中载入更新过的首页。</p><p>要注意的是，只有当状态属性是<code>ApplicationCache.UPDATEREADY</code>或者<code>ApplicationCache.OBSOLETE</code>时，调用<code>swapCache()</code>方法才有意义（当状态是OBSOLETE时，调用<code>swapCache()</code>方法可以立即弃用废弃的缓存，让之后所有的请求都通过网络获取）。如果在状态属性是其他数值的时候调用<code>swapCache()</code>方法，它就会抛出异常。</p><h4 id="4-离线Web应用"><a href="#4-离线Web应用" class="headerlink" title="4. 离线Web应用"></a>4. 离线Web应用</h4><p>离线Web应用指的是将自己“安装”在应用程序缓存中的程序，使得哪怕在浏览器处于离线状态时候依然可访问它。举个最简单的例子——类似时钟和万花筒生成器这样的应用——Web应用要离线可用需要做的事情。但是，大多数重要的Web应用也需要像服务器上传数据：哪怕是简单的游戏应用都有可能需要把用户的最高得分上传到服务器上。这类应用也可以成为离线应用。它们可以使用localStorage来存储应用数据，然后当在线的时候再将数据上传到服务器。在本地存储和服务器端同步数据是将Web应用转变为离线应用最巧妙的缓解，特别是当用户需要从多台设备获取数据的时候。</p><p>为了在离线状态可用，Web应用需要可以告知别人自己是离线还是在线，同时当网络连接的状态发生改变时候也能“感知”到。通过<code>navigator.onLine</code>属性，可以检测浏览器是否在线，同时，在Window对象上注册在线和离线事件的处理程序，可以检测网络连接状态的改变。</p><p>下面以一个简单的离线Web应用结束，该应用使用了这些技术。该应用名叫“PermaNote”——一个简单的记事本程序，它将用户的文本保存到localStorage中，并且在网络连接可用的时候，将其上传到服务器。PermaNote只允许用户编辑单个笔记，而且不考虑任何授权和身份验证的问题——它假设服务端有区分用户的方式，但是不包括任何登陆界面。PermaNode应用包含三个文件。其中appcache文件是一个缓存清单文件，它列出了另外两个文件，同时指定不需要缓存“note”这个url：我们使用此url来实现在服务端读写笔记数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- permanote.appcache --&gt;</span><br><span class="line"></span><br><span class="line">CACHE MANIFEST</span><br><span class="line"></span><br><span class="line"># PermaNote v8</span><br><span class="line">permanote.html</span><br><span class="line">permanote.js</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">note</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- permanote.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"permanote.appcache"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>PermaNote Editor<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"permanote.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">            <span class="selector-id">#editor</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">250px</span>; &#125;</span></span><br><span class="line"><span class="css">            <span class="selector-id">#statusline</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span>; &#125;</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"toolbar"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"savebutton"</span> <span class="attr">onclick</span>=<span class="string">"save()"</span>&gt;</span>Save<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"sync()"</span>&gt;</span>Sync Note<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"applicationCache.update()"</span>&gt;</span>Update Application<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"editor"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"statusline"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// permanote.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> editor, statusline, savebutton, idletimer;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次载入时，初始化本地存储</span></span><br><span class="line">    <span class="keyword">if</span> (localStorage.note == <span class="literal">null</span>)</span><br><span class="line">        localStorage.note = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> (localStorage.lastModified == <span class="literal">null</span>)</span><br><span class="line">        localStorage.lastModified = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (localStorage.lastSaved == <span class="literal">null</span>)</span><br><span class="line">        localStorage.lastSaved = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找编辑器UI元素，并初始化全局变量</span></span><br><span class="line">    editor = <span class="built_in">document</span>.getElementById(<span class="string">'editor'</span>);</span><br><span class="line">    statusline = <span class="built_in">document</span>.getElementById(<span class="string">'statusline'</span>);</span><br><span class="line">    savebutton = <span class="built_in">document</span>.getElementById(<span class="string">'savebutton'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化编辑器，将保存的笔记数据填充为其内容</span></span><br><span class="line">    editor.value = localStorage.note;</span><br><span class="line">    <span class="comment">// 同步前禁止编辑</span></span><br><span class="line">    editor.disabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一旦文本区有内容输入</span></span><br><span class="line">    editor.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将新的值保存到localStorage中</span></span><br><span class="line">        localStorage.note = editor.value;</span><br><span class="line">        localStorage.lastModified = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="comment">// 重置闲置计时器</span></span><br><span class="line">        <span class="keyword">if</span> (idletimer)</span><br><span class="line">            clearTimeout(idletime);</span><br><span class="line">        idletimer = setTimeout(save, <span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// 启用保存按钮</span></span><br><span class="line">        savebutton.disabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次载入应用程序时，尝试同步服务器</span></span><br><span class="line">    sync();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离开页面前保存数据到服务器</span></span><br><span class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (localStorage.lastModified &gt; localStorage.lastSaved)</span><br><span class="line">        save();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离线时，通知用户</span></span><br><span class="line"><span class="built_in">window</span>.onoffline = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'Offline'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次返回在线状态时，进行同步</span></span><br><span class="line"><span class="built_in">window</span>.ononline = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    sync();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有新版本应用的时候，提醒用户</span></span><br><span class="line"><span class="comment">// 这里我们也可以采用location.reload()方法来强制重新载入应用</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onupdateready = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'A new version of this application is available. Reload to run it.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当没有新版本的时候也通知用户</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onnoupdate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">'You are running the latest version of the application'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于在状态栏中显示状态消息的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">status</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    statusline.innerHTML = msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每当笔记内容更新后，如果用户停止编辑超过5分钟</span></span><br><span class="line"><span class="comment">// 就会自动将笔记文本上传到服务器（在线状态下）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">save</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idletimer)</span><br><span class="line">        clearTimeout(idletimer);</span><br><span class="line"></span><br><span class="line">    idletimer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (navigator.onLine) &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">'PUT'</span>, <span class="string">'/note'</span>);</span><br><span class="line">        xhr.send(editor.value);</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            localStorage.lastSaved = <span class="built_in">Date</span>.now();</span><br><span class="line">            savebutton.disabled = <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查服务端是否有新版本的笔记，</span></span><br><span class="line"><span class="comment">// 如果没有，则将当前版本保存到服务器端</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (navigator.onLine) &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, <span class="string">'/note'</span>);</span><br><span class="line">        xhr.send();</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> remoteModTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> remoteModTime = xhr.getResponseHeader(<span class="string">'Last-Modified'</span>);</span><br><span class="line">                remoteModTime = <span class="keyword">new</span> <span class="built_in">Date</span>(remoteModTime).getTime();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (remoteModTime &gt; localStorage.lastModified) &#123;</span><br><span class="line">                status(<span class="string">'Newer note found on server.'</span>);</span><br><span class="line">                <span class="keyword">var</span> useit = confirm(<span class="string">'There is a newer version of the note\n'</span> + </span><br><span class="line">                                    <span class="string">'on the server. Click OK to use that version\n'</span> +</span><br><span class="line">                                    <span class="string">'or click Cancel to continue editing this\n'</span> +</span><br><span class="line">                                    <span class="string">'version and overwrite the server'</span>);</span><br><span class="line">                <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">                <span class="keyword">if</span> (useit) &#123;</span><br><span class="line">                    editor.value = localStorage.note = xhr.responseText;</span><br><span class="line">                    localStorage.lastSaved = now;</span><br><span class="line">                    status(<span class="string">'Newest version downloaded'</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    status(<span class="string">'Ignoring newer version of the note.'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                localStorage.lastModified = now;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                status(<span class="string">'You are editing the current version of the note'</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (localStorage.lastModified &gt; localStorage.lastSaved) &#123;</span><br><span class="line">                save();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            editor.disabled = <span class="literal">false</span>;</span><br><span class="line">            editor.focus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 离线状态下，不能同步</span></span><br><span class="line">        status(<span class="string">"Can't sync while offline"</span>);</span><br><span class="line">        editor.disabled = <span class="literal">false</span>;</span><br><span class="line">        editor.focus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web应用允许使用浏览器提供的API实现将数据存储到用户的电脑上，这种客户端存储相当于赋予了Web浏览器记忆功能。比方说，Web应用就可以用这种方式来“记住”用户的偏好甚至是用户所有的状态信息，以便准确地“回忆”起用户上一次访问的位置。客户端存储遵循“同源策略”，因此不同站点的页面是无法互相读取对方存储的数据，而同一站点的不同页面之间是可以互相共享存储数据的，它为我们提供了一种通信机制，例如，一个页面上填写的表单数据可以显示在另外一个页面中。Web应用可以选择它们存储数据的有效期：比如采用临时存储可以让数据保存至当前窗口关闭或者浏览器退出；采用永久存储，可以将数据永久地存储到硬盘上，数年或者数月不失效。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript客户端存储" scheme="http://www.xiaoleon.cn/tags/JavaScript%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>JS(11) 脚本化HTTP</title>
    <link href="http://www.xiaoleon.cn/2018/01/30/js-11/"/>
    <id>http://www.xiaoleon.cn/2018/01/30/js-11/</id>
    <published>2018-01-30T14:44:34.000Z</published>
    <updated>2018-02-02T12:48:05.169Z</updated>
    
    <content type="html"><![CDATA[<p>超文本传输协议（<code>HyperText Transfer Protocol，HTTP</code>）规定Web浏览器如何从Web服务器获取文档和向Web服务器提交表单内容，以及Web服务器如何响应这些请求和提交。Web浏览器会处理大量HTTP。通常，HTTP并不在脚本的控制下，只是当用户单机链接、提交表单和输入URL时才发生。</p><a id="more"></a><p>术语Ajax描述了一种主要使用脚本操纵HTTP的Web应用架构。Ajax应用的主要特点是使用脚本操纵HTTP和Web服务器进行数据交换，不会导致页面重载。避免页面重载的能力使Web应用感觉更像传统的桌面应用。Web应用可以使用Ajax技术把用户的交互数据记录到服务器中，也可以开始只显示简单页面，之后按需加载额外的数据和页面组件来提升应用的启动时间。</p><p><code>&lt;img&gt;</code>元素无法实现完整的Ajax传输协议，因为数据交换是单向的：客户端能发送数据到服务器，但服务器的响应一直是张图片导致客户端无法轻易从中提取信息。然而，<code>&lt;iframe&gt;</code>元素更加强大，为了把<code>&lt;iframe&gt;</code>作为Ajax传输协议使用，脚本首先要把发送给Web服务器的信息编码到URL中，然后设置<code>&lt;iframe&gt;</code>的src属性为该URL。服务器能创建一个包含相应内容的HTML，并把它返回给Web浏览器，并且在<code>&lt;iframe&gt;</code>中显示它。<code>&lt;iframe&gt;</code>需要对用户不可见，例如可以使用css隐藏它。脚本能通过遍历<code>&lt;iframe&gt;</code>的文档对象来读取服务端的响应。</p><p>实际上，<code>&lt;script&gt;</code>元素的src属性能设置URL并发起HTTP GET请求。使用<code>&lt;script&gt;</code>元素实现脚本操纵HTTP是非常吸引人的，因此它们可以跨域通信而不受限于同源策略。通常，使用基于<code>&lt;script&gt;</code>的Ajax传输协议时，服务器的响应采用JSON编码的数据格式，当执行脚本时，JavaScript解析器能够自动将其“解码”。由于它使用JSON数据格式，因此这种Ajax传输协议也叫做“JSONP”。</p><p>虽然在<code>&lt;iframe&gt;</code>和<code>&lt;script&gt;</code>传输协议上能实现Ajax技术，但通常还有更简单的方式。一段时间以来，所有浏览器都支持XMLHttpRequest对象，它定义了用脚本操纵HTTP的API。除了常用的GET请求，这个API还包含实现POST请求的能力，同时它能用文本或Document对象的形式返回服务器的响应。虽然名字叫XMLHttpRequest API，但并没有限定只能使用XML文档，它能获取任何类型的文本文档。</p><p>Comet传输协议比Ajax更精妙，但都需要客户端和服务器之间建立（必要时重新建立）连接，同时需要服务器保持连接处于打开状态，这样它才能够发送异步信息。隐藏的<code>&lt;iframe&gt;</code>能像Comet传输协议一样有用，例如，如果服务器以<code>&lt;iframe&gt;</code>中待执行的<code>&lt;script&gt;</code>元素的形式发送每条信息。实现Comet的一种更可靠跨平台方案是客户端建立一个和服务器的连接（使用Ajax传输协议），同时服务器保持这个连接打开直到它需要推送一条消息。服务器每发送一条消息就关闭这个连接，这样可以确保客户端正确接收到消息。处理该消息之后，客户端马上为后续的消息推送建立一个新连接。</p><p>实现可靠的跨平台Comet传输协议是非常有挑战性的，所以大部分使用Comet架构的Web应用开发者依赖于像Dojo这样的Web框架库中的传输协议。</p><p>在Ajax和Comet之上构建更高级的通信协议是可行的。例如，这些客户端/服务器技术可以用RPC（Remote Procedure call，远程过程调用）机制或发布/订阅事件系统的基础。</p><hr><h3 id="一、使用XMLHttpRequest"><a href="#一、使用XMLHttpRequest" class="headerlink" title="一、使用XMLHttpRequest"></a>一、使用XMLHttpRequest</h3><p>浏览器在XMLHttpRequest类上定义了它们的HTTP API。这个类的每个实例都表示一个独立的请求/响应对，并且这个对象的属性和方法允许指定请求细节和提取响应数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在IE5和IE6中模拟XMLHttpRequest()构造函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.XMLHttpRequest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">'Msxml2.XMLHTTP.6.0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e1) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">'Msxml2.XMLHTTP.3.0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (e2) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'XMLHttpRequest is not supported!'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个HTTP请求由4部分组成：</p><ul><li><p>HTTP请求方法或动作（verb）</p></li><li><p>正在请求的URL</p></li><li><p>一个可选的请求头集合，其中可能包括身份验证信息</p></li><li><p>一个可选的请求主体</p></li></ul><p>服务器返回的HTTP响应包含3部分：</p><ul><li><p>一个数字和文字组成的状态码，用来显示请求的成功和失败</p></li><li><p>一个响应头集合</p></li><li><p>响应主体</p></li></ul><p>HTTP的基础请求/相应架构非常简单并且易于使用。但在实践中会有各种各样随之而来的复杂问题：客户端和服务器交换cookie，服务器重定向浏览器到其他服务器，缓存某些资源而剩下的不换村，某些客户端通过代理服务器发送所有的请求等。XMLHttpRequest不是协议级的HTTP API而是浏览器级的API。浏览器需要考虑cookie、重定向、缓存和代理，但代码只需要关心请求和响应。</p><h4 id="1-指定请求"><a href="#1-指定请求" class="headerlink" title="1. 指定请求"></a>1. 指定请求</h4><p>创建XMLHttpRequest对象之后，发起HTTP请求的下一步是调用XMLHttpRequest对象的<code>open()</code>方法去指定这个请求的两个必须部分：方法和URL。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.open(<span class="string">'GET'</span>,                     <span class="comment">// 开始一个HTTP GET请求</span></span><br><span class="line">            <span class="string">'data.csv'</span>);                <span class="comment">// URL的内容</span></span><br></pre></td></tr></table></figure><p><code>open()</code>的第一个参数指定HTTP方法或动作。这个字符串不区分大小写，但通常大家用大写字母来匹配HTTP协议。“GET”和“POST”方法是得到广泛支持的。“GET”用于常规请求，它适用于当URL完全制定请求资源，当请求对服务器没有任何副作用以及当服务器的响应是可缓存时。“POST”方法常用于HTML表单。它在请求主体中包含额外数据（表单数据）且这些数据常存储到服务器上的数据库中（副作用）。相同URL的重复POST请求从服务器得到的响应可能不同，同时不应该缓存使用这个方法的请求。</p><p>除了“GET”和“POST”之外，XMLHttpRequest规范也允许把“DELETE”、“HEAD”、“OPTIONS”和“PUT”作为<code>open()</code>的第一个参数。旧浏览器并不支持所有这些方法，但至少“HEAD”得到广泛支持。</p><p><code>open()</code>的第二个参数是URL，它是请求的主题。这时相对于文档的URL，这个文档包含调用<code>open()</code>的脚本。如果只i的那个绝对URL、协议、主机和端口通常必须匹配所在文档的对应内容：跨域的请求通常会报错。</p><p>如果有请求头的话，请求进程的下个步骤就是设置它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br></pre></td></tr></table></figure><p>如果对相同的头调用<code>setRequestHeader()</code>多次，新值不会取代之前指定的值，相反，HTTP请求将包含这个头的多个副本或这个头将指定多个值。</p><p>我们不能自己指定“Content-Length”、“Date”、“Referer”或“User-Agent”头，XMLHttpRequest将自动添加这些头而防止伪造它们。类似地，XMLHttpRequest对象自动处理cookie、连接时间、字符集和编码判断，所以我们无法向<code>setRequestHeader()</code>传递这些头信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Accept-Charset      Content-Transfer-Encoding       TE</span><br><span class="line">Accept-Encoding     Date                            Trailer</span><br><span class="line">Connection          Expect                          Transfer-Encoding</span><br><span class="line">Content-Length      Host                            Upgrade</span><br><span class="line">Cookie              Keep-Alive                      User-Agent</span><br><span class="line">Cookie2             Referer                         Via</span><br></pre></td></tr></table></figure><p>我们能为请求指定“Authorization”头，但通常不需要这么做。如果请求一个受密码保护的URL，把用户名和密码作为第4个和第5个参数传递给<code>open()</code>，则XMLHttpRequest将设置合适的头。</p><p>使用XMLHttpRequest发起HTTP请求的最后一步是指定可选的请求主体并向服务器发送它。使用<code>send()</code>方法像如下这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>GET请求绝对没有主体，所以应该传递null或省略这个参数。POST请求通常拥有主体，同时它应该匹配使用<code>setRequestHeader()</code>指定的“Content-Type”头。</p><blockquote><p><strong>顺序问题</strong></p><p>HTTP请求的各部分有指定顺序：请求方法和URL首先到达，然后是请求头，最后是请求主体。XMLHttpRequest实现通常直到调用<code>send()</code>方法才开始启动网络。但XMLHttpRequest API的设计似乎使每个方法都将写入网络流。这意味着调用XMLHttpRequest方法的顺序必须匹配HTTP请求的架构。例如，<code>setRequestHeadr()</code>方法的调用必须在调用<code>open()</code>之后且在调用<code>send()</code>之前，否则它将抛出异常。</p></blockquote><p>下面使用了我们目前介绍的所有XMLHttpRequest方法。它用POST方法发送文本字符串给服务器，并忽略服务器返回的任何响应。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postMessage</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'POST'</span>, <span class="string">'/log.php'</span>);</span><br><span class="line">    request.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=UTF-8'</span>);</span><br><span class="line">    request.send(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-取得响应"><a href="#2-取得响应" class="headerlink" title="2. 取得响应"></a>2. 取得响应</h4><p>一个完整的HTTP响应由状态码、响应头集合和响应主体组成。这些都可以通过XMLHttpRequest对象的属性和方法使用：</p><ul><li><p>status和statusText属性以数字和文本的形式返回HTTP状态码。这些属性保存标准的HTTP值，像200和“OK”表示成功请求，404和“Not Found”表示URL不能匹配服务器上的任何资源。</p></li><li><p>使用<code>getResponseHeader()</code>和<code>getAllResponseHeaders()</code>能查询响应头。XMLHttpRequest会自动处理cookie：它会从<code>getAllResponseHeaders()</code>头返回集合中过滤掉cookie头，而如果给<code>getResponseHeader()</code>传递“Set-Cookie”和“Set-Cookie2”则返回null。</p></li><li><p>响应主体可以从responseText属性中得到文本形式的，从responseXML属性中得到Document形式的。</p></li></ul><p>XMLHttpRequest对象通常异步使用：发送请求后，<code>send()</code>方法立即返回，直接响应返回，前面列出的相应方法和属性才有效。为了在响应准备就绪时得到通知，必须监听XMLHttpRequest对象上的readystatechange事件。但是为了理解这个事件类型，我们必须理解readyState属性。</p><p>readyState是一个整数，它指定了HTTP请求的状态，下表列出了它可能的值。</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>UNSENT</td><td>0</td><td><code>open()</code>尚未调用</td></tr><tr><td>OPENED</td><td>1</td><td><code>open()</code>已调用</td></tr><tr><td>HEADERS_RECEIVED</td><td>2</td><td>接收到头信息</td></tr><tr><td>LOADING</td><td>3</td><td>接收到响应主体</td></tr><tr><td>DONE</td><td>4</td><td>响应完成</td></tr></tbody></table><p>第一列的符号是XMLHttpRequest构造函数定义的常量。这些常量是XMLHttpRequest规范的一部分，但老的浏览器和IE8没有定义它们，通常看到使用硬编码值4来表示XMLHttpRequest.DONE。</p><p>理论上，每次readyState属性改变都会触发readystatechange事件。实际中，当readyState改变为0或1时可能没有触发这个事件。当调用<code>send()</code>时，即使readyState仍处于OPENED状态，也通常触发它。某些浏览器在LOADING状态时能触发多次事件来给出进度反馈。当readyState值改变为4或服务器的响应完成时，所有的浏览器都触发readystatechange事件。因为在响应完成之前也会触发事件，所以事件处理程序应该一直检验readyState值。</p><p>为了监听readystatechange事件，请把事件处理函数设置为XMLHttpRequest对象的onreadystatechange属性。也能用<code>addEventListener()</code>，但通常每个请求只需要一个处理程序，所以只设置onreadystatechange更容易。</p><p>下面定义了<code>getText()</code>函数来演示如何监听readystatechange事件。事件处理程序首先要确保请求完成。如果这样，它会检查响应状态码来确保请求成功。然后它查找“Content-Type”头来验证响应主体是否时期望的类型。如果3个条件都得到满足，它会把响应主体（以文本形式）发送给指定的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getText</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'GET'</span>, url);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState == <span class="number">4</span> &amp;&amp; request.status == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> type = request.getResponseHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line">            <span class="keyword">if</span> (type.match(<span class="regexp">/^text/</span>))</span><br><span class="line">                callback(request.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    request.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>1) 同步响应</p><p>由于其本身的性质，异步处理HTTP响应是最好的方式。然而，XMLHttpRequest也支持同步响应。如果把false作为第三个参数传给<code>open()</code>，那么<code>send()</code>方法将阻塞直到请求完成。在这种情况下，不需要使用事件处理程序：一旦<code>send()</code>返回，仅需要检查XMLHttpRequest对象的status和responseText属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTextSync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">"GET"</span>, url, <span class="literal">false</span>);</span><br><span class="line">    request.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.status != <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(request.statusText);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> type = request.getResponseHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!type.match(<span class="regexp">/^text/</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected textual response; got: '</span> + type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> request.responseText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步请求是吸引人的，但应该避免使用它们。客户端JavaScript是单线程的，当<code>send()</code>方法阻塞时，它通常会导致整个浏览器UI冻结。如果连接的服务器响应慢，那么用户的浏览器将冻结。</p></li><li><p>2) 响应解码</p><p>在前面的示例中，我们假设服务器使用像“text/plain”、“text/html”、“text/css”这样的MIME类型发送文本响应，然后我们使用XMLHttpRequest对象的responseText属性得到它。</p><p>还可以通过其他方式来处理服务器的响应。如果服务器发送XML或XHTML文档作为其响应，我们可以通过responseXML属性获得一个解析形式的XML文旦。这个属性的值是一个Document对象。</p><p>如果服务器向发送诸如对象或数组这样的结构化数据作为其响应，它应该传输JSON编码的字符串数据。当接收它时，可以把responseText属性传递给<code>JSON.parse()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'GET'</span>, url);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState == <span class="number">4</span> &amp;&amp; request.status == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> type = request.getResponseHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line">            <span class="keyword">if</span> (type.indexOf(<span class="string">'xml'</span>) !== <span class="number">-1</span> &amp;&amp; request.responseXML)</span><br><span class="line">                callback(request.responseXML);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">'application/json'</span>)</span><br><span class="line">                callback(<span class="built_in">JSON</span>.parse(request.responseText));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                callback(request.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    request.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中检查该响应的“<code>Content-Type</code>”头且专门处理“<code>application/json</code>”影响。我们可能希望特殊编码的另一个响应类型是“<code>application/javascript</code>”或“<code>text/javascript</code>”。我们能使用XMLHttpRequest请求JavaScript脚本，然后使用全局<code>eval()</code>执行这个脚本。但是，在这种情况下不需要使用XMLHttpRequest对象，因为<code>&lt;script&gt;</code>元素本身操纵HTTP脚本的能力完全可以加载并执行脚本。且记住<code>&lt;script&gt;</code>元素能发起跨域HTTP请求，而XMLHttpRequest API则禁止。</p><p>Web服务端通常使用二进制数据响应HTTP请求。responseText属性只能用于文本（比如图片文件），且它不能妥善处理二进制响应，即使对最终字符串使用了<code>charCodeAt()</code>。XHR2定义了处理二进制响应的方法，本文不详细介绍该方法。</p><p>服务器响应的正常解码是假设服务器为这个响应发送了“<code>Content-Type</code>”头和正确的MIME类型。假设我们将下载XML文件，而我们计划把它当作纯文本对待。可以使用<code>setOverrideMimeType()</code>让XMLHttpRequest知道它不需要把文件解析成XML文档</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.overrideMimeType(<span class="string">'text/plain; charset=utf-8'</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-编码请求主体"><a href="#3-编码请求主体" class="headerlink" title="3. 编码请求主体"></a>3. 编码请求主体</h4><p>HTTP POST请求包括一个请求主体，它包含客户端传递给服务器的数据。</p><ul><li><p>1) 表单编码的请求</p><p>默认情况下，HTML表单通过POST方法发送给服务器，而编码后的表单数据则用做请求主体。对表单数据使用的编码方案相对简单：对每个表单元素的名字和值执行普通的URL编码（使用十六进制转义码替换特殊字符），使用等号把编码后的名字和值分开，并使用“<code>&amp;</code>”符号分开名值对。一个简单表单的编码如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find=pizza&amp;zipcode=<span class="number">01234</span>&amp;radius=<span class="number">1</span>km</span><br></pre></td></tr></table></figure><p>表单数据编码格式有一个正式的MIME类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>当使用POST方法提交这种顺序的表单数据时，必须设置“<code>Content-Type</code>”请求头为这个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeFormData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!data) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> pairs = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> name <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.hasOwnProperty(name))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> data[name] === <span class="string">'function'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> value = data[name].toString();</span><br><span class="line">        name = <span class="built_in">encodeURIComponent</span>(name.replace(<span class="string">'%20'</span>, <span class="string">'+'</span>));</span><br><span class="line">        value = <span class="built_in">encodeURIComponent</span>(value.replace(<span class="string">'%20'</span>, <span class="string">'+'</span>));</span><br><span class="line">        pairs.push(name + <span class="string">'='</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pairs.join(<span class="string">'&amp;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postData</span>(<span class="params">url, data, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'OPEN'</span>, url);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span> &amp;&amp; callback)</span><br><span class="line">            callback(request);</span><br><span class="line">    &#125;;</span><br><span class="line">    request.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">    request.send(encodeFormData(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url, data, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'GET'</span>, url + <span class="string">'?'</span> + encodeFormData(data));</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span> &amp;&amp; callback)</span><br><span class="line">            callback(request);</span><br><span class="line">    &#125;;</span><br><span class="line">    request.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2) JSON编码的请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postJSON</span>(<span class="params">url, data, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'POST'</span>, url);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span> &amp;&amp; callback)</span><br><span class="line">            callback(request);</span><br><span class="line">    &#125;;</span><br><span class="line">    request.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">    request.send(<span class="built_in">JSON</span>.stringigy(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>3) XML编码的请求</p><p>XML有时也用于数据传输的编码。JavaScript对象的用表单编码或JSON编码版本表达的pizza查询，也能用XML文档来表示它。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">query</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">find</span> <span class="attr">zipcode</span>=<span class="string">"01234"</span> <span class="attr">radius</span>=<span class="string">"1km"</span>&gt;</span></span><br><span class="line">        pizza</span><br><span class="line">    <span class="tag">&lt;/<span class="name">find</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">query</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在目前展示的所有示例中，XMLHttpRequest的<code>send()</code>方法的参数是一个字符串或null。实际上，这里可以传入XML Document对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postQuery</span>(<span class="params">url, what, where, radius, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'POST'</span>, url);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span> &amp;&amp; callback)</span><br><span class="line">            callback(request);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> doc = <span class="built_in">document</span>.implementation.createDocument(<span class="string">''</span>, <span class="string">'query'</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">var</span> query = doc.documentElement;</span><br><span class="line">    <span class="keyword">var</span> find = doc.createElement(<span class="string">'find'</span>);</span><br><span class="line">    query.appendChild(find);</span><br><span class="line">    find.setAttribute(<span class="string">'zipcode'</span>, where);</span><br><span class="line">    find.setAttribute(<span class="string">'radius'</span>, radius);</span><br><span class="line">    find.appendChild(doc.createTextNode(what));</span><br><span class="line">    request.send(doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当给<code>send()</code>方法传入XML文档时，并没有预先指定“Content-Type”头，但XMLHttpRequest对象会自动设置一个合适的头。类似地，如果给<code>send()</code>传入一个字符串但没有指定“Content-Type”头，那么XMLHttpRequest会添加“<code>ext/plain;charset=utf-8</code>”头。</p></li><li><p>4) 上传文件</p><p>HTML表单的特性之一是当用户通过<code>&lt;input type=&quot;file&quot;&gt;</code>元素选择文件时，表单将在它产生的POST请求主体中发送文件内容。HTML表单始终能上传文件，但它还不能使用XMLHttpRequest API做相同的事情。然后，XHR2 API允许通过向<code>send()</code>方法传入File对象来实现上传文件。</p><p>没有<code>File()</code>对象构造函数，脚本仅能获得表示用户当前选择文件的File对象。在支持File对象的浏览器中，每个<code>&lt;input type=&quot;file&quot;&gt;</code>元素有一个files属性，它是File对象中的类数组对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">whenReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elts = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elts.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> input = elts[i];</span><br><span class="line">        <span class="keyword">if</span> (input.type != <span class="string">'file'</span>)   </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">var</span> url = input.getAttribute(<span class="string">'data-uploadto'</span>);</span><br><span class="line">        <span class="keyword">if</span> (!url)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        input.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> file = <span class="keyword">this</span>.files[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (!file)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">            xhr.open(<span class="string">'POST'</span>, url);</span><br><span class="line">            xhr.send(file);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>文件类型是更通用的二进制大对象（Blob）类型中的一个子类型。XHR2允许向<code>send()</code>方法传入任何Blob对象。如果没有显式设置Content-Type头，这个Blob对象的type属性用于设置待上传的Content-Type头。如果需要上传已经产生的二进制数据，可以把数据转化为Blob并将其作为请求主体。</p></li><li><p>5) multipart/form-data请求</p><p>当HTML表单同时包含文件上传元素和其他元素时，浏览器不能使用普通的表单编码而必须使用称为“<code>multipart/form-data</code>”的特殊Content-Type来用POST方法提交表单。这种编码包括使用长“边界”字符串把请求主体分离成多个部分。对于文本数据，手动创建”<code>multipart/form-data</code>“请求主体是可能的，但很复杂。</p><p>XHR2定义了新的FormData API，它容易实现多部分请求主体。首先，使用<code>FormData()</code>构造函数创建FormData对象，然后按需多次调用这个对象的<code>append()</code>方法把个体“部分”（可以是字符串、File或Blob对象）添加到请求中。最后，把FormData对象传递给<code>send()</code>方法。<code>send()</code>方法将对请求定义合适的边界字符串和设置“Content-Type”头。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postFormData</span>(<span class="params">url, data, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> FormData === <span class="string">'undefined'</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'FormData is not implemented'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'POST'</span>, url);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span> &amp;&amp; callback)</span><br><span class="line">            callback(request);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> formdata = <span class="keyword">new</span> FormData();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.hasOwnProperty(name))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">var</span> value = data[name];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        formdata.append(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    request.send(formdata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-HTTP进度事件"><a href="#4-HTTP进度事件" class="headerlink" title="4. HTTP进度事件"></a>4. HTTP进度事件</h4><p>在之前的示例中，使用readystatechange事件探测HTTP请求的完成。XHR2规范草案定义了更多有用的事件集，在这个新的事件模型中，XMLHttpRequest对象在请求的不同阶段触发不同类型的事件，所以它不需要再检查readyState属性。</p><p>在支持它们的浏览器中，这些新事件会像如下这样触发。当调用<code>send()</code>时，触发单个loadstart事件。当正在加载服务器响应时，XMLHttpRequest对象会发生progress事件，通常每隔50毫秒左右，所以可以使用这些事件给用户反馈请求的进度。如果请求快速完成，它可能从不会触发progress事件。当事件完成，会触发load事件。</p><p>一个完成的请求不一定是成功的请求，例如，load事件的处理程序应该检查XMLHttpRequest对象的status状态码来确定收到的是“200 OK”而不是“404 Not Found”的HTTP响应。</p><p>HTTP请求无法完成有3种情况，对应3种事件。如果请求超时，会触发timeout事件。如果请求中止，会触发abort事件。最后，像太多重定向这样的网络错误会阻止请求完成，但这些情况发生时会触发error事件。</p><p>对于任何具体请求，浏览器将只会触发load、abort、timeout和error事件中的一个。XHR2规范草案指出一旦这些事件中的一个发生后，浏览器应该触发loadend事件。</p><p>可以通过XMLHttpRequest对象的<code>addEventListener()</code>方法为这些progress事件中的每个都注册处理程序。如果每种事件只有一个事件处理程序，通常更容易的方法是只设置对应的处理程序属性，比如onprogress和onload。甚至可以使用这些属性是否存在来测试浏览器是否支持progress事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'onprogress'</span> <span class="keyword">in</span> (<span class="keyword">new</span> XMLHttpRequest())) &#123;</span><br><span class="line">    <span class="comment">// 支持progress事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了像type和timestamp这样常用的Event对象属性外，与这些progress事件相关联的事件对象还有3个有用的属性。loaded属性是目前传输的字节数值。total属性是自“Content-Length”头传输的数据的整体长度（单位是字节），如果不知道内容长度则为0。最后，如果直到内容长度则lengthComputable属性为true，否则为false。显然，total和loaded属性对progress事件处理程序相当有用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.lengthComputable)</span><br><span class="line">        progress.innerHTML = <span class="built_in">Math</span>.round(<span class="number">100</span> * e.loaded / e.total) + <span class="string">'% Complete'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-上传进度事件"><a href="#5-上传进度事件" class="headerlink" title="5. 上传进度事件"></a>5. 上传进度事件</h4><p>除了为监控HTTP响应的加载定义的这些有用的事件外，XHR2也给出了用于监控HTTP请求上传的事件。在实现这些特性的浏览器中，XMLHttpRequest对象将有upload属性。upload属性值是一个对象，它定义了<code>addEventListener()</code>方法和整个progress事件集合，比如onprogress和onload。（但upload对象没有定义onreadystatechange属性，upload仅能触发新的事件类型。）</p><p>我们能仅仅像使用常见的progress事件处理程序一样使用upload事件处理程序。对于XMLHttpRequest对象x，设置<code>x.onprogress</code>以监控响应的下载进度，并且设置<code>x.upload.onprogress</code>以监控请求的上传进度。</p><p>下面我们延时如何使用upload progress事件把上传进度反馈给用户。这个示例也演示了如何从拖放API中获得File对象和如何使用FormData API在单个XMLHttpRequest请求中上传多个文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">whenReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elts = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'fileDropTarget'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elts.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> target = elts[i];</span><br><span class="line">        <span class="keyword">var</span> url = target.getAttribute(<span class="string">'data-uploadto'</span>);</span><br><span class="line">        <span class="keyword">if</span> (!url)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        createFileUploadDropTarget(target, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createFileUploadDropTarget</span>(<span class="params">target, url</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> uploading = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(target, url);</span><br><span class="line"></span><br><span class="line">        target.ondragenter = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'dragenter'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uploading)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> types = e.dataTransfer.types;</span><br><span class="line">            <span class="keyword">if</span> (types &amp;&amp; </span><br><span class="line">                (types.contains &amp;&amp; types.contains(<span class="string">'Files'</span>)) ||</span><br><span class="line">                (types.indexOf &amp;&amp; types.indexOf(<span class="string">'Files'</span>) !== <span class="number">-1</span>)) &#123;</span><br><span class="line">                target.classList.add(<span class="string">'wantdrop'</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        target.ondragover = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!uploading)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        target.ondragleave = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!uploading)</span><br><span class="line">                target.classList.remove(<span class="string">'wantdrop'</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        target.ondrop = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (uploading) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> files = e.dataTransfer.files;</span><br><span class="line">            <span class="keyword">if</span> (files &amp;&amp; files.length) &#123;</span><br><span class="line">                uploading = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">var</span> message = <span class="string">"Uploading files:&lt;ul&gt;"</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++)</span><br><span class="line">                    message += <span class="string">'&lt;li&gt;'</span> + files[i].name + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">                message += <span class="string">'&lt;/ul&gt;'</span>;</span><br><span class="line"></span><br><span class="line">                target.innerHTML = message;</span><br><span class="line">                target.classList.remove(<span class="string">'wantdrop'</span>);</span><br><span class="line">                target.classList.add(<span class="string">'uploading'</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">                xhr.open(<span class="string">'POST'</span>, url);</span><br><span class="line">                <span class="keyword">var</span> body = <span class="keyword">new</span> FormData();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; file.length; i++)</span><br><span class="line">                    body.append(i, files[i]);</span><br><span class="line">                xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.lengthComputable) &#123;</span><br><span class="line">                        target.innerHTML = message + <span class="built_in">Math</span>.round(e.loaded / e.total * <span class="number">100</span>) + <span class="string">'% COmplete'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                xhr.upload.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                    uploading = <span class="literal">false</span>;</span><br><span class="line">                    target.classList.remove(<span class="string">'uploading'</span>);</span><br><span class="line">                    target.innerHTML = <span class="string">'Drop files to upload'</span>;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                xhr.send(body);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            target.classList.remove(<span class="string">'wantdrop'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="6-中止请求和超时"><a href="#6-中止请求和超时" class="headerlink" title="6. 中止请求和超时"></a>6. 中止请求和超时</h4><p>可以通过调用XMLHttpRequest对象的<code>abort()</code>方法来取消正在进行的HTTP请求。<code>abort()</code>方法在所有的XMLHttpRequest版本和XHR2中可用，调用<code>abort()</code>方法在这个对象上触发abort事件，可以通过XMLHttpRequest对象的onabort属性来判断是否存在。</p><p>调用<code>abort()</code>的主要原因是完成取消或超时请求消耗的时间太长或当响应变得无关时。假设使用XMLHttpRequest为文本输入域请求自动完成推荐。如ugoyonghu在服务器的建议达到之前输入了新字符，这时等待请求不再有用，应该中止。</p><p>XHR2定义了timeout属性来指定请求自动中止后的毫秒数，也定义了timeout事件用于当超时发生时触发（不是abort事件）。可以用<code>setTimeout()</code>和<code>abort()</code>方法实现自己的超时。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timedGetText</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="keyword">var</span> timedout = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        timedout = <span class="literal">true</span>;</span><br><span class="line">        request.abort();</span><br><span class="line">    &#125;, timeout);</span><br><span class="line">    request.open(<span class="string">'GET'</span>, url);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readystate !== <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (timedout)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="keyword">if</span> (request.status == <span class="number">200</span>)</span><br><span class="line">            callback(request.responseText);</span><br><span class="line">    &#125;;</span><br><span class="line">    request.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-跨域HTTP请求"><a href="#7-跨域HTTP请求" class="headerlink" title="7. 跨域HTTP请求"></a>7. 跨域HTTP请求</h4><p>作为同源策略的一部分，XMLHttpRequest对象通常仅可以发起和文档具有相同服务器的HTTP请求。这个限制关闭了安全漏洞，但它笨手笨脚并且也阻止了大量合适使用的跨域请求。可以在<code>&lt;form&gt;</code>和<code>&lt;iframe&gt;</code>元素中使用跨域URL，而浏览器显示最终的跨域文档。但因为同源策略，浏览器不允许原始脚本查找跨域文档的内容。使用XMLHttpRequest，文档内容都是通过responseText属性暴露，所以同源策略不允许XMLHttpRequest进行跨域请求。（注意<code>&lt;script&gt;</code>元素并未真正受限于同源策略：它加载并执行任何来源的脚本。）</p><p>XHR2通过在HTTP相应中选择发送合适的CORS（Cross-Origin Resource Sharing，跨域资源共享）允许跨域访问网站。作为Web程序员，使用这个功能并不需要做什么额外的工作：如果浏览器支持XMLHttpRequest的CORS且实现跨域请求的网站决定使用CORS允许跨域请求，那么同源策略将会放宽而跨域请求就会正常工作。</p><p>虽然实现CORS支持的跨域请求工作不需要做任何事情，但有些安全细节需要了解。首先，如果给XMLHttpRequest的<code>open()</code>方法传入用户名和密码，那么它们绝对不会通过跨域请求发送（这使分布式密码破解攻击成为可能）。除外，跨域请求通常也不会包含其他任何的用户证书：cookie和HTTP身份令牌（token）通常不会作为请求的内容部分发送且任何作为跨域响应来接收的cookie都会丢弃。如果跨域请求需要这几种凭证才能成功，那么必须在用<code>send()</code>发送请求前设置XMLHttpRequest的withCredentials属性为true。这样做不常见，但测试withCredentials的存在性是测试浏览器是否支持CORS的一种方法。</p><p>下面示例使用XMLHttpRequest实现HTTP HEAD请求以下载文档中<code>&lt;a&gt;</code>元素链接资源的类型、大小和时间等信息。这个HEAD请求按需发起，且由此产生的链接信息会出现在工具提示中。这个示例假设跨域链接的信息不可用，但通过支持CORS的浏览器尝试下载它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">whenReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> supportsCORS = (<span class="keyword">new</span> XMLHttpRequest()).withCredentials !== <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> links = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; links.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> link = links[i];</span><br><span class="line">        <span class="keyword">if</span> (!link.href)                             </span><br><span class="line">            <span class="comment">// 跳过没有超链接的锚点</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (link.title)                             </span><br><span class="line">            <span class="comment">// 跳过已经有工具提示的链接</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (link.host !== location.host || link.protocol !== location.protocol) &#123;</span><br><span class="line">            <span class="comment">// 如果这是一个跨域链接</span></span><br><span class="line">            link.title = <span class="string">'站外链接'</span>;</span><br><span class="line">            <span class="keyword">if</span> (!supportsCORS)</span><br><span class="line">                <span class="comment">// 如果没有CORS支持就退出</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 否则，我们能了解这个链接的更多信息</span></span><br><span class="line">            <span class="comment">// 所以继续前进，注册事件处理程序，于是我们可以尝试</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (link.addEventListener)</span><br><span class="line">            link.addEventListener(<span class="string">'mouseover'</span>, mouseoverHandler, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            link.attachEvent(<span class="string">'onmouseover'</span>, mouseoverHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mouseoverHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> link = e.target || e.srcElement;</span><br><span class="line">        <span class="keyword">var</span> url = link.href;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        req.open(<span class="string">'HEAD'</span>, url);</span><br><span class="line">        req.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (req.readyState !== <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> type = req.getResponseHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line">                <span class="keyword">var</span> size = req.getResponseHeader(<span class="string">'Content-Length'</span>);</span><br><span class="line">                <span class="keyword">var</span> date = req.getResponseHeader(<span class="string">'Last-Modified'</span>);</span><br><span class="line"></span><br><span class="line">                link.title = <span class="string">'类型：'</span> + type + <span class="string">' \n'</span> + <span class="string">'大小：'</span> + size + <span class="string">' \n'</span> + <span class="string">'时间：'</span> + date;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!link.title)</span><br><span class="line">                    link.title = <span class="string">"Couldn't fetch details:\n"</span> + req.status + <span class="string">' '</span> + req.statusText;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        req.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (link.removeEventListener)</span><br><span class="line">            link.removeEventListener(<span class="string">'mouseover'</span>, mouseoverHandler, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            link.detachEvent(<span class="string">'onmouseover'</span>, mouseoverHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="二、借助script发送HTTP请求：JSONP"><a href="#二、借助script发送HTTP请求：JSONP" class="headerlink" title="二、借助script发送HTTP请求：JSONP"></a>二、借助script发送HTTP请求：JSONP</h3><p>本文概述提到过<code>&lt;script&gt;</code>元素可以作为一种Ajax传输机制：只须设置<code>&lt;script&gt;</code>元素的src属性（假如它还没插入到document中，需要插入进去），然后浏览器就会发送一个HTTP请求以下载src属性所指向的URL。使用<code>&lt;script&gt;</code>元素进行Ajax传入的一个主要原因是，它不受同源策略的影响，因此可以使用它们从其他的服务器请求数据，第二个原因是包含JSON编码数据的响应体会自动解码执行。</p><blockquote><p><strong>脚本和安全性</strong></p><p>为了使用<code>&lt;script&gt;</code>元素进行Ajax传入，必须允许Web页面可以执行远程服务器发送过来的任何JavaScript代码。这意味着对于不可信的服务器，不应该采取该技术。当与可信的服务器通信时，要提防攻击者可能进入服务器中，然后黑客会接管你的网页，运行他自己的代码，并显示任何他想要的内容，还表现的就像这些内容本就来自你的网站。</p><p>需要注意的是，这种方式普遍用于可信的第三方脚本，特别是在页面中嵌入广告和“组件”。作为Ajax传输使用的<code>&lt;script&gt;</code>与可信的Web服务通信，没有比这更危险的了。</p></blockquote><p>这种使用<code>&lt;script&gt;</code>元素作为Ajax传入的技术称为JSONP，若HTTP请求所得到的响应数据是经过JSON编码的，则适合使用该技术。P代表“填充”或“前缀”。</p><p>假设我们已经写了一个服务，它处理GET请求并返回JSON编码的数据，同源的文档可以在代码中使用XMLHttpRequest和JSON.parse()。加入在服务器上启用了CORS，在新的浏览器上，跨域的文档也可以使用XMLHttpRequest享受到该服务。在不支持CORS的旧浏览器上，跨域文档只能通过<code>&lt;script&gt;</code>元素访问这个服务。使用JSONP，JSON响应数据是合法的JavaScript代码，当它到达时浏览器将执行它。相反，不使用JSONP，而是对JSON编码过的数据解码，结果还是数据，并没有做任何事情。</p><p>这就是JSONP中P的意义所在。当通过<code>&lt;script&gt;</code>元素调用数据时，响应内容必须用JavaScript函数名和圆括号包裹起来。而不是发送这样一段JSON数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">"buckle"</span>: <span class="string">"my shoe"</span>&#125;]</span><br></pre></td></tr></table></figure><p>它会发送这样一个包裹后的JSON响应：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleResponse(</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">"buckle"</span>: <span class="string">"my shoe"</span>&#125;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>包裹后的响应会成为<code>&lt;script&gt;</code>元素的内容，它先判断JSON编码后的数据，然后把它传递给<code>handleResponse()</code>函数，我们可以假设，文档会拿这些数据做一些有用的事情。</p><p>为了可行起见，我们必须通过某种方式告诉服务，它正在从一个<code>&lt;script&gt;</code>元素调用，必须返回一个JSONP响应，而不应该是普通的JSON响应。这个可以通过在URL中添加一个查询参数来实现：例如，追加“<code>?json</code>”。</p><p>在实践中，支持JSONP的服务不会强制指定客户端必须实现的回调函数名称，比如handleResponse。想法，它们使用查询参数的值，允许客户端指定一个函数名，然后使用函数名去填充响应。下面代码使用了一个名为jsonp的查询参数来指定回调函数的名称。许多支持JSONP的服务都能分辨出这个参数名。另一个常见的参数名称是callback，为了让使用到的服务支持类似特殊的需求，就需要在代码上做一些修改了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSONP</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cbnum = <span class="string">'cb'</span> + getJSONP.count++;</span><br><span class="line">    <span class="keyword">var</span> cbname = <span class="string">'getJSONP.'</span> + cbnum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (url.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>)</span><br><span class="line">        url += <span class="string">'?jsonp='</span> + cbname;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        url += <span class="string">'&amp;jsonp='</span> + cbname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line"></span><br><span class="line">    getJSONP[cbnum] = <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callback(response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">delete</span> getJSONP[cbnum];</span><br><span class="line">            script.parentNode.removeChild(script);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    script.src = url;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getJSONP.counter = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="三、基于服务器端推送事件的Comet技术"><a href="#三、基于服务器端推送事件的Comet技术" class="headerlink" title="三、基于服务器端推送事件的Comet技术"></a>三、基于服务器端推送事件的Comet技术</h3><p>在服务器端推送事件的标准草案中定义了一个EventSource对象，简化了Comet应用程序的编写可以传递一个URL给<code>EventSource()</code>构造函数，然后再返回的实例上监听消息事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ticker = <span class="keyword">new</span> EventSource(<span class="string">'stockprices.php'</span>);</span><br><span class="line">ticker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type = e.type;</span><br><span class="line">    <span class="keyword">var</span> data = e.data;</span><br><span class="line">    <span class="comment">// 现在处理事件类型和事件的字符串数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与message事件关联的事件对象有一个data属性，这个属性保存服务器作为该事件的负载发送的任何字符串。如同其他类型的事件一样，该对象还有一个type属性，默认值是message，事件源可以修改这个值。onmessage事件处理程序接收从一个给定的服务器事件源发出的所有事件，如果有必要，也可以根据type属性派发一个事件。</p><p>服务器端推送事件的协议很简单。客户端（创建一个EventSource对象时会）建立一个到服务器的链接，服务器保持这个连接处于打开状态。当发生一个事件时，服务器端在连接中写入几行文本，抛给客户端的事件可能看起来是这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">event: bid              <span class="comment">// 设置时间对象的类型</span></span><br><span class="line">data: GOOG              <span class="comment">// 设置data属性</span></span><br><span class="line">daa: <span class="number">999</span>                <span class="comment">// 追加新的一行和更多的数据</span></span><br><span class="line">                        <span class="comment">// 一个空行会触发消息事件</span></span><br></pre></td></tr></table></figure><p>该协议还有一些额外的细节，比如允许事件携带给定ID，然后再次连上的客户端高速服务器它受到的最后一个事件的ID，这样服务器就可以重新发送客户端错过的事件。</p><p>Comet架构的一个常见应用是聊天应用，聊天客户端可以通过XMLHttpRequest向聊天室发送新的消息，也可以通过EventSource对象订阅聊天信息。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 一个使用EventSource的简易聊天客户端</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 注意一些UI细节</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> nick = prompt(<span class="string">'Enter your nickname'</span>);               <span class="comment">// 获取用户昵称</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>);           <span class="comment">// 找出input表单元素</span></span></span><br><span class="line"><span class="javascript">        input.focus();                                          <span class="comment">// 设置键盘焦点</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 通过EventSource注册新消息的通知</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> chat = <span class="keyword">new</span> EventSource(<span class="string">'/chat'</span>);</span></span><br><span class="line"><span class="javascript">        chat.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;                      <span class="comment">// 当捕获一条消息时</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> msg = event.data;                                <span class="comment">// 从事件对象中取得文本数据</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> node = <span class="built_in">document</span>.createTextNode(msg);            <span class="comment">// 把它放入一个文本节点</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);            <span class="comment">// 创建一个div</span></span></span><br><span class="line"><span class="javascript">            div.appendChild(node);                              <span class="comment">// 将文本节点插入div中</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.insertBefore(div, input);             <span class="comment">// 将div插入input之前</span></span></span><br><span class="line"><span class="javascript">            input.scrollIntoView();                             <span class="comment">// 保证input元素可见</span></span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 使用XMLHttpRequest把用户的消息发送给服务器</span></span></span><br><span class="line"><span class="javascript">        input.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                           <span class="comment">// 用户完成输入</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> msg = nick + <span class="string">': '</span> + input.value;                <span class="comment">// 组合用户名和用户输入的信息</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">            xhr.open(<span class="string">'POST'</span>, <span class="string">'/chat'</span>);                          <span class="comment">// 发送到/chat</span></span></span><br><span class="line"><span class="javascript">            xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain;charset=UTF-8'</span>);</span></span><br><span class="line"><span class="undefined">            xhr.send(msg);</span></span><br><span class="line"><span class="javascript">            input.value = <span class="string">''</span>;                                   <span class="comment">// 准备下次输入</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input"</span> <span class="attr">style</span>=<span class="string">"width:100%"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们通过一个服务器示例结束Comet架构的探讨。下面示例展示了一个用NodeJS编写的定制HTTP服务器。当一个客户端请求根URL为“<code>/</code>”时，它会把上面示例展示的聊天客户端代码发送到客户端。当客户端创建了一个指向“<code>/chat</code>”的GET请求时，它会用一个数组来保存响应数据流并保持连接处于打开状态。当客户端发起针对“chat”的POST请求时，它会将响应的主体部分作为一条聊天消息使用并写入数据，以“<code>data:</code>”作为Server-Sent Events的前缀，添加到每个已打开的响应数据流上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定制的Server-Sent Events聊天服务器</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clientui = <span class="built_in">require</span>(<span class="string">'fs'</span>).readFileSync(<span class="string">'chatclient.html'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServerResponse对象数组，用于接收发送的事件</span></span><br><span class="line"><span class="keyword">var</span> clients = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每20秒发送一条注释到客户端</span></span><br><span class="line"><span class="comment">// 这样它们就不会关闭连接再重连</span></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clients.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">        client.write(<span class="string">':ping?n'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新服务器</span></span><br><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> http.Server();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当服务器获取到一个新的请求，运行回调函数</span></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 解析请求的URL</span></span><br><span class="line">    <span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>).parse(request.url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求是发送到“/”，服务器就发送客户端聊天室UI</span></span><br><span class="line">    <span class="keyword">if</span> (url.pathname === <span class="string">'/'</span>) &#123;</span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>&#125;);</span><br><span class="line">        response.write(clientui);</span><br><span class="line">        response.end();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果请求是发送到“/chat”之外的地址，则返回404</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (url.pathname !== <span class="string">'/chat'</span>) &#123;</span><br><span class="line">        response.writeHead(<span class="number">404</span>);</span><br><span class="line">        response.end();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果请求类型是post，那么就有一个客户端发送了一条新的消息</span></span><br><span class="line">    <span class="keyword">if</span> (request.method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">        request.setEncoding(<span class="string">'utf-8'</span>);</span><br><span class="line">        <span class="keyword">var</span> body = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在获取到数据后，将其添加到请求主体中</span></span><br><span class="line">        request.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">            body += chunk;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当请求完成时，发送一个空响应</span></span><br><span class="line">        <span class="comment">// 并将消息传播到所有处于监听状态的客户端中</span></span><br><span class="line">        request.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            response.writeHead(<span class="number">200</span>);</span><br><span class="line">            response.end();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将消息转换成文本/事件流格式</span></span><br><span class="line">            <span class="comment">// 确保每一行的前缀都是“data:”</span></span><br><span class="line">            <span class="comment">// 并以两个换行符结束</span></span><br><span class="line">            message = <span class="string">'data: '</span> + body + <span class="string">"\r\n\r\n"</span>;</span><br><span class="line">            <span class="comment">// 发送消息给所有监听的客户端</span></span><br><span class="line">            clients.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">                client.write(message);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Otherwise, a client is requesting a stream of messages</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">'Content-Type'</span>: <span class="string">'text/event-stream'</span></span><br><span class="line">        &#125;);</span><br><span class="line">        response.write(<span class="string">'data: Connected\n\n'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果客户端关闭了链接</span></span><br><span class="line">        <span class="comment">// 从活动客户端数组中删除对应的响应对象</span></span><br><span class="line">        request.connection.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            clients.splice(clients.indexOf(response), <span class="number">1</span>);</span><br><span class="line">            response.end();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记下响应对象，这样就可以向他发送未来的消息</span></span><br><span class="line">        clients.push(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器，监听8000端口</span></span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;超文本传输协议（&lt;code&gt;HyperText Transfer Protocol，HTTP&lt;/code&gt;）规定Web浏览器如何从Web服务器获取文档和向Web服务器提交表单内容，以及Web服务器如何响应这些请求和提交。Web浏览器会处理大量HTTP。通常，HTTP并不在脚本的控制下，只是当用户单机链接、提交表单和输入URL时才发生。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript脚本化HTTP" scheme="http://www.xiaoleon.cn/tags/JavaScript%E8%84%9A%E6%9C%AC%E5%8C%96HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JS(10) 脚本化文档</title>
    <link href="http://www.xiaoleon.cn/2018/01/30/js-10/"/>
    <id>http://www.xiaoleon.cn/2018/01/30/js-10/</id>
    <published>2018-01-30T14:33:04.000Z</published>
    <updated>2018-02-02T12:48:05.179Z</updated>
    
    <content type="html"><![CDATA[<p>客户端JavaScript的存在使得静态的HTML文档变成了交互式的Web应用。脚本化Web页面内容是JavaScript的核心目标。每一个Web浏览器窗口、标签页和框架由一个Window对象所表示。每个Window对象有一个document属性引用了Document对象。Document对象表示窗口的内容，Document对象并非独立的，它是一个巨大的API中的核心对象，叫做文档对象模型（<code>Document Object Model，DOM</code>），它代表和操作文档的内容。</p><a id="more"></a><p>本文主要介绍以下内容：</p><ul><li><p>如何在文档中查询或选取单独的元素</p></li><li><p>如何将文档作为节点树来遍历，如何找到任何文档元素的祖先、兄弟和后代元素</p></li><li><p>如何查询和设置文档元素的属性</p></li><li><p>如何通过创建、插入和删除节点来修改文档结构</p></li><li><p>如何与HTML表单一起工作</p></li></ul><hr><h3 id="一、DOM概览"><a href="#一、DOM概览" class="headerlink" title="一、DOM概览"></a>一、DOM概览</h3><p>文档对象模型（DOM）是表示和操作HTML和XML文档内容的基础API。API不是特别复杂，但是需要理解大量的架构细节。首先，应该理解HTML或XML文档的嵌套元素在DOM树对象中的表示。HTML文档的树状结构包含表示HTML标签或元素和表示文本字符串的节点，它也可能包含表示HTML注释的节点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>An HTML Document<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">i</span>&gt;</span>simple<span class="tag">&lt;/<span class="name">i</span>&gt;</span> document.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="二、选取文档元素"><a href="#二、选取文档元素" class="headerlink" title="二、选取文档元素"></a>二、选取文档元素</h3><p>大多数客户端JavaScript程序运行时总是在操作一个或多个文档元素。当这些程序启动时，可以使用全局变量document来引用Document对象。但是，为了操作文档中的元素，必须通过某种方式获得或选取这些引用文档元素的Element对象。DOM定义许多方式来选取元素，查询文档的一个或多个元素有如下办法</p><ul><li><p>用指定的id属性</p></li><li><p>用指定的name属性</p></li><li><p>用指定的标签名字</p></li><li><p>用指定的css类</p></li><li><p>匹配指定的css选择器</p></li></ul><h4 id="1-通过ID获取元素"><a href="#1-通过ID获取元素" class="headerlink" title="1. 通过ID获取元素"></a>1. 通过ID获取元素</h4><p>任何HTML元素可以有一个id属性，在文档中该值必须唯一。可以用Document对象的<code>getElementById()</code>方法选取一个基于唯一ID的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> section1 = <span class="built_in">document</span>.getElementById(<span class="string">'section1'</span>);</span><br></pre></td></tr></table></figure><p>这是最简单和常用的选取元素的方法。如果想要操作某一组指定的文档元素，提供这些元素的id属性值，并使用id查找这些Element对象。如果需要通过ID查找多个元素，会发现下面的<code>getElements()</code>函数非常有用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElements</span>(<span class="params"><span class="regexp">/*ids...*/</span></span>)</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">elements</span> = </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> id = <span class="built_in">arguments</span>[i];</span><br><span class="line">        <span class="keyword">var</span> elt = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">        <span class="keyword">if</span> (elt == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'No element with id: '</span> + id);</span><br><span class="line">        elements[id] = elt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-通过名字选取元素"><a href="#2-通过名字选取元素" class="headerlink" title="2. 通过名字选取元素"></a>2. 通过名字选取元素</h4><p>HTML的name属性最初打算为表单元素分配名字，在表单数据提交到服务器时使用该属性的值。类似id属性，name是给元素分配名字，但是区别于id，name属性的值不是必须唯一：多个元素可能有同样的名字，在表单中，单选和复选按钮通常是这种情况。而且，和id不一样的是name属性只在少数HTML元素中有效，包括表单、表单元素、<code>&lt;iframe&gt;</code>和<code>&lt;img&gt;</code>元素。</p><p>基于name属性的值选取HTML元素，可以使用Document对象的<code>getElementsByName()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> radiobuttons = <span class="built_in">document</span>.getElementsByName(<span class="string">'favorite_color'</span>);</span><br></pre></td></tr></table></figure><p><code>getElementsByName()</code>定义在HTMLDocument类中，而不再Document类中，所以它只针对HTML文档可用，在XML文档中不可用。它返回一个NodeList对象，后者的行为类似一个包含若干Element对象的只读数组。在IE9及以下版本中，<code>getElementsByName()</code>也返回id属性匹配指定值的元素。为了兼容，应该小心谨慎，不要将同样的字符串同时用作名字和id。</p><h4 id="3-通过标签名选取元素"><a href="#3-通过标签名选取元素" class="headerlink" title="3. 通过标签名选取元素"></a>3. 通过标签名选取元素</h4><p>Document对象的<code>getElementsByTagName()</code>方法可以用来选取指定类型（标签名）的所有HTML或XML元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spans = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>);</span><br></pre></td></tr></table></figure><p>类似于<code>getElementsByName()</code>，<code>getElementsByTagName()</code>返回一个NodeList对象，返回的元素按照在文档中的顺序排序。给<code>getElementsByTagName()</code>传递通配符参数“*”将获得一个代表文档中所有元素的NodeList对象。</p><p>Element类也定义<code>getElementsByTagName()</code>方法，其原理和Document版本的一样，但是它只选取调用该方法的元素的后代元素。因此，要查找文档中第一个<code>&lt;p&gt;</code>元素里面的所有<code>&lt;span&gt;</code>元素，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstpara = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> firstParaSpans = firstpara.getElementsByTagName(<span class="string">'span'</span>);</span><br></pre></td></tr></table></figure><p>HTMLDocument对象还定义两个属性，它们指代特殊的单个元素而不是元素的集合。<code>document.body</code>是一个HTML文档的<code>&lt;body&gt;</code>元素，<code>document.head</code>是<code>&lt;head&gt;</code>元素。这些属性总是会定义：如果文档源代码未显式地包含<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>元素，浏览器将隐式地创建它们。Document类的documentElement属性指代文档的跟属性。在HTML文档中，它总是指代<code>&lt;html&gt;</code>元素。</p><h4 id="4-通过css类选取元素"><a href="#4-通过css类选取元素" class="headerlink" title="4. 通过css类选取元素"></a>4. 通过css类选取元素</h4><p>HTML元素的class属性值是一个以空格隔开的列表，可以为空或包含多个标识符。它描述一种方法来定义多组相关的文档元素：在它们的class属性中有相同标识符的任何元素属于改组的一部分。在JavaScript中clsss是保留字，所以客户端JavaScript使用className属性来保存HTML的class属性值。class属性通常与css样式表一起使用，对某组内的所有元素应用相同的样式。</p><p>类似<code>getElementsByTagName()</code>，在HTML文档和HTML元素上都可以调用<code>getElementsByClassName()</code>，它的返回值是一个实时的NodeList对象，包含文档或元素所有匹配的后代节点。<code>getElementsByClassName()</code>只需要一个字符串参数，但是该字符串可以由多个空格隔开的标识符组成。只有当元素的class属性值包含所有的指定的标识符时才匹配，但是标识符的顺序是无关紧要的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> warinings = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'warning'</span>);</span><br><span class="line"><span class="keyword">var</span> log = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'fatal error'</span>);</span><br></pre></td></tr></table></figure><h4 id="5-通过css选择器选取元素"><a href="#5-通过css选择器选取元素" class="headerlink" title="5. 通过css选择器选取元素"></a>5. 通过css选择器选取元素</h4><p>css样式表有一种非常强大的语法，那就是选择器，它用来描述文档中的若干或多组元素。Document对方提供了<code>querySelectorAll()</code>方法，用于根据选择器获取元素。它接收包含一个css选择器的字符串参数，返回一个表示文档中匹配选择器的所有元素的NodeList对象。与前面描述的选取元素的方法不同，<code>querySelectorAll()</code>返回的NodeList对象并不是实时的：它包含在调用时刻选择器所匹配的元素，但它并不更新后续文档的变化。如果没有匹配的元素，<code>querySelectorAll()</code>将会返回一个空的NodeList对象。如果选择器字符串非法，<code>querySelectorAll()</code>将抛出一个异常。</p><p>除了<code>querySelectorAll()</code>，文档对象还定义了<code>querySelector()</code>方法，与前者工作原理类似，但它只返回第一个匹配的元素，或者如果没有匹配的元素就返回null。</p><p>这两个方法在Element节点中也有定义。在元素上调用时，指定的选择器仍然在整个文档中进行匹配，然后过滤出结果集以便它只包含指定元素的后代元素。这看起来是违反常规的，因为它意味着选择器字符串能包含元素的祖先而不仅仅是上述所匹配的元素。</p><p>注意，css定义了“<code>:first-line</code>”和“<code>:first-letter</code>”等伪元素。在css中，它们匹配文本节点的一部分而不是实际元素。如果和<code>querySelectorAll()</code>或<code>querySelector()</code>一起使用它们是不匹配的。而且，很多浏览器会拒绝返回“<code>:link</code>”和“<code>:visited</code>”等伪类的匹配结果，因为这会泄漏用户的浏览历史记录。</p><p><code>querySelectorAll()</code>是终极的选取元素的方法：它是一种非常强大的技术，通过它客户端的JavaScript程序能选择它们想要操作的元素。幸运的是，甚至在没有<code>querySelectorAll()</code>的原生支持的浏览器中也可以使用css选择器。jQuery库使用这种基于css选择器的查询作为它的核心编程方式。基于jQuery的Web应用程序使用一个轻便的、跨浏览器的、和<code>querySelectorAll()</code>等效的方法，命名为<code>$()</code>。</p><p>jquery的css选择器匹配代码已经作为一个独立的标准库提出来并发布了，命名为Sizzle。它已经被Dojo和其他一些客户端库所采纳，使用一个类似Sizzle的库的好处就是在老式浏览器中选取元素也能正常工作，并保证一个基准的选择器集合在所有的浏览器中都能运行。</p><h4 id="6-document-all"><a href="#6-document-all" class="headerlink" title="6. document.all"></a>6. document.all</h4><p>在DOM标准化之前，IE引入了<code>document.all</code>集合来表示所有文档中的元素（除了Text节点）。<code>document.all</code>已经被标准的方法所取代，现在已经废弃不应该再使用了。</p><hr><h3 id="三、文档结构和遍历"><a href="#三、文档结构和遍历" class="headerlink" title="三、文档结构和遍历"></a>三、文档结构和遍历</h3><p>一旦从文档中选取了一个元素，有时需要查找文档中与之在结构上相关的部分（父亲、兄弟和子女）。文档从概念上可以看作是一颗节点对象树。</p><h4 id="1-作为节点树的文档"><a href="#1-作为节点树的文档" class="headerlink" title="1. 作为节点树的文档"></a>1. 作为节点树的文档</h4><p>Document对象、它的Element对象和文档中表示文本的Text对象都是Node对象。Node对象定义了以下重要的属性：</p><ul><li><p><code>parentNode</code></p><p>  该节点的父节点，或者针对类似Document对象应该是null，因为它没有父节点。</p></li><li><p><code>childNodes</code></p><p>  只读的类数组对象（NodeList对象），它是该节点的子节点的实时表示。</p></li><li><p><code>firstChild</code>、<code>lastChild</code></p><p>  该节点的子节点中的第一个和最后一个，如果该节点没有子节点则为null。</p></li><li><p><code>nextSibling</code>、<code>previousSibling</code></p><p>  该节点的兄弟节点中的前一个和下一个。具有相同父节点的两个节点为兄弟节点。节点的顺序反映了它们在文档中出现的顺序。这两个属性将节点之间以双向链表的形式连接起来。</p></li><li><p><code>nodeType</code></p><p>  该节点的类型。9代表Document节点，1代表Element节点，3代表Text节点，8代表Comment节点，11代表DocumentFragment节点。</p></li><li><p><code>nodeValue</code></p><p>  Text节点或Comment节点的文本内容。</p></li><li><p><code>nodeName</code></p><p>  元素的标签名，以大写形式表示。</p></li></ul><p>使用这些Node属性，可以用以下类似的表达式得到文档的第一个子节点下面的第二个子节点的引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.childNodes[<span class="number">0</span>].childNodes[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">document</span>.firstNode.firstChild.nextSibling;</span><br></pre></td></tr></table></figure><p>假设上述提到的文档代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么第一个子节点下面的第二个子节点就是<code>&lt;body&gt;</code>元素，它的nodeType为1，nodeName为“BODY”。</p><p>但请注意，该API对文档文本的变化极为敏感。例如，如果修改了文档，在<code>&lt;html&gt;</code>和<code>&lt;head&gt;</code>标签之间插入一个新行，那么表示该新行的Text节点就是文档的第一个子节点下面的第一个子节点，并且<code>&lt;head&gt;</code>元素就是第二个子节点而不是<code>&lt;body&gt;</code>元素了。</p><h4 id="2-作为元素树的文档"><a href="#2-作为元素树的文档" class="headerlink" title="2. 作为元素树的文档"></a>2. 作为元素树的文档</h4><p>当将主要的兴趣点集中在文档的元素上而非它们之间的文本（和它们之间的空白）上时，我们可以使用另外一个更有用的API。它将文档看作是Element对象树，忽略部分文档：Text和Comment节点。</p><p>该API的第一部分是Element对象的children属性。类似ChildNodes，他也是一个NodeList对象，但不同的是children列表只包含Element对象。children并非标准属性，但是它在所有当前的浏览器中都能工作。</p><p>注意，Text和Comment节点没有children属性，它意味着<code>Node.parentNode</code>属性不可能返回Text或Comment节点。任何Element的parentNode总是另一个Element，或者，追溯到树根的Document或DocumentFragment节点。</p><p>基于元素的文档遍历API的第二部分是Element属性，后者类似Node对象的子属性和兄弟属性</p><p><code>firstElementChild，lastElementChild</code>：类似<code>firstChild</code>和<code>lastChild</code>，但只代表子Element。</p><p><code>nextElementSibling，previousElementSibling</code>：类似<code>nextSibling</code>和<code>previousSibling</code>，但只代表兄弟Element。</p><p><code>childElementCount</code>：子元素的数量。返回的值和<code>children.length</code>值相等。</p><p>子元素和兄弟元素的属性是标准属性。由于逐个元素的文档遍历的API并未完全标准化，我们仍然可以通过如下的遍历函数来实现这种功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回元素e的第n层祖先元素，如果不存在此类祖先或祖先不是Element，</span></span><br><span class="line"><span class="comment">（列入Document或DocumentFragment）则返回null</span></span><br><span class="line"><span class="comment">如果n为0，则返回e本身</span></span><br><span class="line"><span class="comment">如果n为1，则返回其父元素</span></span><br><span class="line"><span class="comment">如果n为2，则返回其祖父元素，依此类推</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parent</span>(<span class="params">e, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="literal">undefined</span>)</span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; e) &#123;</span><br><span class="line">        e = e.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!e || e.nodeType !== <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回元素e的第n个兄弟元素</span></span><br><span class="line"><span class="comment">如果n为正，返回后续的第n个兄弟元素</span></span><br><span class="line"><span class="comment">如果n为负，返回前面的第n个兄弟元素</span></span><br><span class="line"><span class="comment">如果n为零，返回e本身</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sibling</span>(<span class="params">e, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(e &amp;&amp; n !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.nextElementSibling) &#123;</span><br><span class="line">                e = e.nextElementSibling;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (e = e.nextSibling; e &amp;&amp; e.nodeType !== <span class="number">1</span>; e = e.nextSibling) &#123;</span><br><span class="line">                    <span class="comment">// 空循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.previousElementSibling) &#123;</span><br><span class="line">                e = e.previousElementSibling;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (e = e.previousSibling; e &amp;&amp; e.nodeType !== <span class="number">1</span>; e = e.previousSibling) &#123;</span><br><span class="line">                    <span class="comment">// 空循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回元素e的第n代子元素，如果不存在则为null</span></span><br><span class="line"><span class="comment">负值n代表从后往前技术。0表示第一个子元素，而-1代表最后一个</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params">e, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.children) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 转换负的n为数组索引</span></span><br><span class="line">            n += e.children.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e.children[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.firstElementChild) &#123;</span><br><span class="line">            e = e.firstElementChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (e = e.firstChild; e &amp;&amp; e.nodeType !== <span class="number">1</span>; e = e.nextSibling) &#123;</span><br><span class="line">                <span class="comment">// 空循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sibling(e, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.lastElementChild) &#123;</span><br><span class="line">            e = e.lastElementChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (e = e.lastChild; e &amp;&amp; e.nodeType !== <span class="number">1</span>; e = e.previousSibling) &#123;</span><br><span class="line">                <span class="comment">// 空循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sibling(e, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-自定义Element的方法"><a href="#3-自定义Element的方法" class="headerlink" title="3. 自定义Element的方法"></a>3. 自定义Element的方法</h4><p>所有当前浏览器都实现了DOM，故类似Element和HTMLDocument等类型都像String和Array一样是类。他们不是构造函数，但它们有原型对象，可以用自定义方法扩展它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.nextElementSibling)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.nextElementSibling;</span><br><span class="line">    <span class="keyword">var</span> sib = <span class="keyword">this</span>.nextSibling;</span><br><span class="line">    <span class="keyword">while</span>(sib &amp;&amp; sib.nodeType !== <span class="number">1</span>) &#123;</span><br><span class="line">        sib = sib.nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sib;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="四、属性"><a href="#四、属性" class="headerlink" title="四、属性"></a>四、属性</h3><p>HTML元素由一个标签和一组称为属性（attribute）的名值对组成。HTML元素的属性值在代表这些元素的HTMLElement对象的属性（property）中是可用的。DOM还定义了另外的API来获取或设置XML属性值和非标准的HTML属性。</p><h4 id="1-HTML属性作为Element的属性"><a href="#1-HTML属性作为Element的属性" class="headerlink" title="1. HTML属性作为Element的属性"></a>1. HTML属性作为Element的属性</h4><p>表示HTML文档元素的HTMLElement对象定义了读/写属性，它们影射了元素的HTML属性。HTMLElement定义了通用的HTTP属性（如id、标题lang和dir）的属性，以及事件处理程序属性（如onclick）。特定的Element子类型为其元素定义了特定的属性。例如，查询一张图片的url，可以使用表示<code>&lt;img&gt;</code>的HTMLElement对象的src属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">'myimage'</span>);</span><br><span class="line"><span class="keyword">var</span> imgurl = image.src;</span><br><span class="line">image.id === <span class="string">'myimage'</span>;</span><br></pre></td></tr></table></figure><p>同样的，可以为一个<code>&lt;form&gt;</code>元素设置表单提交的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.forms[<span class="number">0</span>];</span><br><span class="line">f.action = <span class="string">'http://www.example.com/submit.php'</span>;</span><br><span class="line">f.method = <span class="string">'post'</span>;</span><br></pre></td></tr></table></figure><p>HTML属性名不区分大小写，但JavaScript属性名则大小写敏感。从HTML属性名转换到JavaScript属性名应该采用小写。但是，如果属性名包含不止一个单词，则将除了第一个单词以外的单词的首字母大写，例如defaultChecked和tabIndex。</p><p>有些HTML属性名在JavaScript中是保留字。对于这些属性，一般的规则是为属性名加前缀“html”。例如，HTML的for属性在JavaScript中变为htmlFor属性。但“class”在JavaScript中变为className。</p><p>表示HTML属性的值通常是字符串。当属性为布尔值或数值，属性也是布尔值或数值，而不是字符串。事件处理程序属性值总是Function对象（或null）。H5规范定义了一个新的属性（如<code>&lt;input&gt;</code>和相关元素的form属性）用以将元素ID转换为实际的Element对象。最后，任何HTML元素的style属性值是<code>CSSStyleDeclaration</code>对象，而不是字符串。</p><p>注意，这个基于属性的API用来获取和设置属性值，但没有定义任何从元素中删除属性的方法。奇怪的是，delete操作符也无法完成此目的。</p><h4 id="2-获取和设置非标准HTML属性"><a href="#2-获取和设置非标准HTML属性" class="headerlink" title="2. 获取和设置非标准HTML属性"></a>2. 获取和设置非标准HTML属性</h4><p>如上所述，HTMLElement和其子类型定义了一些属性，它们对应于元素的标准HTML属性。Element类型还定义了<code>getAttribute()</code>和<code>setAttribute()</code>方法来查询和设置非标准的HTML属性，也可用来查询和设置XML文档中元素上的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> image = <span class="built_in">document</span>.images[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> width = <span class="built_in">parseInt</span>(image.getAttribute(<span class="string">'width'</span>));</span><br><span class="line">image.setAttribute(<span class="string">'class'</span>, <span class="string">'thumbnail'</span>);</span><br></pre></td></tr></table></figure><p>上述代码给出了这些方法和前面的基于属性的API之间两个重要的区别。首先，属性值都被看作是字符串。<code>getAttribute()</code>不返回数值、布尔值或对象。其次，方法使用标准属性名，甚至当这些名称为JavaScript保留字时也不例外。对HTML元素来说，属性名不区分大小写。</p><p>Element类还定义了两个相关方法，<code>hasAttribute()</code>和<code>removeAttribute()</code>，它们用来检测命名属性是否存在和完全删除属性。当属性为布尔值时这些方法特别有用：有些属性（如disabled等）在一个元素中是否存在是重点关键，而其值却无关紧要。</p><h4 id="3-数据集属性"><a href="#3-数据集属性" class="headerlink" title="3. 数据集属性"></a>3. 数据集属性</h4><p>有时候在HTML元素上绑定一些额外的信息也是很有帮助的，当JavaScript选取这些元素并以某种方式操纵这些信息时就是很典型的情况。有时可以通过给class属性添加特殊的标识符来完成。其他时候针对更复杂的数据，客户端程序员会借助使用非标准的属性。如上所述，可以使用<code>getAttribute()</code>和<code>setAttribute()</code>来读和写非标准属性的值。</p><p>H5提供了一个解决方案。在HTML5文档中，任意以“<code>data-</code>”为前缀的小写的属性名字都是合法的。这些“数据集属性”将不会对其元素的表现产生影响，它们定义了一种标准的、附加额外数据的方法，并不是在文档合法性上做出让步。</p><p>H5还在Element对象上定义了<code>dataset</code>属性。该属性指代一个对象，它的各个属性对应于去掉前缀的<code>data-</code>属性。因此<code>dataset.x</code>应该保存<code>data-x</code>属性的值。带连字符的属性对应于驼峰命名法属性名：<code>data-jquery-test</code>属性就变成<code>dataset.jqueryTest</code>属性。</p><h4 id="4-作为Attr节点的属性"><a href="#4-作为Attr节点的属性" class="headerlink" title="4. 作为Attr节点的属性"></a>4. 作为Attr节点的属性</h4><p>还有一种使用Element的属性的方法。Node类型定义了attributes属性。针对非Element对象的任何节点，该属性为null。对于Element对象，attributes属性是只读的类数组对象，它代表元素的所有属性。类似Nodelists，attributes对象也是实时的。它可以用数字索引访问，这意味着可以枚举元素的所有属性。并且，它也可以用属性名索引。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.attributes[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">document</span>.body.attributes.bgColor;</span><br><span class="line"><span class="built_in">document</span>.body.attributes[<span class="string">'onload'</span>];</span><br></pre></td></tr></table></figure><p>当索引attributes对象时得到的值是Attr对象。Attr对象一类特殊的Node，但从来不会像Node一样去用。Attr的name和value属性返回该属性的名字和值。</p><hr><h3 id="五、元素的内容"><a href="#五、元素的内容" class="headerlink" title="五、元素的内容"></a>五、元素的内容</h3><h4 id="1-作为HTML的元素内容"><a href="#1-作为HTML的元素内容" class="headerlink" title="1. 作为HTML的元素内容"></a>1. 作为HTML的元素内容</h4><p>读取Element的innerHTML属性作为字符串标记返回那个元素的内容。在元素上设置该属性调用了Web浏览器的解析器，用新字符串内容的解析展现形式替换元素当前内容。</p><p>Web浏览器很擅长解析HTML，通常设置innerHTML效率非常高，甚至在指定的值需要解析时效率也是相当不错。但注意，对innerHTML属性用“+=”操作符重复追加一小段文本通常效率低下，因为它既要序列化又要解析。</p><p>innerHTML是IE4中引入的，虽然所有的浏览器都支持他已经有很长时段时间了，但随着H5的到来它才变得标准化。H5说innerHTML应该在Document节点以及Element节点上工作正常，但这还未被普遍地支持。</p><p>H5还标准化了outerHTML属性。当查询outerHTML时，返回的HTML或XML标记的字符串包含被查询元素的开头和结尾标签。当设置元素的outerHTML时，元素本身被新的内容所替换。只有Element节点定义了outerHTML属性，Document节点则无。</p><p>IE引入的另一个特性是<code>insertAdjacentHTML()</code>方法，它将在H5中标准化，它将任意的HTML标记字符插入到指定的元素“相邻”的位置。标记是该方法的第二个参数，并且“相邻”的精确含义依赖于第一个参数的值。第一个参数为具有以下值之一的字符串：<code>“beforebegin”、“afterbegin”、“beforeend”和“afterend”</code>。</p><pre><code>|&lt;div id=&quot;target&quot;&gt;|This is the element content|&lt;/div&gt;|↑                 ↑                           ↑      ↑beforebegin   afterbegin                  beforeend  afterend</code></pre><h4 id="2-作为纯文本的元素内容"><a href="#2-作为纯文本的元素内容" class="headerlink" title="2. 作为纯文本的元素内容"></a>2. 作为纯文本的元素内容</h4><p>有时需要查询纯文本形式的元素内容，或者在文档中插入纯文本（不必转义HTML标记中使用的尖括号和&amp;符号）。标准的方法是用Node的textContent属性来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> text = para.textContent;</span><br><span class="line">para.textContent = <span class="string">'hello world!'</span>;</span><br></pre></td></tr></table></figure><p><code>textContent</code>属性在除了低版本IE的所有当前浏览器中都支持。在IE中，可以用Element的innerText属性来代替。微软在IE 4中引入了innerText属性，它在除了低版本的FireFox的所有当前浏览器都支持。</p><p><code>textContent</code>和<code>innerText</code>属性非常相似，通常可以互相替换使用。不过要小心空元素（在JavaScript中字符串””是假值）和未定义的属性之间的区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个参数，返回元素的textContent或innerText</span></span><br><span class="line"><span class="comment">两个参数，用value参数的值设置元素的textContent或innerText</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">textContent</span>(<span class="params">element, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content = element.textContent;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (content !== <span class="literal">undefined</span>)</span><br><span class="line">            <span class="keyword">return</span> content;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> element.innerText;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (content !== <span class="literal">undefined</span>)</span><br><span class="line">            element.textContent = value;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            element.innerText = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>textContent属性就是将指定元素的所有后代Text节点简单地串联在一起。innerText没有一个明确指定的行为，但是和textContent有一些不同。innerText不返回<code>&lt;script&gt;</code>元素的内容。它忽略多余的空白，并试图保留表格格式。同时，innerText针对某些表格元素（<code>&lt;table&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;tr&gt;</code>）是只读的属性。</p><h4 id="3-作为Text节点的元素内容"><a href="#3-作为Text节点的元素内容" class="headerlink" title="3. 作为Text节点的元素内容"></a>3. 作为Text节点的元素内容</h4><p>另一种方法处理元素的内容是当作一个子节点列表，每个子节点可能有它字迹的一组子节点。当考虑元素的内容时，通常感兴趣的是它的Text节点。</p><p>下面展示一个<code>textContent()</code>函数，它递归地遍历元素的子节点，然后连接后代节点中所有的Text节点的文本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">textContent</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> child, type, s = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(child = e.firstChild; child != <span class="literal">null</span>; child = child.nextSibling) &#123;</span><br><span class="line">        type = child.nodeType;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="number">3</span> || type === <span class="number">4</span>)</span><br><span class="line">            s += child.nodeValue;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="number">1</span>)</span><br><span class="line">            s += textContent(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nodeValue属性可以读/写，设置它可以改变Text或CDATASection节点所显示的内容。Text和CDATASection都是CharacterData的子类型。CharacterData定义了data属性，它和nodeValue的文本相同。以下函数通过设置data属性将Text节点的内容转换成大写形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upcase</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n.nodeType == <span class="number">3</span> || n.nodeType == <span class="number">4</span>)     <span class="comment">// 如果n是Text或CDATA节点</span></span><br><span class="line">        n.data = n.data.toUpperCase();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n.childNodes.length; i++)</span><br><span class="line">            upcase(n.childNodes[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CharacterData还定义了一些在Text或CDATASection节点不太常用的方法来添加、删除、插入和替换文本。除了修改已存在Text节点的内容，还可以在Element中插入全新的Text节点或用新Text节点来替换已有节点。</p><hr><h3 id="六、创建、插入和删除节点"><a href="#六、创建、插入和删除节点" class="headerlink" title="六、创建、插入和删除节点"></a>六、创建、插入和删除节点</h3><p>我们已经看到用HTML和纯文本字符串如何来查询和修改文档内容，也已经看到我们能够遍历Document来检查组成Document的每个Element和Text节点。在每个节点级别修改文档也是有可能的。Document类型定义了创建Element和Text对象的方法，Node类型定义了在节点树中插入、删除和替换的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadasync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    s.src = url;</span><br><span class="line">    head.appendChild(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-创建节点"><a href="#1-创建节点" class="headerlink" title="1. 创建节点"></a>1. 创建节点</h4><p>创建新的Element节点可以使用Document对象的<code>createElement()</code>方法。给方法传递元素的标签名：对HTML文档来说该文档不区分大小写，对XML文档则区分大小写。</p><p>Text节点用类似的方法创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newnode = <span class="built_in">document</span>.createTextNode(<span class="string">'text node content'</span>);</span><br></pre></td></tr></table></figure><p>Document也定义了一些其他的工厂方法，如不经常使用的<code>createComment()</code>、<code>createDocumentFragment()</code>。</p><p>另一种创建新文档节点的方法是复制已存在的节点。每个节点有一个<code>cloneNode()</code>方法来返回该节点的一个全新副本。给方法传递参数true也能够递归地复制所有的后代节点，或传递参数false只是执行一个浅复制。在除了IE的其他浏览器中，Document对象还定义了一个类似的方法叫<code>importNode()</code>。如果给它传递另一个文档的一个节点，它将返回一个适合本文档插入的节点的副本。传递true作为第二个参数，该方法将递归地导入所有的后代节点。</p><h4 id="2-插入节点"><a href="#2-插入节点" class="headerlink" title="2. 插入节点"></a>2. 插入节点</h4><p>一旦有了一个新节点，就可以用Node的方法<code>appendChild()</code>或<code>insertBefore()</code>将它插入到文档中。<code>appendChild()</code>是在需要插入的Element节点上调用的，它插入指定的节点使其称为那个节点的最后一个子节点。</p><p><code>insertBefore()</code>就像<code>appencChild()</code>一样，除了它接收两个参数。第一个参数就是待插入的节点，第二个参数是已存在的节点，新节点将插入该节点的前面。该方法应该是在新节点的父节点上调用，方法的第二个参数必须是该父节点的子节点。如果传递null作为第二个参数，<code>insertBefore()</code>的行为类似<code>appencChild()</code>，它将节点插入在最后。</p><p>如果调用<code>appencChild()</code>或<code>insertBefore()</code>将已存在文档中的一个节点再次插入，那么节点将自动从它当前的位置删除并在新的位置重新插入：没有必要显式地删除该节点。</p><h4 id="3-删除和替换节点"><a href="#3-删除和替换节点" class="headerlink" title="3. 删除和替换节点"></a>3. 删除和替换节点</h4><p><code>removeChild()</code>方法是从文档树中删除一个节点。但是请小心：该方法不是在待删除的节点上调用，而是在其父节点上调用。在父节点上调用该方法，并将需要删除的子节点作为方法参数传递给它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n.parentNode.removeChild(n);</span><br></pre></td></tr></table></figure><p><code>replaceChild()</code>方法删除一个子节点并用一个新的节点取而代之。在父节点上调用该方法，第一个参数是新节点，第二个参数是需要代替的节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n.parentNode.replaceChild(<span class="built_in">document</span>.createTextNode(<span class="string">'[ REDACRTED ]'</span>, n));</span><br></pre></td></tr></table></figure><h4 id="4-使用DocumentFragment"><a href="#4-使用DocumentFragment" class="headerlink" title="4. 使用DocumentFragment"></a>4. 使用DocumentFragment</h4><p>DocumentFragment是一种特殊的Node，它作为其他节点的一个临时的容器。像这样创建一个DocumentFragment</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment();</span><br></pre></td></tr></table></figure><p>像Document节点一样，DocumentFragment是独立的，而不是任何其他文档的一部分。它的parentNode总是null。但类似Element，它可以有任意多的子节点，可以用<code>appendChild()</code>、<code>insertBefore()</code>等方法来操作它们。</p><p>DocumentFragment的特殊之处在于它使得一组节点被当作一个节点看待：如果给<code>appendChild()</code>、<code>insertBefore()</code>或<code>replaceChild()</code>传递一个DocumentFragment，其实是将该文档片段的所有子节点插入到文档中，而非片段本身。（文档片段的子节点从片段移动到文档中，文档片段清空以便重用。）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倒序排序节点n的子节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="comment">// 从后至前循环子节点，将每一个子节点移动到文档片段中</span></span><br><span class="line">    <span class="comment">// n的最后一个节点变成f的第一个节点，反之亦然</span></span><br><span class="line">    <span class="comment">// 注意，给f添加一个节点，该节点自动地会从n中删除</span></span><br><span class="line">    <span class="keyword">while</span>(n.lastChild)</span><br><span class="line">        f.appendChild(n.lastChild);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后，把f的所有子节点一次性全部移回n中</span></span><br><span class="line">    n.appendChild(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面代码使用innerHTML属性和DocumentFragment实现<code>insertAdjacentHTML()</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Insert = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.createElement(<span class="string">'div'</span>).insertAdjacentHTML) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            before: <span class="function"><span class="keyword">function</span>(<span class="params">e, h</span>) </span>&#123; e.insertAdjacentHTML(<span class="string">'beforebegin'</span>, h); &#125;,</span><br><span class="line">            after: <span class="function"><span class="keyword">function</span>(<span class="params">e, h</span>) </span>&#123; e.insertAdjacentHTML(<span class="string">'afterend'</span>, h); &#125;,</span><br><span class="line">            atStart: <span class="function"><span class="keyword">function</span>(<span class="params">e, h</span>) </span>&#123; e.insertAdjacentHTML(<span class="string">'afterbegin'</span>, h); &#125;,</span><br><span class="line">            atEnd: <span class="function"><span class="keyword">function</span>(<span class="params">e, h</span>) </span>&#123; e.insertAdjacentHTML(<span class="string">'beforeend'</span>, h); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fragment</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> elt = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">        <span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">        elt.innerHTML = html;</span><br><span class="line">        <span class="keyword">while</span>(elt.firstChild)</span><br><span class="line">            frag.appendChild(elt.firstChild);</span><br><span class="line">        <span class="keyword">return</span> frag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> Insert = &#123;</span><br><span class="line">        before: <span class="function"><span class="keyword">function</span>(<span class="params">elt, html</span>) </span>&#123;</span><br><span class="line">            elt.parentNode.insertBefore(fragment(html), elt);</span><br><span class="line">        &#125;,</span><br><span class="line">        after: <span class="function"><span class="keyword">function</span>(<span class="params">elt, html</span>) </span>&#123;</span><br><span class="line">            elt.parentNode.insertBefore(fragment(html), elt.nextSibling);</span><br><span class="line">        &#125;,</span><br><span class="line">        atStart: <span class="function"><span class="keyword">function</span>(<span class="params">elt, html</span>) </span>&#123;</span><br><span class="line">            elt.insertBefore(fragment(html), elt.firstChild);</span><br><span class="line">        &#125;,</span><br><span class="line">        atEnd: <span class="function"><span class="keyword">function</span>(<span class="params">elt, html</span>) </span>&#123;</span><br><span class="line">            elt.appendChild(fragment(html));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Element.prototype.insertAdjacentHTML = <span class="function"><span class="keyword">function</span>(<span class="params">pos, html</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(pos.toLowerCase()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'beforebegin'</span>: <span class="keyword">return</span> Insert.before(<span class="keyword">this</span>, html);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'afterend'</span>: <span class="keyword">return</span> Insert.after(<span class="keyword">this</span>, html);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'afterbegin'</span>: <span class="keyword">return</span> Insert.atStart(<span class="keyword">this</span>, html);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'beforeend'</span>: <span class="keyword">return</span> Insert.atEnd(<span class="keyword">this</span>, html);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Insert;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><hr><h3 id="七、文档和元素的几何形状和滚动"><a href="#七、文档和元素的几何形状和滚动" class="headerlink" title="七、文档和元素的几何形状和滚动"></a>七、文档和元素的几何形状和滚动</h3><p>在本文中，到目前为止我们考虑的文档被看作是元素和文本节点的抽象树。但是当浏览器在窗口中渲染文档时，它创建文档的一个视图表现层，在那里每个元素有自己的位置和尺寸。通常，Web应用程序可以将文档看作是元素的树，并且不用关心在屏幕上这些元素是如何渲染的。但有时，判定一个元素精确的几个形状也是非常有必要的。如果想用css动态定位一个元素到某个已经由浏览器定位后的普通元素的旁边，首先需要判定那个元素的当前位置。</p><p>本节阐述了在浏览器窗口中完成文档的布局以后，怎样才能在抽象的基于树的文档模型与几何形状的基于坐标的视图之间来回变换。</p><h4 id="1-文档坐标和视口坐标"><a href="#1-文档坐标和视口坐标" class="headerlink" title="1. 文档坐标和视口坐标"></a>1. 文档坐标和视口坐标</h4><p>元素的位置是以像素来度量的，向右代表X坐标的增加，向下代表Y坐标的增加。但是，有两个不同的点作为坐标系的原点：元素的X和Y坐标可以相对于文档的左上角或者相对于在其中显示文档的视口的左上角。在顶级窗口和标签页中，“视口”只是实际显示文档内容的浏览器的一部分：它不包括浏览器“外壳”（如菜单、工具条和标签页）。针对框架页中显示的文档，视口是定义了框架页的<code>&lt;iframe&gt;</code>元素。无论在何种情况下，当讨论元素的位置时，必须弄清楚所使用的坐标是文档坐标还是视口坐标。（视口坐标有时也叫做窗口坐标）。</p><p>如果文档比视口要小，或者说它还未出现滚动，则文档的左上角就是视口的左上角，文档和视口坐标系统是同一个。但是，一般来说，要在两种坐标系之间互相转换，必须加上或减去滚动的偏移量（scroll offset）。例如，在文档坐标中如果一个元素的Y坐标是200px，并且用户已经把浏览器向下滚动75px，那么视口坐标中元素的Y坐标是125px。同样，在视口坐标中如果一个元素的X坐标是400px，并且用户已经水平滚动了视口200px，那么文档坐标中元素的X坐标是600px。</p><p>文档坐标比视口坐标更加基础，并且在用户滚动时它们不会发生变化。不过，在客户端编程中使用视口坐标是非常常见的。当使用css指定元素的位置时运用了文档坐标。但是，最简单的查询元素位置的方法返回视口坐标中的位置。类似地，当为鼠标事件注册事件处理程序函数时，报告的鼠标指针的坐标是在视口坐标系中的。</p><p>为了在坐标系之间互相转换，我们需要判定浏览器窗口的滚动条的位置。Window对象的pageXOffset和pageYOffset属性在所有的浏览器中提供这些值。也可以通过scrollLeft和scrollTop属性来获得滚动条的位置。</p><p>令人迷惑的是，正常情况下通过查询文档的根节点（<code>document.documentElement</code>）来获取这些属性值，但在怪异模式下，必须在文档的<code>&lt;body&gt;</code>元素（<code>document.body</code>）上查询它们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollOffset</span>(<span class="params">w</span>) </span>&#123;</span><br><span class="line">    w = w || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w.pageXOffset != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            x: w.pageXOffset,</span><br><span class="line">            y: w.pageYOffset</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> d = w.document;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">'CSS1Compat'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            x: d.documentElement.scrollLeft,</span><br><span class="line">            y: d.documentElement.scrollTop</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  &#123;</span><br><span class="line">        x: d.body.scrollLeft,</span><br><span class="line">        y: d.body.scrollTop</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时能够判定视口的尺寸也是非常有用的——例如，为了确定文档的哪些部分是当前可见的。利用滚动偏移量查询视口尺寸的简单方法在IE8及更早的版本中无法工作，而且该技术在IE中的运行方式还要取决于浏览器处于怪异模式还是标准模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewportSize</span>(<span class="params">w</span>) </span>&#123;</span><br><span class="line">    w = w || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w.innerWidth != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            w: w.innerWidth,</span><br><span class="line">            h: w.innerHeight</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> d = w.document;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">'CSS1Compat'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            w: d.documentElement.clientWidth,</span><br><span class="line">            h: d.documentElement.clientHeight</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        w: d.body.clientWidth,</span><br><span class="line">        h: d.body.clientHeight</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-查询元素的几何尺寸"><a href="#2-查询元素的几何尺寸" class="headerlink" title="2. 查询元素的几何尺寸"></a>2. 查询元素的几何尺寸</h4><p>判定一个元素的尺寸和位置最简单的方法是调用它的<code>getBoundingClientRect()</code>方法。该方法是在IE5中引入的，而现在当前的所有浏览器都实现了。它不需要参数，返回一个有left、right、top和bottom属性的对象。</p><p>这个方法返回元素在视口坐标中的位置。（<code>getBoundingClientRect()</code>方法名中的“Client”是一种间接指代，它就是Web浏览器客户端——专指它定义的窗口或视口。）为了转化为甚至用户滚动浏览器窗口以后仍然有效的文档坐标，需要加上滚动的偏移量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = e.getBoundingClientRect();</span><br><span class="line"><span class="keyword">var</span> offsets = getScrollOffsets();</span><br><span class="line"><span class="keyword">var</span> x = box.left + offsets.x;</span><br><span class="line"><span class="keyword">var</span> y = box.top + offsets.y;</span><br></pre></td></tr></table></figure><p><code>getBoundingClientRect()</code>返回的对象还包含width和height属性，但是在低版本IE中未实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = e.getBoundingClientRect();</span><br><span class="line"><span class="keyword">var</span> w = box.width || (box.right - box.left);</span><br><span class="line"><span class="keyword">var</span> h = box.height || (box.bottom - box.top);</span><br></pre></td></tr></table></figure><p>注意：<code>getBoundingClientRect()</code>所返回的坐标包含元素的边框和内边距，但不包含元素的外边距。</p><p>如果<code>getBoundingClientRect()</code>方法名中的“Client”指定了返回的矩形的坐标系，那么方法名中的“Bounding”作何解释呢？浏览器在布局时块状元素（如图片、段落和div元素等）总是为矩形。但是，内联元素（如span、code和b等）可能垮了多行，因此可能由多个矩形组成。想像一下，一些被断成两行的斜体文本（用<code>&lt;i&gt;&lt;/i&gt;</code>标记的）。它的形状是由第一行的右边部分和第二行的左边部分两个矩形组成的。如果在内联元素上调用<code>getBoundingClientRect()</code>，它返回“边界矩形”。对于如上描述的<code>&lt;i&gt;</code>元素，边界矩形会包含整整两行的宽度。</p><p>如果想查询内联元素每个独立的矩形，调用<code>getClientRects()</code>方法来获得一个只读的类数组对象，它的每个元素类似于<code>getBoundingClientRect()</code>返回的矩形对象。</p><p>注意，<code>getBoundingClientRect()</code>和<code>getClientRects()</code>所返回的矩形对象并不是实时的。在用户滚动或改变浏览器窗口大小时不会更新它们。</p><h4 id="3-判定元素在某点"><a href="#3-判定元素在某点" class="headerlink" title="3. 判定元素在某点"></a>3. 判定元素在某点</h4><p><code>getBoundingClientRect()</code>方法使我们能在视口中判定元素的位置。但有时我们想反过来，判定在视口中的指定位置上有什么元素。这可以用Document对象的<code>elementFromPoint()</code>方法来判定。传递X和Y坐标（使用视口坐标而非文档坐标），该方法返回在指定位置的一个元素。选取元素的算法的意图是它返回在那个点的最里面的和最上面的元素。如果指定的点在视口以外，<code>elementFromPoint()</code>返回null，即使该点在转换为文档坐标后是完美有效的，返回值也一样。</p><p><code>elementFromPoint()</code>方法看上去很有用，典型的案例是将鼠标指针的坐标传递给它来判定鼠标在哪个元素上。但是鼠标事件对象已经在target属性中包含了这些信息，因此实际上<code>elementFromPoint()</code>不经常使用。</p><h4 id="4-滚动"><a href="#4-滚动" class="headerlink" title="4. 滚动"></a>4. 滚动</h4><p>下文示例展示了如何在浏览器窗口中查询滚动条的位置，该例子中的scrollLeft和scrollTop属性可以用来设置让浏览器滚动。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> documentHeight = <span class="built_in">document</span>.documentElement.offsetHeight;</span><br><span class="line"><span class="keyword">var</span> viewportHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.scrollTo(<span class="number">0</span>, documentHeight - viewportHeight);</span><br></pre></td></tr></table></figure><p>Window的<code>scrollBy()</code>方法和<code>scroll()</code>和<code>scrollTo()</code>类似，但是它的参数是相对的，并在当前滚动条的偏移量上增加。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    scrollBy(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>通常，除了滚动到文档中用数字表示的位置，我们只是想让它滚动使得文档中的某个元素可见。可以利用<code>getBoundingClientRect()</code>计算元素的位置，并转换为文档坐标，然后用<code>scrollTo()</code>方法达到目的。但是在需要显示的HTML元素上调用<code>scrollIntoView()</code>方法更加方便。该方法保证了元素能在视口中可见。默认情况下，它试图将元素的上边缘放在或尽量接近视口的上边缘。如果只传递false作为参数，它将试图将元素的下边缘放在或尽量接近视口的下边缘。只要有助于元素在视口内可见，浏览器也会水平滚动视口。</p><p><code>scrollIntoView()</code>的行为与设置<code>window.location.hash</code>为一个命名锚点（<code>&lt;a name=&quot;&quot;&gt;</code>元素）的名字后浏览器产生的行为类似。</p><h4 id="5-关于元素尺寸、位置和溢出的更多信息"><a href="#5-关于元素尺寸、位置和溢出的更多信息" class="headerlink" title="5. 关于元素尺寸、位置和溢出的更多信息"></a>5. 关于元素尺寸、位置和溢出的更多信息</h4><p><code>getBoundingClientRect()</code>方法在所有当前的浏览器上都有定义，但如果需要支持老式浏览器，不能依靠此方法而必须使用更老的技术来判定元素的尺寸和位置。元素的尺寸比较简单：任何HTML元素的只读属性offsetWidth和offsetHeight以css像素返回它的屏幕尺寸。返回的尺寸包含元素的边框和内边距，除去了外边距。</p><p>所有的HTML元素拥有offsetLeft和offsetTop属性来返回元素的X和Y坐标。对于很多元素，这些值是文档坐标，并直接指定元素的位置。但对于已定位元素的后代元素和一些其他元素（如表格单元），这些属性返回的坐标是相对于祖先元素的而非文档。offsetParent属性指定这些属性所相对的父元素。如果offsetParent为null，这些属性都是文档坐标。因此，一般来说，用offsetLeft和offsetTop来计算元素e的位置需要一个循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementPosition</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(e != <span class="literal">null</span>) &#123;</span><br><span class="line">        x += e.offsetLeft;</span><br><span class="line">        y += e.offsetTop;</span><br><span class="line">        e = e.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: x, <span class="attr">y</span>: y &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过循环offsetParent对象链来累加偏移量，该函数计算指定元素的文档坐标。这里不能对元素的位置就一锤定音，尽管如此——这个<code>getElementPosition()</code>函数也不总是计算正确的值。</p><p>除了这些名字以offset开头的属性外，所有的文档元素定义了其他两组属性，其名称一组以client开头，另一组以scroll开头。即，每个HTML元素都有以下这些属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">offsetWidth     clientWidth     scrollWidth</span><br><span class="line">offsetHeight    clientHeight    scrollHeight</span><br><span class="line">offsetLeft      clientLeft      scrollLeft</span><br><span class="line">offsetTop       clientTop       scrollTop</span><br><span class="line">offsetParent</span><br></pre></td></tr></table></figure><p>为了理解这些client和scroll属性，我们需要直到HTML元素的实际内容有可能比分配用来容纳内容的盒子更大，因此单个元素可能有滚动条。内容区域是视口，就像浏览器的窗口，当实际内容比视口更大时，需要把元素的滚动条位置考虑进去。</p><p>clientWidth和clientHeight类似offsetWidth和offsetHeight，不同的是它们不包含边框大小，只包含内容和它的内边距。同时，如果浏览器在内边距和边框之间添加了滚动条，clientWidth和clientHeight在其返回值中也不包含滚动条。注意，对于类似<code>&lt;i&gt;</code>、<code>&lt;code&gt;</code>和<code>&lt;span&gt;</code>这些内联元素，clientWidth和clientHeight总是返回0。</p><p>有一个特殊的案例，在文档的跟元素上查询这些属性时，它们的返回值和窗口的innerWidth和innerHeight属性值相等。</p><p>clientLeft和clientTop属性没什么用：它们返回元素的内边距的外边缘和它的边框的外边缘之间的水平距离和垂直距离，通常这些值就等于左边和上边的边框宽度。但是如果元素有滚动条，并且浏览器将这些滚动条放置在左侧或顶部（不太常见），clientLeft和clientTop也就包含了滚动条的宽度。对于内联元素，clientLeft和clientTop总是0。</p><p>scrollWidth和scrollHeight是元素的内容区域加上它的内边距再加上任何溢出内容的尺寸。当内容正好和内容区域匹配而没有溢出时，这些属性与clientWidth和clientHeight是相等的。但当溢出时，它们就包含溢出的内容，返回值比clientWidth和clientHeight要大。</p><p>最后，scrollLeft和scrollTop指定元素的滚动条的位置。scrollLeft和ScrollTop是可写的属性，通过设置它们来让元素中的内容滚动。（HTML元素没有类似Window对象的<code>scrollTo()</code>方法。）</p><hr><h3 id="八、HTML表单"><a href="#八、HTML表单" class="headerlink" title="八、HTML表单"></a>八、HTML表单</h3><p>HTML的<code>&lt;form&gt;</code>元素和各种各样的表单输入元素在客户端编程中有着重要的地位。这些HTML元素可以追述到Web的最开始，比JavaScript更早。HTML表单就是第一代Web应用程序背后的运作机制，它根本就不需要JavaScript。用户输入从表单元素来收集；表单将这些输入递交给服务器；服务器处理输入并生成一个新的HTML页面显示在客户端。</p><p>即使当整个表单数据都是由客户端JavaScript来处理并不会提交到服务器时，HTML表单元素仍然是收集用户数据很好的方法。在服务端程序中，表单必须要有一个“提交”按钮，否则它就没有用处。另一方面，在客户端编程中，“提交”按钮不是必须的（虽然它可能仍然有用）。服务端程序是基于表单提交动作的——它们按表单大小的块处理数据——这限制了它们的交互性。客户端程序是基于事件的——它们可以对单独的表单元素上的事件做出相应——这使得它们有更好的响应度。</p><table><thead><tr><th>HTML元素</th><th>类型属性</th><th>事件处理程序</th><th>描述和事件</th></tr></thead><tbody><tr><td><code>&lt;input type=&quot;button&quot;&gt;</code>或<code>&lt;button type=&quot;button&quot;&gt;</code></td><td>“button”</td><td>onclick</td><td>按钮</td></tr><tr><td><code>&lt;input type=&quot;checkbox&quot;&gt;</code></td><td>“checkbox”</td><td>onchange</td><td>复选按钮</td></tr><tr><td><code>&lt;input type=&quot;file&quot;&gt;</code></td><td>“file”</td><td>onchange</td><td>载入Web服务器的文件的文件名输入域；它的value是只读的</td></tr><tr><td><code>&lt;input type=&quot;hidden&quot;&gt;</code></td><td>“hidden”</td><td>none</td><td>数据由表单提交，但对用户不可见</td></tr><tr><td><code>&lt;option&gt;</code></td><td>none</td><td>none</td><td>Select对象中的单个选项；事件处理程序在Select对象上，而非单独的Option对象上</td></tr><tr><td><code>&lt;input type=&quot;password&quot;&gt;</code></td><td>“password”</td><td>onchange</td><td>密码输入框，输入的字符不可见</td></tr><tr><td><code>&lt;input type=&quot;radio&quot;&gt;</code></td><td>“radio”</td><td>onchange</td><td>单选按钮，同时只能选定一个</td></tr><tr><td><code>&lt;input type=&quot;reset&quot;&gt;</code>或<code>&lt;button type=&quot;reset&quot;&gt;</code></td><td>“reset”</td><td>onclick</td><td>重置表单的按钮</td></tr><tr><td><code>&lt;select&gt;</code></td><td>“select-one”</td><td>onchange</td><td>选项只能单选的列表或下拉菜单</td></tr><tr><td><code>select multiple</code></td><td>“select-multiple”</td><td>onchange</td><td>选项可以多选的列表</td></tr><tr><td><code>&lt;input type=&quot;submit&quot;&gt;</code>或<code>&lt;button type=&quot;submit&quot;&gt;</code></td><td>“submit”</td><td>onclick</td><td>表单提交按钮</td></tr><tr><td><code>&lt;input type=&quot;text&quot;&gt;</code></td><td>“text”</td><td>onchange</td><td>单行文本输入域；type属性缺少或无法识别时默认的input元素</td></tr><tr><td><code>&lt;textarea&gt;</code></td><td>“textarea”</td><td>onchange</td><td>多行文本输入域</td></tr></tbody></table><h4 id="1-选取表单和表单元素"><a href="#1-选取表单和表单元素" class="headerlink" title="1. 选取表单和表单元素"></a>1. 选取表单和表单元素</h4><p>表单和它们所包含的元素可以用如<code>getElementbyId()</code>和<code>getElementsByTagName()</code>等标准的方法从文档中来选取。在支持<code>querySelectAll()</code>的浏览器中，也可以通过这个方法获取对应的元素。有name或id属性的<code>&lt;form&gt;</code>元素能够通过很多方法来选取。<code>name=&quot;address&quot;</code>属性的<code>&lt;form&gt;</code>可以用以下任何方法来选取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.address;                                 <span class="comment">// 不可靠：不要使用</span></span><br><span class="line"><span class="built_in">document</span>.address;                               <span class="comment">// 仅当表单有name属性时可用</span></span><br><span class="line"><span class="built_in">document</span>.forms.address;                         <span class="comment">// 显式访问有name或id的表单</span></span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>];                              <span class="comment">// 不可靠：n是表单的序号</span></span><br></pre></td></tr></table></figure><p>如果要明确地选取一个表单元素，可以索引表单对象的elements属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.forms.address.elements[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">document</span>.forms.address.elements.street;</span><br></pre></td></tr></table></figure><p>一般来说指定文档元素的方法用id属性要比name属性更佳。但是，name属性在HTML表单提交中有特殊的目的，它在表单中较为常用，在其他元素较少使用。它应用于相关的复选按钮组和强制共享name属性的、互斥的单选按钮组。请记住，当用name来索引一个HTMLCollection并且它包含多个元素来共享name时，返回值是一个类数组对象，它包含所有匹配的元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"shipping"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Shipping Method<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"method"</span> <span class="attr">value</span>=<span class="string">"1st"</span>&gt;</span>First-class<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"method"</span> <span class="attr">value</span>=<span class="string">"2day"</span>&gt;</span>2-day Air<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"method"</span> <span class="attr">value</span>=<span class="string">"overnite"</span>&gt;</span>Overnight<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于该表单，用如下代码来引用单选按钮元素数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> methods = <span class="built_in">document</span>.forms.shipping.elements.method;</span><br></pre></td></tr></table></figure><p>注意，<code>&lt;form&gt;</code>元素本身有一个HTML属性和对应的JavaScript属性叫“method”，所以在此案例中，必须要用该表单的elements属性而非直接访问method属性。为了判定用户选取哪种运输方式，需要遍历数组中的表单元素并检测它们的checked属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shipping_method;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; methods.length; i++)</span><br><span class="line">    <span class="keyword">if</span> (methods[i].checked)</span><br><span class="line">        shipping_method = methods[i].value;</span><br></pre></td></tr></table></figure><h4 id="2-表单和元素的属性"><a href="#2-表单和元素的属性" class="headerlink" title="2. 表单和元素的属性"></a>2. 表单和元素的属性</h4><p>在JavaScript产生之前，要用一个专用的“提交”按钮来提交表单，用一个专用的“重置”按钮来重置各表单元素的值。JavaScript的Form元素支持两个方法：<code>submit()</code>和<code>reset()</code>，它们完成同样的目的。调用Form对象的<code>submit()</code>方法来提交表单，调用<code>reset()</code>方法来重置表单元素的值。</p><hr><h3 id="九、其他文档特性"><a href="#九、其他文档特性" class="headerlink" title="九、其他文档特性"></a>九、其他文档特性</h3><h4 id="1-Document的属性"><a href="#1-Document的属性" class="headerlink" title="1. Document的属性"></a>1. Document的属性</h4><p>本文已经介绍的Document属性有body、documentElement和forms等这些特殊的文档元素。文档还定义了一些其他有趣的属性：</p><ul><li><p><code>cookie</code></p><p>  允许JavaScript程序读、写HTTP cookie的特殊的属性</p></li><li><p><code>domain</code></p><p>  该属性允许当Web页面之间交互时，相同域名下互相信任的Web服务器之间协作放宽同源策略安全限制</p></li><li><p><code>lastModified</code></p><p>  包含文档修改时间的字符串</p></li><li><p><code>location</code></p><p>  与Window的location属性引用同一个Location对象</p></li><li><p><code>referrer</code></p><p>  如果有，它表示浏览器导航到当前链接的上一个文档。该属性值和HTTP的Referer头信息的内容相同，只是拼写上有两个r</p></li><li><p><code>title</code></p><p>  文档的<code>&lt;title&gt;</code>标签之间的内容</p></li><li><p><code>URL</code></p><p>  文档的URL，只读字符串而不是Location对象。该属性值与location.href的初始值相同，只是不包含Location对象的动态变化。例如，如果用户在文档中导向到一个新的片段，location.href会发生变化，但是document.URL则不会</p></li></ul><p>referrer是这些属性中最有趣的属性之一：它包含用户链接到当前文档的上一个文档的URL。可以用如下代码来使用该属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.referrer.indexOf(<span class="string">'http://www.google.com/search?'</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">document</span>.referrer.substring(ref.indexOf(<span class="string">'?'</span>) + <span class="number">1</span>).split(<span class="string">'&amp;'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args[i].substring(<span class="number">0</span>, <span class="number">2</span>) == <span class="string">'q='</span>) &#123;</span><br><span class="line">            <span class="built_in">document</span>.write(<span class="string">'&lt;p&gt;Welcome Google User.'</span>);</span><br><span class="line">            <span class="built_in">document</span>.write(<span class="string">'You searched for: '</span> + <span class="built_in">unescape</span>(args[i].substring(<span class="number">2</span>)).replace(<span class="string">'+'</span>, <span class="string">' '</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-document-write-方法"><a href="#2-document-write-方法" class="headerlink" title="2. document.write()方法"></a>2. document.write()方法</h4><p>只有在解析文档时才能使用<code>write()</code>方法输出HTML到当前文档中，理解这点非常重要。也就是说能够在<code>&lt;script&gt;</code>元素中的顶层代码中调用<code>document.write()</code>，就是因为这些脚本的执行是文档解析流程的一部分。如果将<code>document.write()</code>放在一个函数的定义中，而该函数的调用是从一个事件处理程序中发起的，产生的结果未必是你想要的——事实上，它会擦出当前文档和它包含的脚本！同理，在设置了defer和async的脚本中不要使用<code>document.write()</code>。</p><p>值得一提的是Document对象还支持<code>writeln()</code>方法，除了在其参数的输出之后追加一个换行符以外它和<code>write()</code>方法完全一样。例如，在<code>&lt;pre&gt;</code>元素内输入预格式化的文本时着非常有用。</p><p>在当今的代码中<code>document.write()</code>方法并不常用：innerHTML属性和其他DOM技术提供了更好的方法来为文档增加内容。另一方面，某些算法的确使得它们本身成为很好的流式I/O API，如同<code>write()</code>方法提供的API一样。如果正在书写在运行时计算和输出文本的代码，可以考虑如下代码，它利用指定元素的innerHTML属性包装了简单的<code>write()</code>和<code>close()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ElementStream</span>(<span class="params">elt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> elt === <span class="string">'string'</span>)</span><br><span class="line">        elt = <span class="built_in">document</span>.getElementById(elt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.elt = elt;</span><br><span class="line">    <span class="keyword">this</span>.buffer = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementStream.prototype.write = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.buffer += <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">""</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ElementStream.prototype.writeln = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.buffer += <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">""</span>) + <span class="string">"\n"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ElementStream.prototype.close = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elt.innerHTML = <span class="keyword">this</span>.buffer;</span><br><span class="line">    <span class="keyword">this</span>.buffer = <span class="string">''</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-查询选取的文本"><a href="#3-查询选取的文本" class="headerlink" title="3. 查询选取的文本"></a>3. 查询选取的文本</h4><p>有时判定用户在文档中选取了哪些文本非常有用。可以用类似如下的函数达到目的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedText</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.getSelection)                    <span class="comment">// H5标准API</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.getSelection().toString();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.selection)                <span class="comment">// IE特有的技术</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.selection.createRange().text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准的<code>window.getSelection()</code>方法返回一个Selection对象，后者描述了当前选取的一系列一个或多个Range对象。Selection和Range定义了一个不太常用的较为复杂的API。<code>toString()</code>方法是Selection对象中最重要的也广泛实现了的特性，它返回选取的纯文本内容。</p><h4 id="4-可编辑的内容"><a href="#4-可编辑的内容" class="headerlink" title="4. 可编辑的内容"></a>4. 可编辑的内容</h4><p>有两种方法来启用编辑功能。其一，设置任何变迁的HTML contenteditable属性；其二，设置对应元素的JavaScript contentEditable属性；这都将使得元素的内容变成可编辑。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"editor"</span> <span class="attr">contenteditable</span>&gt;</span></span><br><span class="line">    Click to edit</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器可能为表单字段和contenteditable元素支持自动拼写检查。在支持该功能的浏览器中，检查可能默认开启或关闭。为元素添加spellcheck属性来显式开启拼写检查，而使用<code>spellcheck=false</code>来显式关闭该功能。</p><p>将Document对象的designMode属性设置为“on”使得整个文档可编辑。（设置为“off”将恢复为只读文档）designMode属性并没有对应的HTML属性。如下代码使得<code>&lt;iframe&gt;</code>内部的文档可编辑</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"editor"</span> <span class="attr">src</span>=<span class="string">"about:blank"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">onLoad(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> editor = <span class="built_in">document</span>.getElementById(<span class="string">'editor'</span>);</span></span><br><span class="line"><span class="javascript">    editor.contentDocument.designMode = <span class="string">'on'</span>;</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;客户端JavaScript的存在使得静态的HTML文档变成了交互式的Web应用。脚本化Web页面内容是JavaScript的核心目标。每一个Web浏览器窗口、标签页和框架由一个Window对象所表示。每个Window对象有一个document属性引用了Document对象。Document对象表示窗口的内容，Document对象并非独立的，它是一个巨大的API中的核心对象，叫做文档对象模型（&lt;code&gt;Document Object Model，DOM&lt;/code&gt;），它代表和操作文档的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript脚本化文档" scheme="http://www.xiaoleon.cn/tags/JavaScript%E8%84%9A%E6%9C%AC%E5%8C%96%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>JS(9) 类型、值和变量</title>
    <link href="http://www.xiaoleon.cn/2018/01/30/js-9/"/>
    <id>http://www.xiaoleon.cn/2018/01/30/js-9/</id>
    <published>2018-01-30T14:23:02.000Z</published>
    <updated>2018-02-02T12:48:05.179Z</updated>
    
    <content type="html"><![CDATA[<p>计算机程序的运行需要对值（<code>value</code>）进行操作。在编程语言中，能够表示并操作的值的类型称作数据类型（<code>type</code>），编程语言最基本的特性就是能够支持多种数据类型。当程序需要将值保存起来以备将来使用时，便将其赋值给一个变量（<code>variable</code>）。变量是一个值的符号名称，可以通过名称来获得对值的引用。变量的工作机制是编程语言的另一个基本特性。</p><a id="more"></a><p>JavaScript的数据类型分为两类：原始类型（<code>primitive type</code>）和对象类型（<code>object type</code>）。JavaScript中的原始类型包括数字、字符串和布尔值。</p><p>JavaScript中有两个特殊的原始值：<code>null</code>（空）和<code>undefined</code>（未定义），它们不是<code>数字</code>、<code>字符串</code>和<code>布尔值</code>。它们通常分别代表了各自特殊类型的唯一的成员。</p><p>JavaScript中除了以上类型之外就是对象了（ES6中新增了<code>Symbol</code>类型）。对象（<code>object</code>）是属性（<code>property</code>）的集合，每个属性都由“名/值对”（值可以是原始值，比如数字、字符串，也可以是对象）构成。其中有一个比较特殊的对象——全局对象（<code>global object</code>）。</p><p>JavaScript的类型可以分为原始类型和对象类型，也可分为可以拥有方法的类型和不能拥有方法的类型，同样可分为可变类型（<code>mutable</code>）和不可变类型（<code>immutable</code>）。可变类型的值是可修改的，对象和数组属于可变类型：JavaScript程序可以更改对象属性值和数组元素的值。<code>数字</code>、<code>布尔值</code>、<code>null</code>和<code>undefined</code>属于不可变类型——比如，修改一个数值的内容本身就说不通。<code>字符串</code>可以堪称是由字符组成的数组，然而在JavaScript中，字符串是不可变的：可以访问字符串任意位置的文本，但JavaScript并为提供修改已知字符串的文本内容的方法。</p><p>JavaScript可以自由地进行数据类型转换，比如，如果在程序期望使用字符串的地方使用了数字，JavaScript会自动将数字转换为字符串。如果在期望使用布尔值的地方使用了非布尔值，程序也会进行相应的转换。</p><hr><h3 id="一、数字"><a href="#一、数字" class="headerlink" title="一、数字"></a>一、数字</h3><p>和其他编程语言不同，JavaScript不区分整数值和浮点数值。JavaScript中所有数字均用浮点数值表示。JavaScript采用IEEE 754标准定义的64位浮点格式表示数字，这意味着它能表示的最大值是<code>±1.7976931348623157 * 10e308</code>，最小值是<code>±5 * 10e-324</code>。</p><p>按照JavaScript中的数字格式，能够表示的整数范围是从<code>-2*53 ~ 2*53</code>，包含边界值。如果使用了超过此范围的整数，则无法保证低位数字的精度。然而需要注意的是，JavaScript中实际的操作（比如数字索引），则是基于32位整数。</p><h4 id="1-整型直接量"><a href="#1-整型直接量" class="headerlink" title="1. 整型直接量"></a>1. 整型直接量</h4><p>在JavaScript程序中，用一个数字序列表示一个十进制整数，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">100000</span></span><br></pre></td></tr></table></figure><p>除了十进制的整型直接量，JavaScript同样能识别八进制、十六进制值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xff</span>;                           <span class="comment">// 15*16+15=255</span></span><br><span class="line"><span class="number">0377</span>;                           <span class="comment">// 3*64+7*8+7=255</span></span><br></pre></td></tr></table></figure><p>最好不要使用以0为前缀的整型直接量，毕竟我们无法得知当前JavaScript的实现是否支持八进制的解析。在ES6的严格模式下，八进制直接量是明令禁止的。</p><h4 id="2-浮点型直接量"><a href="#2-浮点型直接量" class="headerlink" title="2. 浮点型直接量"></a>2. 浮点型直接量</h4><p>浮点型直接量可以含有小数点，它们采用的是传统的实数写法。一个实数由整数部分、小数点和小数部分组成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">2345.789</span></span><br><span class="line"><span class="number">6.02e23</span></span><br><span class="line"><span class="number">1.4738223E-32</span></span><br></pre></td></tr></table></figure><h4 id="3-JavaScript中的算术运算"><a href="#3-JavaScript中的算术运算" class="headerlink" title="3. JavaScript中的算术运算"></a>3. JavaScript中的算术运算</h4><p>JavaScript程序是使用语言本身提供的算术运算符来进行数字运算的。这些运算符包括<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>。</p><p>除了基本的运算符外，JavaScript还支持更加复杂的算术运算，这些复杂运算通过作为Math对象的属性定义的函数和常量来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>);                        <span class="comment">// =&gt; 9007199254740992: 2e53</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">.6</span>);                         <span class="comment">// =&gt; 1.0: 四舍五入</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">.6</span>);                          <span class="comment">// =&gt; 1.0: 向上取整</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">.6</span>);                         <span class="comment">// =&gt; 0.0: 向下取整</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="number">-5</span>);                           <span class="comment">// =&gt; 5: 求绝对值</span></span><br><span class="line"><span class="built_in">Math</span>.max(x, y, z);                      <span class="comment">// 返回最大值</span></span><br><span class="line"><span class="built_in">Math</span>.min(x, y, z);                      <span class="comment">// 返回最小值</span></span><br><span class="line"><span class="built_in">Math</span>.random();                          <span class="comment">// 生成一个大于等于0小于1.0的伪随机数</span></span><br><span class="line"><span class="built_in">Math</span>.PI;                                <span class="comment">// π: 圆周率</span></span><br><span class="line"><span class="built_in">Math</span>.E;                                 <span class="comment">// e: 自然对数的底数</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">3</span>);                           <span class="comment">// 3的平方根</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">3</span>, <span class="number">1</span>/<span class="number">3</span>);                       <span class="comment">// 3的立方根</span></span><br><span class="line"><span class="built_in">Math</span>.sin(<span class="number">0</span>);                            <span class="comment">// 三角函数，还有Math.cos，Math.atan等</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">10</span>);                           <span class="comment">// 10的自然对数</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">100</span>)/<span class="built_in">Math</span>.LN10;                <span class="comment">// 以10为底100的对数</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">512</span>)/<span class="built_in">Math</span>.LN2;                 <span class="comment">// 以2为底512的对数</span></span><br><span class="line"><span class="built_in">Math</span>.exp(<span class="number">3</span>);                            <span class="comment">// e的三次幂</span></span><br></pre></td></tr></table></figure><p>JavaScript中的算术运算在溢出（<code>overflow</code>）、下溢（<code>underflow</code>）或被零整除时不会报错。当数字运算结果超过了JavaScript所能表示的数字上限，结果为一个特殊的无穷大值（<code>infinity</code>），在JavaScript中以<code>Infinity</code>表示，负无穷大以<code>-Infinity</code>表示。无穷大值的行为特征和我们所期望的是一致的：基于它们的加减乘除运算结果还是无穷大值。</p><p>下溢（<code>underflow</code>）是当运算结果无限接近于零并比JavaScript所能表示的最小值还小的时候发生的情形。这种情况下，JavaScript会返回0。当一个负数发生下溢时，JavaScript返回一个特殊的值“<code>负零</code>”。这个值几乎和正常的零完全一样，JavaScript程序中很少用到负零。</p><p>被零整出在JavaScript中并不报错：它只是简单地返回无穷大或负无穷大。但有一个例外，零除以零是没有意义的，这种整除运算结果也是一个非数字值（<code>not-a-number, NaN</code>）。无穷大除以无穷大，给任意负数作开方运算或者算术运算符不是数字或无法转换为数字的操作数一起使用时都将会返回NaN。</p><p>JavaScript中的非数字值有一点特殊：它和任何值都不想等，包括自身。也就是说，没办法通过<code>x==NaN</code>来判断变量x是否是NaN。相反，应当使用<code>x!=x</code>来判断，当前仅当x为NaN的时候，表达式的结果才为true。函数<code>isNaN()</code>的作用与此类似，如果参数是NaN或者是一个非数字值（比如字符串和对象），则返回true。JavaScript有一个类似的函数<code>isFinite()</code>，在参数不是NaN、Inifity或-Infinity的时候返回true。</p><blockquote><p>负零值同样有些特殊，它和正零值是相等的（甚至使用===严格相等来判断）。</p></blockquote><p>这意味着这两个值几乎一模一样，除了作为除数之外。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> negz = <span class="number">-0</span>;</span><br><span class="line">zero === negz;                          <span class="comment">// true 正零值和负零值相等</span></span><br><span class="line"><span class="number">1</span>/zero === <span class="number">1</span>/negz;                      <span class="comment">// false 正无穷大和负无穷大不等</span></span><br></pre></td></tr></table></figure><hr><h3 id="二、文本"><a href="#二、文本" class="headerlink" title="二、文本"></a>二、文本</h3><p>字符串（string）是一组由16位值组成的不可变的有序序列，每个自负通常来自于Unicode字符集。JavaScript通过字符串类型来表示文本。字符串的长度（length）是其所含16位值的个数。JavaScript字符串（和其数组）的索引从零开始：第一个字符的位置是0，第二个字符的位置是1，以此类推。空字符串（empty string）长度为0，JavaScript中并没有表示单个字符的“字符型”。要表示一个16位值，只须将其赋值给字符串变量即可，这个字符串长度为1。</p><h4 id="1-字符串直接量"><a href="#1-字符串直接量" class="headerlink" title="1. 字符串直接量"></a>1. 字符串直接量</h4><p>在JavaScript程序中的字符串直接量，是由单引号或双引号括起来的字符序列。由单引号定界的字符串中可以包含双引号，由双引号定界的字符串中也可以包含单引号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>;</span><br><span class="line"><span class="string">'testing'</span>;</span><br><span class="line"><span class="string">"3.14"</span>;</span><br><span class="line"><span class="string">'name="myform"'</span>;</span><br><span class="line"><span class="string">"Wouldn't you prefer O'Reilly's book?"</span>;</span><br></pre></td></tr></table></figure><p>在ES3中，字符串直接量必须写在一行中，而在ES5中，字符串直接量可以拆分成数行，每行必须以反斜线（<code>\</code>）结束，反斜线和行结束符都不算是字符串直接量的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"two\nlines"</span>;</span><br><span class="line"><span class="string">"one\</span></span><br><span class="line"><span class="string">long\</span></span><br><span class="line"><span class="string">line"</span>                                   <span class="comment">// 用三行代码定义了显示为单行的字符串，在ES5中可用</span></span><br></pre></td></tr></table></figure><h4 id="2-字符串的使用"><a href="#2-字符串的使用" class="headerlink" title="2. 字符串的使用"></a>2. 字符串的使用</h4><p>JavaScript的内置功能之一就是字符串连接。如果将加号（+）运算符用于数字，表示两数相加。但将它用于字符串，则表示字符串连接，将第二个字符串拼接在第一个之后。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">'Hello, '</span> + <span class="string">'world'</span>;              <span class="comment">// 'Hello, world'</span></span><br><span class="line">greeting = <span class="string">"Welcome to my blog, "</span> + <span class="string">' '</span> + name;</span><br></pre></td></tr></table></figure><p>要确定一个字符串的长度——其所包含的16位值的个数——可以使用字符串的length属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.length;</span><br></pre></td></tr></table></figure><p>除了length属性，字符串还提供许多可以调用的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello, world'</span>;</span><br><span class="line">s.charAt(<span class="number">0</span>);                            <span class="comment">// 'h'</span></span><br><span class="line">s.charAt(s.length<span class="number">-1</span>);                   <span class="comment">// 'd'</span></span><br><span class="line">s.substring(<span class="number">1</span>, <span class="number">4</span>);                      <span class="comment">// 'ell'</span></span><br><span class="line">s.slice(<span class="number">1</span>, <span class="number">4</span>);                          <span class="comment">// 'ell'</span></span><br><span class="line">s.slice(<span class="number">-3</span>);                            <span class="comment">// 'rld'</span></span><br><span class="line">s.indexOf(<span class="string">'l'</span>);                         <span class="comment">// 2</span></span><br><span class="line">s.lastIndexOf(<span class="string">'l'</span>);                     <span class="comment">// 10</span></span><br><span class="line">s.indexOf(<span class="string">'l'</span>, <span class="number">3</span>);                      <span class="comment">// 3</span></span><br><span class="line">s.split(<span class="string">', '</span>);                          <span class="comment">// ['hello', 'world']</span></span><br><span class="line">s.replace(<span class="string">'h'</span>, <span class="string">'H'</span>);                    <span class="comment">// 'Hello, world'</span></span><br><span class="line">s.toUpperCase();                        <span class="comment">// 'HELLO, WORLD'</span></span><br></pre></td></tr></table></figure><p>记住，在JavaScript中字符串是固定不变的，类似<code>replace()</code>和<code>toUpperCase()</code>的方法都返回新字符串，原字符串本身并没有发生改变。</p><p>在ES5中，字符串可以当作只读数组，除了使用<code>charAt()</code>方法，也可以使用方括号来访问字符串中的单个字符（16位值）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'hello, world'</span>;</span><br><span class="line">s[<span class="number">0</span>];                                   <span class="comment">// 'h'</span></span><br><span class="line">s[s.length - <span class="number">1</span>];                        <span class="comment">// 'd'</span></span><br></pre></td></tr></table></figure><hr><h3 id="三、布尔值"><a href="#三、布尔值" class="headerlink" title="三、布尔值"></a>三、布尔值</h3><p>布尔值指代真或假、开或关、是或否。这个类型只有两个值，保留字true和false。</p><p>任意JavaScript的值都可以转换为布尔值，下面这些值会被转换成false</p><p><code>undefined    null    0    -0    NaN    &quot;&quot;</code></p><p>所有其他值，包括所有对象（数组）都会转成true。</p><hr><h3 id="四、null和undefined"><a href="#四、null和undefined" class="headerlink" title="四、null和undefined"></a>四、null和undefined</h3><p><code>null</code>是JavaScript语言的关键字，它表示一个特殊值，常用来描述“空值”。对<code>null</code>执行<code>typeof</code>运算，结果返回字符串“<code>object</code>”，也就是说，可以将<code>null</code>认为是一个特殊的对象值，含义是“<code>非对象</code>”。但实际上，通常认为<code>null</code>是它自有类型的唯一一个成员，它可以表示数字、字符串和对象是“无值”的。</p><p>JavaScript还有第二个值来表示值的空缺，用未定义的值表示更深层次的“空值”。在ES3中，<code>undefined</code>是可读/写的变量，可以给它赋任意值。这个错误在ES5中做了修正，<code>undefined</code>在该版本中是只读的。如果使用<code>typeof</code>运算符得到<code>undefined</code>的类型，则返回“<code>undefined</code>”，表明这个值是这个类型的唯一成员。</p><hr><h3 id="五、全局对象"><a href="#五、全局对象" class="headerlink" title="五、全局对象"></a>五、全局对象</h3><p>全局对象（<code>global object</code>）在JavaScript中有着重要的用途：全局对象的属性是全局定义的符号，JavaScript程序可以直接使用。当JavaScript解释器启动时，它将创建一个新的全局对象，并给它一组定义的初始属性：</p><ul><li><p>全局属性，比如<code>undefined</code>、<code>Infinity</code>和<code>NaN</code></p></li><li><p>全局函数，比如<code>isNaN()</code>、<code>parseInt()</code>、<code>eval()</code></p></li><li><p>构造函数：比如<code>Date()</code>、<code>RegExp()</code>、<code>String()</code>、<code>Object()</code>和<code>Array()</code></p></li><li><p>全局对象，比如<code>Math</code>和<code>JSON</code></p></li></ul><p>在代码的最顶级——不在任何函数内的JavaScript代码——可以使用JavaScript关键字<code>this</code>来引用全局对象。</p><hr><h3 id="六、包装对象"><a href="#六、包装对象" class="headerlink" title="六、包装对象"></a>六、包装对象</h3><p>JavaScript对象是一种复合值：它是属性或已命名值的集合。通过“<code>.</code>”符号来引用属性值。当属性值是一个函数的时候，称其为方法。我们看到字符串也同样具有属性和方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello world!'</span>;</span><br><span class="line"><span class="keyword">var</span> word = s.substring(s.indexOf(<span class="string">' '</span>) + <span class="number">1</span>, s.length);</span><br></pre></td></tr></table></figure><p>字符串既然不是对象，为什么它会有属性呢？只要引用了字符串s的属性，JavaScript就会将字符串值通过调用<code>new String(s)</code>的方式转换成对象，这个对象继承了字符串的方法，并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会销毁。</p><p>同字符串一样，数字和布尔值也具有各自的方法：通过<code>Number()</code>和<code>Boolean()</code>构造函数创建一个临时对象，这些方法的调用均是来自于这个临时对象。<code>null</code>和<code>undefined</code>没有包装对象：访问它们的属性会造成一个类型错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'test'</span>;</span><br><span class="line">s.len = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> t = s.len;</span><br></pre></td></tr></table></figure><p>运行上述代码时，t的值是<code>undefined</code>。第二行代码创建一个临时字符串对象，并给其<code>len</code>属性赋值为4，随即销毁这个对象。第三行通过原始的字符串值创建一个新字符串对象，尝试读取其<code>len</code>属性，这个属性自然不存在，表达式求值结果为<code>undefined</code>。这段代码说明了在读取字符串、数字和布尔值的属性值（或方法）的时候，表现的和对象一样。但如果试图给其属性赋值，则会忽略这个操作：修改只是发生在临时对象上，而这个临时对象并未继续保留下来。</p><p>存取字符串、数字或布尔值的属性时创建的临时对象称作包装对象。它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象。</p><p>需要注意的是，可通过<code>String()</code>、<code>Number()</code>、<code>Boolean()</code>构造函数来显式创建包装对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'test'</span>, n = <span class="number">1</span>, b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> S = <span class="keyword">new</span> <span class="built_in">String</span>(s);</span><br><span class="line"><span class="keyword">var</span> N = <span class="keyword">new</span> <span class="built_in">Number</span>(n);</span><br><span class="line"><span class="keyword">var</span> B = <span class="keyword">new</span> <span class="built_in">Boolean</span>(b);</span><br></pre></td></tr></table></figure><p>其中“<code>==</code>”运算符时，原始值与其包装对象相等，“<code>===</code>”全等运算符时，它们不等。通过typeof运算符可以看到原始值和其包装对象的不同。</p><hr><h3 id="七、不可变的原始值和可变的对象引用"><a href="#七、不可变的原始值和可变的对象引用" class="headerlink" title="七、不可变的原始值和可变的对象引用"></a>七、不可变的原始值和可变的对象引用</h3><p>JavaScript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着本质区别。原始值是不可更改的：任何方法都无法更改一个原始值。对字符串来说不那么容易理解，因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来修改字符串中的字符。实际上，JavaScript是禁止这样做的，字符串所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s.toUpperCase();                        <span class="comment">// 'HELLO'</span></span><br><span class="line">s;                                      <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure><p>原始值的比较是值的比较：只有在它们的值相等时它们才相等。这对数字、布尔值、null和undefined来说听起来有点难懂，并没有其他办法来比较它们。同样，对于字符串来说则不明显：如果比较两个单独的字符串，当且仅当它们的长度相等且每个索引的字符都想等时，JavaScript才认为它们相等。</p><p>对象和原始值不同，首先，它们是可变的——它们的值是可修改的。对象的比较并非值的比较：即使两个对象包含相同的属性及相同的值，它们也是不相等的。各个索引元素完全相等的两个数组也不想等。</p><p>我们通常将对象成为引用类型（reference type），以此赖和JavaScript的基本类型区分开来。依照术语的叫法，对象值都是引用（reference），对象的比较均是引用的比较：当且仅当它们引用同一个基对象时，它们才相等。</p><hr><h3 id="八、显示类型转换"><a href="#八、显示类型转换" class="headerlink" title="八、显示类型转换"></a>八、显示类型转换</h3><p>做显式类型转换最简单的方法就是使用<code>Boolean()</code>、<code>Number()</code>、<code>String()</code>或<code>Object()</code>函数，当不实用<code>new</code>运算符调用这些函数时，它们会作为类型转换函数做类型转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'3'</span>);                            <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">false</span>);                          <span class="comment">// 'false'</span></span><br><span class="line"><span class="built_in">Boolean</span>([]);                            <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="number">3</span>);                              <span class="comment">// new Number(3)</span></span><br></pre></td></tr></table></figure><p>JavaScript中的某些运算符会做隐式的类型转换，有时用于类型转换。如果“<code>+</code>”运算符的一个操作数是字符串，它将会把另外一个操作数转换为字符串。一元“<code>+</code>”运算符将其操作数转换为数字，同样，一元“<code>!</code>”运算符将其操作数转换为布尔值并取反。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x + <span class="string">''</span>;                                 <span class="comment">// 等价于String(x)</span></span><br><span class="line">+x;                                     <span class="comment">// 等价于Number(x)，也可以是x-0</span></span><br><span class="line">!!x;                                    <span class="comment">// 等价于Boolean(x)</span></span><br></pre></td></tr></table></figure><hr><h3 id="九、变量声明"><a href="#九、变量声明" class="headerlink" title="九、变量声明"></a>九、变量声明</h3><p>在JavaScript程序中，使用一个变量之前应当先声明。变量是使用关键字<code>var</code>来声明的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">var</span> j, sum;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果未在<code>var</code>声明语句中给变量指定初始值，那么虽然声明了这个变量，但在给它存入一个值之前，它的初始值就是<code>undefined</code>。</p><h4 id="1-变量作用域"><a href="#1-变量作用域" class="headerlink" title="1. 变量作用域"></a>1. 变量作用域</h4><p>在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就会被局部变量所遮盖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">'local'</span>;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">&#125;</span><br><span class="line">checkScope();                           <span class="comment">// 'local'</span></span><br></pre></td></tr></table></figure><h4 id="2-函数作用域和声明提前"><a href="#2-函数作用域和声明提前" class="headerlink" title="2. 函数作用域和声明提前"></a>2. 函数作用域和声明提前</h4><p>在JavaScript中没有块级作用域（ES5及以前），JavaScript取而代之地使用了函数作用域（<code>function scope</code>）：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</p><p>在如下所示代码中，在不同位置定义了变量i、j和k，它们都在同一个作用域内——这三个变量在函数体内均是有定义的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> o == <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(k);             <span class="comment">// 输出数字0~9</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(k);                 <span class="comment">// k已经定义了，输出10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(j);                     <span class="comment">// j已经定义了，但可能没有初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-作为属性的变量"><a href="#3-作为属性的变量" class="headerlink" title="3. 作为属性的变量"></a>3. 作为属性的变量</h4><p>当声明一个JavaScript全局变量时，实际上是定义了全局对象的一个属性。当使用<code>var</code>声明一个变量时，创建的属性是不可配置的，也就是说这个变量无法通过<code>delete</code>运算符删除。</p><p>JavaScript全局变量是全局对象的属性，这是在ES规范中强制规定的。对于局部变量则没有如此规定，但我们可以想象得到，局部变量当作跟函数调用相关的某个对象的属性。ES5规范称为“声明上下文对象”。JavaScript可以允许使用<code>this</code>关键字来引用全局对象，却没有方法可以引用局部变量中存放的对象。这种存放局部变量的对象的特有性质，是一种对我们不可见的内部实现。</p><h4 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4. 作用域链"></a>4. 作用域链</h4><p>如果将一个局部变量看作是自定义实现的对象的属性的话，那么可以换个角度来解读变量作用域。每一段JavaScript代码（全局代码或函数）都有一个与之关联的作用域链（<code>scope chain</code>）。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript需要查找变量x的值的时候（这个过程称作“变量解析”（<code>variable resolution</code>）），它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，JavaScript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类推。如果作用域链上没有任何一个对象函数属性x，那么就认为这段代码的作用链上不存在x，并最终抛出一个引用错误（<code>ReferenceError</code>）异常。</p><p>在JavaScript的最顶层代码中，作用域链有一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。理解对象链的创建规则是非常重要的。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来讲，事情变得更加有趣，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机程序的运行需要对值（&lt;code&gt;value&lt;/code&gt;）进行操作。在编程语言中，能够表示并操作的值的类型称作数据类型（&lt;code&gt;type&lt;/code&gt;），编程语言最基本的特性就是能够支持多种数据类型。当程序需要将值保存起来以备将来使用时，便将其赋值给一个变量（&lt;code&gt;variable&lt;/code&gt;）。变量是一个值的符号名称，可以通过名称来获得对值的引用。变量的工作机制是编程语言的另一个基本特性。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript类型" scheme="http://www.xiaoleon.cn/tags/JavaScript%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="JavaScript值" scheme="http://www.xiaoleon.cn/tags/JavaScript%E5%80%BC/"/>
    
      <category term="JavaScript变量" scheme="http://www.xiaoleon.cn/tags/JavaScript%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>JS(8) Window对象</title>
    <link href="http://www.xiaoleon.cn/2018/01/30/js-8/"/>
    <id>http://www.xiaoleon.cn/2018/01/30/js-8/</id>
    <published>2018-01-30T14:09:00.000Z</published>
    <updated>2018-02-02T12:48:05.159Z</updated>
    
    <content type="html"><![CDATA[<p>Window对象是客户端JavaScript程序的全局对象，本文介绍Window对象的属性和方法，这些属性定义了许多不同的API。</p><a id="more"></a><p>本文主要介绍以下方面：</p><ul><li><p><code>setTimeout()</code>和<code>setInterval()</code></p></li><li><p><code>location</code>属性，以及如何获取当前显示文档的url和载入新的文档</p></li><li><p><code>history</code>属性，以及如何在历史记录中向前和向后移动</p></li><li><p><code>navigator</code>属性，以及如何获取浏览器厂商和版本信息，如何使用screen属性查询窗口尺寸</p></li><li><p><code>alert()</code>、<code>promt()</code>、<code>confirm()</code>、<code>showModalDialog()</code></p></li><li><p><code>onerror</code>处理方法，以及如何在未捕获的JavaScript异常发生时调用</p></li><li><p>HTML元素的<code>ID</code>和<code>name</code>作为<code>Window</code>对象的属性来使用</p></li><li><p>如何打开和关闭浏览器窗口，以及如何编写可以在多个窗口和嵌套窗体中工作的JavaScript代码</p></li></ul><hr><h3 id="一、计时器"><a href="#一、计时器" class="headerlink" title="一、计时器"></a>一、计时器</h3><p><code>setTimeout()</code>和<code>setInterval()</code>可以用来注册在指定时间之后单次或重复调用的函数。</p><p>Window对象的<code>setTimeout()</code>方法用来实现一个函数在指定的毫秒数之后运行。<code>setTimeout()</code>返回一个值，这个值可以传递给<code>clearTimeout()</code>用于取消这个函数的执行。</p><p><code>setInterval()</code>和<code>setTimeout()</code>一样，只不过这个函数会在指定毫秒数的间隔里重复调用。</p><p>由于历史原因，<code>setTimeout()</code>和<code>setInterval()</code>的第一个参数可以作为字符串传入。如果这么做，那这个字符串会在指定的超时时间或间隔之后进行求值（相当于执行<code>eval()</code>）。除前两个参数之外，H5规范还允许<code>setTimeout()</code>和<code>setInterval()</code>传入额外的参数，并在调用函数时把这些参数传递过去。</p><p>如果以0毫秒的超时时间来调用<code>setTimeout()</code>，那么指定的函数不会立刻执行。相反，会把它放到队列中，等到前面处于等待状态的事件处理程序全部执行完成后，再“立刻”调用它。</p><hr><h3 id="二、浏览器定位和导航"><a href="#二、浏览器定位和导航" class="headerlink" title="二、浏览器定位和导航"></a>二、浏览器定位和导航</h3><p>Window对象的<code>location</code>属性引用的是Location对象，它表示该窗口中当前显示的文档的url，并定义了方法来使窗口载入新的文档。</p><p>Document对象的<code>location</code>属性也引用到Location对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location == <span class="built_in">document</span>.location;           <span class="comment">// 总是返回true</span></span><br></pre></td></tr></table></figure><p>Document对象也有一个url属性，是文档首次载入后保存该文档的url的静态字符串。如果定位到文档中的片段标识符，Location对象会做相应的更新，而<code>document.url</code>属性则不会改变。</p><h4 id="1-解析url"><a href="#1-解析url" class="headerlink" title="1. 解析url"></a>1. 解析url</h4><p>Window对象的<code>location</code>属性引用的是Location对象，它表示该窗口中当前显示的文档的url。Location对象的href属性是一个字符串，后者包含url的完整文本。Location对象的<code>toString()</code>方法返回href属性的值，因此会隐式调用<code>toString()</code>的情况下，可以使用location代替<code>location.href</code>。</p><p>这个对象的其他属性——<code>protocol</code>、<code>host</code>、<code>hostname</code>、<code>port</code>、<code>pathname</code>和<code>search</code>，分别表示url的各个部分。他们成为“url分解”属性。</p><p>Location对象的<code>hash</code>和<code>search</code>属性比较有趣。如果有的话，<code>hash</code>属性返回url中的“片段标识符”部分。<code>search</code>属性也类似，它返回的是问号之后的url，这部分通常是某种类型的查询字符串。一般来说，这部分内容是用来参数化url并在其中嵌入参数的。</p><h4 id="2-载入新的文档"><a href="#2-载入新的文档" class="headerlink" title="2. 载入新的文档"></a>2. 载入新的文档</h4><p>Location对象的<code>assign()</code>方法可以使窗口载入并显示指定的url中的文档。<code>replace()</code>方法也类似，但它在载入新文档之前会从浏览历史中把当前文档删除。如果脚本无条件地载入一个新文档，<code>replace()</code>方法可能是比<code>assign()</code>方法更好的选择。否则，“后退”按钮会把浏览器带回到原始文档，而相同的脚本则会再次载入新文档。如果检测到用户的浏览器不支持某些特性来显示功能齐全的版本，可以用<code>location.replace()</code>来载入静态的HTML版本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果浏览器不支持XMLHttpRequest对象</span></span><br><span class="line"><span class="comment">// 则将其重定向到一个不需要Ajax的静态页面</span></span><br><span class="line"><span class="keyword">if</span> (!XMLHttpRequest) &#123;</span><br><span class="line">    location.replace(<span class="string">'staticpage.html'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在这个例子中传入<code>replace()</code>的是一个相对url。相对url是相对于当前页面所在的目录来解析的，就像将它们用于一个超链接中。</p><p>除了<code>assign()</code>和<code>replace()</code>方法，Location对象还定义了<code>reload()</code>方法，后者可以让浏览器重新载入当前文档。</p><p>使浏览器跳转到新页面的一种更传统的方法是直接把新的url赋值给location属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location = <span class="string">"http://www.orilly.com"</span>;</span><br></pre></td></tr></table></figure><p>还可以吧相对url赋给<code>location</code>，它们会相对当前url进行解析</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location = <span class="string">"page2.html"</span>;</span><br></pre></td></tr></table></figure><p>纯粹的片段标识符是相对url的一种类型，它不会让浏览器载入新文档，但只会使它滚动到文档的某个位置。<code>#top</code>标识符是个特殊的例子：如果文档中没有元素的ID是“<code>top</code>”，它会让浏览器跳到文档开始处。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳转到文档的顶部</span></span><br><span class="line">location = <span class="string">'#top'</span>;</span><br></pre></td></tr></table></figure><p>Location对象的URL分解属性是可写的，对它们重新赋值会改变url的位置，并且导致浏览器载入一个新的文档（如果改变的是<code>hash</code>属性，则在当前文档中进行跳转）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.search = <span class="string">'?page='</span> + (pagenum + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="三、浏览历史"><a href="#三、浏览历史" class="headerlink" title="三、浏览历史"></a>三、浏览历史</h3><p>History对象用来把窗口的浏览历史用文档和文档状态列表的形式表示。History对象的<code>length</code>属性表示浏览历史列表中的元素数量，但出于安全的因素，脚本不能访问已保存的url。（如果允许，则任意脚本都可以窥探我们的浏览历史）。</p><p>如果窗口包含多个子窗口（比如<code>&lt;iframe&gt;</code>元素），子窗口的浏览历史会按时间顺序穿插在主窗口的历史中。这意味着在主窗口调用<code>history.back()</code>可能会导致其中一个子窗口往回跳转到前一个显示的文档，但主窗口保留当前状态不变。</p><hr><h3 id="四、浏览器和屏幕信息"><a href="#四、浏览器和屏幕信息" class="headerlink" title="四、浏览器和屏幕信息"></a>四、浏览器和屏幕信息</h3><p>脚本有时候需要获取和它们所在的Web浏览器或浏览器所在的桌面相关的信息。本节所介绍Window对象的<code>navigator</code>和<code>screen</code>属性。它们分别引用的是Navigator和Screen对象，而这些对象提供的信息允许脚本来根据环境定制自己的行为。</p><h4 id="1-Navigator对象"><a href="#1-Navigator对象" class="headerlink" title="1. Navigator对象"></a>1. Navigator对象</h4><p>Window对象的<code>navigator</code>属性引用的是包含浏览器厂商和版本信息的Navigator对象。Navigator对象的命名是为了纪念Netscape之后Navigator浏览器，不过所有其他的浏览器也支持它。</p><p>过去，Navigator对象通常被脚本用来确定它们是在IE中还是在Netscape中运行。这种浏览器嗅探方法有问题，因为它要求随着新浏览器和现有浏览器的新版本的引入而不断地调整。如今，有一种更好地功能测试方法，只需要测试所需要的功能，而不是假设特定的浏览器版本及其功能。</p><p>然而，浏览器嗅探有时候仍然有价值。这样的一种情况是，当需要解决存在于某个特定的浏览器的特定版本中的特殊的bug时。Navigator对象有4个属性用于提供关于运行中的浏览器的版本信息，并且可以使用这些属性进行浏览器嗅探。</p><ul><li><p>appName</p><p>  Web浏览器的全称。</p></li><li><p>appVersion</p><p>  此属性通常以数字开始，并跟着包含浏览器厂商和版本信息的详细字符串。</p></li><li><p>userAgent</p><p>  浏览器在它的USER-AGENT HTTP头部中发送的字符串。这个属性通常包含appVersion中的所有信息，并且常常也可能包含其他的细节。</p></li><li><p>platform</p><p>  在其上运行浏览器的操作系统（并且可能是硬件）的字符串。</p></li></ul><p>下文示例中展示了如何使用正则表达式从<code>navigator.userAgent</code>中抽取浏览器名称和版本号的方法（摘自jQuery）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> browser = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = navigator.userAgent.toLowerCase();</span><br><span class="line">    <span class="keyword">var</span> match = <span class="regexp">/(webkit)[ \/]([\w.]+)/</span>.exec(s) ||</span><br><span class="line">    /(opera)(?:.*version)?[ \/]([\w.]+)/.exec(s) ||</span><br><span class="line">    /(msie)([\w.]+)/.exec(s) ||</span><br><span class="line">    !<span class="regexp">/compatible/</span>.test(s) &amp;&amp; <span class="regexp">/(mozilla)(?:.*? rv:([\w.]+))?/</span>.exec(s) ||</span><br><span class="line">    [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: match[<span class="number">1</span>] || <span class="string">''</span>, <span class="attr">version</span>: match[<span class="number">2</span>] || <span class="string">'0'</span> &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>除了浏览器厂商和版本信息的属性之外，Navigator对象还包含一些杂项的属性和方法。以下是一些标准化的属性以及广泛应用但未标准化的属性：</p><ul><li><p>onLine</p><p>  <code>navigator.onLine</code>属性表示浏览器当前是否连接到网络。</p></li><li><p>geolocation</p><p>  Geolocation对象定义用于确定用户地理位置信息的接口。</p></li><li><p>javaEnabled()</p><p>  一个非标准的方法，当浏览器可以运行Java小程序时返回true。</p></li><li><p>cookieEnabled()</p><p>  一个非标准的方法，如果浏览器可以保存永久的cookie时，返回true。当cookie配置为“视具体情况而定”时可能会返回不正确的值。</p></li></ul><h4 id="2-Screen对象"><a href="#2-Screen对象" class="headerlink" title="2. Screen对象"></a>2. Screen对象</h4><p>Window对象的screen属性引用的是Screen对象。它提供有关窗口显示的大小和可用的颜色数量信息。属性<code>width</code>和<code>height</code>指定的是以像素为单位的窗口大小。属性<code>availWidth</code>和<code>availHeight</code>指定的是实际可用的显示大小，它们排除了像桌面任务栏这样的特性所占用的控件。属性<code>colorDepth</code>指定的是显示的<code>BPP</code>（<code>bits-per-pixel</code>）值，典型的值有16、24和32.</p><p><code>window.screen</code>属性和它引用的Screen对象都是非标准但广泛实现的。可以用Screen对象来确定Web应用是否运行在一个小屏幕的设备上。</p><hr><h3 id="五、对话框"><a href="#五、对话框" class="headerlink" title="五、对话框"></a>五、对话框</h3><p>Window对象提供了3个方法来向用户显示简单的对话框。<code>alert()</code>向用户显示一条信息并等待用户关闭对话框。<code>confirm()</code>也显示一条信息，要求用户单机“确定”或“取消”按钮，并返回一个布尔值。<code>propty()</code>同样也显示一条消息，等待用户输入字符串，并返回那个字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = promp(<span class="string">'What is your name?'</span>);</span><br><span class="line">    <span class="keyword">var</span> correct = confirm(<span class="string">'You entered: '</span>) + name + <span class="string">'\n'</span></span><br><span class="line">        + <span class="string">'Click Okay to proceed of Cancel to re-enter;'</span></span><br><span class="line">&#125; <span class="keyword">while</span> (!correct) </span><br><span class="line">alert(<span class="string">'Hello, '</span> + name);</span><br></pre></td></tr></table></figure><p>方法<code>confirm()</code>和<code>prompt()</code>都会产生阻塞，也就是说，在用户关掉它们所显示的对话框之前，它们不会返回。这就意味着在弹出一个对话框前，代码就会停止运行。如果当前正在载入文档，也会停止载入，直到用户用要求的输入进行响应为止。在大多数的浏览器里，<code>alert()</code>也会产生阻塞，并等待用户关闭对话框，但并不总是这样。</p><hr><h3 id="六、错误处理"><a href="#六、错误处理" class="headerlink" title="六、错误处理"></a>六、错误处理</h3><p>Window对象的<code>onerror</code>属性是一个事件处理程序，当未捕获的异常传播到调用栈上时就会调用它，并把错误消息输出到浏览器的JavaScript控制台上。如果给这个属性赋一个函数，那么只要这个窗口中发生了JavaScript错误，就会调用该函数，即它成了窗口的错误处理程序。</p><p>由于历史原因，Window对象的<code>onerror</code>事件处理函数的调用通过三个字符串参数，而不是通过通常传递的一个事件对象。</p><p><code>window.onerror</code>的第一个参数是描述错误的一条消息。第二个参数是一个字符串，它存放引发错误的JavaScript代码所在的文档的url。第三个参数是文档中发生错误的行数。</p><p>除了这三个参数之外，<code>onerror</code>处理程序的返回值也很重要。如果<code>onerror</code>处理程序返回false，它通知浏览器事件处理程序已经处理了错误，不需要其他操作。换句话说，浏览器不应该显示它字迹的错误消息。遗憾的是，由于历史原因，Firefox里的错误处理程序必须返回true来表示它已经处理了错误。</p><p><code>onerror</code>处理程序是早期JavaScript的遗物，那时语言核心不包含<code>try/catch</code>异常处理语句。现代代码很少使用它，但是在开发阶段，你可能要这样定义一个错误处理程序，当由错误发生时，来显式地通知你</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">msg, url, line</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (onerror.num++ <span class="xml"><span class="tag">&lt; <span class="attr">onerror.max</span>) &#123;</span></span></span><br><span class="line"><span class="xml">        alert('ERROR: ' + msg + '\n' + url + ':' + line);</span></span><br><span class="line"><span class="xml">        return true;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">onerror.max = 3;</span></span><br><span class="line"><span class="xml">onerror.num = 0;</span></span><br></pre></td></tr></table></figure><hr><h3 id="七、作为Window对象属性的文档元素"><a href="#七、作为Window对象属性的文档元素" class="headerlink" title="七、作为Window对象属性的文档元素"></a>七、作为Window对象属性的文档元素</h3><p>如果在HTML文档中用<code>id</code>属性来为元素命名，并且如果Window对象没有此名字的属性，Window对象会赋予一个属性，它的名字是<code>id</code>属性的值，而它们的值指向表示文档元素的HTMLElement对象。</p><p>在客户端JavaScript中，Window对象是以全局对象的形式存在于作用域链的最上层，这就意味着在HTML文档中使用的<code>id</code>属性会成为可以被脚本访问的全局变量。如果文档包含一个<code>&lt;button id=&quot;okay&quot;/&gt;</code>元素，可以通过全局变量okay来引用此元素。</p><p>但是，有一个重要的警告：如果Window对象已经具有此名字的属性，这就不会发生。比如，id是“history”、“location”或“navigator”的元素，就不会以全局变量的形式出现，因为这些id已经占用了。同样，如果HTML文档包含一个id为“x”的元素，并且还在代码中声明并赋值给全局变量x，那么显式声明的变量会隐藏隐式的元素变量。如果脚本中的变量声明出现在命名元素之前，那这个变量的存在就会阻止元素获取它的window属性。而如果脚本的变量声明出现在命名元素之后，那么变量的显式赋值会覆盖该属性的隐式值。</p><p>元素ID作为全局变量的隐式应用是Web浏览器演化过程中遗留的怪癖。它主要是出于与已有Web页面后向兼容性的考虑。但这里并不推荐使用这种做法——浏览器厂商可以在任何时候为Window对象定义新属性，而这些新属性都会破坏使用了此属性名的隐式定义的代码。</p><p>用<code>document.getElementById()</code>来显示查找元素，如果给它一个更简单的名字，这种用法会变得更加简便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">&#125;</span><br><span class="line">ui.prompt = $(<span class="string">'prompt'</span>);</span><br></pre></td></tr></table></figure><p>假设<code>ID</code>并没有被Window对象使用的话，那么任何由<code>id</code>属性的HTML元素都会成为全局变量的值。以下HTML元素如果由<code>name</code>属性的话，也会这样表现：</p><p><code>&lt;a&gt; &lt;applet&gt; &lt;area&gt; &lt;embed&gt; &lt;form&gt; &lt;frame&gt; &lt;frameset&gt; &lt;iframe&gt; &lt;img&gt; &lt;object&gt;</code></p><p><code>id</code>元素在文档中必须是唯一的：两个元素不能有相同的<code>id</code>。但是，这对<code>name</code>属性无效。如果上面的元素有多于一个有相同的<code>name</code>属性（或者一个元素有<code>name</code>属性，而另一个元素具有相同值的id属性），具有该名称的隐式全局变量会引用一个类数组对象，这个类数组对象的元素是所有命名的元素。</p><p>有<code>name</code>或<code>id</code>属性的<code>&lt;iframe&gt;</code>元素是个特殊的例子，为它们隐式创建的变量不会引用表示自身的Element对象，而是引用表示<code>&lt;iframe&gt;</code>元素创建的嵌套浏览器窗体的Window对象。</p><hr><h3 id="八、多窗口和窗体"><a href="#八、多窗口和窗体" class="headerlink" title="八、多窗口和窗体"></a>八、多窗口和窗体</h3><p>一个Web浏览器窗口可能在桌面上包含多个标签页。每一个标签页哦都市独立的“浏览上下文”（<code>browsing context</code>），每一个上下文都有独立的Window对象，而且相互之间互不干扰。每个标签页中运行的脚本通常并不知道其他标签页的存在，更不用说和其他标签页的Window对象进行交互操作或者操作其他文档内容了。如果Web浏览器不支持多标签页，或者把标签页关掉了，可能在某一时刻桌面上会有很多打开的Web浏览器窗口。而使用标签页，每个桌面窗口中的Window对象都是独立的，也就是说彼此就是完全独立的，和其他桌面窗口没有任何联系。</p><p>但是窗口并不总是和其他窗口完全没关系。一个窗口或标签页中的脚本可以打开新的窗口或标签页，当一个脚本这样做时，这样多个窗口或窗口与另一个窗口的文档之间就可以互操作。</p><h4 id="1-打开和关闭窗口"><a href="#1-打开和关闭窗口" class="headerlink" title="1. 打开和关闭窗口"></a>1. 打开和关闭窗口</h4><p>使用Window对象的<code>open()</code>方法可以打开一个新的浏览器窗口（或标签页，这通常和浏览器的配置选项有关）。<code>Window.open()</code>载入指定的url到新的或已存在的窗口中，并返回代表那个窗口的Window对象。</p><p>它包含4个可选参数：</p><ul><li><p>第一个参数是要在新窗口中显示文档的url。如果这个参数省略了，那么会使用空白页面的url <code>about:blank</code></p></li><li><p>第二个参数是新打开的窗口的名字。如果指定的是一个已经存在的窗口的名字，会直接使用已存在的窗口。否则，会打开新的窗口，并将这个指定的名字赋值给它。如果省略次参数，会使用指定的名字“<code>_blank</code>”开打一个新的、未命名的窗口。</p><p>窗口的名字是非常重要的，因为它允许<code>open()</code>方法引用已存在的窗口，并同时可以作为<code>&lt;a&gt;</code>和<code>&lt;form&gt;</code>元素上HTML <code>target</code>属性的值，用来表示引用的文档（或表单提交结果）应该显示在命名的窗口中。这个<code>target</code>属性的值可以设置为“<code>_blank</code>”、“<code>_parent</code>”或“<code>_top</code>”，从而使引用的文档显示在新的空白窗口、父窗口/窗体或顶层窗口中。</p></li><li><p>第三个参数是一个以逗号分隔的列表，包含大小和各种属性，用以表明新窗口是如何打开的。如果省略这个参数，那么新窗口就会用一个默认的大小，而且带有一整组标准的UI组件，即菜单栏、状态栏、工具栏等。在标签式浏览器中，会创建一个新的标签。这个参数是非标准的，H5规范也主张浏览器忽略它。注意：当指定第三个参数时，所有没有显式指定的功能都会忽略。出于各种安全原因，浏览器包含对可能指定的功能的限制。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w = <span class="built_in">window</span>.open(<span class="string">'smallwin.html'</span>, <span class="string">'smallwin'</span>, <span class="string">'width=400,height=350,status=yes,resizable:yes'</span>);</span><br></pre></td></tr></table></figure><ul><li>第四个参数只在第二个参数命名是一个存在的窗口时才有用。它是一个布尔值，声明了由第一个参数指定的url是应用替换掉窗口浏览历史的当前条目（true），还是应该在窗口浏览历史中创建一个新的条目（false），后者是默认的设置。</li></ul><p>就像方法<code>open()</code>打开一个新窗口一样，方法<code>close()</code>将关闭一个窗口。如果已经创建了Window对象，可以使用如下的代码将它关掉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win.close();</span><br></pre></td></tr></table></figure><p>运行在那个窗口中的JavaScript代码则可以使用下面的代码关闭</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.close();</span><br></pre></td></tr></table></figure><p>注意：要显式地使用标识符window，这样可以避免混淆Window对象的<code>close()</code>方法和Document对象的<code>close()</code>方法——如果正在从事件处理程序调用<code>close()</code>，这很重要。</p><p>即使一个窗口关闭了，代表它的Window对象仍然存在。已关闭的窗口会有个值为true的closed属性，它的document会是null，它的方法通常也不会再工作。</p><h4 id="2-窗体之间的关系"><a href="#2-窗体之间的关系" class="headerlink" title="2. 窗体之间的关系"></a>2. 窗体之间的关系</h4><p>Window对象的方法<code>open()</code>返回代表新创建的窗口的Window对象。而且这个新窗口具有opener属性，该属性可以打开它的原始窗口。这样，两个窗口就可以相互引用，彼此都可以读取对方的属性或是调用对方的方法。窗体也是这样的，窗口或窗体中运行的代码都可以通过下面介绍的属性引用到自己的窗口或窗体，以及嵌套的子窗体。</p><p>任何窗口中的JavaScript代码都可以将自己的窗口引用为window或self。窗体可以用parent属性引用包含它的窗口或窗体的Window对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.history.back();</span><br></pre></td></tr></table></figure><p>如果一个窗口是顶级窗口或标签，而不是窗体，那么其parent属性引用的就是这个窗口本身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有顶级窗口才会返回true</span></span><br><span class="line">parent == self;</span><br></pre></td></tr></table></figure><p>如果一个窗体包含在另一个窗体中，而后者又包含在顶级窗口中，那么该窗体就可以使用<code>parent.parent</code>来引用顶级窗口。top属性是一个通用的快捷方式，无论一个窗体被嵌套了几层，它的top属性引用的都是指向包含它的顶级窗口。如果一个Window对象代表的是一个顶级窗口，那么它的top属性引用的就是窗口本身。对于那些顶级窗口的直接子窗体，top属性就等价于parent属性。</p><p>parent和top属性允许脚本引用它的窗体的祖先。有不止一种方法可以引用窗口或窗体的子孙窗体。窗体是通过<code>&lt;iframe&gt;</code>元素创建的。可以用获取其他元素的方法来获取一个表示<code>&lt;iframe&gt;</code>的元素对象。假定文档里有<code>&lt;iframe id=&quot;f1&quot;&gt;</code>。那么，表示该iframe的元素对象就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframeElement = <span class="built_in">document</span>.getElementById(<span class="string">'f1'</span>);</span><br></pre></td></tr></table></figure><p><code>&lt;iframe&gt;</code>元素有<code>contentWindow</code>属性，引用该窗体的Window对象，所以此窗体的Window对象就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> childFrame = <span class="built_in">document</span>.getElementById(<span class="string">'f1'</span>).contentWindow;</span><br></pre></td></tr></table></figure><p>可以进行反向操作——从表示窗体的Window对象来获取该窗体的<code>&lt;iframe&gt;</code>元素——用Window对象的<code>frameElement</code>属性。表示顶级窗口的Window对象的frameElement属性为null，窗体中的Window对象的frameElement属性不是null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elt = <span class="built_in">document</span>.getElementById(<span class="string">'f1'</span>);</span><br><span class="line"><span class="keyword">var</span> win = elt.contentWindow;</span><br><span class="line">win.frameElement == elt;                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">window</span>.frameElement == <span class="literal">null</span>;                <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>尽管如此，通常不需要使用<code>getElementById()</code>方法和<code>contentWindow</code>属性来获取窗口中子窗体的引用。每个Window对象都有一个frames属性，它引用自身包含的窗口或窗体的子窗体。frames属性引用的是类数组对象，并可以通过数字或窗体名进行索引。要引用窗口的第一个子窗体，可以用<code>frames[0]</code>。要引用第二个子窗体的第三个子窗体，可以用<code>frames[1].frames[2]</code>。窗体里创建的代码可以用<code>parent.frames[1]</code>引用兄弟窗体。注意<code>frames[]</code>数组里的元素是Window对象，而不是<code>&lt;iframe&gt;</code>元素。</p><p>如果指定<code>&lt;iframe&gt;</code>元素的name或id属性，那么除了用数字进行索引之外，还可以用名字来进行索引。例如，名字为“f1”的帧应该用<code>frames[&#39;f1&#39;]</code>或<code>frames.f1</code>。</p><p>前面讲过，<code>&lt;iframe&gt;</code>以及其他元素的name和id都可以自动通过Window对象的属性来引用，而<code>&lt;iframe&gt;</code>元素和其他的元素有所不同：对于窗体来说，通过Window对象的属性引用的<code>&lt;iframe&gt;</code>是指窗体中的Window对象，而不是元素对象。也就是说，可以通过窗体的名字“f1”来代替<code>frame.f1</code>。实际上，H5规范指出frames属性是一个自引用（self-referential）的属性，就像window和self一样。而这个Window对象看起来像一个由窗体组成的数组。也就是说可以通过<code>window[0]</code>来获取第一个子窗体的引用，可以通过<code>window.length</code>或<code>length</code>查询窗体的编号。但是这里我们使用frames来代替window会比较清晰一些。</p><h4 id="3-交互窗口中的JavaScript"><a href="#3-交互窗口中的JavaScript" class="headerlink" title="3. 交互窗口中的JavaScript"></a>3. 交互窗口中的JavaScript</h4><p>每个窗口和窗体都是它自身的JavaScript的执行上下文，以Window作为全局对象。但是如果一个窗口或窗体中的代码可以应用到其他窗口或窗体（并且同源策略没有阻止它），那么一个窗口或窗体的脚本就可以和其他窗口或窗体中的脚本进行交互。</p><p>设想一个Web页面里有两个<code>&lt;iframe&gt;</code>元素，分别叫“A”和“B”，并假设这些床体所包含的文档来自于相同的一个服务器，并且包含交互脚本。窗体A里的脚本定义了一个变量i</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>这个变量只是全局对象的一个属性，也是Window对象的一个属性。窗体A中的代码可以用标识符i来引用变量，或者用window对象显式地引用这个变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.i;</span><br></pre></td></tr></table></figure><p>由于窗体B中的脚本可以引用窗体A中的Window对象，因此它也可以引用那个Window对象的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.A.i = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>同样的，我们可以在窗体B中定义一个函数，在窗体A中进行调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.B.f();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = parent.B.f;</span><br></pre></td></tr></table></figure><p>当采用这种方式在窗体或窗口间共享函数时，牢记词法作用域的规则非常重要。函数在定义它的作用域中执行，而不是调用它的作用域中执行。就这个例子来说，如果函数f引用了全局变量，那么将在窗体B的属性中查找这些变量，即使函数是由窗体A调用的。</p><p>要记住构造函数也是函数，所以当用构造函数和相关的额原型对象定义一个类时，那个类只在一个单独的窗口中定义。假设一个窗口包含窗体A和窗体B，并且包含Set类。</p><p>顶级窗口的脚本可以创建新的Set对象，类似这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure><p>相反，每个床体中的代码必须显式地用父级窗口的属性类引用<code>Set()</code>构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> parent.Set();</span><br></pre></td></tr></table></figure><p>另外，每个窗体中的代码还可以定义自己的变量来引用构造函数，这样就更方便了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Set</span> = top.Set();</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure><p>和用户定义的类不同，内置的类（String、Date和RegExp等）都会在所有的窗口中自动预定义。但是要注意，每个窗口都有构造函数的一个独立副本和构造函数对应原型对象的一个独立副本。例如，每个窗口都有自己的<code>String()</code>构造函数和<code>String.prototype</code>对象的副本。因此，如果编写一个操作JavaScript字符串的新方法，并且通过把它赋值给当前窗口中的<code>String.prototype</code>对象而使它称为String类的一个方法，那么该窗口中的所有字符串就都可以使用这个新方法。但是，别的窗口中定义的字符串不能使用这个新方法。</p><p>事实上，每个Window都有自己的原型对象，这意味着instanceof操作符不能跨窗口工作。</p><hr><h3 id="九、-WindowProxy对象"><a href="#九、-WindowProxy对象" class="headerlink" title="九、 WindowProxy对象"></a>九、 WindowProxy对象</h3><p>我们已经讲过很多次，Window对象是客户端JavaScript的全局变量。但是从技术上来看，并不是这样的。Web浏览器每次向窗口或窗体中载入新的内容，它都会开始一个新的JavaScript执行上下文，包含一个新创建的全局对象。但是当多个窗口或窗体在使用时，有一个重要的概念，尽管窗体或窗口载入了新的文档，但是引用窗体或窗口的Window对象还仍然是一个有效的引用。</p><p>所以客户端JavaScript有两个重要的对象。客户端全局对象处于作用域链的顶级，并且是全局变量和函数定义的地方。事实上，全局对象会在窗口或窗体载入新内容时被替换。我们称为“Window对象”的对象实际上不是全局对象，而是全局对象的一个代理。每当查询或设置Window对象的属性时，就会在窗口或窗体的当前全局对象上查询或设置相同的属性。H5规范称这个代理对象为WindowProxy，但本文中我们继续使用名次Window对象。</p><p>由于它的代理行为，除了有更长的生命周期之外，代理对象表现得像真正的全局对象。如果可以比较两个对象，那么区分它们会很困难。但事实上，没有办法可以引用到真正地客户端全局对象。全局对象处于作用域链的顶端，但是<code>window</code>、<code>self</code>、<code>top</code>、<code>parent</code>以及窗体的属性全部返回代理对象。<code>window.open()</code>方法也返回代理对象，甚至顶级函数里this关键字的值都是代理对象，而不是真正的全局对象。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Window对象是客户端JavaScript程序的全局对象，本文介绍Window对象的属性和方法，这些属性定义了许多不同的API。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Window对象" scheme="http://www.xiaoleon.cn/tags/Window%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
