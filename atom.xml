<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiao Leon</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaoleon.cn/"/>
  <updated>2018-01-21T14:35:07.633Z</updated>
  <id>http://www.xiaoleon.cn/</id>
  
  <author>
    <name>Leon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>H5(9) 离线Web应用程序</title>
    <link href="http://www.xiaoleon.cn/2018/01/21/html5-9/"/>
    <id>http://www.xiaoleon.cn/2018/01/21/html5-9/</id>
    <published>2018-01-21T14:00:12.000Z</published>
    <updated>2018-01-21T14:35:07.633Z</updated>
    
    <content type="html"><![CDATA[<p>Web应用程序已经变得越来越复杂，越来越成熟了，很多领域都在利用着Web应用程序。但是，它有一个致命的缺点：如果用户没有和Internet建立连接，他就不能利用这个Web应用程序了。</p><p>因此，HTML5中新增了一个API，它使用一个本地缓存机制很好地解决了这个问题，为离线Web应用程序的开发提供了可能性。</p><p>为了让Web应用程序在离线状态时候也能正常工作，就必须要把所有构成Web应用程序的资源文件，诸如HTML文件、CSS文件、Javascript脚本文件等放在本地缓存中，当服务器没有和Internet建立连接的时候，也可以利用本地缓存中的资源文件来正常运行Web应用程序。</p><a id="more"></a><h3 id="一、本地缓存与浏览器网页缓存的区别"><a href="#一、本地缓存与浏览器网页缓存的区别" class="headerlink" title="一、本地缓存与浏览器网页缓存的区别"></a>一、本地缓存与浏览器网页缓存的区别</h3><p>本地缓存是为整个Web应用程序服务的，而浏览器的网页缓存只服务于单个网页。任何网页都具有网页缓存，而本地缓存只缓存那些你指定缓存的网页。</p><p>网页缓存是不安全、不可靠的，因为我们不知道在网站中到底缓存了哪些网页，以及缓存了网页上的哪些资源。而本地缓存是可靠的，我们可以控制对哪些内容进行缓存，不对哪些内容进行缓存，开发人员还可以用编程的手段来控制缓存的更新，利用缓存对象的各种属性、状态和事件来开发出更为强大的离线应用程序。</p><hr><h3 id="二、manifest文件"><a href="#二、manifest文件" class="headerlink" title="二、manifest文件"></a>二、manifest文件</h3><p>Web应用程序的本地缓存是通过每个页面的<code>manifest</code>文件来管理的。<code>manifest</code>文件是一个简单文本文件，在该文件中以清单的形式列举了需要被缓存或不需要被缓存的资源文件的文件名称，以及这些资源文件的访问路径。</p><p>可以为每一个页面单独指定一个<code>manifest</code>文件，也可以对整个Web应用程序指定一个总的<code>manifest</code>文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#version 7</span><br><span class="line">CACHE:</span><br><span class="line">other.html</span><br><span class="line">hello.js</span><br><span class="line">images/myphoto.jpg</span><br><span class="line">NETWORK:</span><br><span class="line">http://lulingniu/NotOffline</span><br><span class="line">NotOffline.asp</span><br><span class="line">*</span><br><span class="line">FALLBACK:</span><br><span class="line">online.js locale.js</span><br><span class="line">CACHE:</span><br><span class="line">newhello.html</span><br><span class="line">newhello.js</span><br></pre></td></tr></table></figure><p>在manifest文件中，第一行必须是“<code>CACHE MANIFEST</code>”文字，以把本文件的作用告知给浏览器，即对本地缓存中的资源文件进行具体设置。同时，真正运行或测试离线Web应用程序的时候，需要对服务器进行配置，让服务器支持<code>text/cache-manifest</code>这个MIME类型。</p><p>例如对Apache服务器进行配置的时候，需要找到<code>{apache_home}/conf/mime.types</code>这个文件，并在文件最后添加代码<code>text/cache-manifest   manifest</code></p><p>在指定资源文件的时候，可以把资源文件分为三类，分别是<code>CACHE</code>、<code>NETWORK</code>、<code>FALLBACK</code>：</p><ul><li><p><code>CACHE</code>类别中指定需要被缓存在本地的资源文件。为某个页面指定需要本地缓存的资源文件时，不需要把这个页面本身指定在<code>CACHE</code>类别中，因为如果一个页面具有<code>manifest</code>文件，浏览器会自动对这个页面进行本地缓存</p></li><li><p><code>NETWORK</code>类别为显式指定不进行本地缓存的资源文件，这些资源文件只有当客户端与服务器端建立连接的时候才能访问。本示例中该类别的<code>“*”</code>为通配符，表示没有在本<code>manifest</code>文件中指定的资源文件都不进行本地缓存</p></li><li><p><code>FALLBACK</code>类别中的每行中指定两个资源文件，第一个资源文件为能够在线访问时使用的资源文件，第二个资源文件为不能在线访问时使用的备用资源文件。</p></li></ul><p>每个类别都是可选的，但是如果文件开头没有指定类别而直接书写资源文件时，浏览器把这些资源文件视为<code>CACHE</code>类别，直到看见文件中第一个被书写出来的类别为止。</p><p>为了让浏览器能够正常阅读该文本文件，需要在Web应用程序页面上的html标签的<code>manifest</code>属性中指定<code>manifest</code>文件的url地址。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可以为每个页面单独指定一个manifest文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"hello.manifest"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 也可以为整个Web应用程序指定一个总的manifest文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"global.manifest"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过这些步骤，将资源文件保存到本地缓存去的基本操作就完成了。当需要对本地缓存去的内容进行修改时，只需要修改<code>manifest</code>文件就可以了。文件被修改后，浏览器可以自动检查<code>manifest</code>文件，并自动更新本地缓存区的内容。</p><hr><h3 id="三、浏览器与服务器的交互过程"><a href="#三、浏览器与服务器的交互过程" class="headerlink" title="三、浏览器与服务器的交互过程"></a>三、浏览器与服务器的交互过程</h3><p>当使用离线Web应用程序进行工作的时候，有必要理解一下浏览器与服务器的交互过程。</p><p>例如一个<code>http://lulingniu</code>网站，以<code>index.html</code>为主页，<code>index.manifest</code>文件为<code>manifest</code>文件，在该文件中请求本地缓存<code>index.html</code>、<code>hello.js</code>、<code>hello1.jpg</code>、<code>hello2.jpg</code>这几个资源文件。</p><p><strong>交互过程</strong>：</p><h4 id="1-首次访问"><a href="#1-首次访问" class="headerlink" title="1. 首次访问"></a>1. 首次访问</h4><ul><li>1)浏览器请求访问<code>http://lulingniu</code></li><li>2)服务器返回<code>index.html</code>网页</li><li>3)浏览器解析<code>index.html</code>网页，请求页面上所有资源文件，包括HTML文件、图像文件、CSS文件、JS文件，以及<code>manifest</code>文件</li><li>4)服务器返回所有资源文件</li><li>5)浏览器处理<code>manifest</code>文件，请求<code>manifest</code>中所有要求本地缓存的文件，包括<code>index.html</code>。如果要求本地缓存所有文件，这将是一个比较大的重复的请求过程</li><li>6)服务器返回所有要求本地缓存的文件</li><li>7)浏览器对本地缓存进行更新，存入包括页面本身在内的所有要求本地缓存的资源文件，并且触发一个事件，通知本地缓存被更新</li></ul><h4 id="2-再次访问，manifest文件没有被修改"><a href="#2-再次访问，manifest文件没有被修改" class="headerlink" title="2. 再次访问，manifest文件没有被修改"></a>2. 再次访问，manifest文件没有被修改</h4><ul><li>1)浏览器再次请求访问<code>http://lulingniu</code></li><li>2)浏览器发现这个页面被本地缓存，于是使用本地缓存中的<code>index.html</code>页面</li><li>3)浏览器解析<code>index.html</code>页面，使用所有本地缓存中的资源文件</li><li>4)浏览器向服务器请求<code>manifest</code>文件</li><li>5)服务器返回一个304代码，通知浏览器<code>manifest</code>没有发生变化</li></ul><h4 id="3-再次访问，manifest文件已更新"><a href="#3-再次访问，manifest文件已更新" class="headerlink" title="3. 再次访问，manifest文件已更新"></a>3. 再次访问，manifest文件已更新</h4><ul><li>1)浏览器再次请求访问<code>http://lulingniu</code></li><li>2)浏览器发现这个页面被本地缓存，于是使用本地缓存中的<code>index.html</code>页面</li><li>3)浏览器解析<code>index.html</code>页面，使用所有本地缓存中的资源文件</li><li>4)浏览器向服务器请求<code>manifest</code>文件</li><li>5)服务器返回更新过的<code>manifest</code>文件</li><li>6)浏览器处理<code>manifest</code>文件，发现该文件已被更新，于是请求所有要求进行本地缓存的资源文件，包括<code>index.html</code>页面本身</li><li>7)浏览器返回要求进行本地缓存的资源文件</li><li>8)浏览器对本地缓存进行更新，存入所有新的资源文件。并且触发一个事件，通知本地缓存被更新。</li></ul><p>需要注意的时，即使资源文件被修改过了，上面的第3步中已装入的资源文件是不会发生变化的，譬如图片不会突然变成新的图片，脚本文件也不会突然使用新的脚本文件，也就是说，这时更新的本地缓存中的内容还不能被使用，只有重新打开这个页面的时候才会使用更新过后的资源文件。</p><p>另外，如果不想修改<code>manifest</code>文件中对于资源文件的设置，但是对服务器上请求缓存的资源文件进行了修改，那么可以通过修改版本号的方式让浏览器认为<code>manifest</code>文件已经被更新过了，以便重新下载修改过的资源文件。</p><hr><h3 id="四、applicationCache对象"><a href="#四、applicationCache对象" class="headerlink" title="四、applicationCache对象"></a>四、applicationCache对象</h3><p><code>applicationCache</code>对象代表了本地缓存，可以用它来通知本地缓存中已经被更新，也允许用户手工更新本地缓存。</p><p>当浏览器对本地缓存进行更新，装入新的资源文件时，会触发<code>applicationCache</code>对象的<code>updateready</code>事件，通知本地缓存已被更新。我们可以利用这个事件告诉用户本地缓存已经被更新，用户需要手工刷新页面来得到最新版本的应用程序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">applicationCache.onUpdateReady = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 本地缓存已被更新，通知用户</span></span><br><span class="line">    alert(<span class="string">'本地缓存已被更新，您可以刷新页面来得到本程序的最新版本。'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-swapCache方法"><a href="#1-swapCache方法" class="headerlink" title="1. swapCache方法"></a>1. swapCache方法</h4><p><code>swapCache</code>方法用来手工执行本地缓存的更新，它只能在<code>applicationCache</code>对象的<code>updateReady</code>事件被触发时调用，<code>updateReady</code>事件只有在服务器的<code>manifest</code>文件被更新，并且把<code>manifest</code>文件中所要求的资源文件下载到本地后触发。顾名思义，这个事件的含义是“本地缓存准备被更新”。</p><p>当这个事件被触发后，我们可以用<code>swapCache</code>方法来手工进行本地缓存的更新。</p><p>例如，如果本地缓存的容量非常大（譬如超过100M），本地缓存的更新工作将需要相对较长的时间，而且还会把浏览器给锁住。这时最好有一个提示，告诉用户正在进行本地缓存的更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">applicationCache.onUpdateReady = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 本地缓存已被更新，通知用户</span></span><br><span class="line">    alert(<span class="string">'正在更新本地缓存...'</span>);</span><br><span class="line">    applicationCache.swapCache();</span><br><span class="line">    alert(<span class="string">'本地缓存已被更新，您可以刷新页面来得到本程序的最新版本。'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如果我们不调用<code>swapCache</code>方法会怎么样？本地缓存就不会被更新了吗？答案时否定的，但是更新的时间不一样。如果不调用<code>swapCache</code>方法，本地缓存将在下一次打开本页面时被更新；如果调用<code>swapCache</code>方法的话，本地缓存将会立刻更新。因此，我们可以使用<code>confirm</code>方法让用户自己选择更新的时机——是立刻更新，还是在下次打开画面时再更新，特别是当他们有可能正在页面上执行一个较大的操作的时候。</p><p>另外，尽管使用<code>swapCache</code>方法立刻更新了本地缓存，但是并不意味着我们页面上的图像和脚本文件也会立刻更新，它们都是在重新打开本页面时才会生效。</p><h4 id="2-update方法"><a href="#2-update方法" class="headerlink" title="2. update方法"></a>2. update方法</h4><p><code>applicationCache</code>的<code>update</code>方法，作用是检查服务器上的<code>manifest</code>文件是否有更新，如果有更新，浏览器会自动下载<code>manifest</code>文件中所有请求本地缓存的资源文件，当这些资源文件下载完毕时，会触发<code>updateReady</code>事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!doctype HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"swapCache.manifest"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">'utf-8'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>swapCache方法实例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>swapCache方法示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 手工检查manifest是否有更新</span></span><br><span class="line">        applicationCache.update();</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    applicationCache.addEventListener(<span class="string">'updateready'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (confirm(<span class="string">'本地缓存已被更新，需要刷新画面来获取应用程序最新版本，是否刷新？'</span>)) &#123;</span><br><span class="line">            applicationCache.swapCache();</span><br><span class="line">            location.reload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># swapCache.manifest</span><br><span class="line"></span><br><span class="line">CACHE MANIFEST</span><br><span class="line">#version 1.20</span><br><span class="line">CACHE:</span><br><span class="line">script.js</span><br></pre></td></tr></table></figure><hr><h3 id="五、applicationCache对象的事件"><a href="#五、applicationCache对象的事件" class="headerlink" title="五、applicationCache对象的事件"></a>五、applicationCache对象的事件</h3><h4 id="1-首次访问-1"><a href="#1-首次访问-1" class="headerlink" title="1. 首次访问"></a>1. 首次访问</h4><ul><li>1)浏览器请求访问<code>http://lilingniu</code></li><li>2)服务器返回<code>index.html</code>网页</li><li>3)浏览器发现该网页具有<code>manifest</code>属性，触发<code>checking</code>事件，检查<code>manifest</code>文件是否存在。不存在时，触发<code>error</code>事件，表示<code>manifest</code>文件未找到，不执行步骤6开始的交互过程</li><li>4)浏览器解析<code>index.html</code>网页，请求页面上的所有资源文件</li><li>5)服务器返回所有资源文件</li><li>6)浏览器处理<code>manifest</code>文件，请求<code>manifest</code>中所有要求本地缓存的文件，包括<code>index.html</code>页面本身，即使刚才已经请求过该文件。如果要求本地缓存所有文件，这将是一个比较大的重复的请求过程。</li><li>7)服务器返回所有要求本地缓存的文件</li><li>8)浏览器触发<code>downloading</code>事件，然后开始下载这些资源。在下载的同时，周期性地触发<code>progress</code>事件，开发人员可以用编程的手段获取多少文件已被下载，多少文件仍然处于下载队列等信息</li><li>9)下载结束后触发<code>cached</code>事件，表示首次缓存成功，存入所有要求本地缓存的资源文件</li></ul><h4 id="2-再次访问"><a href="#2-再次访问" class="headerlink" title="2. 再次访问"></a>2. 再次访问</h4><ul><li>1)步骤1-5同上，步骤5执行完之后，浏览器将核对<code>manifest</code>文件是否被更新。</li><li>2)若没有被更新，触发<code>noupdate</code>事件，步骤6开始的交互过程不会被执行。</li><li>3)若发生了更新，将继续执行后面的步骤，在步骤9中不触发<code>cached</code>事件，而是触发<code>updateready</code>事件，这表示下载结束，可以通过刷新页面来使用更新后的本地缓存，或调用<code>swapCache</code>方法来立刻使用更新后的本地缓存。</li><li>4)另外，在访问缓存名单时如果返回一个HTTP 404错误，或者410错误，则触发<code>obsolete</code>事件。</li><li>5)在整个过程中，如果任何与本地缓存有关的处理中发生错误的话，都会触发<code>error</code>事件。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#version 1.0</span><br><span class="line">CACHE:</span><br><span class="line">index.html</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">manifest</span>=<span class="string">"applicationCacheEvent.manifest"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> msg = <span class="built_in">document</span>.getElementById(<span class="string">'msg'</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'checking'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'checking &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'noupdate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'noupdate &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'downloading'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'downloading &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'progress'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'progress &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'updateready'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'updateready &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'cached'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'cached &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            applicationCache.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                msg.innerHTML += <span class="string">'error &lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">            &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>applicationCache事件流程示例<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web应用程序已经变得越来越复杂，越来越成熟了，很多领域都在利用着Web应用程序。但是，它有一个致命的缺点：如果用户没有和Internet建立连接，他就不能利用这个Web应用程序了。&lt;/p&gt;
&lt;p&gt;因此，HTML5中新增了一个API，它使用一个本地缓存机制很好地解决了这个问题，为离线Web应用程序的开发提供了可能性。&lt;/p&gt;
&lt;p&gt;为了让Web应用程序在离线状态时候也能正常工作，就必须要把所有构成Web应用程序的资源文件，诸如HTML文件、CSS文件、Javascript脚本文件等放在本地缓存中，当服务器没有和Internet建立连接的时候，也可以利用本地缓存中的资源文件来正常运行Web应用程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.xiaoleon.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端开发" scheme="http://www.xiaoleon.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML5" scheme="http://www.xiaoleon.cn/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>H5(8) Web Storage与本地数据库</title>
    <link href="http://www.xiaoleon.cn/2018/01/21/html5-8/"/>
    <id>http://www.xiaoleon.cn/2018/01/21/html5-8/</id>
    <published>2018-01-21T13:53:48.000Z</published>
    <updated>2018-01-21T14:27:29.861Z</updated>
    
    <content type="html"><![CDATA[<p><code>Web Storage</code>存储机制是对HTML4中<code>cookies</code>存储机制的一个改善。由于<code>cookies</code>存储机制有很多缺点，HTML5中不再使用它，转而使用改良后的<code>Web Storage</code>存储机制。</p><p>本地数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库——原本需要保存在服务器端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访问数据的速度。</p><a id="more"></a><h3 id="一、Web-Storage"><a href="#一、Web-Storage" class="headerlink" title="一、Web Storage"></a>一、Web Storage</h3><p><code>Cookies</code>存储永久数据存在以下几个问题：</p><ul><li><p>大小：<code>cookies</code>的大小被限制在4KB</p></li><li><p>带宽：<code>cookies</code>是随HTTP事务一起被发送的，因此会浪费一部分发送<code>cookies</code>时使用的带宽</p></li><li><p>复杂性：要正确的操纵<code>cookies</code>是很困难的</p></li></ul><p><code>Web Storage</code>，顾名思义，就是在Web上存储数据的功能，这里的存储是针对客户端本地而言的，具体来说，又分为两种</p><ul><li>sessionStorage</li></ul><p>将数据保存在<code>session</code>对象中。所谓<code>session</code>，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。<code>session</code>对象可以用来保存在这段时间内所要求保存的任何数据</p><ul><li>localStorage</li></ul><p>将数据保存在客户端本地的硬件设备中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用</p><p>两者区别在于，<code>sessionStorage</code>为临时保存，而<code>localStorage</code>为永久保存。</p><p>读写数据时使用的基本方法：</p><ul><li>sessionStorage</li></ul><p>保存数据：<code>sessionStorage.setItem(key, value)</code></p><p>读取数据：<code>var value = sessionStorage.getItem(key)</code></p><ul><li>localStorage</li></ul><p>保存数据：<code>localStorage.setItem(key, value)</code></p><p>读取数据：<code>var value = localStorage.getItem(key)</code></p><hr><h3 id="二、本地数据库"><a href="#二、本地数据库" class="headerlink" title="二、本地数据库"></a>二、本地数据库</h3><p>HTML5中可以通过sql语句来访问本地的sqlite数据库，有两个必要的步骤</p><ol><li><p>创建访问数据库的对象</p></li><li><p>使用事务处理</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = openDatabase(<span class="string">'mydb'</span>, <span class="string">'1.0'</span>, <span class="string">'Test DB'</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>方法中的四个参数，第一个为数据库名，第二个为版本号，第三个为数据库的描述，第四个为数据库的大小。该方法返回创建后的数据库访问对象，如果该数据库不存在，则创建该数据库。</p><p>实际访问数据库的时候，还需要调用<code>transaction</code>方法，来执行事务处理。使用事务处理，可以防止在对数据库进行访问及执行有关操作的时候受到外界的打扰，因为在web上，同时会有许多人都在对页面进行访问。如果在访问数据库的过程中，正在操作的数据被别的用户给修改掉的话，会引起很多意想不到的后果。因此，可以使用事务来达到在操作完了之前，阻止别的用户访问数据库的目的。</p><p>transaction方法的使用如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.transaction(<span class="function"><span class="keyword">function</span>(<span class="params">tx</span>) </span>&#123;</span><br><span class="line">    tx.executeSql(<span class="string">'create table if not exists logs (id unique, Log)'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>transaction</code>方法使用一个回调函数为参数。在这个函数中，执行访问数据库的语句。</p><p><code>executeSql</code>方法的完整定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction.executeSql(sqlquery, [], dataHandler, errorHandler);</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数为需要执行的SQL语句</p></li><li><p>第二个参数为SQL语句中所有使用到的参数的数组</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction.executeSql(<span class="string">'update people set age=? where name=?;'</span>, [age, name]);</span><br></pre></td></tr></table></figure><ul><li>第三个参数为执行SQL语句成功时调用的回调函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataHandler</span>(<span class="params">transaction, results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行SQL语句成功后的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第四个参数为执行SQL语句出错时调用的回调函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span>(<span class="params">transaction, errmsg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行SQL语句出错时的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Web Storage&lt;/code&gt;存储机制是对HTML4中&lt;code&gt;cookies&lt;/code&gt;存储机制的一个改善。由于&lt;code&gt;cookies&lt;/code&gt;存储机制有很多缺点，HTML5中不再使用它，转而使用改良后的&lt;code&gt;Web Storage&lt;/code&gt;存储机制。&lt;/p&gt;
&lt;p&gt;本地数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库——原本需要保存在服务器端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访问数据的速度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.xiaoleon.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端开发" scheme="http://www.xiaoleon.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML5" scheme="http://www.xiaoleon.cn/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>H5(7) Audio &amp;&amp; Video</title>
    <link href="http://www.xiaoleon.cn/2018/01/21/html5-7/"/>
    <id>http://www.xiaoleon.cn/2018/01/21/html5-7/</id>
    <published>2018-01-21T13:41:34.000Z</published>
    <updated>2018-01-21T14:27:33.607Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="一、元素属性"><a href="#一、元素属性" class="headerlink" title="一、元素属性"></a>一、元素属性</h3><p><code>audio</code>元素与<code>video</code>元素所具有的属性大致相同，所以我们看看这两个元素都具有哪些属性</p><h4 id="1-src"><a href="#1-src" class="headerlink" title="1. src"></a>1. src</h4><p>在该属性中指定媒体数据的URL地址</p><h4 id="2-autoplay"><a href="#2-autoplay" class="headerlink" title="2. autoplay"></a>2. autoplay</h4><p>在该属性中指定媒体是否在页面加载后自动播放。该属性的使用方法如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"sample.mov"</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-preload"><a href="#3-preload" class="headerlink" title="3. preload"></a>3. preload</h4><p>该属性指定视频或音频数据是否预加载。如果使用预加载的话，浏览器会预先将视频或音频数据进行缓冲，这样可以加快播放的速度，因为播放时数据已经预先缓冲完毕。</p><p>该属性由三个可选择的值：<code>none</code>、<code>metadata</code>与<code>auto</code>，默认为<code>auto</code></p><ul><li><p><code>none</code> —— 不进行预加载</p></li><li><p><code>metadata</code> —— 只预加载媒体的元数据（媒体字节数、第一帧、播放列表、持续时间等）</p></li><li><p><code>auto</code> —— 预加载全部视频或音频</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"sample.mov"</span> <span class="attr">preload</span>=<span class="string">"auto"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-poster-（video元素独有属性）"><a href="#4-poster-（video元素独有属性）" class="headerlink" title="4. poster （video元素独有属性）"></a>4. poster （video元素独有属性）</h4><p>当视频不可用时，可以使用该元素向用户展示一副替代用的图片。当视频不可用时，最好使用该属性，以免展示视频的区域内出现一片空白。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"sample.mov"</span> <span class="attr">poster</span>=<span class="string">"cannotuse.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-loop"><a href="#5-loop" class="headerlink" title="5. loop"></a>5. loop</h4><p>在该属性中指定是否循环播放视频或音频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"sample.mov"</span> <span class="attr">autoplay</span> <span class="attr">loop</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-controls"><a href="#6-controls" class="headerlink" title="6. controls"></a>6. controls</h4><p>在该属性中指定是否为视频或音频添加浏览器自带的播放用的控制条。控制条中具有播放、暂停等按钮</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"sample.mov"</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="7-width与height-（video元素独有属性）"><a href="#7-width与height-（video元素独有属性）" class="headerlink" title="7. width与height （video元素独有属性）"></a>7. width与height （video元素独有属性）</h4><p>指定视频的宽度与高度（像素）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"sample.mov"</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"500"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-error属性"><a href="#8-error属性" class="headerlink" title="8. error属性"></a>8. error属性</h4><p>在读取、使用媒体数据的过程中，在正常情况下，<code>video</code>元素或<code>audio</code>元素的<code>error</code>属性为<code>null</code>，但是任何时候只要出现错误，<code>error</code>属性将会返回一个<code>MediaError</code>对象，该对象的<code>code</code>返回对应的错误状态，错误状态共有4个可能值。</p><ul><li><p><code>MEDIA_ERR_ABORTED</code>（数字值为1）：媒体数据的下载过程由于用户的操作原因而被中止</p></li><li><p><code>MEDIA_ERR_NETWORK</code>（数字值为2）：确认媒体资源可用，但是在下载时出现网络错误，媒体数据的下载过程被中止</p></li><li><p><code>MEDIA_ERR_ECODE</code>（数字值为3）：确认媒体资源可用，但是解码时发生错误</p></li><li><p><code>MEDIA_ERR_SRC_NOT_SUPPORTED</code>（数字值为4）：媒体格式不被支持</p></li></ul><h4 id="9-networkState属性"><a href="#9-networkState属性" class="headerlink" title="9. networkState属性"></a>9. networkState属性</h4><p>在媒体数据加载过程中可以使用<code>video</code>元素或<code>audio</code>元素的<code>networkState</code>属性读取当前网络状态，共有如下4种可能值。</p><ul><li><p><code>NETWORK_EMPTY</code>（数字值为0）：元素处于初始状态</p></li><li><p><code>NETWORK_IDLE</code>（数字式为1）：浏览器已选择好用什么编码格式来播放媒体，但尚未建立网络连接</p></li><li><p><code>NETWORK_LOADING</code>（数字值为2）：媒体数据加载中</p></li><li><p><code>NETWORK_NO_SOURCE</code>（数字值为3）：没有支持的编码格式，不执行加载</p></li></ul><h4 id="10-currentSrc属性"><a href="#10-currentSrc属性" class="headerlink" title="10. currentSrc属性"></a>10. currentSrc属性</h4><p>可以使用<code>video</code>元素或<code>audio</code>元素的<code>currentSrc</code>属性来读取播放中的媒体数据的url地址。<code>currentSrc</code>属性为只读属性。</p><h4 id="11-buffered属性"><a href="#11-buffered属性" class="headerlink" title="11. buffered属性"></a>11. buffered属性</h4><p>可以使用<code>video</code>元素或<code>audio</code>元素的<code>buffered</code>属性来返回一个对象，该对象实现<code>TimeRanges</code>接口，以确认浏览器是否已缓存媒体数据。<code>TimeRanges</code>对象表示一段时间范围，在大多数情况下，<code>TimeRanges</code>对象表示的时间范围时一个单一的以0开始的范围，但是如果浏览器发出<code>Range Requests</code>请求，这是<code>TimeRanges</code>对象表示的时间范围是多个时间范围。</p><p><code>TimeRanges</code>对象具有一个<code>length</code>属性，表示有多少个时间范围，大多数情况下存在时间范围时，该值为1；不存在时间范围时，该值为0。<code>TimeRanges</code>对象还具有两个方法，<code>TimeRanges.start(index)</code>与<code>TimeRanges.end(index)</code>，大多数情况下将<code>index</code>值设为0就可以了。</p><p>当用<code>videoElement.buffered</code>语句来实现<code>TimeRanges</code>接口时，<code>TimeRanges.start(0)</code>表示当前缓存区内从媒体数据的什么时间开始进行缓存，<code>TimeRanges.end(0)</code>表示当前缓存区内的结束时间。</p><h4 id="12-readyState属性"><a href="#12-readyState属性" class="headerlink" title="12. readyState属性"></a>12. readyState属性</h4><p>可以使用<code>video</code>元素或<code>audio</code>元素的<code>readyState</code>属性返回媒体当前播放位置的就绪状态，共有5个可能值。</p><ul><li><p><code>HAVE_NOTHING</code>（数字值为0）：没有获取到媒体的任何信息，当前播放位置没有可播放数据</p></li><li><p><code>HAVE_METADATA</code>（数字值为1）：已经获取到了足够的媒体数据，但是当前播放位置没有有效的媒体数据（也就是说，获取到的媒体数据无效，不能播放）</p></li><li><p><code>HAVE_CURRENT_DATA</code>（数字值为2）：当前播放位置已经有数据可以播放，但没有获取到可以让播放器前进的数据。当媒体为视频时，意思是当前帧的数据已获得，但还没有获取到下一帧的数据，或者当前帧已经是播放的最后一帧。</p></li><li><p><code>HAVE_FURURE_DATA</code>（数字值为3）：当前播放位置已经有数据可以播放，而且也获取到了可以让播放器前进的数据。当媒体为视频时，意思是当前帧的数据已获得，而且也获取到了下一帧的数据，当前帧时播放的最后一帧时，<code>readyState</code>属性不可能为<code>HAVE_FUTURE_DATA</code></p></li><li><p><code>HAVE_ENOUGH_DATA</code>（数字值为4）：当前播放位置已经有苏杭距可以播放，同时也获取到了可以让播放器前进的数据，而且浏览器确认媒体数据以某一种速度进行加载，可以保证有足够的后续数据进行播放。</p></li></ul><h4 id="13-seeking属性与seekable属性"><a href="#13-seeking属性与seekable属性" class="headerlink" title="13. seeking属性与seekable属性"></a>13. seeking属性与seekable属性</h4><p>可以使用<code>video</code>元素或<code>audio</code>元素的<code>seeking</code>属性返回一个布尔值，表示浏览器是否正在请求某一特定播放位置的元素，<code>true</code>表示浏览器正在请求数据，<code>false</code>表示浏览器已停止请求。</p><p>可以使用<code>video</code>元素或<code>audio</code>元素的<code>seekable</code>属性来返回一个<code>TimeRanges</code>对象，该对象表示请求到的数据的时间范围。当媒体为视频时，开始时间为请求到的视频数据第一帧的事件，结束时间为请求到的视频数据最后一帧的事件。</p><h4 id="14-currentTime属性、startTime属性和duration属性"><a href="#14-currentTime属性、startTime属性和duration属性" class="headerlink" title="14. currentTime属性、startTime属性和duration属性"></a>14. currentTime属性、startTime属性和duration属性</h4><p>可以使用<code>video</code>元素或<code>audio</code>元素的<code>currentTime</code>属性来读取媒体的当前播放位置，也可以通过修改<code>currentTime</code>属性来修改当前播放位置。如果修改的位置上没有可用的媒体数据时，将抛出<code>INVALID_STATE_ERR</code>异常；如果修改的位置超出了浏览器在一次请求中可以请求的数据范围，将抛出<code>INDEX_SIZE_ERR</code>异常。</p><p>可以使用<code>video</code>元素或<code>audio</code>元素的<code>startTime</code>属性来读取媒体播放的开始时间，通常为0</p><p>可以使用<code>video</code>元素或<code>audio</code>元素的<code>duration</code>属性来读取媒体文件总的播放时间。</p><p>三项属性均为时间，单位为秒。</p><h4 id="15-played属性、paused属性、ended属性"><a href="#15-played属性、paused属性、ended属性" class="headerlink" title="15. played属性、paused属性、ended属性"></a>15. played属性、paused属性、ended属性</h4><p>可以使用<code>video</code>元素或<code>audio</code>元素的<code>played</code>属性来返回一个<code>TimeRanges</code>对象，从该对象中可以读取媒体文件的已播放部分的时间段。开始时间为已播放部分的开始时间，结束时间为已播放部分的结束时间。</p><p>可以使用<code>video</code>元素或<code>audio</code>元素的<code>paused</code>属性来返回一个布尔值，表示是否处于暂停播放中，<code>true</code>表示媒体餐厅播放，<code>false</code>表示媒体正在播放。</p><p>可以使用<code>video</code>元素或<code>audio</code>元素的<code>ended</code>属性来返回一个布尔值，表示是否播放完毕，<code>true</code>表示媒体播放完毕，<code>false</code>表示还没有播放完毕。</p><h4 id="16-defaultPlaybackRate属性与playbackRate属性"><a href="#16-defaultPlaybackRate属性与playbackRate属性" class="headerlink" title="16. defaultPlaybackRate属性与playbackRate属性"></a>16. defaultPlaybackRate属性与playbackRate属性</h4><p>可以使用<code>video</code>元素或<code>audio</code>元素的<code>defaultPlaybackRate</code>属性读取或修改媒体默认的播放速率</p><p>可以使用<code>vidio</code>元素或<code>audio</code>元素的<code>playbackRate</code>属性读取或修改媒体当前的播放速率</p><h4 id="17-volumn属性与muted属性"><a href="#17-volumn属性与muted属性" class="headerlink" title="17. volumn属性与muted属性"></a>17. volumn属性与muted属性</h4><p>可以使用<code>video</code>元素或<code>audio</code>元素的<code>volumn</code>属性读取或修改媒体的播放音量，范围为0到1，0为静音，1为最大音量</p><p>可以使用<code>vidio</code>元素或<code>audio</code>元素的<code>muted</code>属性读取或修改媒体的静音状态，该值为布尔值，<code>true</code>表示处于静音状态，<code>false</code>表示处于非静音状态</p><hr><h3 id="二、方法"><a href="#二、方法" class="headerlink" title="二、方法"></a>二、方法</h3><h4 id="1-play方法"><a href="#1-play方法" class="headerlink" title="1. play方法"></a>1. play方法</h4><p>使用<code>play</code>方法来播放媒体，自动将元素的<code>paused</code>属性值变为<code>false</code></p><h4 id="2-pause方法"><a href="#2-pause方法" class="headerlink" title="2. pause方法"></a>2. pause方法</h4><p>使用<code>pause</code>方法来暂停播放，自动将元素的<code>paused</code>属性值变为<code>true</code></p><h4 id="3-load方法"><a href="#3-load方法" class="headerlink" title="3. load方法"></a>3. load方法</h4><p>使用<code>load</code>方法来重新载入媒体进行播放，自动将元素的<code>playbackRate</code>属性值变为<code>defaultPlaybackRate</code>属性的值，自动将元素的<code>error</code>值变为<code>null</code></p><h4 id="4-canPlayType方法"><a href="#4-canPlayType方法" class="headerlink" title="4. canPlayType方法"></a>4. canPlayType方法</h4><p>使用<code>canPlayType</code>方法来测试浏览器是否支持指定的媒体类型，该方法定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> support = videoElement.canPlayType(type);</span><br></pre></td></tr></table></figure><p>该方法返回3个可能值：</p><ul><li><p>空字符串：表示浏览器不支持此种媒体类型</p></li><li><p><code>maybe</code>：表示浏览器可能支持此种媒体类型</p></li><li><p><code>probably</code>：表示浏览器确定支持此种媒体类型</p></li></ul><hr><h3 id="三、事件"><a href="#三、事件" class="headerlink" title="三、事件"></a>三、事件</h3><p>浏览器在请求媒体数据、下载媒体数据、播放媒体数据中的事件</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>loadstart</td><td>浏览器开始在网上寻找媒体数据</td></tr><tr><td>progress</td><td>浏览器正在获取媒体数据</td></tr><tr><td>suspend</td><td>浏览器暂停获取媒体数据，但是下载过程并没有正常结束</td></tr><tr><td>abort</td><td>浏览器在下载完全部媒体数据之前中止获取媒体数据，但是并不是由错误引起的</td></tr><tr><td>error</td><td>获取媒体数据过程中出错</td></tr><tr><td>emptied</td><td>video元素或audio元素所在的网络突然变为未初始化状态（可能原因：1. 载入媒体过程中突然发生一个致命错误；2. 在浏览器正在选择支持的播放格式时，又调用了load方法重新载入媒体）</td></tr><tr><td>stalled</td><td>浏览器尝试获取媒体数据失败</td></tr><tr><td>play</td><td>即将开始播放，当执行了play方法时触发，或数据下载后元素被设为autoplay属性</td></tr><tr><td>pause</td><td>播放暂停，当执行了pause方法时触发</td></tr><tr><td>loadedmetadata</td><td>浏览器获取完毕媒体的时间长和字节数</td></tr><tr><td>loadeddata</td><td>浏览器已加载完毕当前播放位置的媒体数据，准备播放</td></tr><tr><td>waiting</td><td>播放过程由于得不到下一帧而暂停播放（例如下一帧尚未加载完毕），但很快就能够得到下一帧</td></tr><tr><td>playing</td><td>正在播放</td></tr><tr><td>canplay</td><td>浏览器能够播放媒体，但估计以当前播放速率不能直接将媒体播放完毕，播放期间需要缓冲</td></tr><tr><td>canplaythrough</td><td>浏览器能够播放媒体，而且以当前播放速率能够将媒体播放完毕，不再需要进行缓冲</td></tr><tr><td>seeking</td><td>seeking属性变为true，浏览器正在请求数据</td></tr><tr><td>seeked</td><td>seeking属性变为false，浏览器停止请求数据</td></tr><tr><td>timeupdate</td><td>当前播放位置被改变，可能是播放过程中的自然改变，也可能使被认为的改变，或由于播放不能连续而发生的跳变</td></tr><tr><td>ended</td><td>播放结束后停止播放</td></tr><tr><td>ratechange</td><td>defaultplaybackRate属性或playbackRate属性被改变</td></tr><tr><td>durationchange</td><td>播放时长被改变</td></tr><tr><td>volumnchange</td><td>volumn属性被改变或muted属性被改变</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;一、元素属性&quot;&gt;&lt;a href=&quot;#一、元素属性&quot; class=&quot;headerlink&quot; title=&quot;一、元素属性&quot;&gt;&lt;/a&gt;一、元素属性&lt;/h3&gt;&lt;p&gt;&lt;code&gt;audio&lt;/code&gt;元素与&lt;code&gt;video&lt;/co
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.xiaoleon.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端开发" scheme="http://www.xiaoleon.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML5" scheme="http://www.xiaoleon.cn/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>H5(6) 拖放API</title>
    <link href="http://www.xiaoleon.cn/2018/01/21/html5-6/"/>
    <id>http://www.xiaoleon.cn/2018/01/21/html5-6/</id>
    <published>2018-01-21T13:37:05.000Z</published>
    <updated>2018-01-21T14:27:36.872Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5中，提供了直接支持拖放操作的API。虽然HTML5之前已经可以使用<code>mousedown</code>、<code>mousemove</code>、<code>mouseup</code>来实现拖放操作，但是这只支持浏览器内部的拖放，而在HTML5中，已经支持在浏览器与其他应用程序之间的数据互相拖动，同时也大大简化了有关于拖放方面的代码。</p><a id="more"></a><p>实现拖放的步骤:</p><ul><li><h4 id="1-将想要拖放的对象元素的draggable属性设为true。这样才能将该元素进行拖放。另外，img元素与a元素（必须指定href）默认允许拖放。"><a href="#1-将想要拖放的对象元素的draggable属性设为true。这样才能将该元素进行拖放。另外，img元素与a元素（必须指定href）默认允许拖放。" class="headerlink" title="1. 将想要拖放的对象元素的draggable属性设为true。这样才能将该元素进行拖放。另外，img元素与a元素（必须指定href）默认允许拖放。"></a>1. 将想要拖放的对象元素的<code>draggable</code>属性设为<code>true</code>。这样才能将该元素进行拖放。另外，<code>img</code>元素与<code>a</code>元素（必须指定<code>href</code>）默认允许拖放。</h4></li><li><h4 id="2-编写与拖放有关的事件处理代码。"><a href="#2-编写与拖放有关的事件处理代码。" class="headerlink" title="2.编写与拖放有关的事件处理代码。"></a>2.编写与拖放有关的事件处理代码。</h4></li></ul><table><thead><tr><th>事件</th><th>产生事件的元素</th><th>描述</th></tr></thead><tbody><tr><td>dragstart</td><td>被拖放的元素</td><td>开始拖放操作</td></tr><tr><td>drag</td><td>被拖放的元素</td><td>拖放过程中</td></tr><tr><td>dragenter</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素开始进入本元素的范围内</td></tr><tr><td>dragover</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素正在本元素范围内移动</td></tr><tr><td>dragleave</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素离开本元素的范围</td></tr><tr><td>drop</td><td>拖放的目标元素</td><td>有其他元素被拖放到了本元素中</td></tr><tr><td>dragend</td><td>拖放的对象元素</td><td>拖放操作结束</td></tr></tbody></table><ul><li><h4 id="3-DataTransfer对象的属性和方法"><a href="#3-DataTransfer对象的属性和方法" class="headerlink" title="3.DataTransfer对象的属性和方法"></a>3.DataTransfer对象的属性和方法</h4></li></ul><p><code>DataTransfer</code>对象的属性和方法可以实现定制拖放图标，让它只支持特定拖放（譬如拷贝/移动/）等，甚至可以实现更复杂的拖放操作</p><ul><li><h4 id="4-设定拖放时的视觉效果"><a href="#4-设定拖放时的视觉效果" class="headerlink" title="4.设定拖放时的视觉效果"></a>4.设定拖放时的视觉效果</h4></li></ul><p><code>dropEffect</code>属性与<code>effectAllowed</code>属性结合起来可以设定拖放时的视觉效果。</p><p><code>effectAllowed</code>属性表示当一个元素被拖动时所允许的视觉效果，一般在<code>ondragstart</code>事件中设定，允许设定的值为<code>none</code>、<code>copy</code>、<code>copyLink</code>、<code>copyMove</code>、<code>link</code>、<code>linkMove</code>、<code>move</code>、<code>all</code>、<code>uninitialize</code>。</p><p>dropEffect属性表示实际拖放时的视觉效果，一般在<code>ondragover</code>事件中指定，允许设定的值为<code>none</code>、<code>copy</code>、<code>link</code>、<code>move</code>。<code>dropEffect</code>属性所表示的实际视觉效果必须在<code>effectAllowed</code>属性所表示的允许的视觉效果范围内。</p><blockquote><ul><li>1) 如果<code>effectAllowed</code>属性设定为<code>none</code>，则不允许拖放元素</li><li>2) 如果<code>dropEffect</code>属性设定为<code>none</code>，则不允许被拖放到目标元素中</li><li>3) 如果<code>effectAllowed</code>属性设定为<code>all</code>或不设定，则<code>dropEffect</code>属性允许被设定为任何值，并且按指定的视觉效果进行显示</li><li>4) 如果<code>effectAllowed</code>属性设定为具体效果（不为<code>none</code>、<code>all</code>），<code>dropEffect</code>属性也设定了具体视觉效果，则两个具体效果值必须完全相等，否则不允许将被拖放元素拖放到目标元素中。</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">source.addEventListener(<span class="string">'dragstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dt = ev.dataTransfer;</span><br><span class="line">    dt.effectAllowed = <span class="string">'copy'</span>;</span><br><span class="line">    dt.setData(<span class="string">'text/plain'</span>, <span class="string">'hello world'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">dest.addEventListener(<span class="string">'dragover'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dt = ev.dataTransfer;</span><br><span class="line">    dt.dropEffect = <span class="string">'copy'</span>;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li><h4 id="5-自定义拖放图标"><a href="#5-自定义拖放图标" class="headerlink" title="5.自定义拖放图标"></a>5.自定义拖放图标</h4></li></ul><p>HTML5中允许自定义拖放图标——指的是在用鼠标拖动元素的过程中，位于鼠标指针下部的小图标。</p><p><code>DataTransfer</code>对象有一个<code>setDragImage</code>方法，该方法由三个参数，第一个参数<code>image</code>设定为拖放图标的图标元素，第二个参数x为拖放图标离鼠标指针的x轴方向的位移量，第三个参数y为拖放图标离鼠标指针的y轴方向的位移量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dragIcon = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">dragIcon.src = <span class="string">'http://twivatar.org/twitter/mini'</span>;</span><br><span class="line">source.addEventListener(<span class="string">'dragstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    var dt = ev.dataTransfer;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    dt.setDragImage(dragIcon, <span class="number">-10</span>, <span class="number">-10</span></span>);</span></span><br><span class="line"><span class="function">    <span class="title">dt</span>.<span class="title">setData</span>(<span class="params"><span class="string">"text/plain"</span>, <span class="string">"aaa"</span></span>);</span></span><br><span class="line"><span class="function">&#125;), <span class="title">false</span>);</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML5中，提供了直接支持拖放操作的API。虽然HTML5之前已经可以使用&lt;code&gt;mousedown&lt;/code&gt;、&lt;code&gt;mousemove&lt;/code&gt;、&lt;code&gt;mouseup&lt;/code&gt;来实现拖放操作，但是这只支持浏览器内部的拖放，而在HTML5中，已经支持在浏览器与其他应用程序之间的数据互相拖动，同时也大大简化了有关于拖放方面的代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.xiaoleon.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端开发" scheme="http://www.xiaoleon.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML5" scheme="http://www.xiaoleon.cn/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>H5(5) 文件API</title>
    <link href="http://www.xiaoleon.cn/2018/01/21/html5-5/"/>
    <id>http://www.xiaoleon.cn/2018/01/21/html5-5/</id>
    <published>2018-01-21T13:19:14.000Z</published>
    <updated>2018-01-21T14:27:39.994Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5中提供了一个关于文件操作的文件API，通过使用这个API，对于从Web页面上访问本地文件系统的相关处理会变得十分简单。</p><a id="more"></a><h3 id="一、FileList与file对象"><a href="#一、FileList与file对象" class="headerlink" title="一、FileList与file对象"></a>一、FileList与file对象</h3><p><code>FileList</code>对象表示用户选择的文件列表。HTML5中，通过添加<code>multiple</code>属性，file控件内允许一次放置多个文件。控件内每一个用户选择的文件都是一个file对象，而<code>FileList</code>对象则为这些file对象的列表。</p><p>file对象由两个属性，<code>name</code>属性表示文件名，不包括路径，<code>lastModifiedDate</code>属性表示文件的最后修改日期。</p><hr><h3 id="二、Blob对象"><a href="#二、Blob对象" class="headerlink" title="二、Blob对象"></a>二、Blob对象</h3><p><code>Blob</code>表示二进制原始数据，它提供一个<code>slice</code>方法，可以通过该方法访问到字节内部的原始数据块。事实上，上面的file对象也继承了这个<code>Blob</code>对象。</p><p><code>Blob</code>对象由两个属性，<code>size</code>属性表示一个<code>Blob</code>对象的字节长度，<code>type</code>属性表示<code>Blob</code>的<code>MIME</code>类型，如果是未知类型，则返回一个空字符串。</p><p>对于图像类型的文件，<code>Blob</code>对象的<code>type</code>属性都是以<code>“image/”</code>开头的，后跟图像类型，利用<code>cite</code>型我们可以在Javascript中判断用户选择的文件是否为图像文件。</p><p>另外，HTML5中对file控件添加了<code>accept</code>属性，这样file控件只能接受某种类型的文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="三、FileReader接口"><a href="#三、FileReader接口" class="headerlink" title="三、FileReader接口"></a>三、FileReader接口</h3><p><code>FileReader</code>接口主要用来把文件读入内存，并且读取文件中的数据。<code>FileReader</code>接口提供了一个异步API，使用该API可以在浏览器主线程中访问文件系统，读取文件中的数据。</p><h4 id="1-FileReader接口的方法"><a href="#1-FileReader接口的方法" class="headerlink" title="1. FileReader接口的方法"></a>1. FileReader接口的方法</h4><p><code>FileReader</code>接口拥有4个方法。需要注意的是：无论读取成功或失败，方法并不会返回读取结果，这一结果存储在result属性中。</p><table><thead><tr><th>方法名</th><th>参数</th><th>描述  </th></tr></thead><tbody><tr><td>readAdBinaryString</td><td>file</td><td>将文件读取为二进制码</td></tr><tr><td>readAsText</td><td>file, [encoding]</td><td>将文件读取为文本</td></tr><tr><td>readAdDataURL</td><td>file</td><td>将文件读取为DataURL</td></tr><tr><td>abort</td><td>(none)</td><td>中断读取操作</td></tr></tbody></table><h4 id="2-FileReader接口的事件"><a href="#2-FileReader接口的事件" class="headerlink" title="2. FileReader接口的事件"></a>2. FileReader接口的事件</h4><p>FileReader接口包含了一套完整的事件模型，用于捕获读取文件时的状态。</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>onabort</td><td>数据读取中断时触发</td></tr><tr><td>onerror</td><td>数据读取出错时触发</td></tr><tr><td>onloadstart</td><td>数据读取开始时触发</td></tr><tr><td>onprogress</td><td>数据读取中</td></tr><tr><td>onload</td><td>数据读取成功完成时触发</td></tr><tr><td>onloadend</td><td>数据读取完成时触发，无论成功或失败</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>).files[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">reader.readAsText(file);</span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</span><br><span class="line">    result.innerHTML = <span class="keyword">this</span>.result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>FileReader对象读取到的数据都保存在了result属性中</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML5中提供了一个关于文件操作的文件API，通过使用这个API，对于从Web页面上访问本地文件系统的相关处理会变得十分简单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.xiaoleon.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端开发" scheme="http://www.xiaoleon.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML5" scheme="http://www.xiaoleon.cn/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>H5(4) 新增元素</title>
    <link href="http://www.xiaoleon.cn/2018/01/21/html5-4/"/>
    <id>http://www.xiaoleon.cn/2018/01/21/html5-4/</id>
    <published>2018-01-21T13:17:20.000Z</published>
    <updated>2018-01-21T14:27:42.784Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="1-figure"><a href="#1-figure" class="headerlink" title="1. figure"></a>1. figure</h4><p>figure元素所表示的内容通常是图片、统计图或代码示例，但并不仅限于此，它同样可以用来表示音频插件、视频插件或统计表格等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span> <span class="attr">alt</span>=<span class="string">''</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"2.jpg"</span> <span class="attr">alt</span>=<span class="string">''</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"3.jpg"</span> <span class="attr">alt</span>=<span class="string">''</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-details"><a href="#2-details" class="headerlink" title="2. details"></a>2. details</h4><p>details元素提供了一种替代Javascript的、将画面上局部区域进行展开或收缩的方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">summary</span>&gt;</span>This is title<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-mark"><a href="#3-mark" class="headerlink" title="3. mark"></a>3. mark</h4><p>mark元素表示页面中需要突出显示或高亮显示的，对于当前用户具有参考作用的一段文字。它通常是用于引用原文的时候，目的是引起读者的注意。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">mark</span>&gt;</span>HTML5<span class="tag">&lt;/<span class="name">mark</span>&gt;</span>是近十年来Web开发标准最巨大的飞跃<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-progress"><a href="#4-progress" class="headerlink" title="4. progress"></a>4. progress</h4><p>progress元素代表一个任务的完成进度，这个进度可以是不确定的，只是表示进度正在进行，但不清楚还有多少工作量没有完成，也可以用0到某个最大数字（例如100）之间的数字来表示准确的进度完成情况（例如进度百分比）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">progress</span> <span class="attr">id</span>=<span class="string">"p"</span> <span class="attr">max</span>=<span class="string">100</span> <span class="attr">value</span>=<span class="string">60</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-meter"><a href="#5-meter" class="headerlink" title="5. meter"></a>5. meter</h4><p>meter元素表示规定范围内的数量值。包含如下六个属性：</p><ol><li>value：在元素中特地表示出来的实际值</li><li>min：指定规定的范围时允许使用的最小值，默认为0</li><li>max：指定规定的范围时允许使用的最大值，默认为1</li><li>low：规定范围的下限值，必须小于或等于high属性的值</li><li>high：规定范围的上限值，必须大于或等于low属性的值</li><li>optimum：最佳值，属性值必须在min和max之间</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    磁盘使用量：</span><br><span class="line">    <span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">"40"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"160"</span>&gt;</span>40/160<span class="tag">&lt;/<span class="name">meter</span>&gt;</span>GB</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-menu与command"><a href="#6-menu与command" class="headerlink" title="6. menu与command"></a>6. menu与command</h4><p>menu和command这两个元素是HTML5中新增的用于Web应用程序的元素，它用于菜单、工具条及弹出菜单。其中menu元素相当于菜单，而command元素相当于菜单项。</p><h4 id="7-ol列表"><a href="#7-ol列表" class="headerlink" title="7. ol列表"></a>7. ol列表</h4><p>ol元素中添加了start属性和reversed属性</p><ol><li>start属性。如果不想ol元素所代表的列表编号从1开始，那么可以使用start属性来自定义编号的初始值</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表内容5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表内容6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表内容7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表内容8<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>reversed属性。如果相对列表进行反向排序，可以使用ol的reversed属性。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">reversed</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-cite"><a href="#8-cite" class="headerlink" title="8. cite"></a>8. cite</h4><p>cite元素表示作品（例如一本书、一篇文章、一首歌曲）的标题，HTML5中明确规定了不能用cite元素表示包括作者在内的任何人名，因为人的名字不是标题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我最喜欢的电影是由甄子丹主演的<span class="tag">&lt;<span class="name">cite</span>&gt;</span>精武风云<span class="tag">&lt;/<span class="name">cite</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="9-small"><a href="#9-small" class="headerlink" title="9. small"></a>9. small</h4><p>HTML5中，对small进行了重新定义，使其由原来的通用展示性元素变为更具体的、专门用来标识所谓“小子印刷体”的元素，通常用在诸如免责声明、注意事项、法律规定、与版权相关的法律性声明文字中，同时不允许被应用在页面主内容中，只允许被当作辅助信息用inline方式内嵌在页面上使用。同时，small元素也不意味着元素中内容字体会变小，如果需要将字体变小，需要配合着css样式表来使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;1-figure&quot;&gt;&lt;a href=&quot;#1-figure&quot; class=&quot;headerlink&quot; title=&quot;1. figure&quot;&gt;&lt;/a&gt;1. figure&lt;/h4&gt;&lt;p&gt;figure元素所表示的内容通常是图片、统计图或代码
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.xiaoleon.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端开发" scheme="http://www.xiaoleon.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML5" scheme="http://www.xiaoleon.cn/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>H5(3) 表单介绍</title>
    <link href="http://www.xiaoleon.cn/2018/01/21/html5-3/"/>
    <id>http://www.xiaoleon.cn/2018/01/21/html5-3/</id>
    <published>2018-01-21T13:12:39.000Z</published>
    <updated>2018-01-21T14:27:45.873Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="一、HTML5中关于表单新增了以下属性。"><a href="#一、HTML5中关于表单新增了以下属性。" class="headerlink" title="一、HTML5中关于表单新增了以下属性。"></a>一、HTML5中关于表单新增了以下属性。</h3><h4 id="1-form属性"><a href="#1-form属性" class="headerlink" title="1. form属性"></a>1. form属性</h4><p>在HTML4中，表单内的从属元素必须书写在表单内部，但是在HTML5中，可以把它们书写在页面上任何地方，然后给该元素指定一个form属性，属性值为该表单的id，这样就可以声明该元素从属于指定表单了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">form</span>=<span class="string">"testform"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-formaction属性"><a href="#2-formaction属性" class="headerlink" title="2. formaction属性"></a>2. formaction属性</h4><p>在HTML4中，一个表单内的所有元素都只能通过表单的action属性统一提交到另一个页面，而在HTML5中可以给所有的提交按钮，诸如<code>&lt;input type=&quot;submit&quot;&gt;</code>、<code>&lt;input type=&quot;image&quot;&gt;</code>、<code>&lt;button type=&quot;submit&quot;&gt;</code>都增加不同的formaction属性，可以将表单提交到不同的页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform"</span> <span class="attr">action</span>=<span class="string">"serve.php"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s1"</span> <span class="attr">value</span>=<span class="string">"v1"</span> <span class="attr">formaction</span>=<span class="string">"s1.php"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s2"</span> <span class="attr">value</span>=<span class="string">"v2"</span> <span class="attr">formaction</span>=<span class="string">"s2.php"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s3"</span> <span class="attr">value</span>=<span class="string">"v3"</span> <span class="attr">formaction</span>=<span class="string">"s3.php"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-formmethod属性"><a href="#3-formmethod属性" class="headerlink" title="3. formmethod属性"></a>3. formmethod属性</h4><p>在HTML4中，一个表单内只有一个action属性来对表单内的所有元素统一指定提交页面，所以每个表单内也只有一个method属性来统一指定提交方法。在HTML5中，可以使用formaction属性来对每个表单元素分别指定不同的提交页面，同时也可以使用formmethod属性来对每个表单元素分别指定不同的提交方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform"</span> <span class="attr">action</span>=<span class="string">"serve.php"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s1"</span> <span class="attr">value</span>=<span class="string">"v1"</span> <span class="attr">formaction</span>=<span class="string">"s1.php"</span> <span class="attr">formmethod</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s2"</span> <span class="attr">value</span>=<span class="string">"v2"</span> <span class="attr">formaction</span>=<span class="string">"s2.php"</span> <span class="attr">formmethod</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s3"</span> <span class="attr">value</span>=<span class="string">"v3"</span> <span class="attr">formaction</span>=<span class="string">"s3.php"</span> <span class="attr">formmethod</span>=<span class="string">"delete"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-placeholder属性"><a href="#4-placeholder属性" class="headerlink" title="4. placeholder属性"></a>4. placeholder属性</h4><p>placeholder是指当文本框处于未输入状态时文本框中显示的输入提示。</p><h4 id="5-autofocus属性"><a href="#5-autofocus属性" class="headerlink" title="5. autofocus属性"></a>5. autofocus属性</h4><p>给文本框、选择框或按钮控件加上该属性，当画面打开时，该控件自动获取光标焦点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">autofocus</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-list属性"><a href="#6-list属性" class="headerlink" title="6. list属性"></a>6. list属性</h4><p>在HTML5中，为单行文本框（<code>&lt;input type=&quot;text&quot;&gt;</code>）增加了一个list属性，该属性的值为某个datalist元素的id。datalist元素也是HTML5中新增元素，该元素类似于选择框，但是当用户想要设定的值不在选择列表之内时，允许其自行输入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"greeting"</span> <span class="attr">list</span>=<span class="string">"greetings"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"display:none"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Good Morning"</span>&gt;</span>Good Morning<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Hello"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Good Afternoon"</span>&gt;</span>Good Afternoon<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="二、input新增种类"><a href="#二、input新增种类" class="headerlink" title="二、input新增种类"></a>二、input新增种类</h3><h4 id="1-search"><a href="#1-search" class="headerlink" title="1. search"></a>1. search</h4><p>与text文本框类似，但是它用于搜索</p><h4 id="2-tel"><a href="#2-tel" class="headerlink" title="2. tel"></a>2. tel</h4><p>与text文本框类似，但是专用于电话</p><h4 id="3-url"><a href="#3-url" class="headerlink" title="3. url"></a>3. url</h4><p>与text文本框类似，但是要求用户必须在其中正确输入url格式的文字</p><h4 id="4-email"><a href="#4-email" class="headerlink" title="4. email"></a>4. email</h4><p>与text文本框类似，但是要求用户必须在其中正确输入email格式的文字</p><h4 id="5-datetime、date、month、week、time、datetime-local"><a href="#5-datetime、date、month、week、time、datetime-local" class="headerlink" title="5. datetime、date、month、week、time、datetime-local"></a>5. datetime、date、month、week、time、datetime-local</h4><p>各种日期与时间输入文本框</p><h4 id="6-number"><a href="#6-number" class="headerlink" title="6. number"></a>6. number</h4><p>数值输入文本框。外观与text文本框相同，但不能输入数值以外的文字</p><h4 id="7-range"><a href="#7-range" class="headerlink" title="7. range"></a>7. range</h4><p>只允许输入一段范围内数值的文本框。</p><h4 id="8-color"><a href="#8-color" class="headerlink" title="8. color"></a>8. color</h4><p>颜色选择文本框，选择的值为“#000000”格式的文字。</p><hr><h3 id="三、表单验证"><a href="#三、表单验证" class="headerlink" title="三、表单验证"></a>三、表单验证</h3><h4 id="1-required属性"><a href="#1-required属性" class="headerlink" title="1. required属性"></a>1. required属性</h4><p>HTML5中新增的required属性可以应用在大多数输入元素上，在提交时，如果元素中内容为空白，则不允许提交。</p><h4 id="2-pattern属性"><a href="#2-pattern属性" class="headerlink" title="2. pattern属性"></a>2. pattern属性</h4><p>对input元素使用pattern属性，并且将属性值设为某个格式的正则表达式，在提交时会检查其内容是否符合给定格式。</p><h4 id="3-min和max属性"><a href="#3-min和max属性" class="headerlink" title="3. min和max属性"></a>3. min和max属性</h4><p>min、max属性是数值类型或日期类型的input元素的专用属性，它们限制了在input元素中输入的数值与日期的范围。</p><h4 id="4-step属性"><a href="#4-step属性" class="headerlink" title="4. step属性"></a>4. step属性</h4><p>step属性控制input元素中的值增加或减少时的步幅。</p><hr><h3 id="四、显式验证"><a href="#四、显式验证" class="headerlink" title="四、显式验证"></a>四、显式验证</h3><p>除了input元素添加属性进行元素内容有效性的自动验证外，在HTML5中，form元素与input元素都具有一个<code>checkValidity</code>方法。调用该方法，可以显式地对表单内所有元素内容或单个内容进行有效性验证。</p><p>form元素与input元素还存在一个validity属性，该属性反悔了一个ValidityState对象。该对象具有很多属性，但最简单、最重要的属性为valid属性，表示了表单内所有元素内容是否有效或者单个input元素内容是否有效。</p><hr><h3 id="五、取消验证"><a href="#五、取消验证" class="headerlink" title="五、取消验证"></a>五、取消验证</h3><p>有两种方法取消表单验证：</p><ol><li>利用form元素的novalidate属性，它可以关闭整个表单验证。当整个表单的第二部分需要验证的内容比较多，但又想先提交表单的第一部分内容时，可以使用这种方法。先把该属性设为true，关闭表单验证，提交第一部分内容，然后在提交第二部分时再把它设为false，打开表单验证，提交第二部分内容。</li><li>利用input元素或submit元素的formnovalidate属性，利用input元素的formnovalidate属性可以让表单验证对单个input元素失效。当表单的第二部分中需要验证的元素数量很少时，可以只利用这些元素的formnovalidate属性，让表单验证对这些元素失效。</li><li>如果对submit按钮使用了formnovalidate属性，点击该按钮时，相当于利用了form元素的novalidate属性，整个表单验证都失效了。</li></ol><hr><h3 id="六、自定义错误信息"><a href="#六、自定义错误信息" class="headerlink" title="六、自定义错误信息"></a>六、自定义错误信息</h3><p>HTML5中，可以使用Javascript调用input元素的<code>setCustomValidity</code>方法来自定义错误信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;一、HTML5中关于表单新增了以下属性。&quot;&gt;&lt;a href=&quot;#一、HTML5中关于表单新增了以下属性。&quot; class=&quot;headerlink&quot; title=&quot;一、HTML5中关于表单新增了以下属性。&quot;&gt;&lt;/a&gt;一、HTML5中
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.xiaoleon.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端开发" scheme="http://www.xiaoleon.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML5" scheme="http://www.xiaoleon.cn/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>H5(2) 布局介绍</title>
    <link href="http://www.xiaoleon.cn/2018/01/21/html5-2/"/>
    <id>http://www.xiaoleon.cn/2018/01/21/html5-2/</id>
    <published>2018-01-21T13:03:34.000Z</published>
    <updated>2018-01-21T14:27:48.872Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="一、HTML5新增的主体结构元素包括："><a href="#一、HTML5新增的主体结构元素包括：" class="headerlink" title="一、HTML5新增的主体结构元素包括："></a>一、HTML5新增的主体结构元素包括：</h3><p><code>article</code>元素、<code>section</code>元素、<code>nav</code>元素、<code>aside</code>元素</p><hr><h3 id="二、HTML5新增的非主体结构元素包括："><a href="#二、HTML5新增的非主体结构元素包括：" class="headerlink" title="二、HTML5新增的非主体结构元素包括："></a>二、HTML5新增的非主体结构元素包括：</h3><p><code>header</code>元素、<code>hgroup</code>元素、<code>footer</code>元素、<code>address</code>元素</p><hr><h3 id="三、HTML5显式编排、隐式编排"><a href="#三、HTML5显式编排、隐式编排" class="headerlink" title="三、HTML5显式编排、隐式编排"></a>三、HTML5显式编排、隐式编排</h3><p>显式编排：显式编排是指明确使用<code>section</code>等元素创建文档结构，在每个内容区块内使用标题（<code>h1-h6</code>，<code>hgroup</code>等）。</p><p>隐式编排：隐式编排是指不明确使用<code>section</code>等元素，而是根据页面中所书写的各级标题（<code>h1-h6</code>，<code>hgroup</code>等）把内容区块自动创建出来。因为HTML5分析器只要看到书写了某个级别的标题，就会判断存在相对应的内容区块。</p><p>将这两种编排方式进行对比，很明显，显式编排更加清晰、易读。因为隐式编排容易让自动生成的整个文档结构与想要的文档结构不一样，而且也容易引起文档结构的混乱，所以请尽量使用显式编排。</p><hr><h3 id="四、time元素与微格式"><a href="#四、time元素与微格式" class="headerlink" title="四、time元素与微格式"></a>四、time元素与微格式</h3><h4 id="1-微格式"><a href="#1-微格式" class="headerlink" title="1. 微格式"></a>1. 微格式</h4><p>微格式是一中利用HTML的class属性对网页添加附加信息的方法，附加信息例如新闻事件发生的日期和时间、个人电话号码、企业邮箱等。</p><p>微格式并不是在HTML5之后才有的，在HTML5之前它就和HTML结合使用了，但是在使用过程中发现在日期和时间的机器编码上出现了一些问题，编码过程中会产生一些歧义。HTML5增加了一种新的元素来无歧义的、明确的对机器的日期和时间进行编码，并且以让人易读的方式来展现它。这个元素就是</p><h4 id="2-time元素。"><a href="#2-time元素。" class="headerlink" title="2. time元素。"></a>2. time元素。</h4><p><code>time</code>元素代表24小时中的某个时刻或某个日期，表示时刻时允许带时差。它可以定义很多格式的日期和时间，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">"2010-11-13"</span>&gt;</span>2010年11月13日<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">"2010-11-13"</span>&gt;</span>11月13日<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">"2010-11-13"</span>&gt;</span>我的生日<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">"2010-11-13T20:00"</span>&gt;</span>我生日的晚上8点<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">"2010-11-13T20:00Z"</span>&gt;</span>我生日的晚上8点<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">"2010-11-13T20:00+09:00"</span>&gt;</span>我生日的晚上8点的美国时间<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编码时机器读到的部分在<code>datetime</code>属性里，而元素的开始标记与结束标记中间的部分是显示在网页上的。<code>datetime</code>属性中日期与时间之间要用<code>“T”</code>文字分隔，<code>“T”</code>表示时间。请注意倒数第二行，时间加上Z文字表示给机器编码时使用UTC标准时间，倒数第一行则加上了时差，表示向机器编码另一地区时间，如果时编码本地时间，则不需要添加时差。</p><blockquote><p><code>pubdate</code>属性是一个可选的、<code>boolean</code>的属性，它可以用到<code>article</code>元素中的<code>time</code>元素上，意思是<code>time</code>元素代表了文章或整个网页的发布日期。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;一、HTML5新增的主体结构元素包括：&quot;&gt;&lt;a href=&quot;#一、HTML5新增的主体结构元素包括：&quot; class=&quot;headerlink&quot; title=&quot;一、HTML5新增的主体结构元素包括：&quot;&gt;&lt;/a&gt;一、HTML5新增的主
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.xiaoleon.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端开发" scheme="http://www.xiaoleon.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML5" scheme="http://www.xiaoleon.cn/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>H5(1) 概述</title>
    <link href="http://www.xiaoleon.cn/2018/01/21/html5-1/"/>
    <id>http://www.xiaoleon.cn/2018/01/21/html5-1/</id>
    <published>2018-01-21T12:51:34.000Z</published>
    <updated>2018-01-21T14:27:51.995Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="一、HTML5可以放心使用的三个理由："><a href="#一、HTML5可以放心使用的三个理由：" class="headerlink" title="一、HTML5可以放心使用的三个理由："></a>一、HTML5可以放心使用的三个理由：</h3><ol><li>兼容性：HTML5在老版本的浏览器上也可以正常运行。</li><li>实用性：HTML5内部并没有封装什么很复杂的、不切实际的功能，而只是封装了简单实用的功能。</li><li>非革命性的发展：HTML5的内部功能不是革命性的，只是发展性的。</li></ol><p>以上三点就是所谓的“HTML设计原则”，HTML5也是以该设计原则为基本原则而开发出来的。</p><hr><h3 id="二、HTML5要解决的三个问题："><a href="#二、HTML5要解决的三个问题：" class="headerlink" title="二、HTML5要解决的三个问题："></a>二、HTML5要解决的三个问题：</h3><ol><li>Web浏览器之间的兼容性很低。</li><li>文档结构不够明确。</li><li>Web应用程序的功能受到了限制。</li></ol><hr><h3 id="三、HTML元素规范"><a href="#三、HTML元素规范" class="headerlink" title="三、HTML元素规范"></a>三、HTML元素规范</h3><h4 id="1-省略元素标记"><a href="#1-省略元素标记" class="headerlink" title="1. 省略元素标记"></a>1. 省略元素标记</h4><p>HTML5中，元素的标记可以省略，具体来说，元素的标记分为“不允许写结束标记”、“可以省略结束标记”、“开始标记和结束标记全部可以省略”三种类型。</p><ol><li>不允许写结束标记的元素有：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr。</li><li>可以省略结束标记的元素有：li、dt、dd、p、rt、rp、optgroup、option、colgroup、thead、tbody、tfoot、tr、td、th。</li><li>可以省略全部标记的元素有：html、head、body、colgroup、tbody。</li></ol><blockquote><p><strong>说明</strong>：<br>“不允许写结束标记的元素”是指，不允许使用开发标记与结束标记将元素括起来的形式，只允许使用<code>“&lt;元素/&gt;”</code>的形式进行书写。例如<code>“&lt;br&gt;...&lt;/br&gt;”</code>的书写方式是错误的，正确的书写方式为<code>“&lt;br/&gt;”</code>。当然，HTML5之前的版本中<code>&lt;br&gt;</code>这种写法可以被沿用。<br>“可以省略全部标记的元素”是指，该元素可以完全被省略。请注意，即使标记被省略了，该元素还是以隐式的方式存在的。例如将body元素省略不写时，但它在文档结构中还是存在的，可以使用document.body进行访问。</p></blockquote><h4 id="2-省略boolean元素属性"><a href="#2-省略boolean元素属性" class="headerlink" title="2. 省略boolean元素属性"></a>2. 省略boolean元素属性</h4><p>对于具有boolean值的属性，例如disabled与readonly等，当只写属性而不指定属性值时，表示属性值为true；如果想要将该属性值设为false，可以不使用该属性。另外，要想将属性值设置为true时，也可以将属性名设定为属性值，或将空字符串设定为属性值。</p><p>参考代码示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 只写属性不屑属性值代表属性为true</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">// 不写属性代表属性为false</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">// 属性值=属性名，代表属性为true</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>&gt;</span></span><br><span class="line">// 属性值=空字符串，代表属性为true</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-省略引号"><a href="#3-省略引号" class="headerlink" title="3. 省略引号"></a>3. 省略引号</h4><p>HTML5元素标记中，当属性值不包括空字符串、“&lt;”、“&gt;”、“=”、单引号、双引号等字符时，属性值两边的引号可以省略。</p><p>参考代码示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-新增的input元素的类型"><a href="#4-新增的input元素的类型" class="headerlink" title="4. 新增的input元素的类型"></a>4. 新增的input元素的类型</h4><p>HTML5中新增了很多input元素的类型，举例如下：</p><ol><li>email. 表示必须输入Email地址的文本输入框</li><li>url. 表示必须输入url地址的文本输入框</li><li>number. 表示必须输入数值的文本输入框</li><li>range. 表示必须输入一定范围内数字值的文本输入框</li><li>Date Picker. HTML5拥有多个可供选取日期和时间的新型输入文本框<ul><li>date. 选取日、月、年</li><li>month. 选取月、年</li><li>week. 选取周和年</li><li>time. 选取时间（小时和分钟）</li><li>datetime. 选取时间、日、月、年（UTC时间）</li><li>datetime-local. 选取时间、日、月、年（本地时间）</li></ul></li></ol><h4 id="5-全局属性"><a href="#5-全局属性" class="headerlink" title="5. 全局属性"></a>5. 全局属性</h4><ol><li><p>contentEditable属性。</p><p> 该属性的主要功能是允许用户编辑元素中的内容，所以该元素必须是可以获得鼠标焦点的元素，而且在点击鼠标后要向用户提供一个插入符号，提示用户该元素中的内容允许编辑。contentEditable属性是一个布尔值属性，可以被指定为true或false。</p><p> 元素还具有一个isContentEditable属性，当元素可编辑时，该属性为true；当元素不可编辑时，该属性为false。</p></li><li><p>designMode属性。</p><p> designMode属性用来指定整个页面是否可编辑，当页面可编辑时，页面中任何支持上文所述的contentEditable属性的元素都变成了可编辑状态。designMode属性只能在Javascript脚本里被编辑修改，包含两个属性值——“on”、“off”</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;一、HTML5可以放心使用的三个理由：&quot;&gt;&lt;a href=&quot;#一、HTML5可以放心使用的三个理由：&quot; class=&quot;headerlink&quot; title=&quot;一、HTML5可以放心使用的三个理由：&quot;&gt;&lt;/a&gt;一、HTML5可以放心
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.xiaoleon.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端开发" scheme="http://www.xiaoleon.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML5" scheme="http://www.xiaoleon.cn/tags/HTML5/"/>
    
  </entry>
  
</feed>
