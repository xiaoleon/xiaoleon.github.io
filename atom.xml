<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张啸</title>
  
  <subtitle>世界上最快乐的事，莫过于为理想而奋斗。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaoleon.cn/"/>
  <updated>2018-01-29T14:46:34.092Z</updated>
  <id>http://www.xiaoleon.cn/</id>
  
  <author>
    <name>Leon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS(7) 客户端JavaScript</title>
    <link href="http://www.xiaoleon.cn/2018/01/29/js-7/"/>
    <id>http://www.xiaoleon.cn/2018/01/29/js-7/</id>
    <published>2018-01-29T14:32:39.000Z</published>
    <updated>2018-01-29T14:46:34.092Z</updated>
    
    <content type="html"><![CDATA[<p><code>window</code>对象是所有客户端JavaScript特性和API的主要接入点。它表示Web浏览器的一个窗口或窗体，并且可以用标识符<code>window</code>来引用它。<code>Window</code>对象定义了一些属性，比如，指代<code>Location</code>对象的<code>location</code>属性，<code>Location</code>对象指定当前显示在窗口中的url，并允许脚本往窗口里载入新的url。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location = <span class="string">'http://www.oreilly.com/'</span>;</span><br></pre></td></tr></table></figure><p><code>Window</code>对象还定义了一些方法，比如<code>alert()</code>，可以弹出一个对话框用来显示一些信息。还有<code>setTimeout()</code>，可以注册一个函数，在给定的一段时间之后触发一个回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>注意上面的代码并没有显式地使用<code>window</code>属性。在客户端JavaScript中，<code>Window</code>对象也是全局对象。这意味着<code>Window</code>对象处于作用域链的顶部，它的属性和方法实际上是全局变量和全局函数。<code>Window</code>对象有一个引用自身的属性，叫做<code>window</code>。如果需要引用窗口对象本身，可以用这个属性，但是如果只是想要引用全局窗口对象的属性，通常并不需要用到<code>window</code>。</p><p><code>Window</code>对象的其中一个最重要的属性是<code>document</code>，它引用<code>Document</code>对象，后者表示显示在窗口中的文档。<code>Document</code>对象有一些重要方法，比如<code>getElementById()</code>，可以基于元素<code>id</code>属性的值返回单一的文档元素（表示HTML标签的一对开始/结束标记，以及它们之间的所有内容）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timestamp = <span class="built_in">document</span>.getElementById(<span class="string">'timestamp'</span>);</span><br></pre></td></tr></table></figure><p><code>getElementById()</code>返回的<code>Element</code>对象有其他重要的方法和属性，比如允许脚本获取它的内容，设置属性值等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timestamp.firstChild == <span class="literal">null</span>)</span><br><span class="line">    timestamp.appendChild(<span class="built_in">document</span>.createTextNode(<span class="keyword">new</span> <span class="built_in">Date</span>().toString()));</span><br></pre></td></tr></table></figure><p><code>Window</code>、<code>Documnet</code>和<code>Element</code>对象上另一个重要的属性集合是事件处理程序相关的属性。可以在脚本中为之绑定一个函数，这个函数会在某个事件发生时以异步的方式调用。事件处理程序可以让JavaScript代码修改窗口、文档和元素的行为。事件处理程序的属性名是以单词“<code>on</code>”开始的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timestamp.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.innerHTML = <span class="keyword">new</span> <span class="built_in">Date</span>().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Window</code>对象的<code>onload</code>处理程序是最重要的事件处理程序之一。当显示在窗口中的文档内容稳定并可以操作时会触发它。JavaScript代码通常封装在<code>onload</code>事件处理程序里。</p><hr><h3 id="一、在HTML里嵌套JavaScript"><a href="#一、在HTML里嵌套JavaScript" class="headerlink" title="一、在HTML里嵌套JavaScript"></a>一、在HTML里嵌套JavaScript</h3><p>在HTML文档里嵌入客户端JavaScript代码有4种方法</p><ul><li><p>内联，放置在<code>&lt;script&gt;&lt;/script&gt;</code>标签对之间</p></li><li><p>放置在由<code>&lt;script&gt;</code>标签的<code>src</code>属性指定的外部文件中</p></li><li><p>放置在HTML事件处理程序中，该事件处理程序由<code>onclick</code>或<code>onmouseover</code>这样的HTML属性值指定</p></li><li><p>放在一个URL里，这个URL使用特殊的“<code>javascript:</code>”协议</p></li></ul><p>值得注意的是，HTML事件处理程序属性和<code>javascript:URL</code>这两种方式在现代JavaScript代码里已经很少使用。内联脚本（没有<code>src</code>）也比它们之前用的少了。有个编程哲学叫“<code>unobtrusive JavaScript</code>”，主张内容（HTML）和行为（JavaScript代码）应该尽量地保持分离。根据这个编程哲学，JavaScript最好通过<code>&lt;script&gt;</code>元素的<code>src</code>属性来嵌入HTML文档里。</p><h4 id="1-script元素"><a href="#1-script元素" class="headerlink" title="1. script元素"></a>1. script元素</h4><p>JavaScript代码可以以内联的形式出现在HTML文件里的<code>&lt;script&gt;&lt;/script&gt;</code>标签之间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// javascript代码</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>在XHTML中，<code>&lt;script&gt;</code>标签中的内容被当作其他内容一样对待。如果JavaScript代码包含了“<code>&lt;</code>”或“<code>&amp;</code>”字符，那么这些字符就被解释成XML标记。因此，如果要使用XHTML，最好把所有的JavaScript代码放入到一个CDATA部分里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;![CDATA[</span><br><span class="line"><span class="comment">// javascript代码</span></span><br><span class="line">]]&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>src</code>属性时，<code>&lt;script&gt;&lt;/script&gt;</code>标签之间的任何内容都会忽略。如果需要，可以在<code>&lt;script&gt;</code>标签之间添加代码的补充说明文档或版权信息。但是要注意，如果由任何非空格或JavaScript注释的文本出现在<code>&lt;script src=&quot;&quot;&gt;</code>和<code>&lt;/script&gt;</code>之间，HTML5校验器将会报错。</p><p>以下是src属性的一些优点：</p><ul><li><p>1) 可以把大块的JavaScript代码从HTML文件中删除，这有助于保持内容和行为的分离，从而简化HTML文件</p></li><li><p>2) 如果多个Web页面共用相同的JavaScript代码，用src属性可以让我们只管理一份代码，而不用在代码改变时编辑每个HTML文件</p></li><li><p>3) 如果一个JavaScript代码文件由多个页面共享，就只需要下载它一次，通过使用它的第一个页面——随后的页面可以从浏览器缓存检索它</p></li><li><p>4) 由于src属性的值可以是任意的URL，因此来自一个Web服务器的JavaScript程序或Web页面可以使用由另一个Web服务器输出的代码。很多互联网广告依赖于此</p></li><li><p>5) 从其他网站载入脚本的能力，可以让我们更好地利用缓存。</p></li></ul><p><strong>书签</strong></p><p>在Web浏览器中，“书签”就是一个保存起来的URL。如果书签是<code>javascript:URL</code>，那么保存的就是一小段脚本，叫做<code>bookmarklet</code>。<code>bookmarklet</code>是一个小型程序，很容易就可以从浏览器的菜单或工具栏里启动。<code>bookmarklet</code>里的代码执行起来就像页面上的脚本一样，可以查询和设置文档的内容、呈现和行为。只要书签不返回值，它就可以当作当前显示的任何文档，而不把文档替换成新的内容。</p><p>考虑下面<code>&lt;a&gt;</code>标签里的<code>javascript:URL</code>。单机连接会打开一个简单的JavaScript表达式计算器，它允许在页面环境中计算表达式和执行语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">'javascript:</span></span><br><span class="line"><span class="string">    var e = "", r = "";</span></span><br><span class="line"><span class="string">    do &#123;</span></span><br><span class="line"><span class="string">        e = prompt("Expression: " + e + "\n" + r + \n", e);</span></span><br><span class="line"><span class="string">        try &#123; r = "Result: " + eval(e); &#125;</span></span><br><span class="line"><span class="string">        catch(ex) &#123; r = ex; &#125;</span></span><br><span class="line"><span class="string">    &#125; while(e);</span></span><br><span class="line"><span class="string">    void 0;</span></span><br><span class="line"><span class="string">'</span>&gt;</span><br><span class="line">JavaScript Evaluator</span><br><span class="line">&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><p>注意，即便这个JavaScript URL写成多行，HTML解析器仍将它作为单独的一行对待，并且其中的单行<code>//</code>注释也是无效的。还有，要记住代码是单引号中的HTML属性的一部分，所以代码不可以包含任何单引号。</p><p>在开发时，把这样的链接硬编码在页面中是有用的，而把它另存为可以在任何页面上运行的书签，就更有用了。通常，在浏览器里把超链接的地址加入书签可以这样做，在链接上右击并选择类似“<code>Bookmark Link</code>”的选项，或者拖动链接到书签工具栏。</p><p><code>bookmarklet</code>里的javascript存在于文档之外，可以想象成是一种用户扩展或者对于其他程序的修改。</p><hr><h3 id="二、JavaScript程序的执行"><a href="#二、JavaScript程序的执行" class="headerlink" title="二、JavaScript程序的执行"></a>二、JavaScript程序的执行</h3><p>JavaScript程序的执行有两个阶段。在第一阶段，载入文档内容，并执行<code>&lt;script&gt;</code>元素里的代码（包括内联脚本和外部脚本）。脚本通常会按照它们在文档里出现的顺序执行。所有脚本里的JavaScript代码都是从上往下，按照它在条件、循环以及其他控制语句中的出现顺序执行。</p><p>当文档再入完成，并且所有脚本执行完成后，JavaScript执行就进入它的第二阶段，这个阶段是异步的，而且由事件驱动的。在事件驱动阶段，Web浏览器调用事件处理程序函数（由第一阶段里执行的脚本指定的HTML事件处理程序，或之前调用的事件处理程序来定义），来响应异步发生的事件。调用事件处理程序通常是响应用户输入。但是，还可以由网络活动、运行时间或JavaScript代码中的错误来触发。</p><p>事件驱动阶段里发生的第一个事件是load事件，指示文档已经完全载入，并可以操作。JavaScript程序里经常用这个事件来触发或发送消息。我们会经常看到一些定义函数的脚本程序，除了定义一个onload事件处理程序函数外不做其他操作，这个函数会在脚本事件驱动阶段开始时被load事件触发。正式这个onload事件会对文档进行操作，并做程序想做的任何事。在文档载入完成之后，只要Web浏览器显示文档，事件驱动阶段就会一直持续下去。</p><p>核心JavaScript和客户端JavaScript都有一个单线程执行模型。脚本和事件处理程序在同一时间只能执行一个，没有并发性。</p><h4 id="1-同步、异步和延迟的脚本"><a href="#1-同步、异步和延迟的脚本" class="headerlink" title="1. 同步、异步和延迟的脚本"></a>1. 同步、异步和延迟的脚本</h4><p>JavaScript第一次添加到Web浏览器时，还没有API可以用来遍历和操作文档的结构和内容。当文档还在载入时，JavaScript影响文档内容的唯一方法是快速生成内容。它使用<code>document.write()</code>方法完成上述任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;Table <span class="keyword">of</span> Factorials&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">function factorial(n) &#123;</span></span><br><span class="line"><span class="regexp">    if (n &lt;= 1) return n;</span></span><br><span class="line"><span class="regexp">    else return n * factorial(n - 1);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">document.write('&lt;table&gt;');</span></span><br><span class="line"><span class="regexp">document.write('&lt;tr&gt;&lt;th&gt;n&lt;/</span>th&gt;&lt;th&gt;n!&lt;/th&gt;&lt;/tr&gt;<span class="string">');</span></span><br><span class="line"><span class="string">for (var i = 1; i &lt;= 10; i++) &#123;</span></span><br><span class="line"><span class="string">    document.write('</span>&lt;tr&gt;&lt;td&gt;' + i + '&lt;/td&gt;&lt;td&gt;' + factorial(i) + '&lt;/td&gt;&lt;/tr&gt;<span class="string">');</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">document.write('</span>&lt;<span class="regexp">/table&gt;');</span></span><br><span class="line"><span class="regexp">document.write('Generate at ' + new Date());</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>当HTML解析器遇到<code>&lt;script&gt;</code>元素时，它默认必须先执行脚本，然后再恢复文档的解析和渲染。这对于内联脚本没什么问题，但如果脚本源代码是由一个<code>src</code>属性指定的外部文件，这意味着脚本后面的文档部分在下载和执行脚本之前，都不会出现在浏览器中。</p><p>脚本的执行只在默认情况下是同步和阻塞的。<code>&lt;script&gt;</code>标签可以有<code>defer</code>和<code>async</code>属性，这可以改变脚本的执行方式。这些都是布尔属性、没有值；只需要出现在<code>&lt;script&gt;</code>标签里即可。HTML5说这些属性只在和<code>src</code>属性联合使用时才有效，有些浏览器还支持延迟的内联脚本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"deferred.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"async.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>defer</code>和<code>async</code>属性都像在告诉浏览器链接进来的脚本不会使用<code>document.write()</code>，也不会生成文档内容，因此浏览器可以在下载脚本时继续解析和渲染文档。<code>defer</code>属性使得浏览器延迟脚本的执行，直到文档的载入和解析完成，并可以操作。<code>async</code>属性使得浏览器可以尽快地执行脚本，而不用在下载脚本时阻塞文档解析。如果<code>&lt;script&gt;</code>标签同时有两个属性，同时支持两者的浏览器会遵守<code>async</code>属性并忽略<code>defer</code>属性。</p><p>注意，延迟的脚本会按照它们在文档里的出现顺序执行，而异步脚本在它们载入后执行，这意味着它们可能会无序执行。</p><p>甚至可以在不支持<code>async</code>属性的浏览器里，通过动态创建<code>&lt;script&gt;</code>元素并把它插入到文档中，来实现脚本的异步载入和执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadasync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    s.src = url;</span><br><span class="line">    head.appendChild(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-事件驱动的JavaScript"><a href="#2-事件驱动的JavaScript" class="headerlink" title="2. 事件驱动的JavaScript"></a>2. 事件驱动的JavaScript</h4><p>对于大部分浏览器中的大部分事件来说，会把一个对象传递给事件处理程序作为参数，那个对象的属性提供了事件的详细信息。比如，传递给单击事件的对象，会有一个属性说明鼠标的哪个按钮被单击。（在IE里，这些事件信息被存储在全局event对象里，而不是传递给处理程序函数。）事件处理程序的返回值有时用来指示函数是否充分处理了事件，以及阻止浏览器执行它默认会进行的各种操作。</p><p>有些事件的目标是文档元素，它们会经常往上传递给文档树，这个过程叫做“冒泡”。例如，如果用户在<code>&lt;button&gt;</code>元素上单击鼠标，单击事件就会在按钮上触发。如果注册在按钮上的函数没有处理（并且冒泡停止）该事件，事件会冒泡到按钮嵌套的容器元素，这样，任何注册在容器元素上的单击事件都会调用。</p><p>大部分可以成为事件目标的对象都有一个叫做<code>addEventListener()</code>的方法，而微软只在IE9及以上实现了它，在IE8及以前的浏览器中，必须使用一个相似的方法，叫<code>attachEvent()</code>。</p><p>客户端JavaScript程序还使用异步通知类型，这些类型往往不是事件。如果设置Window对象的onerror属性为一个函数，会在发生JavaScript错误（或其他未捕获的异常）时调用函数。</p><h4 id="3-客户端JavaScript线程模型"><a href="#3-客户端JavaScript线程模型" class="headerlink" title="3. 客户端JavaScript线程模型"></a>3. 客户端JavaScript线程模型</h4><p>JavaScript语言核心并不包含任何线程机制，并且客户端JavaScript传统上也没有定义任何线程机制。HTML5定义了一种作为后台线程的“<code>Web Worker</code>”，但是客户端JavaScript还像严格的单线程一样工作。甚至当可能并发执行的时候，客户端JavaScript也不会知晓是否真的有并行逻辑的执行。</p><p>单线程执行是为了让编程更加简单。编写代码时可以确保两个事件处理程序不会同一时刻运行，操作文档内容时也不必担心会有其他线程试图同时修改文档，并且永远不需要在写JavaScript代码时担心锁、死锁和竞态条件（race condition）。</p><p>单线程执行意味着浏览器必须在脚本和事件句处理程序执行的时候停止响应用户输入。这位JavaScript开发者带来了负担，它意味着JavaScript脚本和事件处理程序不能运行太长时间。如果一个脚本执行计算密集的任务，它将会给文档载入带来延迟，而用户无法在脚本完成前看到文档内容。如果事件处理程序执行计算密集的任务，浏览器可能变得无法响应，可能会导致用户认为浏览器崩溃了。</p><p>如果应用程序不得不执行太多的计算而导致明显的延迟，应该允许文档在执行这个计算之前完全载入，并确保能够告知用户计算正在进行并且浏览器没有挂起。如果可能将计算分解为离散的子任务，可以使用<code>setTimeout()</code>和<code>setInterval()</code>方法在后台运行子任务，同时更新一个进度指示器向用户显示反馈。</p><p>HTML5定义了一种并发的控制方式，叫做“<code>Web Worker</code>”。<code>Web Worker</code>是一个用来执行计算密集任务而不冻结用户界面的后台线程。运行在<code>Web Worker</code>线程里的代码不能访问文档内容，不能和主线程或者其他<code>worker</code>共享状态，只可以和主线程和其他<code>worker</code>通过异步事件进行通信，所以主线程不能检测并发性，并且<code>Web Worker</code>不能修改JavaScript程序的基础单线程执行模型。</p><h4 id="4-客户端JavaScript时间线"><a href="#4-客户端JavaScript时间线" class="headerlink" title="4. 客户端JavaScript时间线"></a>4. 客户端JavaScript时间线</h4><p>本节更详细地解释JavaScript程序执行的时间线</p><ul><li><p>1) Web浏览器创建Document对象，并且开始解析Web页面，解析HTML元素和它们的文本内容后添加<code>Element</code>对象和<code>Text</code>节点到文档中。在这个阶段<code>document.readyState</code>属性的值是“<code>loading</code>”。</p></li><li><p>2) 当HTML解析器遇到没有<code>async</code>和<code>defer</code>属性的<code>&lt;script&gt;</code>元素时，它把这些元素添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载（如果需要）和执行时解析器会暂停。这样脚本就可以用<code>document.write()</code>来吧文本插入到输入流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单定义函数和注册后面使用的注册事件处理程序，但它们可以遍历和操作文档树，因为它们执行时已经存在了。这样，同步脚本可以看到它字迹的<code>&lt;script&gt;</code>元素和它们之前的文档内容。</p></li><li><p>3) 当解析器遇到设置了<code>async</code>属性的<code>&lt;script&gt;</code>元素时，它开始下载脚本文件，并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器没有停下来等它下载。异步脚本禁止使用<code>document.write()</code>方法。它们可以看到自己的<code>&lt;script&gt;</code>元素和它之前的所有文档元素，并且可能或干脆不可能访问其他的文档内容。</p></li><li><p>4) 当文档完成解析，<code>document.readyState</code>属性变成“<code>interactive</code>”。</p></li><li><p>5) 所有有<code>defer</code>属性的脚本，会按它们在文档里的出现顺序执行。异步脚本可能也会在这个事件执行。延迟脚本能访问完整的文档树，禁止使用<code>document.write()</code>方法。</p></li><li><p>6) 浏览器在<code>Document</code>对象上触发<code>DOMContentLoaded</code>事件。这标志着程序执行从同步脚本执行阶段转换到了异步事件驱动阶段。但要注意，这时可能还有异步脚本没有执行完成。</p></li><li><p>7) 这时，文档已经完全解析完成，但是浏览器可能还在等待其他内容载入，比如图片。当所有这些内容完成载入时，并且所有异步脚本完成载入和执行，<code>document.readyState</code>变为“<code>complete</code>”，Web浏览器触发<code>Window</code>对象上的<code>load</code>事件。</p></li><li><p>8) 从此刻起，会调用异步事件，以异步响应用户输入事件、网络事件、计时器过期等。</p></li></ul><p>这是一条理想的时间线，但是有所浏览器都没有支持它的全部细节。所有浏览器普遍都支持<code>load</code>事件，都会触发它，它时决定文档完全载入并可以操作最通用的技术。<code>DOMContentLoaded</code>事件在<code>load</code>事件之前触发，当前所有浏览器都支持这个事件，但是属性的值在浏览器之间由细微的差别。</p><p>这条时间线没有指定什么时候文档开始对用户可见或什么时候Web浏览器必须开始响应用户输入事件。这些是实现细节，对于很长的文档或非常慢的网络连接，Web浏览器理论上会渲染一部分文档，并且在所有脚本执行之前，就能允许用户开始和页面产生一些交互。这种情况下，用户输入事件可能在程序执行的事件驱动阶段开始之前触发。</p><hr><h3 id="三、兼容性和互用性"><a href="#三、兼容性和互用性" class="headerlink" title="三、兼容性和互用性"></a>三、兼容性和互用性</h3><p>Web浏览器是Web应用的操作系统，但是Web是一个存在各种差异的环境，Web文档和应用会在不同操作系统的不同开发商的不同时代的浏览器上查看和运行。写一个健壮的客户端JavaScript程序并能正确地运行在这么多类型的平台上，的确是一种挑战。</p><p>客户端JavaScript兼容性和交互性的问题可以归纳为三类：</p><ul><li><p>演化</p><p>  Web平台一直在演变和发展当中。一个标准规范会倡导一个新的特性或API。如果特性看起来有用，浏览器开发商实现它。如果足够多的开发商实现它，开发者开始试用这个特性，并依赖于这个特性，然后这个特性就在Web平台中广泛使用。有时候浏览器开发商和Web开发者引领这种标准规范的指定，开发好官方的版本，之前该特性已经成为一个事实的标准。另一种情况，新特性已经被添加到Web中，新浏览器支持它但是老浏览器不支持。Web开发者必须在使用老浏览器的大量用户和使用新式浏览器的少量用户之间做出权衡。</p></li><li><p>未实现</p><p>  有时候，浏览器开发商之间对于某一个特性是否足够由用到要实现存在观点上的差异。一些开发商实现了这个特性，而其他的没有实现。有些现代浏览器实现的功能在老旧浏览器中没实现，这种情况还好，但同样实现一个功能在不同浏览器中有很大差别，例如，IE8不支持<code>&lt;canvas&gt;</code>元素，虽然所有其他浏览器已经实现了它。</p></li><li><p>bug</p><p>  每个浏览器都有bug，并且没有按照规范准确地实现所有的客户端JavaScript API。有时候编写能兼容各个浏览器的JavaScript程序是一个糟透了的工作，必须研究已有浏览器中的各种bug。</p></li></ul><p>HTML5标准化的努力的目标是最终产生一个测试套件，这必定会给浏览器兼容性领域留下一些宝贵的财富。</p><h4 id="1-处理兼容性问题的类库"><a href="#1-处理兼容性问题的类库" class="headerlink" title="1. 处理兼容性问题的类库"></a>1. 处理兼容性问题的类库</h4><p>处理不兼容问题其中最简单的方法时使用类库。在实际的开发工作中，今天不少Web开发者在它们所有的Web页面上用了客户端JavaScript框架，比如jQuery。使这些框架必不可少的一个重要功能是：它们定义了新的客户端API并兼容所有浏览器。例如，在jQuery里，事件处理程序的注册是通过叫<code>bind()</code>的方法完成的。如果基于jQuery做所有的Web开发，就永远不需要考虑<code>addEventListener()</code>和<code>attachEvent()</code>之间的不兼容性问题。</p><h4 id="2-分级浏览器支持"><a href="#2-分级浏览器支持" class="headerlink" title="2. 分级浏览器支持"></a>2. 分级浏览器支持</h4><p>分级浏览器（<code>graded browser support</code>）是由Yahoo!率先提出的一种测试技术。从某种维度对浏览器厂商/版本/操作系统变体进行分级。分级浏览器中的A级要通过所有的功能测试用例。对于C级浏览器来说则不必所有用例都通过测试。A级浏览器需要网页完全可用，C级浏览器只需在HTML完整情况下可用即可，而不需要JavaScript和CSS都正常工作。那些不是A级和C级的浏览器都称作X级浏览器：这部分都是全新的浏览器或者太罕见的浏览器。我们默认在这些浏览器中都是网页完全可用的，但官方并不会对X级浏览器中的功能提供完整支持和测试。</p><h4 id="3-功能测试"><a href="#3-功能测试" class="headerlink" title="3. 功能测试"></a>3. 功能测试</h4><p>功能测试（<code>capability testing</code>）是解决不兼容性问题的一种强大技术。如果我们想试用某个功能，但又不清楚这个功能是否在所有的浏览器中都有比较好的兼容性，则需要在脚本中添加相应的代码来检测是否在浏览器中支持该功能。如果期望使用的功能还没有被当前的平台所支持，要么不在该平台中使用它，要么提供可在所有平台上运行的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">    <span class="comment">// 使用w3c方法之前检测是否可用</span></span><br><span class="line">    element.addEventListener(<span class="string">'keydown'</span>, handler, <span class="literal">false</span>);</span><br><span class="line">    element.addEventListener(<span class="string">'keypress'</span>, handler, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">    <span class="comment">// 在使用IE方法之前首先检测是否可用</span></span><br><span class="line">    element.attachEvent(<span class="string">'onkeydown'</span>, handler);</span><br><span class="line">    element.attachEvent(<span class="string">'onkeypress'</span>, handler);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则，选择普遍支持的技术</span></span><br><span class="line">    element.onkeydown = element.onkeypress = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于功能测试最重要的是，它并不涉及浏览器开发商和浏览器的版本号。代码在当前的浏览器集合中有效，在浏览器的后续版本中也同样有效，而不管后续的浏览器是否实现了这些功能的集合。但要注意的是，这种方法需要测试某个属性或方法是否在浏览器中已经定义了，除非该属性或方法完全可用。如果Microsoft要定义一个<code>addEventListener()</code>方法，但Microsoft只是实现了一部分w3c规范，在调用<code>addEventListener()</code>之前这将会给使用特性测试的代码带来很多麻烦。</p><h4 id="4-怪异模式和标准模式"><a href="#4-怪异模式和标准模式" class="headerlink" title="4. 怪异模式和标准模式"></a>4. 怪异模式和标准模式</h4><p>Microsoft在发布IE6的时候，增加了IE5里没有的很多CSS标准特性。但为了确保与现有的Web内容的后向兼容性，它定义了两种不同的渲染模式。在“标准模式”或“CSS兼容模式”中，浏览器要遵循CSS标准，在“怪异模式”中，浏览器表现的和IE4和IE5中的怪异非标准模式一样。渲染模式的选择依赖于HTML文件顶部的<code>DOCTYPE</code>声明，在IE6中打开没有<code>DOCTYPE</code>的页面和声明了某些权限<code>Doctype</code>的页面都会按照怪异模式进行渲染，定义了严格的<code>Doctype</code>的页面会按照标准模式进行渲染，定义了HTML5 Doctype（<code>&lt;!DOCTYPE html&gt;</code>）的页面在所有现代浏览器中都会按照标准模式渲染。</p><p>怪异模式和标准模式之间的差别经历了很长时间的发展历程，现在新版本的IE都支持标准模式，其他主流浏览器也都支持标准模式。这两种模式都已经被HTML5规范所认可。怪异模式和标准模式之间的差异对于HTML和CSS开发者影响最大。但客户端JavaScript代码则是需要知道文档以哪种模式进行渲染的。要进行这种渲染模式的特性检测，通常检查<code>document.compatMode</code>属性。如果其值为“<code>CSS1Compat</code>”，则说明浏览器工作在标准模式；如果值为“<code>BackCompat</code>”（或undefined，说明属性根本不存在），则说明浏览器工作在怪异模式。所有现代浏览器都实现了<code>compatMode</code>属性，并且HTML5规范对它进行了标准化。</p><h4 id="5-浏览器测试"><a href="#5-浏览器测试" class="headerlink" title="5. 浏览器测试"></a>5. 浏览器测试</h4><p>功能测试非常适用于大型功能领域的支持，比如可以使用这种方法来确定浏览器是否支持w3c事件处理模型还是IE的事件处理模型。另外，有时候可能会需要在某种浏览器中解决个别的bug或难题，但却没有太好的方法来检测bug的存在性。在这种情况下，需要创建一个针对某个平台的解决方案，这个解决方案和特定的浏览器厂商、版本或操作系统（或三方面的组合）联系紧密。</p><p>在客户端JavaScript中检测浏览器类型和版本的方法就是使用<code>Navigator</code>对象，确定当前浏览器的厂商和版本的代码通常叫做浏览器嗅探器（<code>browser sniffer</code>）或者客户端嗅探器（<code>client sniffer</code>）。在Web早期，当Netscape和IE平台两者互不兼容的时候，客户端嗅探（<code>client sniffering</code>）就是一种常见的客户端编程技术，现在兼容性情况已经基本稳定，浏览器嗅探不像若干年前这样常用，但偶尔有些场景还会用到。</p><p>需要注意的是，客户端嗅探也可以在服务器端完成，Web服务器根据<code>User-Agent</code>头部可以有选择地返回特定的JavaScript代码给客户端。</p><h4 id="6-Internet-Explorer里的条件注释"><a href="#6-Internet-Explorer里的条件注释" class="headerlink" title="6. Internet Explorer里的条件注释"></a>6. Internet Explorer里的条件注释</h4><p>实际上，读者会发现客户端JavaScript编程中的很多不兼容性都是针对IE的。也就是说，必须按照某种方式为IE编写代码，而按照另一种方式为其他的浏览器编写代码。IE支持条件注释（IE5引入），尽管这种做法并不符合标准规范，但是在处理不兼容性时非常有用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if IE 6]&gt;</span></span><br><span class="line"><span class="comment">This content is actually inside an HTML comment.</span></span><br><span class="line"><span class="comment">It will only be displayed in IE 6.</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if lte IE 7]&gt;</span></span><br><span class="line"><span class="comment">This content will only be displayed by IE 5, 6 and 7 and earlier.</span></span><br><span class="line"><span class="comment">lte stands for 'less than or equal'. You can also use 'lt', 'gt' and 'gte'.</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if !IE]&gt;&lt;--&gt;</span></span><br><span class="line">This is normal HTML content, but IE will not display it.</span><br><span class="line">Because of the comment above and the comment below.</span><br><span class="line"><span class="comment">&lt;!--&gt;&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line">This is normal content, displayed by all browsers.</span><br></pre></td></tr></table></figure><p>IE的JavaScript解释器也支持条件注释，C和C++程序员可能觉得它们和C预处理器的<code>#ifdef/#endif</code>功能很相似。IE中的JavaScript条件注释以文本<code>/*@cc_on</code>开头，以文本<code>@*/</code>结束（cc_on stands中的cc表示条件编译）。下面的条件注释包含了只在IE中执行的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@cc_on</span></span><br><span class="line"><span class="comment">  @if (@_jscript)</span></span><br><span class="line"><span class="comment">    // 该代码位于一条JS注释内但在IE中执行它</span></span><br><span class="line"><span class="comment">    alert("In IE");</span></span><br><span class="line"><span class="comment">  @end</span></span><br><span class="line"><span class="comment">@*/</span></span><br></pre></td></tr></table></figure><p>在一条条件注释内部，关键字<code>@if</code>、<code>@else</code>和<code>@end</code>划分出哪些是要被IE的JavaScript解释器有条件地执行的代码。大多数时候，只需要上面所示的简单的条件：<code>@if(@_jscript)</code>。JScript是Microsoft字迹的JavaScript解释器的名字，而<code>@_jscript</code>变量在IE中总是为true。</p><p>通过条件注释和常规的JavaScript注释的合理的交叉组合，可以设置在IE中运行一段代码而在所有其他浏览器中运行另一段不同的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@cc_on</span></span><br><span class="line"><span class="comment">  @if (@_jscript)</span></span><br><span class="line"><span class="comment">    // 这里的代码在一条条件注释中，也在一条常规的JavaScript注释中</span></span><br><span class="line"><span class="comment">    // IE会执行这段代码，其他浏览器不执行它</span></span><br><span class="line"><span class="comment">    alert('You are using Internet Explorer');</span></span><br><span class="line"><span class="comment">  @else*/</span></span><br><span class="line">    <span class="comment">// 这段代码并没在JavaScript注释中，但仍然在IE条件注释中</span></span><br><span class="line">    <span class="comment">// 也就是说除了IE之外的所有浏览器都执行这里的代码</span></span><br><span class="line">    alert(<span class="string">'You are not using Internet Explorer'</span>);</span><br><span class="line">  <span class="comment">/*@end</span></span><br><span class="line"><span class="comment">@*/</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、可访问性"><a href="#四、可访问性" class="headerlink" title="四、可访问性"></a>四、可访问性</h3><p>Web是发布信息的理想工具，而JavaScript程序可以增强对信息的访问。然而，因为程序员写代码太过随意，以至于那些有视觉障碍或者肢体困难的用户没办法正确地获取信息。</p><p>盲人用户使用一种叫做屏幕阅读器的“辅助性技术”将书面的文字变成语音词汇。有些屏幕阅读器是识别JavaScript的，而另一些只能在禁用JavaScript时才会工作得更好。如果站点过于依赖JavaScript来呈现数据的话，就会把那些使用读屏软件的用户拒之门外。JavaScript可访问性的一条重要原则是，设计的代码即使在禁用JavaScript解释器的浏览器中也能正常使用（或至少以某种形式正常使用）。</p><p>可访问性关心的另一个重要的问题是，对于那些只使用键盘但不能使用鼠标的用户来说，如果编写的JavaScript代码依赖于特定的鼠标事件，这就会将那些不使用鼠标的用户排除在外。Web浏览器允许使用键盘来遍历和激活一个Web页面中的UI元素。并且JavaScript代码也应该允许这样做。</p><hr><h3 id="五、安全性"><a href="#五、安全性" class="headerlink" title="五、安全性"></a>五、安全性</h3><p>Web浏览器中包含JavaScript解释器，也就是说，一旦载入Web页面，就可以让任意的JavaScript代码在计算机里执行。很明显，这里存在着安全隐患，浏览器厂商也在不断地权衡下面这两个方面之间的博弈：</p><ul><li><p>定义强大的客户端API，启用强大的Web应用</p></li><li><p>阻止恶意代码读取或修改数据、盗取隐私、诈骗或浪费时间</p></li></ul><p>在标准化HTML5的进程中，浏览器厂商会小心掂量某个长期存在的安全限制，并且在不引入新的安全漏洞的基础上给客户端JavaScript添加少量的功能。</p><h4 id="1-JavaScript不能做什么"><a href="#1-JavaScript不能做什么" class="headerlink" title="1. JavaScript不能做什么"></a>1. JavaScript不能做什么</h4><p>Web浏览器针对恶意代码的第一条防线就是它们不支持某些功能。</p><ul><li><p>客户端JavaScript没有权限来写入或删除客户计算机上的任意文件或列出任意目录。</p></li><li><p>客户端JavaScript没有任何通用的网络能力。</p></li></ul><p>浏览器针对恶意代码的第二条防线是在自己支持的某些功能上施加限制。</p><ul><li><p>JavaScript程序可以打开一个新的浏览器窗口，但是为了防止广告商滥用弹出窗口，很多浏览器限制了这一功能，使得只有为了响应鼠标单击这样的用户触发事件的时候，才能使用它。</p></li><li><p>JavaScript程序可以关闭自己打开的浏览器窗口，但是不允许它不经过用户确认就关闭其他的窗口。</p></li><li><p>HTML <code>FileUpload</code>元素的<code>value</code>属性是只读的。如果可以设置这个属性，脚本就能设置它为任意期望的文件名，从而导致表单上传指定文件的内容到服务器。</p></li><li><p>脚本不能读取从不同服务器载入的文档的内容，除非这个就是包含该脚本的文档。类似地，一个脚本不能在来自不同服务器的文档上注册事件监听器。这就防止脚本窃取其他页面的用户输入。这一限制叫做同源策略（<code>same-origin policy</code>）。</p></li></ul><h4 id="2-同源策略"><a href="#2-同源策略" class="headerlink" title="2. 同源策略"></a>2. 同源策略</h4><p>同源策略是对JavaScript代码能够操作哪些Web内容的一条完整的安全限制。当Web页面使用多个<code>&lt;iframe&gt;</code>元素或者打开其他浏览器窗口的时候，这一策略通常就会发挥作用。在这种情况下，同源策略负责管理窗口或窗体中的JavaScript代码以及和其它窗口或帧的交互。具体来说，脚本只能读取和所属文档相同的窗口和文档的属性。</p><p>文档的来源包含协议、主机，以及载入文档的URL端口。从不同Web服务器载入的文档具有不同的来源。通过同一主机的不同端口载入的文档具有不同的来源。使用<code>http:</code>协议载入的文档和使用<code>https:</code>协议载入的文档具有不同的来源，即使它们来自同一个服务器。</p><p>脚本本身的来源和同源策略并不相关，相关的是脚本所嵌入的文档的来源，理解这一点很重要。例如，假设一个来自主机A的脚本被包含到（使用<code>&lt;script&gt;</code>标记的<code>src</code>属性）宿主B的一个Web网页中。这个脚本的来源是主机B，并且可以完整地访问包含它的文档的内容。如果脚本打开一个新窗口并载入来自主机B的另一个文档，脚本对这个文档的内容也具有完全的访问权限。但是，如果脚本打开第三个窗口并载入一个来自主机C的文档（或者是来自主机A），同源策略就会发挥作用，阻止脚本访问这个文档。</p><p>实际上，同源策略并非应用于不同源的窗口中的所有对象的所有属性。不过它应用到了其中的大多数属性，尤其是对<code>Document</code>对象的几乎所有属性而言。凡是包含另一个服务器中文档的窗口或窗体，都是同源策略适用的范围。如果脚本打开一个窗口，脚本也可以关闭它，但不能以任何方式查看窗口内部。同源策略还应用于使用<code>XMLHttpRequest</code>生成的HTTP请求。这个对象允许客户端JavaScript生成任意的HTTP请求到脚本所属文档的Web服务器，但是不允许脚本和其他Web服务器通信。</p><h4 id="3-不严格的同源策略"><a href="#3-不严格的同源策略" class="headerlink" title="3. 不严格的同源策略"></a>3. 不严格的同源策略</h4><p>在某些情况下，同源策略就显得太过严格了。本节会介绍三种不严格的同源策略。</p><p>同源策略给那些使用多个子域的大站点带来了一些问题。例如，来自<code>home.example.com</code>的文档里的脚本想要合法地读取从<code>developer.example.com</code>载入的文档的属性，或者来自<code>orders.example.com</code>的脚本可能需要读<code>catalog.example.com</code>上的文档的属性。为了支持这种类型的多域名站点，可以使用Document对象的domain属性。在默认情况下，属性domain存放的是载入文档的服务器的主机名。可以设置这一属性，不过使用的字符串必须是具有有效的域前缀或它本身。因此，如果一个domain属性的初始值是字符串“<code>home.example.com</code>”，就可以把它设置为字符串“<code>example.com</code>”，但是不能设置为“<code>home.example</code>”或“<code>ample.com</code>”。另外，domain值中必须有一个点号，不能把它设置为“<code>com</code>”或其他顶级域名。</p><p>如果两个窗口包含的脚本把domain设置成了相同的值，那么这两个窗口就不再受同源策略的约束，它们可以相互读取对方的属性。例如，从<code>order.example.com</code>和<code>catalog.example.com</code>载入的文档中的脚本可以把它们的<code>document.domain</code>属性都设置为“<code>example.com</code>”，这样一来，这些文档就有了同源性，可以相互读取属性。</p><p>不严格的同源策略的第二项技术已经标准化为：跨域资源共享（<code>Cross-Origin Resource Sharing</code>）。这个标准草案用新的“<code>Origin:</code>”请求头和新的<code>Access-Control-Allow-Origin</code>响应头来扩展HTTP。它允许服务器用头信息显式地列出源，或使用通配符来匹配所有的源并允许由任何地址请求文件。</p><p>另一种新技术，叫做跨文档消息（<code>cross-document messaging</code>），允许来自一个文档的脚本可以传递文本消息到另一个文档里的脚本，而不管脚本的来源是否不同。调用<code>Window</code>对象上的<code>postMessage()</code>方法，可以异步传递消息事件（可以用onmessage事件处理函数处理它）到窗口的文档里。一个文档里的脚本还是不能调用在其他文档里的方法和读取属性，但它们可以用这种消息传递技术来实现安全的通信。</p><h4 id="4-脚本化插件和ActiveX控件"><a href="#4-脚本化插件和ActiveX控件" class="headerlink" title="4. 脚本化插件和ActiveX控件"></a>4. 脚本化插件和ActiveX控件</h4><p>尽管核心JavaScript语言和基本的客户端对象模型缺乏大多数恶意代码所需要的文件系统功能和网络功能，但情况并不像看上去那么简单。在很多Web浏览器中，JavaScript亦被用作很多软件或插件的“脚本引擎”，这样的组件由IE中的ActiveX控件和其他浏览器的插件。Flash和Java插件是最常安装的例子，它们为客户端脚本提供了非常重要且强大的特性。</p><p>脚本化ActiveX控件和插件的能力也存在着安全性的问题。例如，Java applet具有访问底层网络的能力。Java安全“沙箱”阻止applet和载入它的服务器之外的任何服务器进行通信，因此，这并未打开一个安全漏洞。但是，它暴露了一个根本问题：如果插件是可以脚本化的，我们不仅要无条件相信Web浏览器的安全架构，还要相信插件的安全架构。实际上，Java和Flash插件看上去具有健壮的安全性，并且不会为客户端JavaScript引来安全问题。然而，ActiveX脚本化有着更加糟糕的历史遗留问题。IE浏览器已经能够访问各种各样的脚本化ActiveX控件，而这些控件是Windows操作系统的一部分，并且在过去，操作系统还存在很多可被控件利用的安全漏洞。</p><h4 id="5-跨站脚本"><a href="#5-跨站脚本" class="headerlink" title="5. 跨站脚本"></a>5. 跨站脚本</h4><p>跨站脚本（<code>Cross-site scripting</code>），或者叫做XSS，这个术语用来表示一类安全问题，也就是攻击者向目标Web站点注入HTML标签或者脚本。防止XSS攻击是服务器端Web开发者的一项基本工作。然而，客户端JavaScript程序员也必须意识到或者能够预防跨站脚本。</p><p>如果Web页面动态地产生文档内容，并且这些文档内容是基于用户提交的数据的，而并没有通过从中移除任何嵌入的HTML标签来“消毒”的话，那么这个Web页面很容易遭到跨站脚本攻击。来看一个小例子，考虑如下的Web页面，它使用JavaScript通过用户的名字来向用户问好</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> name = <span class="built_in">decodeURIComponent</span>(<span class="built_in">window</span>.location.search.substring(<span class="number">1</span>)) || <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">'Hello '</span> + name);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两行脚本使用<code>window.location.search</code>来获得它们自己的URL中以“<code>?</code>”开始的部分。它使用<code>document.write()</code>来向文档添加动态生成的内容。这个页面专门通过如下的一个URL来调用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/greet.html?David</span><br></pre></td></tr></table></figure><p>这么使用的时候，它会显示文本“Hello David”。但考虑以下，当用下面的URL来调用它，会发生什么情况</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- %3C和%3E是尖括号的编码 --&gt;</span> </span><br><span class="line">http://www.example.com/greet.html?%3Cscript%3Ealert('David')%3C/script%3E</span><br></pre></td></tr></table></figure><p>只用这个URL，脚本会动态生成另一个脚本。在这个例子中，注入的脚本只显示一个对话框，这还是相对较好的情况。但是，如果考虑以下的情况</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://siteA/greet.html?name=%3Cscript src=siteB/evil.js%3E%3C/script%3E</span><br></pre></td></tr></table></figure><p>之所以叫做跨站脚本攻击，就是因为它涉及多个站点。站点B（或者站点C）包含一个专门构造的到站点A的链接，它会注入一个来自站点B的脚本。脚本<code>eval.js</code>驻留在恶意站点B中，但现在，它嵌入到站点A中，并且可以对站点A的内容进行任何想要的操作。它可能损坏这个页面或者使其不能正常工作。这可能会对站点A的用户带来不少坏处。更危险的是，恶意脚本可以读取A所存储的cookie（可能是统计数据或者其他的个人验证信息），然后把数据发送回站点B。注入的脚本甚至可以诱骗用户击键并将数据发送回站点B。</p><p>通常，防止XSS攻击的方式是，在使用任何不可信的数据来动态创建文档内容之前，从中移除HTML标签。可以通过添加如下一行代码来移除尖括号，从而修复前面给出的<code>greet.html</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = name.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>).replace(<span class="regexp">/&gt;/g</span>, <span class="string">'%gt;'</span>);</span><br></pre></td></tr></table></figure><p>HTML5的内容安全策略则更进一步，它为<code>&lt;iframe&gt;</code>元素定义了一个sandbox属性。在实现之后，它允许显示不可信的内容，并自动禁用脚本。</p><h4 id="6-拒绝服务攻击"><a href="#6-拒绝服务攻击" class="headerlink" title="6. 拒绝服务攻击"></a>6. 拒绝服务攻击</h4><p>这里描述的同源策略和其他的安全限制可以很好地预防恶意代码毁坏数据或者防止侵犯隐私这种问题。然而，它们并不能防止另外一种攻击：拒绝服务攻击，这种攻击手法非常暴利。如果访问了启用JavaScript功能的一个恶意Web站点，这个站点可以使用一个<code>alert()</code>对话框的无限循环占用浏览器，或者用一个无限循环或没有意义的计算来占用CPU。</p><p>某些浏览器可以检测运行时间很长的脚本，并且让用户选择终止它们。但是恶意脚本可以使用<code>window.setInterval()</code>这样的方法来占用CPU，并通过分配很多的内存来攻击你的系统。Web浏览器并没有通用的方法来防止这种笨重的攻击手法。实际上，由于没有人会返回一个滥用这种脚本的网站，因此这在Web上不是一个常见的问题。</p><hr><h3 id="六、客户端框架"><a href="#六、客户端框架" class="headerlink" title="六、客户端框架"></a>六、客户端框架</h3><p>一些Web开发者发现基于客户端框架或类库来创建它们的Web应用非常便捷，从某种意义上来讲类库也是框架，它们对Web浏览器提供的标准和专用API进行了封装，向上提供更高级别的API，用以更高效地进行客户端变成开发。一旦使用一个框架，就要用框架定义的API来写代码，使用框架的一个明显的好处是高级的API可以用更简洁的代码完成更复杂的功能。此外，完善的框架也会帮我们处理上文提到的很多兼容性、安全性和可访问性问题。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;window&lt;/code&gt;对象是所有客户端JavaScript特性和API的主要接入点。它表示Web浏览器的一个窗口或窗体，并且可以用标识符&lt;code&gt;window&lt;/code&gt;来引用它。&lt;code&gt;Window&lt;/code&gt;对象定义了一些属性，比如，指代&lt;code&gt;Location&lt;/code&gt;对象的&lt;code&gt;location&lt;/code&gt;属性，&lt;code&gt;Location&lt;/code&gt;对象指定当前显示在窗口中的url，并允许脚本往窗口里载入新的url。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="客户端JavaScript" scheme="http://www.xiaoleon.cn/tags/%E5%AE%A2%E6%88%B7%E7%AB%AFJavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS(6) Object.assign()</title>
    <link href="http://www.xiaoleon.cn/2018/01/29/js-6/"/>
    <id>http://www.xiaoleon.cn/2018/01/29/js-6/</id>
    <published>2018-01-29T14:26:15.000Z</published>
    <updated>2018-01-29T14:32:29.966Z</updated>
    
    <content type="html"><![CDATA[<p><code>Object.assign()</code>方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><p><code>target</code>：目标对象</p></li><li><p><code>sources</code>：源对象</p></li></ul><p><strong>返回值</strong></p><ul><li>目标对象</li></ul><hr><h3 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a>一、描述</h3><p>如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。</p><p><code>Object.assign()</code>方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的<code>[[Get]]</code>和目标对象的<code>[[Set]]</code>，所以它会调用相关的getter和setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含<code>getter</code>，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用<code>Object.getOwnPropertyDescriptor()</code>和<code>Object.defineProperty()</code>。</p><p><code>String</code>类型和<code>Symbol</code>类型的属性都会被拷贝。</p><p>在出现错误的情况下，例如，如果属性不可写，会引发<code>TypeError</code>，如果在引发错误之前添加了任何属性，则可以更改<code>target</code>对象。</p><p>注意，<code>Object.assign()</code>会跳过那些值为<code>null</code>或<code>undefined</code>的源对象。</p><hr><h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><h4 id="1-复制一个对象"><a href="#1-复制一个对象" class="headerlink" title="1. 复制一个对象"></a>1. 复制一个对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy);                              <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-只有一个参数"><a href="#2-只有一个参数" class="headerlink" title="2. 只有一个参数"></a>2. 只有一个参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj) === obj;                     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果该参数不是对象，则会先转换成对象，然后返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">true</span>);                            <span class="comment">// &#123; [[PrimitiveValue]]: true &#125;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="number">10</span>);                              <span class="comment">// &#123; [[PrimitiveValue]]: 10 &#125;</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="string">'abc'</span>);                           <span class="comment">// &#123; &#123;0: 'a', 1: 'b', 2: 'c', length: 3, [[PrimitiveValue]]: 'abc'&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>);                        <span class="comment">// 'number'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>);                       <span class="comment">// 报错 undefined无法转成对象</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>);                            <span class="comment">// 报错 null无法转成对象</span></span><br></pre></td></tr></table></figure><h4 id="3-深拷贝问题"><a href="#3-深拷贝问题" class="headerlink" title="3. 深拷贝问题"></a>3. 深拷贝问题</h4><p>针对深拷贝，需要使用其他方法，因为<code>Object.assign()</code>拷贝的是属性值。加入源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2));          <span class="comment">// &#123; a: 0, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">    obj1.a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1));          <span class="comment">// &#123; a: 1, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2));          <span class="comment">// &#123; a: 0, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">    obj2.a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1));          <span class="comment">// &#123; a: 1, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2));          <span class="comment">// &#123; a: 2, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">    obj2.b.c = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1));          <span class="comment">// &#123; a: 1, b: &#123; c: 3 &#125; &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2));          <span class="comment">// &#123; a: 2, b: &#123; c: 3 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deep Clone</span></span><br><span class="line">    obj1 = &#123; <span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">let</span> obj3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</span><br><span class="line">    obj1.a = <span class="number">4</span>;</span><br><span class="line">    obj1.b.c = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj3));          <span class="comment">// &#123; a: 0, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h4 id="4-合并对象"><a href="#4-合并对象" class="headerlink" title="4. 合并对象"></a>4. 合并对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o3 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(o1, o2, o3);</span><br><span class="line"><span class="built_in">console</span>.log(obj);                               <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o1);                                <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;，注意目标对象自身也会改变</span></span><br></pre></td></tr></table></figure><h4 id="5-合并具有相同属性的对象"><a href="#5-合并具有相同属性的对象" class="headerlink" title="5. 合并具有相同属性的对象"></a>5. 合并具有相同属性的对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o3 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, o1, o2, o3);</span><br><span class="line"><span class="built_in">console</span>.log(obj);                               <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>属性被后续参数中具有相同属性的其他对象覆盖。</p><h4 id="6-拷贝symbol类型的属性"><a href="#6-拷贝symbol类型的属性" class="headerlink" title="6. 拷贝symbol类型的属性"></a>6. 拷贝symbol类型的属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; [<span class="built_in">Symbol</span>(<span class="string">'foo'</span>)]: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, o1, o2);</span><br><span class="line"><span class="built_in">console</span>.log(obj);                               <span class="comment">// &#123; a: 1, [Symbol('foo')]: 2 &#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj);              <span class="comment">// [Symbol(foo)]</span></span><br></pre></td></tr></table></figure><h4 id="7-继承属性和不可枚举属性"><a href="#7-继承属性和不可枚举属性" class="headerlink" title="7. 继承属性和不可枚举属性"></a>7. 继承属性和不可枚举属性</h4><p>继承属性和不可枚举属性是不能拷贝的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;, &#123;           <span class="comment">// foo是个继承属性</span></span><br><span class="line">    bar: &#123;</span><br><span class="line">        value: <span class="number">2</span>                                <span class="comment">// bar是个不可枚举属性</span></span><br><span class="line">    &#125;,</span><br><span class="line">    baz: &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span>                        <span class="comment">// baz是个自身可枚举属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy);                              <span class="comment">// &#123; baz: 3 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="8-原始类型"><a href="#8-原始类型" class="headerlink" title="8. 原始类型"></a>8. 原始类型</h4><p>原始类型会被包装为对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> v2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> v3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> v4 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, <span class="literal">null</span>, v2, <span class="literal">undefined</span>, v3, v4);</span><br><span class="line"><span class="comment">// 原始类型会被包装，null和undefined会被忽略</span></span><br><span class="line"><span class="comment">// 注意，只有字符串的包装对象才可能有自身可枚举属性</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);                               <span class="comment">// &#123; '0': 'a', '1': 'b', '2': 'c' &#125;</span></span><br></pre></td></tr></table></figure><h4 id="9-异常"><a href="#9-异常" class="headerlink" title="9. 异常"></a>9. 异常</h4><p>异常会打断后续拷贝任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'foo'</span>, &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);                                             <span class="comment">// target的foo属性是个只读属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, &#123;<span class="attr">bar</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">foo2</span>: <span class="number">2</span>, <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">foo3</span>: <span class="number">3</span>&#125;, &#123;<span class="attr">baz</span>: <span class="number">4</span>&#125;);</span><br><span class="line"><span class="comment">// TypeError: 'foo' is read-only</span></span><br><span class="line"><span class="comment">// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target.bar);                        <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo2);                       <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo);                        <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo3);                       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(target.baz);                        <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4 id="10-拷贝访问器"><a href="#10-拷贝访问器" class="headerlink" title="10. 拷贝访问器"></a>10. 拷贝访问器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    get bar() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="comment">// &#123; foo: 1, bar: 2 &#125;</span></span><br><span class="line"><span class="comment">// copy.bar的值来自obj.bar的getter函数的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(copy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个函数会拷贝所有自有属性的属性描述符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeAssign</span>(<span class="params">target, ...sources</span>) </span>&#123;</span><br><span class="line">    sources.forEach(<span class="function"><span class="params">source</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> descriptors = <span class="built_in">Object</span>.keys(source).reduce(<span class="function">(<span class="params">descrpitors, key</span>) =&gt;</span> &#123;</span><br><span class="line">            descriptors[key] = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, key);</span><br><span class="line">            <span class="keyword">return</span> descriptors;</span><br><span class="line">        &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object.assign默认也会拷贝可枚举的Symbols</span></span><br><span class="line">        <span class="built_in">Object</span>.getOwnPropertySymbols(source).forEach(<span class="function"><span class="params">sym</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, sym);</span><br><span class="line">            <span class="keyword">if</span> (descriptor.enumerate) &#123;</span><br><span class="line">                descriptors[sym] = descriptor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">Object</span>.defineProperties(target, descriptors);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copy = completeAssign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy);                              <span class="comment">// &#123; foo: 1, get bar() &#123; return 2; &#125; &#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">MDN Object.assign()</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/object#Object-assign" target="_blank" rel="noopener">阮一峰 ECMAScript 6入门</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Object.assign()&lt;/code&gt;方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。&lt;/p&gt;
    
    </summary>
    
      <category term="原生JS学习" scheme="http://www.xiaoleon.cn/categories/%E5%8E%9F%E7%94%9FJS%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Object.assign()" scheme="http://www.xiaoleon.cn/tags/Object-assign/"/>
    
      <category term="JS函数" scheme="http://www.xiaoleon.cn/tags/JS%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>JS(5) 类和模块</title>
    <link href="http://www.xiaoleon.cn/2018/01/29/js-5/"/>
    <id>http://www.xiaoleon.cn/2018/01/29/js-5/</id>
    <published>2018-01-29T13:50:01.000Z</published>
    <updated>2018-01-29T14:24:46.922Z</updated>
    
    <content type="html"><![CDATA[<p>每个JavaScript对象都是一个属性集合，相互之间没有任何联系。在JavaScript中也可以定义对象的类，让每个对象都共享某些属性，这种“共享”的特性是非常有用的。类的成员或实例都包含一些属性，用以存放或定义它们的状态，其中有些属性定义了它们的行为（通常称为方法）。这些行为通常是由类定义的，而且为所有实例所共享。</p><a id="more"></a><p>在JavaScript中，类的实现是基于其原型继承机制的。如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例，并且往往意味着（但不是绝对）它们是由同一个构造函数创建并初始化的。</p><h3 id="一、类和原型"><a href="#一、类和原型" class="headerlink" title="一、类和原型"></a>一、类和原型</h3><p>在JavaScript中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。我们在前文中定义了一个<code>inherit()</code>函数，这个函数返回一个新创建的对象，后者继承自某个原型对象。如果定义了一个原型对象，然后通过<code>inherit()</code>函数创建一个继承自它的对象，这样就定义了一个JavaScript类。通常，类的实例还需要进一步的初始化，通常是通过定义一个函数来创建并初始化这个新对象。下方代码给一个表示“值的范围”的类定义了原型对象，还定义了一个“工厂”函数用以创建并初始化类的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range.js 实现一个能表示值的范围的类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用inherit()函数来创建对象，这个对象继承自在下面定义的原型对象</span></span><br><span class="line">    <span class="comment">// 原型对象作为函数的一个属性存储，并定义所有“范围对象”所共享的方法</span></span><br><span class="line">    <span class="keyword">var</span> r = inherit(range.methods);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储新的“范围对象”的起始位置和结束位置</span></span><br><span class="line">    <span class="comment">// 这两个属性是不可继承的，每个对象都拥有唯一的属性</span></span><br><span class="line">    r.from = <span class="keyword">from</span>;</span><br><span class="line">    r.to = to;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回这个新创建的对象</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型对象定义方法，这些方法为每个范围对象所继承</span></span><br><span class="line">range.methods = &#123;</span><br><span class="line">    <span class="comment">// 如果x在范围内，则返回true，否则返回false</span></span><br><span class="line">    <span class="comment">// 这个方法可以比较数字范围，也可以比较字符串和日期范围</span></span><br><span class="line">    includes: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="keyword">this</span>.to;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于范围内的每个整数都调用一次f</span></span><br><span class="line">    <span class="comment">// 这个方法只可用作数字范围</span></span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from); x &lt;= <span class="keyword">this</span>.to; x++) &#123;</span><br><span class="line">            f(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回表示这个范围的字符串</span></span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.from + <span class="string">'...'</span> + <span class="keyword">this</span>.to + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是使用“范围对象”的一些例子</span></span><br><span class="line"><span class="keyword">var</span> r = range(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">r.includes(<span class="number">2</span>);                                  <span class="comment">// =&gt; true  2在这个范围内</span></span><br><span class="line">r.foreach(<span class="built_in">console</span>.log);                         <span class="comment">// =&gt; 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(r);                                 <span class="comment">// =&gt; (1...3)</span></span><br></pre></td></tr></table></figure><p>这段代码定义了一个工厂方法<code>range()</code>，用来创建新的范围对象。我们注意到，这里给<code>range()</code>函数定义了一个属性<code>range.methods</code>，用以快捷地存放定义类的原型对象。把原型对象挂在函数上没什么大不了，但也不是惯用做法。再者，注意<code>range()</code>函数给每个范围对象都定义了<code>from</code>和<code>to</code>属性，用以定义范围的起始位置和结束位置，这两个属性是非共享的，当然也是不可继承的。最后，注意在<code>range.methods</code>中定义的那些可共享、可继承的方法都用到了<code>from</code>和<code>to</code>属性，而且使用了<code>this</code>关键字，为了指代它们，二者使用<code>this</code>关键字来指代调用这个方法的对象。任何类的方法都可以通过<code>this</code>的这种基本用法来读取对象的属性。</p><hr><h3 id="二、类和构造函数"><a href="#二、类和构造函数" class="headerlink" title="二、类和构造函数"></a>二、类和构造函数</h3><p>上文示例中展示了在JavaScript中定义类的其中一种方法。但这种方法并不常用，毕竟它没有定义构造函数，构造函数是用来初始化新创建的对象的。使用<code>new</code>关键字调用构造函数会自动创建一个新对象，因此构造函数本身只需初始化这个新对象的状态即可。调用构造函数的一个重要特征是，构造函数的<code>prototype</code>属性被用做新对象的原型。这意味着通过同一个构造函数创建的所有对象都继承自一个相同的对象，因此它们都是同一个类的成员。下文示例对前面代码进行了修改，使用构造函数代替工厂函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range2.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个构造函数，用以初始化新创建的“范围对象”</span></span><br><span class="line"><span class="comment">// 注意，这里并没有创建并返回一个对象，仅仅是初始化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 存储“范围对象”的起始位置和结束位置</span></span><br><span class="line">    <span class="comment">// 这两个属性是不可继承的，每个对象都拥有唯一的属性</span></span><br><span class="line">    <span class="keyword">this</span>.from = <span class="keyword">from</span>;</span><br><span class="line">    <span class="keyword">this</span>.to = to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有“范围对象”都继承自这个对象</span></span><br><span class="line"><span class="comment">// 注意：属性的名字必须是prototype</span></span><br><span class="line">Range.prototype = &#123;</span><br><span class="line">    includes: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="keyword">this</span>.to;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from); x &lt;= <span class="keyword">this</span>.to; x++) &#123;</span><br><span class="line">            f(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.from + <span class="string">'...'</span> + <span class="keyword">this</span>.to + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Range(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">r.includes(<span class="number">2</span>);                                  <span class="comment">// =&gt; true  2在这个范围内</span></span><br><span class="line">r.foreach(<span class="built_in">console</span>.log);                         <span class="comment">// =&gt; 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(r);                                 <span class="comment">// =&gt; (1...3)</span></span><br></pre></td></tr></table></figure><p>将两个代码进行对比，可以发现两种定义类的技术的差别。首先，注意当工程函数<code>range()</code>转化为构造函数时被重命名为<code>Range()</code>。这里遵循了一个常见的编程约定：定义构造函数即是定义类，并且类名首字母要大写。而普通的函数和方法都是首字母小写。</p><p>再者，注意<code>Range()</code>构造函数是通过<code>new</code>关键字调用的，而<code>range()</code>工厂函数则不必使用new。由于<code>Range()</code>构造函数是通过<code>new</code>关键字调用的，因此不必调用<code>inherit()</code>或其他什么逻辑来创建新对象。<code>Range()</code>构造函数只不过就是初始化<code>this</code>而已。构造函数甚至不必返回这个新创建的对象，构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。</p><blockquote><p>构造函数就是用来“构造新对象”的，它必须通过关键字<code>new</code>来调用，如果将构造函数用作普通函数的话，往往不会正常工作。开发者可以通过命名约定（构造函数首字母大写，普通方法首字母小写）来判断是否应当在函数之前冠以关键字<code>new</code>。</p></blockquote><p>两个代码之间还有一个非常重要的区别，就是原型对象的命名，在第一段示例代码中的原型是<code>range.methods</code>。这种命名方式很方便同时具有很好的语义，但又过于随意。在第二段代码中的原型是<code>Range.prototype</code>，这是一个强制的命名。对<code>Range()</code>构造函数的调用会自动使用<code>Range.prototype</code>作为新<code>Range</code>对象的原型。</p><h4 id="1-构造函数和类的标识"><a href="#1-构造函数和类的标识" class="headerlink" title="1. 构造函数和类的标识"></a>1. 构造函数和类的标识</h4><p>上文提到，原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。而初始化对象的状态的构造函数则不能作为类的标识，如果两个构造函数的<code>prototype</code>属性指向同一个原型对象，那么这两个构造函数创建的实例是属于同一个类的。</p><p>尽管构造函数不像原型那样基础，但构造函数是类的“外在表现”。很明显的，构造函数的名字通常用做类名。比如，我们说<code>Range()</code>构造函数创建<code>Range</code>对象。然而，更根本的讲，当使用<code>instanceof</code>运算符来检测对象是否属于某个类时会用到构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果r继承自Range.prototype，则返回true</span></span><br><span class="line">r <span class="keyword">instanceof</span> Range</span><br></pre></td></tr></table></figure><p>实际上<code>instanceof</code>运算符并不会检查<code>r</code>是否由<code>Range()</code>构造函数初始化而来，而是会检查<code>r</code>是否继承自<code>Range.prototype</code>。不过，<code>instanceof</code>的语法则强化了“构造函数是类的公有标识”的概念。本文后面还会对<code>instanceof</code>运算符进行介绍。</p><h4 id="2-constructor属性"><a href="#2-constructor属性" class="headerlink" title="2. constructor属性"></a>2. constructor属性</h4><p>上文实例中，将<code>Range.prototype</code>定义为一个新对象，这个对象包含类所需要的方法。其实没有必要新创建一个对象，用单个对象直接量的属性就可以方便地定义原型上的方法。任何JavaScript函数都可以用作构造函数，并且调用构造函数是需要用到一个<code>prototype</code>属性的。因此，每个JavaScript函数（ES5中的<code>Function.bind()</code>方法返回的函数除外）都自动拥有一个<code>prototype</code>属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性<code>constructor</code>。<code>constructor</code>属性的值是一个函数对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;          <span class="comment">// 这是一个函数对象</span></span><br><span class="line"><span class="keyword">var</span> p = F.prototype;            <span class="comment">// 这是F相关联的原型对象</span></span><br><span class="line"><span class="keyword">var</span> c = p.constructor;          <span class="comment">// 这是与原型相关联的函数</span></span><br><span class="line">c === F;                        <span class="comment">// true  对于任意函数 F.prototype.constructor == F</span></span><br></pre></td></tr></table></figure><p>可以看到构造函数的原型中存在预先定义好的<code>constructor</code>属性，这意味着对象通常继承的<code>constructor</code>均指代它们的构造函数。由于构造函数是类的“公共标识”，因此这个<code>constructor</code>属性为对象提供了类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> F();                <span class="comment">// 创建类F的一个对象</span></span><br><span class="line">o.constructor === F;            <span class="comment">// true  constructor属性指代这个类</span></span><br></pre></td></tr></table></figure><p>需要注意的是，示例2定义的<code>Range</code>类使用它自身的一个新对象重写预定义的<code>Range.prototype</code>对象。这个新定义的原型对象不含有<code>constructor</code>属性。因此<code>Range</code>类的实例也不含有<code>constructor</code>属性，我们可以通过补救措施来修正这个问题，显式给原型添加一个构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Range.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Range,         // 显式设置构造函数反向引用</span><br><span class="line">    includes: function(x) &#123; ... &#125;,</span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; ... &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种常见的解决办法是使用预定义的原型对象，预定义的原型对象包含<code>constructor</code>属性，然后依次给原型对象添加方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展预定义的Range.prototype对象，而不重写之</span></span><br><span class="line"><span class="comment">// 这样就自动创建Range.prototype.constructor属性</span></span><br><span class="line">Range.prototype.includes = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; ... &#125;;</span><br><span class="line">Range.prototype.foreach = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; ... &#125;;</span><br><span class="line">Range.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="三、JavaScript中Java式的类继承"><a href="#三、JavaScript中Java式的类继承" class="headerlink" title="三、JavaScript中Java式的类继承"></a>三、JavaScript中Java式的类继承</h3><p>Java或其他类似强类型面向对象语言的类可能是这个样子：</p><ul><li><p>实例字段</p><p>  它们是基于实例的属性或变量，用以保存独立对象的状态。</p></li><li><p>实例方法</p><p>  它们是类的所有实例所共享的方法，由每个独立的实例调用。</p></li><li><p>类字段</p><p>  这些属性或变量是属于类的，而不是属于类的某个实例的。</p></li><li><p>类方法</p><p>  这些方法是属于某个类的，而不是属于类的某个实例的。</p></li></ul><p>JavaScript和Java的一个不同之处在于，JavaScript中的函数都是以值的形式出现的，方法和字段之间并没有太大的区别。如果属性值是函数，那么这个属性就定义一个方法；否则，它只是一个普通的属性或“字段”。尽管存在诸多差异，我们还是可以用JavaScript模拟出Java中的这四种类成员类型。JavaScript中的类牵扯三种不同的对象，三种对象的属性的行为和下面三种类成员非常相似：</p><ul><li><p>构造函数对象</p><p>  构造函数（对象）为JavaScript的类定义了名字。任何添加到这个构造函数对象的属性都是类字段和类方法（如果属性值是函数的话就是类方法）。</p></li><li><p>原型对象</p><p>  原型对象的属性被类的所有实例所继承，如果原型对象的属性值是函数的话，这个函数就作为类的实例的方法来调用。</p></li><li><p>实例对象</p><p>  类的每个实例都是一个独立的对象，直接给这个实例定义的属性是不会为所有实例对象所共享的。定义在实例上的非函数属性，实际上是实例的字段。</p></li></ul><p>在JavaScript中定义类的步骤可以缩减为一个分三步的算法。第一步，先定义一个构造函数，并设置初始化新对象的实例属性。第二步，给构造函数的<code>prototype</code>对象定义实例的方法。第三步，给构造函数定义类字段和类属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineClass</span>(<span class="params">constructor,           <span class="regexp">//</span> 用以设置实例的属性的函数</span></span></span><br><span class="line"><span class="function"><span class="params">                    methods,                <span class="regexp">//</span> 实例的方法，复制至原型中</span></span></span><br><span class="line"><span class="function"><span class="params">                    statics</span>)                // 类属性，复制至构造函数中</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (methods) &#123;</span><br><span class="line">        extend(<span class="keyword">constructor</span>.prototype, methods);</span><br><span class="line">    &#125;</span><br><span class="line">    if (statics) &#123;</span><br><span class="line">        extend(<span class="keyword">constructor</span>, statics);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Range类的另一个实现</span><br><span class="line">var SimpleRange = defineClass(function(f, t) &#123; <span class="keyword">this</span>.f = f; <span class="keyword">this</span>.t = t; &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                includes: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; ... &#125;,</span><br><span class="line">                                toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                upto: <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SimpleRange(o, t); &#125;</span><br><span class="line">                            &#125;)</span><br></pre></td></tr></table></figure><p>尽管JavaScript可以模拟出Java式的类成员，但Java中有很多重要的特性是无法在JavaScript类中模拟的。首先，对于Java类的实例方法来说，实例字段可以用作局部变量，而不需要使用关键字<code>this</code>来引用它们。JavaScript是没办法模拟这个特性的，但可以使用<code>with</code>语句来近似地实现这个功能（但并不推荐）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Complex.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;'</span> + r + <span class="string">', '</span> + i + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中可以使用<code>final</code>声明字段为常量，并且可以将字段和方法声明为<code>private</code>，用以表示它们是私有成员且在类的外面是不可见的。在JavaScript中没有这些关键字，关于这个问题我们在后文中还会碰到：私有属性可以使用闭包里的局部变量来模拟，常量属性可以在ES5中直接实现。</p><hr><h3 id="四、类的扩充"><a href="#四、类的扩充" class="headerlink" title="四、类的扩充"></a>四、类的扩充</h3><p>JavaScript中基于原型的继承机制是动态的：对象从其原型继承属性，如果创建对象之后原型的属性发生改变，也会影响到继承这个原型的所有实例对象。这意味着我们可以通过给原型对象添加新方法来扩充JavaScript类。</p><p>JavaScript内置类的原型对象也是一样如此“开放”，也就是说可以给数字、字符串、数组、函数等数据类型添加方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">o <span class="regexp">/*, ...args */</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// bind方法的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些其他例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多次调用这个函数f，传入一个迭代数</span></span><br><span class="line"><span class="comment">// 比如，要输出hello三次</span></span><br><span class="line"><span class="comment">// var n = 3；</span></span><br><span class="line"><span class="comment">// n.times(function(n) &#123; console.log(n + 'hello'); &#125;);</span></span><br><span class="line"><span class="built_in">Number</span>.prototype.times = <span class="function"><span class="keyword">function</span>(<span class="params">f, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="built_in">Number</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        f.call(context, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不存在ES5的string.trim()方法的话，就定义它</span></span><br><span class="line"><span class="comment">// 这个方法用以除去字符串开头和结尾的空格</span></span><br><span class="line"><span class="built_in">String</span>.prototype.trim = <span class="built_in">String</span>.prototype.trim || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+/</span>|\s+$/g, <span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回函数的名字，如果它有（非标准的）name属性，则直接使用name属性</span></span><br><span class="line"><span class="comment">// 否则，将函数转换为字符串然后从中提取名字</span></span><br><span class="line"><span class="comment">// 如果是没有名字的函数，则返回一个空字符串</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name || <span class="keyword">this</span>.toString().match(<span class="regexp">/function\s*\([^()*]\(/</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以给<code>Object.prototype</code>添加方法，从而使所有的对象都可以调用这些方法。但这种做法并不推荐，因为ES5之前，无法将这些新增的方法设置为不可枚举的，如果给<code>Object.prototype</code>添加属性，这些属性是可以被<code>for/in</code>循环遍历到的。后面我们会给出一个ES5的例子，其中使用<code>Object.defineProperty()</code>方法可以安全地扩充<code>Object.prototype</code>。</p><p>然后并不是所有的宿主环境可以使用<code>Object.defineProperty()</code>，这跟ECMAScript的具体实现有关。比如在很多Web浏览器中，可以给<code>HTMLElement.prototype</code>添加方法，这样当前文档中表示HTML标记的所有对象就都可以继承这些方法。但IE则不支持这样做。</p><hr><h3 id="五、类和类型"><a href="#五、类和类型" class="headerlink" title="五、类和类型"></a>五、类和类型</h3><p>JavaScript定义了少量的数据类型：<code>null、undefined、布尔值、数字、字符串、函数和对象</code>。<code>typeof</code>运算符可以得出值的类型。然而，我们往往更希望将类作为类型来对待，这样就可以根据对象所属的类来区分它们。JavaScript语言核心中的内置对象可以根据它们的<code>class</code>属性来区分彼此。但当我们使用本文中提到的技术来定义类的话，实例对象的<code>class</code>属性都是“<code>Object</code>”，此时无法根据<code>class</code>属性进行区分。</p><p>接下来我们介绍三种用以检测任意对象的类的技术：<code>instanceof</code>运算符、<code>constructor</code>属性，以及构造函数的名字。</p><h4 id="1-instanceof"><a href="#1-instanceof" class="headerlink" title="1. instanceof"></a>1. instanceof</h4><p><code>instanceof</code>操作符左侧是待检测其类的对象，右侧是定义类的构造函数。这里的继承可以不是直接继承。如果<code>o</code>所继承的对象继承自另一个对象，后一个对象继承自<code>c.prototype</code>，<code>o instanceof c</code>值同样是<code>true</code>。</p><p>正如本文前面所讲的，构造函数是类的公共个标识，但原型是唯一的标识。尽管<code>instanceof</code>运算符的右侧是构造函数，但计算过程中实际上是检测了对象的继承关系，而不是检测创建对象的构造函数。</p><p>如果想检测对象的原型链上是否存在某个特定的原型对象，可以使用<code>isPrototypeOf()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range.methods.isPrototypeOf(r);</span><br></pre></td></tr></table></figure><p><code>instanceof</code>运算符和<code>isPrototypeOf()</code>方法的缺点是，我们无法通过对象类获得类名，只能检测对象是否属于指定的类名。</p><h4 id="2-constructor"><a href="#2-constructor" class="headerlink" title="2. constructor"></a>2. constructor</h4><p>另一种识别对象是否属于某个类的方法是使用<code>constructor</code>属性，因为构造函数是类的公共标识，所以最直接的方法就是使用<code>constructor</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeAndValue</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">switch</span>(x.constructor) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Number</span>: <span class="keyword">return</span> <span class="string">'Number: '</span> + x;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">String</span>: <span class="keyword">return</span> <span class="string">'String: '</span> + x;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Date</span>: <span class="keyword">return</span> <span class="string">'Date: '</span> + x;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">RegExp</span>: <span class="keyword">return</span> <span class="string">'RegExp: '</span> + x;</span><br><span class="line">        <span class="keyword">case</span> Complex: <span class="keyword">return</span> <span class="string">'Complex: '</span> + x; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在代码中关键字<code>case</code>后的表达式都是函数，如果改用<code>typeof</code>运算符获取到对象的<code>class</code>属性的话，它们应当改为字符串。</p><p>使用<code>constructor</code>属性检测对象属于某个类的技术的不足之处和<code>instanceof</code>一样。在多个执行上下文的场景中它是无法正常工作的。</p><p>同样，在JavaScript中也并非所有的对象都包含<code>constructor</code>属性，在每个新创建的函数原型上默认会有<code>constructor</code>属性，但我们常常会忽略原型上的<code>constructor</code>属性。</p><h4 id="3-构造函数的名称"><a href="#3-构造函数的名称" class="headerlink" title="3. 构造函数的名称"></a>3. 构造函数的名称</h4><p>使用<code>instanceof</code>和<code>constructor</code>属性来检测对象所属的类有一个主要的问题，在多个执行上下文中存在构造函数的多个副本的时候，这两种方法的检测结果会出错。多个执行上下文中的函数看起来是一模一样的，但它们是相互独立的对象，因此彼此也不相等。</p><p>一种可能的解决方案是使用构造函数的名字而不是构造函数本身作为类标识符。一个窗口里的<code>Array</code>构造函数和另一个窗口的<code>Array</code>构造函数是不相等的，但是它们的名字是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以判断值的类型的type()函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t, c, n;                    <span class="comment">// type, class, name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理null值的特殊情形</span></span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">'null'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另外一种特殊情形：NaN和它自身不相等</span></span><br><span class="line">    <span class="keyword">if</span> (o !== o) <span class="keyword">return</span> <span class="string">'nan'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果typeof的值不是“object”，则使用这个值，这可以识别出原始值的类型和函数</span></span><br><span class="line">    <span class="keyword">if</span> ((t = <span class="keyword">typeof</span> o) !== <span class="string">'object'</span>) <span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回对象的类名，除非值是“Object”，这种方式可以识别出大多数的内置对象</span></span><br><span class="line">    <span class="keyword">if</span> ((c = classof(o)) !== <span class="string">'Object'</span>) <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果对象构造函数的名字存在的话，则返回它</span></span><br><span class="line">    <span class="keyword">if</span> (o.constructor &amp;&amp; <span class="keyword">typeof</span> o.constructor === <span class="string">'function'</span> &amp;&amp; (n = o.constructor.getName())) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他的类型都无法判别，一律返回“Object”</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Object'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classof</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回函数的名字（可能是空字符串），不是函数的话返回null</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'name'</span> <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name = <span class="keyword">this</span>.toString().match(<span class="regexp">/function\s*([^(]*\()/</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种使用构造函数名字来识别对象的类的做法和使用<code>constructor</code>属性一样有一个问题：并不是所有的对象都有<code>constructor</code>属性。此外，并不是所有的函数都有名字。如果使用不带名字的函数定义表达式定义一个构造函数，<code>getName()</code>方法则会返回空字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个构造函数没有名字</span></span><br><span class="line"><span class="keyword">var</span> Complex = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.r = x;</span><br><span class="line">    <span class="keyword">this</span>.i = y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这个构造函数有名字</span></span><br><span class="line"><span class="keyword">var</span> Range = <span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">f, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.from = f;</span><br><span class="line">    <span class="keyword">this</span>.to = t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-鸭式辩型"><a href="#4-鸭式辩型" class="headerlink" title="4. 鸭式辩型"></a>4. 鸭式辩型</h4><p>上文所描述的检测对象的类的各种技术多少都会有些问题，至少在客户端JavaScript中是如此。解决办法就是规避掉这些问题：不要关注“对象的类是什么”，而是关注“对象能做什么”。这种思考问题的方式在Python和Ruby中非常普遍，成为“鸭式辩型”</p><p><strong>像鸭子一样走路、有用并且嘎嘎叫的鸟就是鸭子</strong></p><p>对于JavaScript来说，这句话可以理解为“如果一个对象可以像鸭子一样走路、游泳并且嘎嘎叫，就认为这个对象是鸭子，哪怕它并不是从鸭子类的原型对象继承而来的”。</p><p>我们拿前文中的<code>Range</code>类来举例，起初定义这个类用以描述数字的范围。但要注意，<code>Range()</code>构造函数并没有对实参进行类型检查以确保实参是数字类型。但却将参数使用“<code>&gt;</code>”运算符进行比较运算，因为这里假定它们是可比较的。同样，<code>includes()</code>方法使用“<code>&lt;=</code>”运算符进行比较，但没有对范围的结束点进行类似的假设。因为类并没有强制使用特定的类型，它的<code>includes()</code>方法可以作用于任何结束点，只要结束点可以用关系运算符执行比较运算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowercase = <span class="keyword">new</span> Range(<span class="string">'a'</span>, <span class="string">'z'</span>);</span><br><span class="line"><span class="keyword">var</span> thisYear = <span class="keyword">new</span> Range(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2009</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2010</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><code>Range</code>类的<code>foreach()</code>方法中也没有显式的检测表示范围的结束点的类型，但<code>Math.ceil()</code>和“<code>++</code>”运算符表明它只能对数字结束点进行操作。</p><p>另外一个例子，我们之前讨论的类数组对象。在很多场景下，我们并不知道一个对象是否真的是<code>Array</code>实例，当然是可以通过判断是否包含非负的<code>length</code>属性来得知是否是<code>Array</code>的实例。我们说“包含一个值是非负整数的length”是数组的一个特性——“会走路”，任何具有“会走路”这个特征的对象都可以当作数组来对待。然而必须要了解的是，真正数组的<code>length</code>属性具有一些独有的行为：当添加新元素时，数组的长度会自动更新，并且当给<code>length</code>属性设置一个更小的整数时，数组会被自动截断。我们说这些特征是“会游泳”和“嘎嘎叫”。如果所实现的代码需要“会游泳”且能“嘎嘎叫”，则不能使用只“会走路”的类似数组的对象。</p><p>上文所讲到的鸭式辩型的例子提到了进行对象的“<code>&lt;</code>”运算符的职责以及<code>length</code>属性的特殊行为。但当我们提到鸭式辩型时，往往是说检测对象是否实现了一个或多个方法。一个强类型的<code>triathlon()</code>函数所需要的参数必须是<code>TriAthlete</code>对象。而一中“鸭式辩型”式的做法是，只要对象包含<code>walk()</code>、<code>swin()</code>和<code>bike()</code>这三个方法就可以作为参数传入。同里，可以重新设计<code>Range</code>类，使用结束点对象的<code>compareTo()</code>和<code>succ()</code>方法来替代“<code>&lt;</code>”和“<code>++</code>”运算符。</p><p>鸭式辩型的实现方法让人感觉太“放任自流”：仅仅是假设输入对象实现了必要的方法，根本没有执行进一步的检查。如果输入对象没有遵循“假设”，那么当代吗试图调用那些不存在的方法时就会报错。另一种实现方法是对输入对象进行检查。但不是检查它们的类，而是用适当的名字来检查它们所实现的方法。这样可以将非法输入尽可能早地拦截在外，并可给出带有更多提示信息的报错。</p><p>下文示例中按照鸭式辩型的理念定义了<code>quacks()</code>函数。<code>quacks()</code>函数用以检查一个对象是否实现了剩下参数所表示的方法。对于除第一个参数外的每个参数，如果是字符串的话则直接检查是否存在以它命名的方法；如果是对象的话则检查第一个对象中的方法是否在这个对象中也具有同名的方法；如果参数是函数，则假定它是构造函数，函数将检查第一个对象实现的方法是否在构造函数的原型对象中也具有同名的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用鸭式辩型实现的函数</span></span><br><span class="line"><span class="comment">// 如果o实现了除第一个参数之外的参数所表示的方法，则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quacks</span>(<span class="params">o <span class="regexp">/*, ...*/</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> arg = <span class="built_in">arguments</span>[i];</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">typeof</span> arg) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> o[arg] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span>  <span class="string">'function'</span>:</span><br><span class="line">                arg = arg.prototype;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'objet'</span>:</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> m <span class="keyword">in</span> arg) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg[m] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> o[m] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个<code>quacks()</code>函数还有一些地方是需要尤为注意的。首先，这里只是通过特定的名称来检测对象是否含有一个或多个值为函数的属性。我们无法得知这些已经存在的属性的细节信息，如果，函数是干什么用的？它们需要多少参数？参数类型是什么？然而这是鸭式辩型的本质所在，如果使用鸭式辩型而不是强制的类型检测的方式定义API，那么创建的API应当更具灵活性才可以，这样才能确保你提供给用户的API更加安全可靠。关于<code>quacks()</code>函数还有另一问题需要注意，就是它不能应用于内置类。比如，不能通过<code>quacks(o, Array)</code>来检测o是否实现了<code>Array</code>中所有同名的方法。原因是内置类的方法都是不可枚举的，<code>quacks()</code>中的<code>for/in</code>循环无法遍历到它们（注意，ES5中有一个补救办法，就是使用<code>Object.getOwnPropertyNames()</code>）。</p><hr><h3 id="六、JavaScript中的面向对象技术"><a href="#六、JavaScript中的面向对象技术" class="headerlink" title="六、JavaScript中的面向对象技术"></a>六、JavaScript中的面向对象技术</h3><p>到目前为止，我们讨论了JavaScript中类的基础知识：原型对象的重要性、它和构造函数之间的联系、<code>instanceof</code>运算符如何工作等。下面我们举一个例子，介绍如何利用JavaScript中的类进行编程。</p><h4 id="1-集合类"><a href="#1-集合类" class="headerlink" title="1. 集合类"></a>1. 集合类</h4><p>集合（<code>set</code>）是一种数据结构，用以表示非重复值的无序集合。集合的基础方法包括添加值、检测值是否在集合中，这种集合需要一种通用的实现，以保证操作效率。JavaScript的对象是属性名以及与之对应的值的基本集合。因此将对象只用做字符串的集合是大材小用。下面的例子实现了一个更加通用的<code>Set</code>类，它实现了从JavaScript值到唯一字符串的映射，然后将字符串用作属性名。对象和函数都不具备如此简明可靠的唯一字符串表示。因此集合类必须给集合中的每一个对象或函数定义一个唯一的属性标识。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;                        <span class="comment">// 这是一个构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.valus = &#123;&#125;;                    <span class="comment">// 集合数据保存在对象的属性里</span></span><br><span class="line">    <span class="keyword">this</span>.n = <span class="number">0</span>;                         <span class="comment">// 集合中值的个数</span></span><br><span class="line">    <span class="keyword">this</span>.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);    <span class="comment">// 把所有的参数都添加进这个集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;    <span class="comment">// 遍历每个参数</span></span><br><span class="line">        <span class="keyword">var</span> val = <span class="built_in">arguments</span>[i];                     <span class="comment">// 待添加到集合中的值</span></span><br><span class="line">        <span class="keyword">var</span> str = <span class="built_in">Set</span>._v2s(val);                    <span class="comment">// 把它转换为字符串</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.values.hasOwnProperty(str)) &#123;     <span class="comment">// 如果不在集合中</span></span><br><span class="line">            <span class="keyword">this</span>.values[str] = val;                 <span class="comment">// 将字符串和值对应起来</span></span><br><span class="line">            <span class="keyword">this</span>.n++;                               <span class="comment">// 集合中值的计数加一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;                                    <span class="comment">// 支持链式方法调用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> str= <span class="built_in">Set</span>._v2s(<span class="built_in">arguments</span>[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.values.hasOwnProperty(str)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>.values[str];</span><br><span class="line">            <span class="keyword">this</span>.n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.prototype.contains = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.values.hasOwnProperty(<span class="built_in">Set</span>._v2s(value));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.prototype.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合中的所有元素，在指定的上下文中调用f</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.foreach = <span class="function"><span class="keyword">function</span>(<span class="params">f, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> s <span class="keyword">in</span> <span class="keyword">this</span>.values) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.values.hasOwnproperty(s)) &#123;</span><br><span class="line">            f.call(context, <span class="keyword">this</span>.values[s]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个内部函数，用以将任意JavaScript值和唯一的字符串对应起来</span></span><br><span class="line"><span class="built_in">Set</span>._v2s = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (val) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">undefined</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'u'</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">null</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'n'</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'t'</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'f'</span>;</span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="keyword">switch</span>(<span class="keyword">typeof</span> val) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'#'</span> + val;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'"'</span> + val;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'@'</span> + objectId(val);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对任意对象来说，都会返回一个字符串</span></span><br><span class="line">    <span class="comment">// 针对不同的对象，这个函数会返回不同的字符串</span></span><br><span class="line">    <span class="comment">// 对于同一个对象的多次调用，总是返回相同的字符串</span></span><br><span class="line">    <span class="comment">// 为了做到这一点，它给o创建了一个属性，在ES5中，这个属性是不可枚举且只读的</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">objectId</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> prop = <span class="string">"|**objectid**|"</span>;        <span class="comment">// 私有属性，用以存放id</span></span><br><span class="line">        <span class="keyword">if</span> (!o.hasOwnProperty(prop)) &#123;      <span class="comment">// 如果对象没有id</span></span><br><span class="line">            o[prop] = <span class="built_in">Set</span>._v2s.next++;      <span class="comment">// 将下一个值赋给它</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>._v2s.next = <span class="number">100</span>;                        <span class="comment">// 设置初始id的值</span></span><br></pre></td></tr></table></figure><h4 id="2-枚举类型"><a href="#2-枚举类型" class="headerlink" title="2. 枚举类型"></a>2. 枚举类型</h4><p>枚举类型（<code>enumerated type</code>）是一种类型，它是值的有限集合，如果值定义为这个类型则该值是可列出的。<code>Enum</code>是ES5中的保留字，很有可能在将来JavaScript就会内置支持枚举类型。</p><p>下文示例中包含一个单独函数<code>enumeration()</code>。但它不是构造函数，它并没有定义一个名叫“<code>enumeration</code>”的类。相反，它是一个工厂方法，每次调用它都会创建并返回一个新的类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用4个值创建新的Coin类：Coin、Penny、Coin.Nickel等</span></span><br><span class="line"><span class="keyword">var</span> Coin = enumeration(&#123;<span class="attr">Penny</span>: <span class="number">1</span>, <span class="attr">Nickel</span>: <span class="number">5</span>, <span class="attr">Dime</span>: <span class="number">10</span>, <span class="attr">Quarter</span>: <span class="number">25</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> c = Coin.Dime;                          <span class="comment">// 这是新类的实例</span></span><br><span class="line">c <span class="keyword">instanceof</span> Coin;                          <span class="comment">// true  instanceof正常工作</span></span><br><span class="line">c.constructor == Coin;                      <span class="comment">// true  构造函数的属性正常工作</span></span><br><span class="line">Coin.Quarter + <span class="number">3</span> * Coin.Nicker;             <span class="comment">// 40  将值转换为数字</span></span><br><span class="line">Coin.Dime == <span class="number">10</span>;                            <span class="comment">// true  更多转换为数字的例子</span></span><br><span class="line">Coin.Dime &gt; Coin.Nickel;                    <span class="comment">// true  关系运算符正常工作</span></span><br><span class="line"><span class="built_in">String</span>(Coin.Dime) + <span class="string">':'</span> + Coin.Dime;        <span class="comment">// "Dime:10"  强制转换为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数创建一个新的枚举类型，实参对象表示类的每个实例的名字和值</span></span><br><span class="line"><span class="comment">// 返回值是一个构造函数，它标识这个新类</span></span><br><span class="line"><span class="comment">// 注意，这个构造函数也会抛出易畅：不能使用它来创建该类型的新实例</span></span><br><span class="line"><span class="comment">// 返回的构造函数包含名值对的映射表</span></span><br><span class="line"><span class="comment">// 包括由值组成的数组，以及一个foreach()迭代器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumeration</span>(<span class="params">namesToValues</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这个虚拟的构造函数是返回值</span></span><br><span class="line">    <span class="keyword">var</span> enumeration = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="string">"Can't Instantiate Enumerations"</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举值继承自这个对象</span></span><br><span class="line">    <span class="keyword">var</span> proto = enumeration.prototype = &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: enumeration,</span><br><span class="line">        toString: function() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;,</span><br><span class="line">        valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.value; &#125;,</span><br><span class="line">        toJSON: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    enumeration.values = [];                <span class="comment">// 用以存放枚举对象的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在创建新类型的实例</span></span><br><span class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> namesToValues) &#123;           <span class="comment">// 遍历每个值</span></span><br><span class="line">        <span class="keyword">var</span> e = inherit(proto);             <span class="comment">// 创建一个代表它的对象</span></span><br><span class="line">        e.name = name;                      <span class="comment">// 给它一个名字</span></span><br><span class="line">        e.value = namesToValues[name];      <span class="comment">// 给它一个值</span></span><br><span class="line">        enumeration[name] = e;              <span class="comment">// 将它设置为构造函数的属性</span></span><br><span class="line">        enumeration.values.push(e);         <span class="comment">// 将它存储到值数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个类方法，用来对类的实例进行迭代</span></span><br><span class="line">    enumeration.foreach = <span class="function"><span class="keyword">function</span>(<span class="params">f, c</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.values.length; i++) &#123;</span><br><span class="line">            f.call(c, <span class="keyword">this</span>.values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回标识这个新类型的构造函数</span></span><br><span class="line">    <span class="keyword">return</span> enumeration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用这个枚举类型来实现一个“<code>hello world</code>”小程序的话，就可以使用枚举类型来表示一副扑克牌。</p><figure class="highlight javascript"><figcaption><span>使用枚举类型来表示一副扑克牌</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Card</span>(<span class="params">suit, rank</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.suit = suit;                       <span class="comment">// 每张牌都有花色</span></span><br><span class="line">    <span class="keyword">this</span>.rank = rank;                       <span class="comment">// 以及点数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举类型定义花色和点数</span></span><br><span class="line">Card.Suit = enumeration(&#123;<span class="attr">Clubs</span>: <span class="number">1</span>, <span class="attr">Diamonds</span>: <span class="number">2</span>, <span class="attr">Hearts</span>: <span class="number">3</span>, <span class="attr">Spades</span>: <span class="number">4</span>&#125;);</span><br><span class="line">Card.Rank = enumeration(&#123;<span class="attr">Two</span>: <span class="number">2</span>, <span class="attr">Three</span>: <span class="number">3</span>, <span class="attr">Four</span>: <span class="number">4</span>, <span class="attr">Five</span>: <span class="number">5</span>, <span class="attr">Six</span>: <span class="number">6</span>, </span><br><span class="line">                        Seven: <span class="number">7</span>, <span class="attr">Eight</span>: <span class="number">8</span>, <span class="attr">Nine</span>: <span class="number">9</span>, <span class="attr">Ten</span>: <span class="number">10</span>,</span><br><span class="line">                        Jack: <span class="number">11</span>, <span class="attr">Queen</span>: <span class="number">12</span>, <span class="attr">King</span>: <span class="number">13</span>, <span class="attr">Ace</span>: <span class="number">14</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用以描述牌面的文本</span></span><br><span class="line">Card.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.rank.toString() + <span class="string">' of '</span> + <span class="keyword">this</span>.suit.toString();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较扑克牌中两张牌的大小</span></span><br><span class="line">Card.prototype.compareTo = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rank &lt; that.rank) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rank &gt; that.rank) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以扑克牌的玩法规则对牌进行排序的函数</span></span><br><span class="line">Card.orderByRank = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.compareTo(b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以桥牌的玩法规则对扑克牌进行排序的函数</span></span><br><span class="line">Card.orderBySuit = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.suit &lt; b.suit) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.suit &gt; b.suit) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.rank &lt; b.rank) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.rank &gt; b.rank) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用以表示一副标准扑克牌的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deck</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cards = <span class="keyword">this</span>.cards = [];            <span class="comment">// 一副牌就是由牌组成的数组</span></span><br><span class="line">    Card.Suit.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;         <span class="comment">// 初始化这个数组</span></span><br><span class="line">        Card.Rank.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">            cars.push(<span class="keyword">new</span> Card(s, r));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 洗牌的方法：重新洗牌并返回洗好的牌</span></span><br><span class="line">Deck.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历数组中的每个元素，随机找出牌面最小的元素，并与之（当前遍历的元素）交换</span></span><br><span class="line">    <span class="keyword">var</span> deck = <span class="keyword">this</span>.cards, len = deck.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>)), temp;      <span class="comment">// 随机数</span></span><br><span class="line">        temp = deck[i], deck[i] = deck[r], deck[r] = temp;      <span class="comment">// 交换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发牌的方法：返回牌的数组</span></span><br><span class="line">Deck.prototype.deal = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cards.length &lt; n)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'Out of cards'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cards.splice(<span class="keyword">this</span>.cards.length - n, n);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一副新扑克牌，洗牌并发牌</span></span><br><span class="line"><span class="keyword">var</span> deck = (<span class="keyword">new</span> Deck()).shuffle();</span><br><span class="line"><span class="keyword">var</span> hand = deck.deal(<span class="number">13</span>).sort(Card.orderBySuit);</span><br></pre></td></tr></table></figure><h4 id="3-标准转换方法"><a href="#3-标准转换方法" class="headerlink" title="3. 标准转换方法"></a>3. 标准转换方法</h4><p>对象类型转换时，有一些方法是在需要做类型转换时由JavaScript解释器自动调用的。不需要为定义的每个类都实现这些方法，但这些方法的确非常重要，如果没有为自定义的类实现这些方法，也应当是有意为之，而不应当因为疏忽而漏掉了它们。</p><p>最重要的方法首当<code>toString()</code>，这个方法的作用是返回一个可以表示这个对象的字符串。在希望使用字符串的地方用到对象的话（比如将对象用作属性名或使用“<code>+</code>”运算符来进行字符串连接运算），JavaScript会自动调用这个方法。如果没有实现这个方法，类会默认从<code>Object.prototype</code>中继承<code>toString()</code>方法，这个方法的运算结果是“<code>[object Object]</code>”，这个字符串用处不大。<code>toString()</code>方法应当返回一个可读的字符串，这样最终用户才能将这个输出值利用起来，然而有时候并不一定非要如此，不管怎样，可以返回可读字符串的<code>toString()</code>方法也会让程序调试变得更加轻松。</p><p><code>toLocaleString()</code>和<code>toString()</code>类似：<code>toLocaleString()</code>是以本地敏感性(<code>locale-sensitive</code>)的方式来将对象转换为字符串。默认情况下，对象所继承的<code>toLocaleString()</code>方法只是简单地调用<code>toString()</code>方法。有一些内置类型包含有用的<code>toLocaleString()</code>方法用以实际上返回本地化相关的字符串。如果需要为对象到字符串的转换定义<code>toString()</code>方法，那么同样需要定义<code>toLocaleString()</code>方法用以处理本地化的对象到字符串的转换。</p><p>第三个方法是<code>valueOf()</code>，它用来将对象转换为原始值。比如，当数学运算符（除了“<code>+</code>”运算符）和关系运算符作用于数字文本表示的对象时，会自动调用<code>valueOf()</code>方法。大多数对象都没有合适的原始值来表示它们，也没有定义这个方法。</p><p>第四个方法是<code>toJSON()</code>，这个方法是由<code>JSON.stringify()</code>自动调用的。JSON格式用于序列化良好的数据结构，而且可以处理JavaScript原始值、数组和纯对象。它和类无关，当对一个对象执行序列化操作时，它会忽略对象的原型和构造函数。比如将<code>Range</code>对象或<code>Complex</code>对象作为参数传入<code>JSON.stringify()</code>，会返回诸如<code>{&quot;form&quot;: 1, &quot;to&quot;: 3}</code>或<code>{&quot;r&quot;: 1, &quot;i&quot;: -1}</code>这种字符串。如果将这些字符串传入<code>JSON.parse()</code>，则会得到一个和<code>Range</code>对象和<code>Complex</code>对象具有相同属性的纯对象，但这个对象不会包含从<code>Range</code>和<code>Complex</code>继承来的方法。</p><p>上文实例中的<code>Set</code>类并没有定义上述方法中的任何一个，JavaScript中没有哪个原始值可以表示集合，因此也没有必要定义<code>valueOf()</code>方法，但该类应当包含<code>toString()</code>、<code>toLocaleString()</code>和<code>toJSON()</code>方法。可以用如下代码来实现，注意<code>extend()</code>函数的用法，这里使用<code>extend()</code>来向<code>Set.prototype</code>来添加方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将这些方法添加至Set类的原型对象中</span></span><br><span class="line">extend(<span class="built_in">Set</span>.prototype, &#123;</span><br><span class="line">    <span class="comment">// 将集合转换为字符串</span></span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> s = <span class="string">"&#123;"</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            s += ((i++ &gt; <span class="number">0</span>) ? <span class="string">", "</span>: <span class="string">""</span>) + v;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 类似toString，但是对于所有的值都将调用toLocaleString()</span></span><br><span class="line">    toLocaleString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> s = <span class="string">"&#123;"</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i++ &gt; <span class="number">0</span>) s += <span class="string">', '</span>;</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="literal">null</span>) s+= v;               <span class="comment">// null和undefined</span></span><br><span class="line">            <span class="keyword">else</span> s += v.toLocaleString();       <span class="comment">// 其他情况</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 将集合转换为值数组</span></span><br><span class="line">    toArray: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = [];</span><br><span class="line">        <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            a.push(v);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于要从JSON转换为字符串的集合都将被当作数组来对待</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.toJSON = <span class="built_in">Set</span>.prototype.toArray;</span><br></pre></td></tr></table></figure><h4 id="4-比较方法"><a href="#4-比较方法" class="headerlink" title="4. 比较方法"></a>4. 比较方法</h4><p>JavaScript的相等运算符比较对象时，比较的是引用而不是值。也就是说，给定两个对象引用，如果要看它们是否指向同一个对象，不是检查这两个对象是否具有相同的属性名和相同的属性值，而是直接比较这两个单独的对象是否相等，或者比较它们的顺序（就像“<code>&lt;</code>”和“<code>&gt;</code>”运算符进行的比较一样）。如果定义一个类，并且希望比较类的实例，应该定义合适的方法来执行比较操作。</p><p>为了能让自定义类的实例具备比较的功能，定义一个名叫<code>equals()</code>实例方法，这个方法只能接收一个实参，如果这个实参和调用此方法的对象相等的话则返回<code>true</code>。当然，这里所说的相等的含义是根据类的上下文来决定的。相对简单的类，可以通过简单地比较它们的<code>constructor</code>属性来确保两个对象是相同类型，然后比较两个对象的实例属性以保证它们的值相等。我们可以轻易地为<code>Range</code>类也实现类似的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Range类重写它的constructor属性，现在将它添加进去</span></span><br><span class="line">Range.prototype.constructor = Range;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个Range对象和其他不是Range的对象均不相等</span></span><br><span class="line"><span class="comment">// 当且仅当两个范围的端点相等，它们才相等</span></span><br><span class="line">Range.prototype.equals = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (that == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">// 处理null和undefined</span></span><br><span class="line">    <span class="keyword">if</span> (that.constructor !== Range)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">// 处理非Range对象</span></span><br><span class="line">    <span class="comment">// 当且仅当两个端点相等，才返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.from == that.from &amp;&amp; <span class="keyword">this</span>.to == that.to;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给<code>Set</code>类定义<code>equals()</code>方法稍微有些复杂，不能简单地比较两个集合的<code>values</code>属性，还要进行更深层次的比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.equals = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 一些次要情况的快捷处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> === that)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果that对象不是一个集合，它和this不相等</span></span><br><span class="line">    <span class="comment">// 我们用到了instanceof，使得这个方法可以用于Set的任何子类</span></span><br><span class="line">    <span class="comment">// 如果希望采用鸭式辩型的方法，可以降低检查的严格成都</span></span><br><span class="line">    <span class="comment">// 或者可以通过this.constructor == that.constructor来加强检查的严格程度</span></span><br><span class="line">    <span class="comment">// 注意，null和undefined两个值是无法用于instanceof运算的</span></span><br><span class="line">    <span class="keyword">if</span> (!(that <span class="keyword">instanceof</span> <span class="built_in">Set</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果两个集合的大小不一样，则它们不相等</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size() != that.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在检查两个集合中的元素是否完全一样</span></span><br><span class="line">    <span class="comment">// 如果两个集合不相等，则通过抛出异常来终止foreach循环</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!that.contains(v))</span><br><span class="line">                <span class="keyword">throw</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;                            <span class="comment">// 所有的元素都匹配，则两个集合相等</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x === <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">// 如果集合中有元素在另外一个集合中不存在</span></span><br><span class="line">        <span class="keyword">throw</span> x;                                    <span class="comment">// 重新抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于某些类来说，往往需要比较一个实例“大于”或者“小于”另外一个实例。比如，我们可能会基于<code>Range</code>对象的下边界来定义实例的大小关系。枚举类型可以根据名字的字母表顺序来定义实例的大小，也可以根据它包含的数值来定义大小，另一方面，<code>Set</code>对象其实是无法排序的。</p><p>如果将对象用于JavaScript的关系比较运算符，比如“<code>&lt;</code>”和“<code>&gt;</code>”，JavaScript会首先调用对象<code>valueOf()</code>方法，如果这个方法返回一个原始值，则直接比较原始值。上文中的<code>enumeration()</code>方法所返回的枚举类型包含<code>valueOf()</code>方法，因此可以使用关系运算符对它们做有意义的比较。但大多数类并没有<code>valueOf()</code>方法，为了按照显式定义的规则来比较这些类型的对象，可以定义一个名叫<code>compareTo()</code>的方法。</p><p><code>compareTo()</code>方法应当只能接收一个参数，这个方法将这个参数和调用它的对象进行比较。如果<code>this</code>对象小于参数对象，<code>compareTo()</code>应当返回比0小的值。如果<code>this</code>对象大于参数对象，应当返回比0大的值。如果两个对象相等，应该返回0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Range.prototype.compareTo = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.from - that.from;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文提到的<code>equals()</code>方法对其参数执行了类型检查，如果参数类型不合法则返回<code>false</code>。<code>compareTo()</code>方法并没有返回一个表示“这两个值不能比较”的值，由于<code>compareTo()</code>没有对参数做任何类型检查，因此如果给<code>compareTo()</code>方法传入错误类型的参数，往往会抛出异常。</p><p>注意，如果两个范围对象的下边界相等，为<code>Range</code>类定义的<code>compareTo()</code>方法会返回0。这意味着就<code>compareTo()</code>而言，任何两个起始点相同的<code>Range</code>对象都相等。这个相等概念的定义和<code>equals()</code>方法定义的相等概念是相背的，<code>equals()</code>要求两个端点均相等才算相等。最好将<code>Range</code>类的<code>equals()</code>和<code>compareTo()</code>方法中处理相等的逻辑保持一致。这里是<code>Range</code>类修正后的<code>compareTo()</code>方法，它的比较逻辑和<code>equals()</code>保持一致，但当传入不可比较的值时仍然会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据下边界来对Range对象排序，如果下边界相等则比较上边界</span></span><br><span class="line"><span class="comment">// 如果传入非Range值，则抛出异常</span></span><br><span class="line"><span class="comment">// 当且仅当this.equals(that)时，才返回0</span></span><br><span class="line">Range.prototype.compareTo = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(that <span class="keyword">instanceof</span> Range)) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Can't compare a Range with "</span> + that);</span><br><span class="line">    <span class="keyword">var</span> diff = <span class="keyword">this</span>.from - that.from;           <span class="comment">// 比较下边界</span></span><br><span class="line">    <span class="keyword">if</span> (diff == <span class="number">0</span>)</span><br><span class="line">        diff = <span class="keyword">this</span>.to - that.to;               <span class="comment">// 如果相等，比较上边界</span></span><br><span class="line">    <span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-方法借用"><a href="#5-方法借用" class="headerlink" title="5. 方法借用"></a>5. 方法借用</h4><p>JavaScript中的方法没有什么特别：无非是一些简单的函数，赋值给了对象的属性，可以通过对象来调用它。一个函数可以赋值给两个属性，然后作为两个方法来调用它。比如，我们在Set类中就这样做了，将<code>toArray()</code>方法创建了一个副本，并让它可以和<code>toJSON()</code>方法一样完成同样的功能。</p><p>多个类中的方法可以共用一个单独的函数。比如，<code>Array</code>类通常定义了一些内置方法，如果定义了一个类，它的实例是数组类的对象，则可以从<code>Array.prototype</code>中将函数复制至所定义的类的原型对象中，如果以经典的面向对象语言的视角来看JavaScript的话，把一个类的方法用到其他的类中的做法也称作“多重继承”（<code>multiple inheritance</code>）。然而，JavaScript并不是经典的面向对象语言，我们更倾向于将这种方法重用称作为“方法借用”（<code>borrowing</code>）。</p><p>不仅<code>Array</code>的方法可以借用，还可以自定义泛型方法（<code>generic method</code>）。比如我们定义泛型方法<code>toString()</code>和<code>equals()</code>，可以被<code>Range</code>、<code>Complex</code>和<code>Card</code>这些简单的类使用。如果<code>Range</code>类没有定义<code>equals()</code>方法，可以这样借用泛型方法<code>equals()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range.prototype.equals = generic.equals;</span><br></pre></td></tr></table></figure><p>注意，<code>generic.equals()</code>只会执行浅比较，因此这个方法并不适用于其实例太复杂的类，它们的实例属性通过其<code>equals()</code>方法指代对象。同样需要注意，这个方法包含一些特殊情况的程序逻辑，以处理新增至<code>Set</code>对象中的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generic = &#123;</span><br><span class="line">    <span class="comment">// 返回一个字符串，这个字符串包含构造函数的名字（如果构造函数包含名字）</span></span><br><span class="line">    <span class="comment">// 以及所有非继承来的、非函数属性的名字和值</span></span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> s = <span class="string">'['</span>;</span><br><span class="line">        <span class="comment">// 如果这个对象包含构造函数，且构造函数包含名字</span></span><br><span class="line">        <span class="comment">// 这个名字会作为返回字符串的一部分</span></span><br><span class="line">        <span class="comment">// 需要注意的是，函数的名字属性是非标准的，并不是在所有的环境中都可用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.constructor &amp;&amp; <span class="keyword">this</span>.constructor.name) &#123;</span><br><span class="line">            s += <span class="keyword">this</span>.constructor.name + <span class="string">': '</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举所有非继承的属性</span></span><br><span class="line">        <span class="keyword">var</span> n = o;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.hasOwnProperty(name))</span><br><span class="line">                <span class="keyword">continue</span>;                           <span class="comment">// 跳过继承的属性</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> value = <span class="keyword">this</span>[name];</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;                           <span class="comment">// 跳过方法</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n++) &#123;</span><br><span class="line">                s += <span class="string">', '</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s += name + <span class="string">'='</span> + value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">']'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过比较this和that的构造函数和实例属性来判断它们是否相等</span></span><br><span class="line">    <span class="comment">// 这种方法只适合于那些实例属性是原始值的情况，原始值可以通过“===”来比较</span></span><br><span class="line">    <span class="comment">// 这里还处理一中特殊情况，就是忽略由Set类添加的特殊属性</span></span><br><span class="line">    equals: <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (that == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.constructor !== that.constructor)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name === <span class="string">'|**objectid**'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;                               <span class="comment">// 跳过特殊属性</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.hasOwnProperty(name))</span><br><span class="line">                <span class="keyword">continue</span>;                               <span class="comment">// 跳过继承来的属性</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[name] !== that[name])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">// 比较是否相等</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                                   <span class="comment">// 如果所有属性都匹配，两个对象相等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-私有状态"><a href="#6-私有状态" class="headerlink" title="6. 私有状态"></a>6. 私有状态</h4><p>在经典的面向对象编程中，经常需要将对象的某个状态封装或隐藏在对象内，只有通过对象的方法才能访问这些状态，对外只暴露一些重要的状态变量可以直接读写。为了实现这个目的，类似Java的编程语言允许声明类的“私有”实例字段，这些私有实例字段只能被类的实例方法访问，且在类的外部是不可见的。</p><p>我们可以通过将变量（或参数）闭包在一个构造函数内来模拟实现私有实例字段，调用构造函数会创建一个实例。为了做到这一点，需要在构造函数内定义一个函数（因此这个函数可以访问构造函数内部的参数和变量），并将这个函数赋值给新创建对象的属性。下文实例展示了对<code>Range</code>类的另一种封装，新版的类的实例包含<code>from()</code>和<code>to()</code>方法用以返回范围的端点，而不是用<code>from</code>和<code>to</code>属性来获取端点。这里的<code>from()</code>和<code>to()</code>方法是定义在每个<code>Range</code>对象上的，而不是从原型中继承来的。其他的<code>Range</code>方法还是和之前一样定义在原型中，但获取端点的方式从之前直接从属性读取变成了通过<code>from()</code>和<code>to()</code>方法来读取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不要将端点保存为对象的属性，相反，定义存取器函数来返回端点的值</span></span><br><span class="line">    <span class="comment">// 这些值都保存在闭包中</span></span><br><span class="line">    <span class="keyword">this</span>.from = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">from</span>; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.to = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> to; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型上的方法无法直接操作端点</span></span><br><span class="line"><span class="comment">// 它们必须调用存取器方法</span></span><br><span class="line">Range.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Range,</span><br><span class="line">    includes: function(x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.from() &lt;= x &amp;&amp; x &lt;= <span class="keyword">this</span>.to();</span><br><span class="line">    &#125;,</span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from()), max = <span class="keyword">this</span>.to(); x &lt;= max; x++) &#123;</span><br><span class="line">            f(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.from() + <span class="string">'...'</span> + <span class="keyword">this</span>.to() + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个新的<code>Range</code>类定义了用以读取范围端点的方法，但没有定义设置端点的方法或属性。这让类的实例看起来是不可修改的，如果使用正确的话，一旦创建<code>Range</code>对象，端点数据就不可修改了。除非使用ES5中的某些特性，但<code>from</code>和<code>to</code>属性依然是可写的，并且<code>Range</code>对象实际上并不是真正不可修改的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Range(<span class="number">1</span>, <span class="number">5</span>);                    <span class="comment">// 一个不可修改的范围</span></span><br><span class="line">r.from = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                               <span class="comment">// 通过方法替换来修改它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但要注意的是，这种封装技术造成了更多的系统开销，使用闭包来封装类的状态的类一定会比不使用封装的状态变量的等价类运行速度更慢，并占用更多内存。</p><h4 id="7-构造函数的重载和工厂方法"><a href="#7-构造函数的重载和工厂方法" class="headerlink" title="7. 构造函数的重载和工厂方法"></a>7. 构造函数的重载和工厂方法</h4><p>有时候，我们希望对象的初始化有多种方式。比如，我们想通过半径和角度（极坐标）来初始化一个<code>Complex</code>对象，而不是通过实部和虚部来初始化，或者通过元素组成的数组来初始化一个<code>Set</code>对象，而不是通过传入构造函数的参数来初始化它。</p><p>有一个方法可以实现，通过重载（<code>overload</code>）这个构造函数来让它根据传入的参数的不同来执行不同的初始化方法。下面就是重载<code>Set</code>构造函数的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.values = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.n = o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">1</span> &amp;&amp; isArrayLike(<span class="built_in">arguments</span>[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">this</span>.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">this</span>.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码所定义的<code>Set</code>构造函数可以显式将一组元素作为参数列表传入，也可以传入元素组成的数组。但是这个构造函数有多义性，如果集合的某个成员是一个数组就无法通过这个构造函数来创建这个集合了（为了做到这一点，需要创建一个空集合，然后显式调用<code>add()</code>方法）。</p><p>在使用极坐标来初始化复数的例子中，实际上并没有看到有函数重载。代表复数两个纬度的数字都是浮点数，除非给构造函数传入第三个参数，否则构造函数无法识别到底传入的是极坐标参数还是直角坐标参数。相反，可以写一个工厂方法——一个类的方法用以返回类的一个实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Complex.polar = <span class="function"><span class="keyword">function</span>(<span class="params">r, theta</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Complex(r * <span class="built_in">Math</span>.cos(theta), r * <span class="built_in">Math</span>.sin(theta));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.fromArray = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    s = <span class="keyword">new</span> <span class="built_in">Set</span>();                      <span class="comment">// 创建一个空集合</span></span><br><span class="line">    s.add.apply(s, a);                  <span class="comment">// 将数组a的成员作为参数传入add()方法</span></span><br><span class="line">    <span class="keyword">return</span> s;                           <span class="comment">// 返回这个新集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以给工厂方法定义任意的名字，不同名字的工厂方法用以执行不同的初始化。但由于构造函数是类的公有标识，因此每个类只能有一个构造函数。但这并不是一个“必须遵守”的规则。在JavaScript中是可以定义多个构造函数继承自一个原型对象的，如果这样做的话，由这些构造函数的任意一个所创建的对象都属于同一类型（并不推荐这种技术）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set类的一个辅助构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SetFromArray</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Set</span>.apply(<span class="keyword">this</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SetFromArray.prototype = <span class="built_in">Set</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> SetFromArray([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">s <span class="keyword">instanceof</span> <span class="built_in">Set</span>;                       <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h3 id="七、子类"><a href="#七、子类" class="headerlink" title="七、子类"></a>七、子类</h3><p>在面向对象编程中，类B可以继承自另外一个类<code>A</code>。我们将<code>A</code>称为父类（<code>superclass</code>），将<code>B</code>称为子类（<code>subclass</code>）。<code>B</code>的实例从<code>A</code>继承了所有的实例方法。类<code>B</code>可以定义自己的实例方法，有些方法可以重载<code>A</code>中的同名方法，如果<code>B</code>的方法重载了<code>A</code>中的方法，<code>B</code>中的重载方法可能会调用<code>A</code>中的重载方法，这种做法称为“方法链”（<code>method chaining</code>）。同样，子类的构造函数<code>B()</code>有时候需要调用父类的构造函数<code>A()</code>，这种做法称为“构造函数链”（<code>constructor chaining</code>）。子类还可以有子类，当涉及类的层次结构时，往往需要定义抽象类（<code>abstract class</code>）。抽象类中定义的方法没有实现。抽象类中的抽象方法是在抽象类的具体子类中实现的。</p><p>在JavaScript中创建子类的关键之处在于，采用合适的方法对原型对象进行初始化。如果类<code>B</code>继承自类<code>A</code>，<code>B.prototype</code>必须是<code>A.prototype</code>的后嗣。<code>B</code>的实例继承自<code>B.prototype</code>，后者也同样继承自<code>A.prototype</code>。本节将对刚才提到的子类相关的术语做一一讲解，还会介绍类继承的替代方案：“组合”（<code>composition</code>）。</p><p>我们从上文的<code>Set</code>类开始讲解，本节将会讨论如何定义子类，如果实现构造函数链并重载方法，如果使用组合来代替继承，以及最后如果通过抽象类从实现中提炼出接口。</p><h4 id="1-定义子类"><a href="#1-定义子类" class="headerlink" title="1. 定义子类"></a>1. 定义子类</h4><p>JavaScript的对象可以从类的原型对象中继承属性（通常继承的是方法）。如果<code>O</code>是类<code>B</code>的实例，<code>B</code>是<code>A</code>的子类，那么<code>O</code>也一定从<code>A</code>中继承了属性。为此，首先要确保<code>B</code>的原型对象继承自<code>A</code>的原型对象。通过<code>inherit()</code>函数，可以这样实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.prototype = inherit(A.prototype);             <span class="comment">// 子类派生自父类</span></span><br><span class="line">B.prototype.constructor = B;                    <span class="comment">// 重载继承来的constructor属性</span></span><br></pre></td></tr></table></figure><p>这两行代码是在JavaScript中创建子类的关键。如果不这样做，原型对象仅仅是一个普通对象，它只继承自<code>Object.prototype</code>，这意味着我们的类和所有的类一样是<code>Object</code>的子类。如果将这两行代码添加至<code>defineClass()</code>函数中，可以将它变成<code>defineSubClass()</code>函数和<code>Function.prototype.extend()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineSubClass</span>(<span class="params">superclass,             <span class="regexp">//</span> 父类的构造函数</span></span></span><br><span class="line"><span class="function"><span class="params">                        constructor,            <span class="regexp">//</span> 新的子类的构造函数</span></span></span><br><span class="line"><span class="function"><span class="params">                        methods,                <span class="regexp">//</span> 实例方法：复制至原型中</span></span></span><br><span class="line"><span class="function"><span class="params">                        statics</span>)                 // 类属性：复制至构造函数中</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 建立子类的原型对象</span></span><br><span class="line">    <span class="keyword">constructor</span>.prototype = inherit(superclass.prototype);</span><br><span class="line">    <span class="keyword">constructor</span>.prototype.<span class="keyword">constructor</span> = <span class="keyword">constructor</span>;</span><br><span class="line"></span><br><span class="line">    //像对常规类一样复制方法和类属性</span><br><span class="line">    if (methods) &#123;</span><br><span class="line">        extend(<span class="keyword">constructor</span>.prototype, methods);</span><br><span class="line">    &#125;</span><br><span class="line">    if (statics) &#123;</span><br><span class="line">        extend(<span class="keyword">constructor</span>, statics);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="keyword">constructor</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 也可以通过父类构造函数的方法来做到这一点</span><br><span class="line">Function.prototype.extend = function(<span class="keyword">constructor</span>, methods, statics) &#123;</span><br><span class="line">    <span class="keyword">return</span> defineSubClass(<span class="keyword">this</span>, <span class="keyword">constructor</span>, methods, statics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下文实例中展示了不使用<code>defineSubClass()</code>函数如何“手动”实现子类。这里定义了<code>Set</code>的子类<code>SingletonSet</code>。<code>SingletonSet</code>是一个特殊的集合，它是只读的，而且含有单独的常量成员。</p><figure class="highlight javascript"><figcaption><span>Singleton 一个简单的子类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SingletonSet</span>(<span class="params">member</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.member = member;                   <span class="comment">// 记住集合中这个唯一的成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个原型对象，这个原型对象继承自Set的原型</span></span><br><span class="line">SingletonSet.prototype = inherit(<span class="built_in">Set</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给原型添加属性</span></span><br><span class="line"><span class="comment">// 如果有同名的属性就覆盖Set.prototype中的同名属性</span></span><br><span class="line">extend(Singleton.prototype, &#123;</span><br><span class="line">    <span class="comment">// 设置合适的constructor属性</span></span><br><span class="line">    <span class="keyword">constructor</span>: SingletonSet,</span><br><span class="line">    // 这个集合是只读的，调用add()和remove()都会报错</span><br><span class="line">    add: function() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'read-only set'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'read-only set'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// SingletonSet的实例中永远只有一个元素</span></span><br><span class="line">    size: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 这个方法只调用一次，传入这个集合的唯一成员</span></span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f, context</span>) </span>&#123;</span><br><span class="line">        f.call(context, <span class="keyword">this</span>.member);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// contains()方法非常简单：只须检查传入的值是否匹配这个集合唯一的成员即可</span></span><br><span class="line">    contains: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x === <span class="keyword">this</span>.member;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的<code>SingletonSet</code>类是一个比较简单的实现，它包含5个简单的方法定义。它实现了5个核心的<code>Set</code>方法，但从它的父类中继承了<code>toString()</code>、<code>toArray()</code>和<code>equals()</code>方法。定义子类就是为了继承这些方法。比如，<code>Set</code>类的<code>equals()</code>方法用来对<code>Set</code>实例进行比较，只要<code>Set</code>的实例包含<code>size()</code>和<code>foreach()</code>方法，就可以通过<code>equals()</code>比较。因为<code>SingletonSet</code>是<code>Set</code>的子类，所以它自动继承了<code>equals()</code>的实现，不用再实现一次。当然，如果想要最简单的实现方式，那么给<code>SingletonSet</code>类定义它自己的<code>equals()</code>版本会更高效一些</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SingletonSet.prototype.equals = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> that <span class="keyword">instanceof</span> <span class="built_in">Set</span> &amp;&amp; that.size() == <span class="number">1</span> &amp;&amp; that.contains(<span class="keyword">this</span>.member);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>SingletonSet</code>不是将<code>Set</code>中的方法列表静态地借用过来，而是动态地从<code>Set</code>类继承方法。如果给<code>Set.prototype</code>添加新的方法，<code>Set</code>和<code>SingletonSet</code>的所有实例就会立即拥有这个方法（假定<code>Singleton</code>没有定义与之同名的方法）。</p><h4 id="2-构造函数和方法链"><a href="#2-构造函数和方法链" class="headerlink" title="2. 构造函数和方法链"></a>2. 构造函数和方法链</h4><p>前文中<code>SingletonSet</code>类定义了全新的集合实现，而且将它继承自其父类的和新方法全部替换。然而定义子类时，我们往往希望对付类的行为进行修改或扩充，而不是完全替换掉它们。为了做到这一点，构造函数和子类的方法需要调用或链接到父类构造函数和父类方法。</p><p>下文示例对此做了展示。它定义了<code>Set</code>的子类<code>NonNullSet</code>，它不允许<code>null</code>和<code>undefined</code>作为它的成员。为了使用这种方式对成员做限制，<code>NonNullSet</code>需要在其<code>add()</code>方法中对<code>null</code>和<code>undefined</code>值做检测。但它需要完全重新实现一个<code>add()</code>方法，因此它调用父类中的这个方法。注意，<code>NonNullSet()</code>构造函数同样不需要重新实现，它只须将它的参数传入父类构造函数（作为函数来调用它，而不是通过构造函数来调用），通过父类的构造函数来初始化新创建的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NonNullSet是Set的子类，它的成员不能是null和undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NonNullSet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 仅链接到父类，作为普通函数调用父类的构造函数来初始化通过该构造函数调用创建的对象</span></span><br><span class="line">    <span class="built_in">Set</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将NonNullSet设置为Set的子类</span></span><br><span class="line">NonNullSet.prototype = inherit(<span class="built_in">Set</span>.prototype);</span><br><span class="line">NonNullSet.prototype.constructor = NonNullSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了将null和undefined排除在外，只须重写add()方法</span></span><br><span class="line">NonNullSet.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数是不是null或undefined</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>[i] == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Can't add null or undefined to a NonNullSet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类的add()方法以执行实际插入操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Set</span>.prototype.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们将这个非<code>null</code>集合的概念推而广之，称为“过滤后的集合”，这个集合中的成员必须首先传入一个过滤函数再执行添加操作。为此，定义一个类工厂函数，传入一个过滤函数，返回一个新的<code>Set</code>子类。实际上，可以对此做进一步的通用化的处理，定义一个可以接收两个参数的类工厂：子类和用于<code>add()</code>方法的过滤函数。这个工厂方法称为<code>filteredsetSubclass()</code>，并通过这样的方法来使用它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个只能保存字符串的“集合”类</span></span><br><span class="line"><span class="keyword">var</span> StringSet = filteredSetSubclass(<span class="built_in">Set</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个集合类的成员不能是null、undefined或函数</span></span><br><span class="line"><span class="keyword">var</span> MySet = filteredSetSubclass(NonNullSet, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x !== <span class="string">'function'</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>下文示例是这个类工厂的实现代码，注意，这个例子中的方法链和构造函数链和<code>NonNullSet</code>中的实现是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数返回具体的Set类的子类，并重写该类的add()方法用以对添加的元素做特殊的处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filteredSetSubclass</span>(<span class="params">superclass, filter</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 子类构造函数</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">constructor</span> = function() &#123;</span><br><span class="line">        <span class="comment">// 调用父类构造函数</span></span><br><span class="line">        superclass.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> proto = <span class="keyword">constructor</span>.prototype = inherit(superclass.prototype);</span><br><span class="line">    proto.<span class="keyword">constructor</span> = <span class="keyword">constructor</span>;</span><br><span class="line">    proto.add = function() &#123;</span><br><span class="line">        <span class="comment">// 在添加任何成员之前首先使用过滤器将所有参数进行过滤</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> v = <span class="built_in">arguments</span>[i];</span><br><span class="line">            <span class="keyword">if</span> (!filter(v))</span><br><span class="line">                <span class="keyword">throw</span> (<span class="string">'value '</span> + v + <span class="string">' rejected by filter'</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用父类的add()方法</span></span><br><span class="line">        superclass.prototype.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">constructor</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，值得强调的是，类似这种创建类工厂的能力是JavaScript语言动态特性的一个体现，类工厂是一种强大和有用的特性，这在Java和C++等语言中是没有的。</p><h4 id="3-组合vs子类"><a href="#3-组合vs子类" class="headerlink" title="3. 组合vs子类"></a>3. 组合vs子类</h4><p>在前文中，定义的集合可以根据特定的标准对集合成员进行限制，而且使用了子类的技术来实现这种功能，所创建的自定义子类使用了特定的过滤函数来对集合中的成员做限制。父类和过滤函数的每个组合都需要创建一个新的类。</p><p>然而还有另一种更好的方法来完成这种需求，即面向对象编程中一条广为人知的设计原则：“组合优于继承”。这样，可以利用组合的原理定义一个新的集合实现，它“包装”了另外一个集合对象，在将受限制的成员过滤掉之后会用到这个（包装的）集合对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现一个FilteredSet，它包装某个指定的“集合”对象，</span></span><br><span class="line"><span class="comment">并对传入add()方法的值应用了某种指定的过滤器</span></span><br><span class="line"><span class="comment">“范围”类中其他所有的和新方法延续到包装后的实例中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> FilteredSet = <span class="built_in">Set</span>.extend(</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">FilteredSet</span>(<span class="params">set, filter</span>) </span>&#123;         </span><br><span class="line">        <span class="keyword">this</span>.set = set;</span><br><span class="line">        <span class="keyword">this</span>.filter = filter;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实例方法</span></span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//　如果已有过滤器，直接使用它</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.filter) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> v = <span class="built_in">arguments</span>[i];</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.filter(v))</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'FilteredSet: value '</span> + v + <span class="string">' rejected by filter.'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用set中的add()方法</span></span><br><span class="line">            <span class="keyword">this</span>.set.add.apply(<span class="keyword">this</span>.set, <span class="built_in">arguments</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 剩下的方法都保持不变</span></span><br><span class="line">        remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.set.remove.apply(<span class="keyword">this</span>.set, <span class="built_in">arguments</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        contains: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.set.contains(v);</span><br><span class="line">        &#125;,</span><br><span class="line">        size: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.set.size();</span><br><span class="line">        &#125;,</span><br><span class="line">        foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f, c</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.set.foreach(f, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在这个例子中使用组合的一个好处是，只须创建一个单独的<code>FilteredSet</code>子类即可。可以利用这个类的实例来创建任意带有成员限制的集合实例。比如，不用上文中定义的<code>NonNullSet</code>类，可以这样做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> FilteredSet(<span class="keyword">new</span> <span class="built_in">Set</span>(), <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x !== <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>甚至还可以对已经过滤后的集合进行过滤</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> FilteredSet(s, &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(x <span class="keyword">instanceof</span> <span class="built_in">Set</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-类的层次结构和抽象类"><a href="#4-类的层次结构和抽象类" class="headerlink" title="4. 类的层次结构和抽象类"></a>4. 类的层次结构和抽象类</h4><p>在上节中给出了“组合优于继承”的原则，但为了将这条原则阐述清除，创建了<code>Set</code>的子类。这样做的原因是最终得到的类是<code>Set</code>的实例，它会从<code>Set</code>继承有用的辅助方法，比如<code>toString()</code>和<code>equals()</code>。尽管这是一个很实际的原因，但不用创建类似<code>Set</code>类这种具体类的子类也可以很好的用组合来实现“范围”。上文中的<code>SingletonSet</code>类可以有另外一种类似的实现，这个类还是继承自<code>Set</code>，因此它可以继承很多辅助方法，但它的实现和其父类的实现完全不一样。<code>SingletonSet</code>并不是<code>Set</code>类的专用版本，而是完全不同的另一种<code>Set</code>。在类层次结构中<code>SingletonSet</code>和<code>Set</code>应当是兄弟关系，而非父子关系。</p><p>不管是在经典的面向对象语言中还是在JavaScript中，通行的解决办法是“从实现中抽离出接口”。假定定义了一个<code>AbstractSet</code>类，其中定义了一些辅助方法比如<code>toString()</code>，但并没有实现诸如<code>foreach()</code>这样的和新方法。这样，实现的<code>Set</code>、<code>SingletonSet</code>和<code>FilteredSet</code>都是这个抽象类的子类，<code>FilteredSet</code>和<code>SingletonSet</code>都不必再实现某个不相关的类的子类了。</p><p>下文示例在这个思路上更进一步，定义了一个层次结构的抽象的集合类。<code>AbstractSet</code>只定义了一个抽象方法：<code>contains()</code>。任何类只要“声称”自己是一个表示范围的类，就必须至少定义这个<code>contains()</code>方法。然后，定义<code>AbstractSet</code>的子类<code>AbstractEnumerableSet</code>。这个类增加了抽象的<code>size()</code>和<code>foreach()</code>方法，而且定义了一些有用的非抽象方法（<code>toString()</code>、<code>toArray()</code>、<code>equals()</code>等），<code>AbstractEnumerableSet</code>并没有定义<code>add()</code>和<code>remove()</code>方法，它只代表只读集合。<code>SingletonSet</code>可以实现为非抽象子类。最后，定义了<code>AbstractEnumerableSet</code>的子类<code>AbstractWritableSet</code>。这个<code>final</code>抽象集合定义了抽象方法<code>add()</code>和<code>remove()</code>，并实现了诸如<code>union()</code>和<code>intersection()</code>等非具体方法，这两个方法调用了<code>add()</code>和<code>remove()</code>。<code>AbstractWritableSet</code>是<code>Set</code>和<code>FilteredSet</code>类相应的父类。但这个例子中并没有实现它，而是实现了一个新的名叫<code>ArraySet</code>的非抽象类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可用作任何抽象方法，非常方便</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abstractmethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'abstract method'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AbstractSet类定义了一个抽象方法 contains()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AbstractSet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Can't instantiate abstract classes"</span>);</span><br><span class="line">&#125;</span><br><span class="line">AbstractSet.prototype.contains = abstractmethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NotSet是AbstractSet的一个非抽象子类</span></span><br><span class="line"><span class="comment">所有不在其他集合中的成员都在这个集合中</span></span><br><span class="line"><span class="comment">因为它是在其他集合是不可写的条件下定义的</span></span><br><span class="line"><span class="comment">同时由于它的成员是无限个，因此它是不可枚举的</span></span><br><span class="line"><span class="comment">我们只能用它来检测元素成员的归属情况</span></span><br><span class="line"><span class="comment">注意，我们使用了Function.prototype.extend()方法来快捷定义这个子类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> NotSet = Abstract.extend(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">NotSet</span>(<span class="params">set</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set = set;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        contains: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="keyword">this</span>.set.contains(x);</span><br><span class="line">        &#125;,</span><br><span class="line">        toString: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'~'</span> + <span class="keyword">this</span>.set.toString();</span><br><span class="line">        &#125;,</span><br><span class="line">        equals: <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that <span class="keyword">instanceof</span> NotSet &amp;&amp; <span class="keyword">this</span>.set.equals(that.set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AbstractEnumerableSet是AbstractSet的一个抽象子类</span></span><br><span class="line"><span class="comment">它定义了抽象方法size()和foreach()</span></span><br><span class="line"><span class="comment">然后实现了非抽象方法isEmpty()、toArray()、to[Locale]String()和equals()方法</span></span><br><span class="line"><span class="comment">子类实现了contains()、size()和foreach()，这三个方法可以很轻易地调用这5个非抽象方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> AbstractEnumerableSet = AbstractSet.extend(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Can't instantiate abstract classes"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        size: abstractmethod,</span><br><span class="line">        foreach: abstractmethod,</span><br><span class="line">        isEmpty: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.size() == <span class="number">0</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> s = <span class="string">"&#123;"</span>, i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (i++ &gt; <span class="number">0</span>)</span><br><span class="line">                    s += <span class="string">', '</span>;</span><br><span class="line">                s += v;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> s + <span class="string">"&#125;"</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        toLocaleString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> s = <span class="string">"&#123;"</span>, i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (i++ &gt; <span class="number">0</span>)</span><br><span class="line">                    s += <span class="string">', '</span>;</span><br><span class="line">                <span class="keyword">if</span> (v == <span class="literal">null</span>)</span><br><span class="line">                    s += v;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    s += v.toLocaleString();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> s + <span class="string">"&#125;"</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        toArray: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> a = [];</span><br><span class="line">            <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                a.push(v);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;,</span><br><span class="line">        equals: <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(that <span class="keyword">instanceof</span> AbstractEnumerableSet))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 如果它们的大小不同，则它们不相等</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.size() != that.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 检查每一个元素是否也在that中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!that.contains(v))</span><br><span class="line">                        <span class="keyword">throw</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 所有的元素都匹配：集合相等</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(x) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x === <span class="literal">false</span>)</span><br><span class="line">                    <span class="comment">// 集合不相等</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 发生了其他的异常：重新抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SingletonSet是AbstractEnumerableSet的非抽象子类</span></span><br><span class="line"><span class="comment">singleton集合是只读的，它只包含一个成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> SingletonSet = AbstractEnumerableSet.extend(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SingletonSet</span>(<span class="params">member</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.member = member;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        contains: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x === <span class="keyword">this</span>.member;</span><br><span class="line">        &#125;,</span><br><span class="line">        size: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f, ctx</span>) </span>&#123;</span><br><span class="line">            f.call(ctx, <span class="keyword">this</span>.member);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AbstractWritableSet是AbstractEnumerableSet的抽象子类</span></span><br><span class="line"><span class="comment">它定义了抽象方法add()和remove()</span></span><br><span class="line"><span class="comment">然后实现了非抽象方法union()、intersection()和difference()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> AbstractWritableSet = AbstractEnumerableSet.extend(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Can't instantiate abstract classes"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        add: abstractmethod,</span><br><span class="line">        remove: abstractmethod,</span><br><span class="line">        union: <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">            that.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                self.add(v);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        intersection: <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">this</span>.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!that.contains(v))</span><br><span class="line">                    self.remove(v);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        difference: <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">            that.foreach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">                self.remove(v);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ArraySet是AbstractWritableSet的非抽象子类</span></span><br><span class="line"><span class="comment">它以数组的形式表示集合中的元素</span></span><br><span class="line"><span class="comment">对于它的contains()方法使用了数组的线性查找</span></span><br><span class="line"><span class="comment">因为contains()方法的算法复杂度是o(n)而不是o(1)</span></span><br><span class="line"><span class="comment">它非常适用于相对小型的集合，注意，这里的实现用到了ES5的数组方法indexOf()和forEach()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> ArraySet = AbstractWritableSet.extend(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ArraySet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.values = [];</span><br><span class="line">        <span class="keyword">this</span>.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        contains: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.values.indexOf(v) != <span class="number">-1</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        size: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.values.length;</span><br><span class="line">        &#125;,</span><br><span class="line">        foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f, c</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.values.forEach(f, c);</span><br><span class="line">        &#125;,</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> arg = <span class="built_in">arguments</span>[i];</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.contains(arg)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.values.push(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> p = <span class="keyword">this</span>.values.indexOf(<span class="built_in">arguments</span>[i]);</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">this</span>.values.splice(p, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="八、ES5中的类"><a href="#八、ES5中的类" class="headerlink" title="八、ES5中的类"></a>八、ES5中的类</h3><p>ES5给属性特性增加了方法支持（<code>getter</code>、<code>setter</code>、<code>可枚举性</code>、<code>可写性</code>和<code>可配置性</code>），而且增加了对象可扩展性的限制，这些方法同时非常适合用于类的定义。</p><h4 id="1-让属性不可枚举"><a href="#1-让属性不可枚举" class="headerlink" title="1. 让属性不可枚举"></a>1. 让属性不可枚举</h4><p>上文中的<code>Set</code>类使用了一个小技巧，将对象存储为“集合”的成员：它给添加至这个“集合”的任何对象定义了“对象id”属性。之后如果在<code>for/in</code>循环中对这个对象做遍历，这个新添加的属性也会遍历到。ES5中可以通过设置属性为“不可枚举”（<code>nonenumerable</code>）来让属性不会遍历到。下文示例展示了如果通过<code>Object.defineProperty()</code>来做到这一点，同时也展示了如何定义一个<code>getter</code>函数以检测对象是否是可扩展的（<code>extensible</code>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将代码包装在一个匿名函数中，这样定义的变量就在这个函数作用域内</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个不可枚举的属性objectId，它可以被所有对象继承</span></span><br><span class="line">    <span class="comment">// 当读取这个属性时调用getter函数</span></span><br><span class="line">    <span class="comment">// 它没有定义setter，因此它是只读的</span></span><br><span class="line">    <span class="comment">// 它是不可配置的，因此它是不能删除的</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'objectId'</span>, &#123;</span><br><span class="line">        get: idGetter,                              <span class="comment">// 取值器</span></span><br><span class="line">        enumerable: <span class="literal">false</span>,                          <span class="comment">// 不可枚举的</span></span><br><span class="line">        configurable: <span class="literal">false</span>                         <span class="comment">// 不可配置的</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当读取objectId的时候直接调用这个getter函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">idGetter</span>(<span class="params"></span>) </span>&#123;                           <span class="comment">// getter函数返回该id</span></span><br><span class="line">        <span class="keyword">if</span> (!(idprop <span class="keyword">in</span> <span class="keyword">this</span>)) &#123;                    <span class="comment">// 如果对象中不存在id</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Object</span>.isExtensible(<span class="keyword">this</span>))         <span class="comment">// 并且可以增加属性</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"Can't define id for nonextensible objects"</span>);</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, idprop, &#123;</span><br><span class="line">                value: nextid++,                    <span class="comment">// 给属性赋值</span></span><br><span class="line">                writable: <span class="literal">false</span>,                    <span class="comment">// 只读</span></span><br><span class="line">                enumerable: <span class="literal">false</span>,                  <span class="comment">// 不可枚举</span></span><br><span class="line">                configurable: <span class="literal">false</span>                 <span class="comment">// 不可配置</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[idprop];                        <span class="comment">// 返回已有的或新的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// idGetter()用到了这些变量，这些都属于私有变量</span></span><br><span class="line">    <span class="keyword">var</span> idprop = <span class="string">"|**objectId**|"</span>;                  <span class="comment">// 假设这个属性没有用到</span></span><br><span class="line">    <span class="keyword">var</span> nextid = <span class="number">1</span>;                                 <span class="comment">// 设置初始值</span></span><br><span class="line">&#125;)();                                               <span class="comment">// 立即执行包装函数</span></span><br></pre></td></tr></table></figure><h4 id="2-定义不可变的类"><a href="#2-定义不可变的类" class="headerlink" title="2. 定义不可变的类"></a>2. 定义不可变的类</h4><p>除了可以设置属性为不可枚举的，ES5还可以设置属性为只读的，当我们希望类的实例都是不可变的，这个特性非常有帮助。下文示例使用<code>Object.defineProperties()</code>和<code>Object.create()</code>定义不可变的<code>Range</code>类。它同样适用<code>Object.defineProperties()</code>来为类创建原型对象，并将（原型对象的）实例方法设置为不可枚举的，就像内置类的方法一样。不仅如此，它还将这些实例方法设置为“只读”和“不可删除”的，这样就可以防止对类中做任何修改。最后还展示了一个有趣的技巧，其中实现的构造函数也可以用作工厂函数，这样不论调用函数之前是否带有<code>new</code>关键字，都可以正确的创建实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法可以使用new调用，也可以省略new，它可以用作构造函数也可以用作工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这些是对from和to只读属性的描述符</span></span><br><span class="line">    <span class="keyword">var</span> props = &#123;</span><br><span class="line">        <span class="keyword">from</span>: &#123;</span><br><span class="line">            value: <span class="keyword">from</span>,</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            writable: <span class="literal">false</span>,</span><br><span class="line">            configurable: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        to: &#123;</span><br><span class="line">            value: to,</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            writable: <span class="literal">false</span>,</span><br><span class="line">            configurable: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Range) &#123;                            <span class="comment">// 如果作为构造函数使用</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperties(<span class="keyword">this</span>, props);               <span class="comment">// 定义属性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                <span class="comment">// 如果作为工厂方法来调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(Range.prototype, props);       <span class="comment">// 返回新Range对象，并由props指定属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用同样的方法给Range.prototype对象添加属性</span></span><br><span class="line"><span class="comment">// 那么我们需要给这些属性设置它们的特性</span></span><br><span class="line"><span class="comment">// 因为我们无法识别出它们的可枚举性、可写性或可配置性，这些属性特性默认都是false</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(Range.prototype, &#123;</span><br><span class="line">    includes: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; ... &#125; </span><br><span class="line">    &#125;,</span><br><span class="line">    foreach: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; ... &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代码示例中用到了<code>Object.defineProperties()</code>和<code>Object.create()</code>来定义不可变的和不可枚举的属性。这两个方法非常强大，但属性描述符对象让代码的可读性变得更差。另一种改进的做法是将修改这个已定义属性的特性的操作定义为一个工具函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将o的指定名字（或所有）的属性设置为不可写的和不可配置的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">freezeProps</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> props = (<span class="built_in">arguments</span>.length == <span class="number">1</span>)                 <span class="comment">// 如果只有一个参数</span></span><br><span class="line">        ? <span class="built_in">Object</span>.getOwnPropertyNames(o)                 <span class="comment">// 使用所有的属性</span></span><br><span class="line">        : <span class="built_in">Array</span>.prototype.splice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);    <span class="comment">// 否则传入了指定名字的属性</span></span><br><span class="line">    props.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;                         <span class="comment">// 将它们都设置为只读的和不可变的</span></span><br><span class="line">        <span class="comment">// 忽略不可配置的属性</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Object</span>.getOwnPropertyDescriptor(o, n).configurable)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(o, n, &#123;</span><br><span class="line">            writable: <span class="literal">false</span>,</span><br><span class="line">            configurable: <span class="literal">false</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> o;                                           <span class="comment">// 我们可以继续使用o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将o的指定名字（或所有）的属性设置为不可枚举的和可配置的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hideProps</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> props = (<span class="built_in">arguments</span>.length == <span class="number">1</span>)                 <span class="comment">// 如果只有一个参数</span></span><br><span class="line">        ? <span class="built_in">Object</span>.getOwnPropertyNames(o)                 <span class="comment">// 使用所有的属性</span></span><br><span class="line">        : <span class="built_in">Array</span>.prototype.splice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);    <span class="comment">// 否则传入了指定名字的属性</span></span><br><span class="line">    props.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)) </span>&#123;                        <span class="comment">// 将它们设置为不可枚举的</span></span><br><span class="line">        <span class="comment">// 忽略不可配置的属性</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Object</span>.getOwnPropertyDescriptor(o, n).configurable) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(o, n, &#123; <span class="attr">enumerable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>可以用来创建新属性，也可以修改已有属性的特性。当用它们创建新属性时，默认的属性特性的值都是<code>false</code>。但当用它们修改已经存在的属性时，默认的属性特性依然保持不变。</p><p>使用这些工具函数，就可以充分利用ES5的特性来实现一个不可变的类，而且不用动态地修改这个类。下文示例的<code>Range</code>类就用到刚才定义的工具函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;                              <span class="comment">// 不可变的类Range的构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.from = <span class="keyword">from</span>;</span><br><span class="line">    <span class="keyword">this</span>.to = to;</span><br><span class="line">    freezeProps(<span class="keyword">this</span>);                                  <span class="comment">// 将属性设置为不可变的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Range.prototype = hideProps(&#123;                           <span class="comment">// 使用不可枚举的属性来定义原型</span></span><br><span class="line">    <span class="keyword">constructor</span>: Range,</span><br><span class="line">    includes: function(x) &#123; ... &#125;,</span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; ... &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-封装对象状态"><a href="#3-封装对象状态" class="headerlink" title="3. 封装对象状态"></a>3. 封装对象状态</h4><p>构造函数中的变量和参数可以用作它创建的对象的私有状态，该方法在ES3中的一个缺点是，访问这些私有状态的存取器方法是可以替换的，在ES5中可以通过定义属性<code>getter</code>和<code>setter</code>方法将状态变量更健壮地封装起来，这两个方法是无法删除的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个版本的Range类是可变的，但将端点变量进行了良好的封装</span></span><br><span class="line"><span class="comment">// 但端点的大小顺序还是固定的：from &lt;= to</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果from &gt; to</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">from</span> &gt; to)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Range: from must be &lt;= to"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义存取器方法以维持不变</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getFrom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">from</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setFrom</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f &lt;= to)</span><br><span class="line">            <span class="keyword">from</span> = f;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Range: from must be &lt;= to"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setTo</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= <span class="keyword">from</span>) </span><br><span class="line">            to = t;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Range: from must be &lt;= to"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将使用取值器的属性设置为可枚举的、不可配置的</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(<span class="keyword">this</span>, &#123;</span><br><span class="line">        <span class="keyword">from</span>: &#123;</span><br><span class="line">            get: getFrom,</span><br><span class="line">            set: setFrom,</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        to: &#123;</span><br><span class="line">            get: getTo,</span><br><span class="line">            set: setTo,</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和前面的例子比，原型对象没有做任何修改</span></span><br><span class="line"><span class="comment">// 实例方法可以像读取普通的属性一样读取from和to</span></span><br><span class="line">Range.prototype = hideProps(&#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Range,</span><br><span class="line">    includes: function(x) &#123; ... &#125;,</span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123; ... &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-防止类的扩展"><a href="#4-防止类的扩展" class="headerlink" title="4. 防止类的扩展"></a>4. 防止类的扩展</h4><p>通常认为，通过给原型对象添加方法可以动态地对类进行扩展，这是JavaScript本身的特性。ES5可以根据需要对此特性加以限制。<code>Object.preventExtension()</code>方法可以将对象设置为不可扩展的，也就是说不能给对象添加任何新属性。<code>Object.seal()</code>则更加强大，它除了能阻止用户给对象添加新属性，还能将当前已有的属性设置为不可配置的，这样就不能删除属性了（但不可配置的属性可以是可写的，也可以转换为只读属性）。可以通过这样一句简单的代码来阻止对<code>Object.prototype</code>的扩展</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.seal(<span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure><p>JavaScript的另外一个动态特性是“对象的方法可以随时替换”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> original_sort_method = <span class="built_in">Array</span>.prototype.sort;</span><br><span class="line"><span class="built_in">Array</span>.prototype.sort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    original_sort_method.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Array sort took "</span> + (end - start) + <span class="string">" milliseconds"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以通过将实例方法设置为只读来防止这类修改，一种方法是使用上面代码所定义的<code>freezeProps()</code>工具函数，另外一种方法是使用<code>Object.freeze()</code>，它的功能和<code>Object.seal()</code>完全一样，它同样会把所有属性都设置为只读的和不可配置的。</p><p>理解类的只读属性的特性至关重要。如果对象<code>o</code>继承了只读属性<code>p</code>，那么给<code>o.p</code>的赋值操作将会失败，就不会给<code>o</code>创建新属性。如果你想重写一个继承来的只读属性，就必须使用<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>或<code>Object.create()</code>来创建这个新属性。也就是说，如果将类的实例方法设置为只读的，那么重写它的子类的方法的难度会更大。</p><p>这种锁定原型对象的做法往往没有必要，但的确有一些场景是需要阻止对象的扩展的。回想一下前文的<code>enumeration()</code>，这是一个类工厂函数。这个函数将枚举类型的每个实例都保存在构造函数对象的属性里，以及构造函数的<code>values</code>数组中。这些属性和数组是表示枚举类型实例的正式实例列表，是可以执行“冻结”（<code>freezing</code>）操作的，这样就不能给它添加新的实例，已有的实例也无法删除或修改。可以给<code>enumeration()</code>函数添加几行简单的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.freeze(enumeration.values);</span><br><span class="line"><span class="built_in">Object</span>.freeze(enumeration);</span><br></pre></td></tr></table></figure><p>需要注意的是，通过在枚举类型中调用<code>Object.freeze()</code>，示例中定义的<code>objectId</code>属性之后也无法使用了。这个问题的解决办法是，在枚举类型被“冻结”之前读取一次它的<code>objectId</code>属性（调用潜在的存取器方法并设置其内部属性）。</p><h4 id="5-子类和ES5"><a href="#5-子类和ES5" class="headerlink" title="5. 子类和ES5"></a>5. 子类和ES5</h4><p>下文示例中使用ES5的特性来实现子类，这里使用上文中<code>AbstractWritableSet</code>类来做进一步说明，来定义这个类的子类<code>StringSet</code>。下面这个例子的最大特点是使用<code>Object.create()</code>创建原型对象，这个原型对象继承自父类的原型，同时给新创建的对象定义属性。这种实现方法的困难之处在于，正如上文说提到的，它需要使用难看的属性描述符。</p><p>这个例子中另外一个有趣之处在于，使用<code>Object.create()</code>创建对象时传入了参数<code>null</code>，这个创建的对象没有继承任何成员。这个对象用来存储集合的成员，同时，这个对象没有原型，这样我们就能对它直接使用<code>in</code>操作符，而不须使用<code>hasOwnProperty()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringSet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.set = <span class="built_in">Object</span>.create(<span class="literal">null</span>);                     <span class="comment">// 创建一个不包含原型的对象</span></span><br><span class="line">    <span class="keyword">this</span>.n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，使用Object.create()可以继承父类的原型</span></span><br><span class="line"><span class="comment">// 而且可以定义单独调用的方法，因为我们没有指定属性的可写性、可枚举性和可配置性</span></span><br><span class="line"><span class="comment">// 因此这些属性特性的默认值都是false</span></span><br><span class="line"><span class="comment">// 只读方法让这个类难于子类化（被继承）</span></span><br><span class="line">StringSet.prototype = <span class="built_in">Object</span>.create(AbstractWritableSet.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: StringSet</span><br><span class="line">    &#125;,</span><br><span class="line">    contains: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> x <span class="keyword">in</span> <span class="keyword">this</span>.set;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    size: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    foreach: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">f, c</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.set).forEach(f, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    add: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(<span class="built_in">arguments</span>[i] <span class="keyword">in</span> <span class="keyword">this</span>.set)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.set[<span class="built_in">arguments</span>[i]] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">this</span>.n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    remove: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">arguments</span>[i] <span class="keyword">in</span> <span class="keyword">this</span>.set) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> <span class="keyword">this</span>.set[<span class="built_in">arguments</span>[i]];</span><br><span class="line">                    <span class="keyword">this</span>.n--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="6-属性描述符"><a href="#6-属性描述符" class="headerlink" title="6. 属性描述符"></a>6. 属性描述符</h4><p>本节给出一个例子，用来讲述基于ES5如何对属性描述进行各种操作，下文示例中给<code>Object.prototype</code>添加了<code>properties()</code>方法（这个方法是不可枚举的）。这个方法的返回值是一个对象，用以表示属性的列表，并定义了有用的方法用来输出属性和属性特性（对于调试非常有用），用来获得属性描述符（当复制属性同时复制属性特性时非常有用）以及用来设置属性的特性（是上文定义的<code>hideProps()</code>和<code>freezeProps()</code>函数不错的替代方案）。这个例子展示了ES5的大多数属性相关的特性，同时使用了一种模块编程技术。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给Object.prototype定义properties()方法，</span></span><br><span class="line"><span class="comment">这个方法返回一个表示调用它的对象上的属性名列表的对象</span></span><br><span class="line"><span class="comment">（如果不带参数调用它，就表示该对象的所有属性）</span></span><br><span class="line"><span class="comment">返回的对象定义了4个有用的方法：toString()、descriptors()、hide()和show()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">namespace</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这个函数成为所有对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">properties</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> names;                                      <span class="comment">// 属性名组成的数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">0</span>)                      <span class="comment">// 所有的自有属性</span></span><br><span class="line">            names = <span class="built_in">Object</span>.getOwnPropertyNames(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">1</span> &amp;&amp; <span class="built_in">Array</span>.isArray(<span class="built_in">arguments</span>[<span class="number">0</span>]))</span><br><span class="line">            names = <span class="built_in">arguments</span>[<span class="number">0</span>];                       <span class="comment">// 名字组成的数组</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            names = <span class="built_in">Array</span>.prototype.splice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个新的Properties对象，用以表示属性名字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Properties(<span class="keyword">this</span>, names);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将它设置为Object.prototype的新的不可枚举的属性</span></span><br><span class="line">    <span class="comment">// 这是从私有函数作用域导出的唯一一个值</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'properties'</span>, &#123;</span><br><span class="line">        value: properties,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个构造函数是由上面的properties()函数所调用的</span></span><br><span class="line">    <span class="comment">// Properties类表示一个对象的属性集合</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Properties</span>(<span class="params">o, names</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.o = o;                                     <span class="comment">// 属性所属的对象</span></span><br><span class="line">        <span class="keyword">this</span>.names = names;                             <span class="comment">// 属性的名字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将代表这些属性的对象设置为不可枚举的</span></span><br><span class="line">    Properties.prototype.hide = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> o = <span class="keyword">this</span>.o, </span><br><span class="line">        hidden = &#123;</span><br><span class="line">            enumerable: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.names.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o.hasOwnProperty(n)) &#123;</span><br><span class="line">                <span class="built_in">Object</span>.defineProperty(o, n, hidden);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将这些属性设置为只读的和不可配置的</span></span><br><span class="line">    Properties.prototype.freeze = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> o = <span class="keyword">this</span>,</span><br><span class="line">        frozen = &#123;</span><br><span class="line">            writable: <span class="literal">false</span>,</span><br><span class="line">            configurable: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.names.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o.hasOwnProperty(n)) &#123;</span><br><span class="line">                <span class="built_in">Object</span>.defineProperty(o, n, frozen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个对象，这个对象是名字到属性描述符的映射表</span></span><br><span class="line">    <span class="comment">// 使用它来复制属性，连同属性特性一起复制</span></span><br><span class="line">    <span class="comment">// Object.defineProperties(dest, src.properties().descriptors());</span></span><br><span class="line">    Properties.prototype.descriptors = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> o = <span class="keyword">this</span>.o,</span><br><span class="line">        desc = &#123;&#125;;</span><br><span class="line">        <span class="keyword">this</span>.names.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!o.hasOwnProperty(n))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            desc[n] = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, n);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个格式化良好的属性列表</span></span><br><span class="line">    <span class="comment">// 列表中包含名字、值和属性特性，使用“permanent”表示不可配置</span></span><br><span class="line">    <span class="comment">// 使用“readonly”表示不可写，使用“hidden”表示不可枚举</span></span><br><span class="line">    <span class="comment">// 普通的可枚举、可写和可配置属性不包含特性列表</span></span><br><span class="line">    Properties.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> o = <span class="keyword">this</span>.o;</span><br><span class="line">        <span class="keyword">var</span> lines = <span class="keyword">this</span>.names.map(nameToString);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;\n "</span> + lines.join(<span class="string">",\n "</span>) + <span class="string">"\n&#125;"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">nameToString</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> s = <span class="string">""</span>,</span><br><span class="line">            desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, n);</span><br><span class="line">            <span class="keyword">if</span> (!desc) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"nonexistent "</span> + n + <span class="string">": undefined"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!desc.configurable) &#123;</span><br><span class="line">                s += <span class="string">"permanent "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((!desc.get &amp;&amp; !desc.set) || !desc.writable) &#123;</span><br><span class="line">                s += <span class="string">"readonly "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!desc.enumerable) &#123;</span><br><span class="line">                s += <span class="string">"hidden "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (desc.get || desc.set) &#123;</span><br><span class="line">                s += <span class="string">"accessor "</span> + n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s += n + <span class="string">": "</span> + ((<span class="keyword">typeof</span> desc.value == <span class="string">'function'</span>) ? <span class="string">'function'</span> : desc.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，将原型对象中的实例方法设置为不可枚举的</span></span><br><span class="line">    <span class="comment">// 这里用到了刚定义的方法</span></span><br><span class="line">    Properties.prototype.properties().hide();</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><hr><h3 id="九、模块"><a href="#九、模块" class="headerlink" title="九、模块"></a>九、模块</h3><p>将代码组织到类中的一个重要原因是，让代码更加“模块化”，可以在很多不同场景中实现代码的重用。但类不是唯一的模块化代码的方式。一般来讲，模块是一个独立的JavaScript文件。模块文件可以包含一个类定义、一组相关的类、一个实用函数库或者是一些待执行的代码。只要以模块的形式编写代码，任何JavaScript代码段就可以当作是一个模块。</p><p>很多JavaScript库和客户端编程框架都包含一些模块系统，CommonJS服务器端JavaScript标准规范创建了一个模块规范，后者同样使用<code>require()</code>函数，这种模块系统通常用来处理模块加载和依赖性管理。</p><p>模块化的目标是支持大规模的程序开发，处理分散源中代码的组装，并且能让代码正确运行，哪怕包含了作者所不期望出现的模块代码，也可以正确执行代码。为了做到这一点，不同的模块必须避免修改全局执行上下文，因此后续模块应当在它们所期望运行的原始（或接近原始）上下文中执行。这实际上意味着模块应当尽可能少地定义全局标识，理想状况是，所有模块都不应当定义超过一个（全局标识）。接下来我们给出的一中简单的方法可以做到这一点，</p><h4 id="1-用作命名空间的对象"><a href="#1-用作命名空间的对象" class="headerlink" title="1. 用作命名空间的对象"></a>1. 用作命名空间的对象</h4><p>在模块创建过程中避免污染全局变量的一种方法是使用一个对象作为命名空间。它将函数和值作为命名空间并将属性存储起来（可以通过全局变量引用），而不是定义全局函数和变量。例如我们前文定义的<code>Set</code>类，它定义了一个全局构造函数<code>Set()</code>。然后给这个类定义了很多实例方法，但将这些实例方法存储为<code>Set.prototype</code>的属性，因此这些方法不是全局的。示例代码里也包含一个<code>_v2s()</code>工具函数，但也没有定义它为全局函数，而是把它存储为<code>Set</code>的属性。</p><p>模块的作者并不知道他的模块会和哪些其他模块一起工作，因此尤为注意这种命名空间的用法带来的命名冲突。然而，使用这个模块的开发者是知道它用了哪些模块、用到了哪些名字的。程序员并不一定要严格遵守命名空间的写法，只需要将常用的值“导入”到全局命名空间中。我们如果要经常使用<code>sets</code>命名空间中的<code>Set</code>类，可以这样导入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Set</span> = sets.Set;                             <span class="comment">// 将Set导入到全局命名空间中</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);                       <span class="comment">// 这样每次使用就不必加set前缀了</span></span><br></pre></td></tr></table></figure><p>有时模块作者会使用更深层嵌套的命名空间。如果<code>sets</code>模块是另外一组更大的模块集合的话，它的命名空间可能会是<code>collections.sets</code>，模块代码的开始会这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collections;                                <span class="comment">// 声明（或重新声明）这个全局变量</span></span><br><span class="line"><span class="keyword">if</span> (!collections)</span><br><span class="line">    collections = &#123;&#125;;                           <span class="comment">// 如果它原本不存在，创建一个顶层的命名空间对象</span></span><br><span class="line">collections.sets = &#123;&#125;;                          <span class="comment">// 将sets命名空间创建在它的内部</span></span><br><span class="line">collections.sets.AbstractSet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;     <span class="comment">// 在collections.sets内定义set类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最顶层的命名空间往往用来标识创建模块的作者或组织，并避免命名空间的明明冲突。使用很长的命名空间来导入模块的方式非常重要，然而程序员往往将整个模块导入全局命名空间，而不是导入单独的类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sets = collections.sets;</span><br></pre></td></tr></table></figure><h4 id="2-作为私有命名空间的函数"><a href="#2-作为私有命名空间的函数" class="headerlink" title="2. 作为私有命名空间的函数"></a>2. 作为私有命名空间的函数</h4><p>模块对外导出一些公用API，这些API是提供给其他程序员使用的，它包括函数、类、属性和方法。但模块的实现往往需要一些额外的辅助函数和方法，这些函数和方法并不需要在模块外部可见。比如，<code>Set</code>类中的<code>_v2s()</code>函数，模块作者不希望<code>Set</code>类的用户在某时刻调用这个函数，因此这个方法最好在类的外部是不可访问的。</p><p>可以通过将模块定义在某个函数的内部来实现。在一个函数中定义的变量和函数都属于函数的局部成员，在函数的外部是不可见的。实际上，可以将这个函数作用域用作模块的私有命名空间（有时称为“模块函数”）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明全局变量Set，使用一个函数的返回值给它赋值</span></span><br><span class="line"><span class="comment">// 函数结束时紧跟的一堆圆括号表示函数定义后立即执行</span></span><br><span class="line"><span class="comment">// 它的返回值将赋值给Set，而不是将这个函数赋值给Set</span></span><br><span class="line"><span class="comment">// 注意它是一个函数表达式，不是一条语句，因此函数“invocation”并没有创建全局变量</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">Set</span> = (<span class="function"><span class="keyword">function</span> <span class="title">invocation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;                                    <span class="comment">// 这个构造函数是局部变量</span></span><br><span class="line">        <span class="keyword">this</span>.values = &#123;&#125;;                               <span class="comment">// 这个对象的属性用来保存这个集合</span></span><br><span class="line">        <span class="keyword">this</span>.n = <span class="number">0</span>;                                     <span class="comment">// 集合中值的个数</span></span><br><span class="line">        <span class="keyword">this</span>.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);                <span class="comment">// 将所有的参数都添加至集合中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给Set.prototype定义实例方法</span></span><br><span class="line">    <span class="built_in">Set</span>.prototype.contains = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 注意我们调用了v2s()，而不是调用带有笨重的前缀的set._v2s()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.values.hasOwnProperty(v2s(value));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Set</span>.prototype.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.n;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Set</span>.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Set</span>.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Set</span>.prototype.foreach = <span class="function"><span class="keyword">function</span>(<span class="params">f, ctx</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是上面的方法用到的一些辅助函数和变量</span></span><br><span class="line">    <span class="comment">// 它们不属于模块的共有API，但它们都隐藏在这个函数作用域内</span></span><br><span class="line">    <span class="comment">// 因此我们不比将它们定义为Set的属性或使用下划线作为其前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">v2s</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">objectId</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> nextId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个模块的共有API是Set()构造函数</span></span><br><span class="line">    <span class="comment">// 我们需要把这个函数从私有命名空间中导出来</span></span><br><span class="line">    <span class="comment">// 以便在外部也可以使用它，在这种情况下，我们通过返回这个构造函数来导出它</span></span><br><span class="line">    <span class="comment">// 它变成第一行代码所指的表达式的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Set</span>;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>注意，这里使用了立即执行的匿名函数，这在JavaScript中是一种惯用法。如果想让代码在一个私有命名空间中运行，只需要给代码加上“<code>(function() { ... })</code>”。开始的做圆括号确保这是一个函数表达式，而不是函数定义语句，因此可以给该前缀添加一个函数名来让代码变得更加清晰。</p><p>一旦将模块代码封装进一个函数，就需要一些方法导出其公用API，以便在模块函数的外部调用它们。在上文实例中，模块函数返回构造函数，这个构造函数随后赋值给一个全局变量。将值返回已经清楚地表名API已经导出在函数作用域之外。如果模块API包含多个单元，则它可以返回命名空间对象。对于<code>sets</code>模块来说，可以将代码写成这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collections;</span><br><span class="line"><span class="keyword">if</span> (!collections) collections = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义sets模块</span></span><br><span class="line">collections.sets = (<span class="function"><span class="keyword">function</span> <span class="title">namespace</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里定义多种“集合类”，使用局部变量和函数</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过返回命名空间对象将API导出</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 导出的属性名：局部变量的名字</span></span><br><span class="line">        AbstractSet: AbstractSet,</span><br><span class="line">        NotSet: NotSet,</span><br><span class="line">        AbstractEnumerableSet: AbstractEnumerableSet,</span><br><span class="line">        SingletonSet: SingletonSet,</span><br><span class="line">        AbstractWritableSet: AbstractWritableSet,</span><br><span class="line">        ArraySet: ArraySet</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>另外一种类似的技术是将模块函数当作构造函数，通过<code>new</code>调用，通过将它们赋值给<code>this</code>来将其导出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collections;</span><br><span class="line"><span class="keyword">if</span> (!collections) collections = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">collections.sets = (<span class="keyword">new</span> <span class="function"><span class="keyword">function</span> <span class="title">namespace</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...省略代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将API导出至对象</span></span><br><span class="line">    <span class="keyword">this</span>.AbstractSet = Abstract;</span><br><span class="line">    <span class="keyword">this</span>.NotSet = NotSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，这里没有返回值</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>作为一种替代方案，如果已经定义了全局命名空间对象，这个模块函数可以直接设置那个对象的属性，不用返回任何内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collections;</span><br><span class="line"><span class="keyword">if</span> (!collections) collections = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">collections.sets = &#123;&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">namespace</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...省略代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将公用API导出到上面创建的命名空间对象上</span></span><br><span class="line">    collections.sets.AbstractSet = AbstractSet;</span><br><span class="line">    collections.sets.NotSet = NotSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出的操作已经执行了，这里不需要再写return语句了</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个JavaScript对象都是一个属性集合，相互之间没有任何联系。在JavaScript中也可以定义对象的类，让每个对象都共享某些属性，这种“共享”的特性是非常有用的。类的成员或实例都包含一些属性，用以存放或定义它们的状态，其中有些属性定义了它们的行为（通常称为方法）。这些行为通常是由类定义的，而且为所有实例所共享。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript类和模块" scheme="http://www.xiaoleon.cn/tags/JavaScript%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>JS(4) 函数</title>
    <link href="http://www.xiaoleon.cn/2018/01/28/js-4/"/>
    <id>http://www.xiaoleon.cn/2018/01/28/js-4/</id>
    <published>2018-01-28T02:26:20.000Z</published>
    <updated>2018-01-28T15:07:19.438Z</updated>
    
    <content type="html"><![CDATA[<p>函数是这样的一段JavaScript代码，它只定义一次，但可能被执行或调用任意次。JavaScript函数是参数化的：函数的定义会包括一个称为形参（<code>parameter</code>）的标识符列表，这些参数在函数体中像局部变量一样工作。函数调用会为形参提供实参的值。函数使用它们实参的值来计算返回值，称为该函数调用表达式的值。除了实参之外，每次调用还会拥有另外一个值——本次调用的上下文——就是<code>this</code>关键字的值。</p><a id="more"></a><p>如果函数挂载在一个对象上，作为对象的一个属性，就称他为对象的方法。当通过这个对象来调用函数时，该对象就是此次调用的上下文（<code>context</code>），也就是该函数的<code>this</code>的值。</p><p>在JavaScript里，函数即对象，程序可以随意操控它们。比如，JavaScript可以把函数赋值给变量，或者作为参数传递给其他函数。因为函数就是对象，所以可以给它们设置属性，甚至调用它们的方法。</p><p>JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。这意味着JavaScript函数构成了一个闭包（<code>closure</code>），它给JavaScript带来了非常强劲的编程能力。</p><h3 id="一、函数定义"><a href="#一、函数定义" class="headerlink" title="一、函数定义"></a>一、函数定义</h3><p>函数使用<code>function</code>关键字来定义，它可以用在函数定义表达式或者函数声明语句离。在两种形式中，函数定义都从<code>function</code>关键字开始，其后跟随这些组成部分：</p><ul><li><p>函数名称标识符</p><p>函数名称是函数声明语句必须的部分。它的用途就像变量的名字，新定义的函数对象会赋值给这个变量。对函数定义表达式来说，这个名字是可选的：如果存在，改名字只存在于函数体中，并指代该函数对象本身。</p></li><li><p>一对圆括号</p><p>其中包含由0个或者多个用逗号隔开的标识符组成的列表。这些标识符是函数的参数名称，它们就像函数体中的局部变量一样。</p></li><li><p>一对花括号</p><p>其中包含0条或多条JavaScript语句。这些语句构成了函数体：一旦调用函数，就会执行这些语句。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printprops</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(p + <span class="string">': '</span> + o[p] + <span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">x1, y1, x2, y2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dx = x2 - x1;</span><br><span class="line">    <span class="keyword">var</span> dy = y2 - y1;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：以表达式方式定义的函数，函数的名称是可选的。一条函数声明语句实际上声明了一个变量，并把一个函数对象赋值给它。相对而言，定义函数表达式时并没有声明一个变量。如果一个函数定义表达式包含名称，函数的局部作用域会包含一个绑定到函数对象的名称。实际上，函数的名称将会成为函数内部的一个局部变量。</p></blockquote><p><strong>函数命名</strong></p><p>任何合法的JavaScript标识符都可以用作一个函数的名称。命名时要尽量选择描述性强而又简洁的函数名。通常函数名的第一个字符为小写，这是一种编程约定。当函数名包含多个单词时，一种约定是将单词以下划线分隔，就像<code>like_this()</code>。还有另外一种约定，就是除了第一个单词之外的单词首字母使用大写字母，就像<code>likeThis()</code>。有些函数是用作内部函数或私有函数（不是作为公用API的一部分），这种函数名通常以一条下划线为前缀。</p><p>函数声明语句“被提前”到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用。不过，以表达式定义的函数就另当别论了，为了调用一个函数，必须要能引用它，而要使用一个以表达式方式定义的函数之前，必须把它赋值给一个变量。变量的声明提前了，但是变量赋值是不会提前的，所以，以表达式方式定义的函数在定义之前无法调用。</p><p>大多数函数都会包含一条<code>return</code>语句，<code>return</code>语句会导致函数停止执行，并返回它的表达式的值给调用者。如果<code>return</code>语句没有一个与之相关的表达式，则它返回undefined值。如果一个函数不包含<code>return</code>语句，那它就只执行函数体中的每条语句，并返回<code>undefined</code>给调用者。</p><hr><h3 id="二、嵌套函数"><a href="#二、嵌套函数" class="headerlink" title="二、嵌套函数"></a>二、嵌套函数</h3><p>在JavaScript里，函数可以嵌套在其他函数里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hypotenuse</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(square(a) + square(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套函数的有趣之处在于它的变量作用域规则：它们可以访问嵌套它们（或多重嵌套）的函数的参数和变量。这些作用于规则对内嵌函数非常重要。</p><p>上文提到，函数声明语句并非真正的语句，ES规范只是允许它们作为顶级语句。它们可以出现在全局代码里，或者内嵌在其他函数中，但它们不能出现在循环、条件判断，或者<code>try/catch/finally</code>以及<code>with</code>语句中。注意，此限制仅适用于以语句声明形式定义的函数。函数定义表达式可以出现在JavaScript代码的任何地方。</p><hr><h3 id="三、函数调用"><a href="#三、函数调用" class="headerlink" title="三、函数调用"></a>三、函数调用</h3><p>构成函数主体的JavaScript代码在定义之时并不会执行，只有调用该函数时，它们才会执行。有4种方式来调用JavaScript函数</p><ul><li><p>作为函数</p></li><li><p>作为方法</p></li><li><p>作为构造函数</p></li><li><p>通过它们的<code>call()</code>和<code>apply()</code>方法直接调用</p></li></ul><h4 id="1-函数调用"><a href="#1-函数调用" class="headerlink" title="1. 函数调用"></a>1. 函数调用</h4><p>使用调用表达式可以进行普通的函数调用也可进行方法调用。一个调用表达式由多个函数表达式组成，每个函数表达式都是由一个函数对象和左圆括号、参数列表和右圆括号组成，参数列表是由逗号分隔的零个或多个参数表达式组成。如果函数表达式是一个属性访问表达式，即该函数是一个对象的属性或属性中的一个元素，那么它就是一个方法调用表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printprops(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> total = distance(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>) + distance(<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> probability = factorial(<span class="number">5</span>) / factorial(<span class="number">13</span>);</span><br></pre></td></tr></table></figure><p>在一个调用中，每个参数表达式（圆括号之间的部分）都会计算出一个值，计算的结果作为参数传递给另外一个函数。这些值作为实参传递给声明函数时定义的形参。在函数体中存在一个形参的引用，指向当前传入的实参列表，通过它可以获得参数的值。</p><p>在ES3和非严格模式的ES5中，函数的调用上下文（this）是全局对象，然而在严格模式下，调用上下文则是undefined。</p><p>以函数形式调用的函数通常不使用this关键字，不过，this可以用来判断当前是否是严格模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并调用一个函数来确定当前脚本运行时是否为严格模式</span></span><br><span class="line"><span class="keyword">var</span> strict = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> !<span class="keyword">this</span>; &#125;());</span><br></pre></td></tr></table></figure><h4 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h4><p>一个方法无非是个保存在一个对象的属性里的JavaScript函数。如果有一个函数f和一个对象o，则可以用下面的代码给<code>o</code>定义一个名为<code>m()</code>的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o.m = f;</span><br><span class="line">o.m();</span><br><span class="line">o.m(x, y);</span><br></pre></td></tr></table></figure><p>对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致。但是，方法调用和函数调用有一个重要的区别，即调用上下文。属性访问表达式由两部分组成：一个对象（<code>o</code>）和属性名称（<code>m</code>），在像这样的方法调用表达式里，对象<code>o</code>称为调用上下文，函数体可以使用关键字<code>this</code>引用该对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculator = &#123;</span><br><span class="line">    operand1: <span class="number">1</span>,</span><br><span class="line">    operand2: <span class="number">1</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="keyword">this</span>.operand1 + <span class="keyword">this</span>.operand2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculator.add();</span><br><span class="line">calculator.result;                          <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure><p>大多数方法调用使用点符号来访问属性，使用方括号也可以进行属性访问操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o[<span class="string">'m'</span>](x, y);</span><br><span class="line">a[o](z)</span><br></pre></td></tr></table></figure><p>方法调用可能包括更复杂的属性访问表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">customer.surname.toUpperCase();</span><br><span class="line">f().m();</span><br></pre></td></tr></table></figure><p>方法和<code>this</code>关键字是面向对象编程范例的核心。任何函数只要作为方法调用实际上都会传入一个隐式的实参——这个实参是一个对象，方法调用的母体就是这个对象。通常来讲，基于那个对象的方法可以执行多种操作，方法调用的语法已经很清晰的表明了函数将基于一个对象进行操作。比较下面两行代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rect.setSize(width, height);</span><br><span class="line">setRectSize(rect, width, height);</span><br></pre></td></tr></table></figure><p>我们假设这两行代码的功能完全一样，它们都作用于一个假定的对象<code>rect</code>。可以看出，第一行的方法调用语法非常清晰地表明这个函数执行的载体是<code>rect</code>对象，函数中的所有操作都将基于这个对象。</p><p>需要注意的是，<code>this</code>是一个关键字，不是变量，也不是属性名。JavaScript的语法不允许给<code>this</code>赋值。</p><p>和变量不同，关键字<code>this</code>没有作用域的限制，嵌套的函数不会从调用它的函数中继承<code>this</code>。如果嵌套函数作为方法调用，其<code>this</code>指向调用它的对象。如果嵌套函数作为函数调用，其<code>this</code>值不是全局对象（非严格模式下）就是<code>undefined</code>（严格模式下）。很多人误以为调用嵌套函数时<code>this</code>会指向调用外层函数的上下文。如果你想访问这个外部函数的<code>this</code>值，需要将<code>this</code>的值保存在一个变量里，这个变量和内部函数都同在一个作用域内。通常使用<code>self</code>变量来保存<code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                         <span class="comment">// 对象中的方法m()</span></span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);            <span class="comment">// true  this的值就是这个对象o</span></span><br><span class="line">        f();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;                      <span class="comment">// 定义嵌套函数f()</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);        <span class="comment">// false  this的值是全局变量或undefined</span></span><br><span class="line">            <span class="built_in">console</span>.log(self === o);        <span class="comment">// true  self指外部函数的this值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">o.m();                                      <span class="comment">// 调用对象o中的方法m()</span></span><br></pre></td></tr></table></figure><h4 id="3-方法链"><a href="#3-方法链" class="headerlink" title="3. 方法链"></a>3. 方法链</h4><p>当方法的返回值是一个对象，这个对象还可以再调用它的方法。这种方法调用序列中（通常称为“链”或“级联”）每次的调用结果都是另外一个表达式的组成部分。比如基于jQuery库，我们常常会这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到所有的header，取得它们id的映射，转换为数组并对它们进行排序</span></span><br><span class="line">$(<span class="string">':header'</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.id; &#125;).get().sort();</span><br></pre></td></tr></table></figure><p>当方法不需要返回值时，最好直接返回<code>this</code>。如果在设计的API中一直采用这种方式，使用API就可以进行“链式调用”风格的变成，在这种编程风格中，只要指定一次要调用的对象即可，余下的方法都可以基于此进行调用。</p><h4 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4. 构造函数"></a>4. 构造函数</h4><p>如果函数或者方法调用之前带有关键字<code>new</code>，他就构成构造函数调用。构造函数调用和普通的函数调用以及方法调用在实参处理、调用上下文和返回值方面都有不同。</p><p>如果构造函数调用在圆括号内包含一组实参列表，先计算这些实参表达式，然后传入函数内，这和函数调用和方法调用是一致的。但如果构造函数没有形参，JavaScript调用的语法是允许省略实参列表和圆括号的。凡是没有形参的构造函数调用都可以省略圆括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两行代码是等价的</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure><p>构造函数调用创建一个新的空对象，这个对象继承自构造函数的<code>prototype</code>属性。构造函数试图初始化这个新创建的对象，并将这个对象用作其调用上下文，因此构造函数可以使用<code>this</code>关键字来引用这个新创建的对象。注意，尽管构造函数看起来像一个方法调用，它依然会使用这个新对象作为调用上下文。也就是说，在表达式<code>new o.m()</code>中，调用上下文并不是<code>o</code>，而是<code>m</code>。</p><p>构造函数通常不使用<code>return</code>关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式地使用<code>return</code>语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用<code>return</code>语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。</p><h4 id="5-间接调用"><a href="#5-间接调用" class="headerlink" title="5. 间接调用"></a>5. 间接调用</h4><p>JavaScript中的函数也是对象，和其他JavaScript对象没什么两样，函数对象也可以包含方法。其中的<code>call()</code>和<code>apply()</code>可以用来间接地调用函数，两个方法都允许显式地调用所需的<code>this</code>值。也就是说，任何函数可以作为任意对象的方法来调用，哪怕这个函数不是那对对象的方法。两个方法都可以指定调用的实参。<code>call()</code>方法使用它自有的实参列表作为函数的实参，<code>apply()</code>方法则要求以数组的形式传入参数。</p><hr><h3 id="四、函数的实参和形参"><a href="#四、函数的实参和形参" class="headerlink" title="四、函数的实参和形参"></a>四、函数的实参和形参</h3><p>JavaScript中的函数定义并未指定函数形参的类型，函数调用也未对传入的实参值作任何类型检查。实际上，JavaScript函数调用甚至不检查传入形参的个数。</p><h4 id="1-可选形参"><a href="#1-可选形参" class="headerlink" title="1. 可选形参"></a>1. 可选形参</h4><p>当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为<code>undefined</code>值。因此在调用函数时形参是否可选以及是否可以省略应当保持较好的适应性。为了做到这一点，应当给省略的参数赋一个合理的默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPropertyNames</span>(<span class="params">o, <span class="regexp">/* optional */</span> a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        a = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> o) &#123;</span><br><span class="line">        a.push(property);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = getPropertyNames(o);                <span class="comment">// 将o的属性存储到一个新数组中</span></span><br><span class="line">getPropertyNames(p, a);                     <span class="comment">// 将p的属性追加到数组a中</span></span><br></pre></td></tr></table></figure><p>如果在第一行代码中不使用<code>if</code>语句，可以使用“<code>||</code>”运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a || [];</span><br></pre></td></tr></table></figure><p>需要注意的是，当用这种可选实参来实现函数时，需要将可选实参放在实参列表的最后。那些调用你的函数的程序员是没法省略第一个实参并传入第二个实参的，它必须将<code>undefined</code>作为第一个实参显式传入。同样注意在函数定义中使用注释<code>/*optional*/</code>来强调形参是可以选的。</p><h4 id="2-可变长的实参列表：实参对象"><a href="#2-可变长的实参列表：实参对象" class="headerlink" title="2. 可变长的实参列表：实参对象"></a>2. 可变长的实参列表：实参对象</h4><p>当调用函数的时候传入的实参个数超过函数定义时的形参个数时，没有办法直接获得未命名的引用。参数对象解决了这个问题。在函数体内，标识符<code>arguments</code>是指向实参对象的引用，实参对象是一个类数组对象，这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。</p><p>实参对象在很多地方都非常有用，下面的例子展示了使用它来验证实参的个数，从而调用正确的逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'function f called with '</span> + <span class="built_in">arguments</span>.length + <span class="string">' arguments, but it expects 3 arguments.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数的其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，通常不必像这样检查实参个数。大多数情况下JavaScript的默认行为是可以满足需要的。省略的实参都将是<code>undefined</code>，多出的参数会自动省略。</p><p>实参对象有一个重要的用处，就是让函数可以操作任意数量的实参。下面的函数就可以接收任意数量的实参，并返回传入实参的最大值（内置函数<code>Max.max()</code>的功能与之类似）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params"><span class="regexp">/* ... */</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="built_in">Number</span>.NEGATIVE_INFINITY;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>[i] &gt; max) &#123;</span><br><span class="line">            max = <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> largest = max(<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1000</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10000</span>, <span class="number">6</span>);      <span class="comment">// =&gt; 10000</span></span><br></pre></td></tr></table></figure><p>类似这种函数可以接收任意个数的实参，这种函数也成为“不定实参函数”（<code>varargs function</code>）。注意，不定实参函数的实参个数不能为零，<code>arguments[]</code>对象最适合的应用场景是在这样一类函数中，这类函数包含固定个数的命名和必须参数，以及随后个数不定的可选实参。</p><p>数组对象包含一个非同寻常的特性。在非严格模式下，当一个函数包含若干形参，实参对象的数组元素是函数形参所对应实参的别名，实参对象中以数字索引，并且形参名称可以认为是相同变量的不同命名。通过实参名字来修改实参值的话，通过<code>arguments[]</code>数组也可以获取到更改后的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);         <span class="comment">// 输出实参的初始值</span></span><br><span class="line">    <span class="built_in">arguments</span>[o] = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x);         <span class="comment">// =&gt; null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果实参对象是一个普通数组的话，第二条<code>console.log(x)</code>语句的结果绝对不会是<code>null</code>，在这个例子中，<code>arguments[0]</code>和<code>x</code>指代同一个值，修改其中一个的值会影响到另一个。</p><p>在严格模式下还有一点（和非严格模式下相比的）不同，在非严格模式中，函数里的<code>arguments</code>仅仅是一个标识符，在严格模式中，它变成了一个保留字。严格模式中的函数无法使用<code>arguments</code>作为形参名或局部变量名，也不能给<code>arguments</code>赋值。</p><p><strong>callee和caller属性</strong></p><p>除了数组元素，实参对象还定义了<code>callee</code>和<code>caller</code>属性，在ES5严格模式中，对这两个属性的读写操作都会产生一个类型错误。而在非严格模式下，ES标准规范规定<code>callee</code>属性指代当前正在执行的函数。<code>caller</code>是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数。通过<code>caller</code>属性可以访问调用栈。<code>callee</code>属性在某些时候会非常有用，比如在匿名函数中通过<code>callee</code>来递归地调用自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="built_in">arguments</span>.callee(x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-将对象属性用作实参"><a href="#3-将对象属性用作实参" class="headerlink" title="3. 将对象属性用作实参"></a>3. 将对象属性用作实参</h4><p>当一个函数包含超过三个形参时，对于程序员来说，要记住调用函数中实参的正确顺序实在让人头疼。最好通过名值对的形式来传入参数，这样参数的顺序就无关紧要了。为了实现这种风格的方法调用，定义函数的时候，传入的实参都写入一个单独的对象之中，在调用的时候传入一个对象，对象中的名值对是真正需要的实参数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arraycopy</span>(<span class="params">from, from_start, to, to_start, length</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">easycopy</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    arraycopy(args.from,</span><br><span class="line">            args.from_start || <span class="number">0</span>,</span><br><span class="line">            args.to,</span><br><span class="line">            args.to_start || <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], b = [];</span><br><span class="line">easycopy(&#123; <span class="attr">from</span>: a, <span class="attr">to</span>: b, <span class="attr">length</span>: <span class="number">4</span> &#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="五、作为值的函数"><a href="#五、作为值的函数" class="headerlink" title="五、作为值的函数"></a>五、作为值的函数</h3><p>函数定义和调用是JavaScript的词法特性，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另外一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = square;</span><br><span class="line">square(<span class="number">4</span>);                              <span class="comment">// =&gt; 16</span></span><br><span class="line">s(<span class="number">4</span>);                                   <span class="comment">// =&gt; 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    square: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> y = o.square(<span class="number">16</span>);                   <span class="comment">// =&gt; 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x; &#125;, <span class="number">20</span>];</span><br><span class="line">a[<span class="number">0</span>](a[<span class="number">1</span>]);                             <span class="comment">// =&gt; 400</span></span><br></pre></td></tr></table></figure><p>考虑一下<code>Array.sort()</code>方法，这个方法可以接收一个函数作为参数，用来处理具体的排序操作。这个函数的作用非常简单，对于任意两个值都返回一个值，以指定它们在排序后的数组中的先后顺序。</p><h4 id="1-自定义函数属性"><a href="#1-自定义函数属性" class="headerlink" title="1. 自定义函数属性"></a>1. 自定义函数属性</h4><p>JavaScript中的函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。当函数需要一个“静态”变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量，显然定义全局变量会让命名空间变得更加杂乱无章。</p><p>比如，我们想写一个返回一个唯一整数的函数，不管在哪里调用函数都会返回这个整数。而函数不能两次返回同一个值，可以把这些信息存放到全局变量中，但这并不是必须的，因为这个信息仅仅是函数本身用到的。最好将这个信息保存到函数对象的一个属性中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uniqueInteger.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueInterger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniqueInterger.counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个函数<code>factorial()</code>使用了自身的属性来缓存上一次的计算结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isFinite</span>(n) &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; n == <span class="built_in">Math</span>.round(n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(n <span class="keyword">in</span> factorial)) &#123;</span><br><span class="line">            factorial[n] = n * factorial(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factorial[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial[<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="六、作为命名空间的函数"><a href="#六、作为命名空间的函数" class="headerlink" title="六、作为命名空间的函数"></a>六、作为命名空间的函数</h3><p><strong>函数作用域</strong>：在函数中声明的变量在整个函数体内都是可见的（包括在嵌套的函数中），在函数的外部是不可见的。不在任何函数内声明的变量是全局变量，在整个JavaScript程序中都是可见的。在JavaScript中是无法声明只在一个代码块内可见的变量的，基于这个原因，我们常常简单的定一个函数用作临时的命名空间，在这个命名空间内定义的变量都不会污染到全局命名空间。</p><p>比如，假设我们写了一段JavaScript模块代码，这段代码将要用在不同的JavaScript程序中。和大多数代码一样，假定这段代码定义了一个用以存储中间计算结果的变量。这样问题就来了，当模块代码放到不同的程序中运行时，我们无法得知这个变量是否已经创建了，如果已经存在这个变量，那么将会和代码发生冲突。解决办法当然是将代码放入一个函数内，然后调用这个函数。这样全局变量就变成了函数内的局部变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mymodule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模块代码</span></span><br><span class="line">    <span class="comment">// 这个模块所使用的所有变量都是局部变量</span></span><br><span class="line">    <span class="comment">// 而不是污染全局命名空间</span></span><br><span class="line">&#125;</span><br><span class="line">mymodule();</span><br></pre></td></tr></table></figure><p>这段代码仅仅定义了一个单独的全局变量，名叫“<code>mymodule</code>”的函数，这样还是太麻烦，可以直接定义一个匿名函数，并在单个表达式中调用它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模块代码</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>最外层的圆括号是习惯用法，尽管有些时候没有必要也不应当省略，这里定义的函数会立即调用。</p><p>下文示例中定义一个返回<code>extend()</code>函数的匿名函数，代码检测是否出现了一个众所周知的IE bug，如果出现了这个bug，就返回一个带补丁的函数版本。此外，这个匿名函数命名空间用来隐藏一组属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个扩展函数，用来将第二个以及后续参数复制至第一个参数</span></span><br><span class="line"><span class="comment">// 这里我们处理了IE bug：在多数IE版本中，如果o的属性拥有一个不可枚举的同名属性，则for/in循环</span></span><br><span class="line"><span class="comment">// 不会枚举对象o的可枚举性，也就是说，将不会正确地处理诸如toString的属性</span></span><br><span class="line"><span class="comment">// 除非我们显式检测它</span></span><br><span class="line"><span class="keyword">var</span> extend = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 修复bug之前，首先检测是否存在</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> &#123;<span class="attr">toString</span>: <span class="literal">null</span>&#125;) &#123;</span><br><span class="line">        <span class="comment">// 如果代码执行到这里，那么for/in循环会正确工作并返回</span></span><br><span class="line">        <span class="comment">// 一个简单版本的extend()函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> source = <span class="built_in">arguments</span>[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> source) &#123;</span><br><span class="line">                    o[prop] = source[prop];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果代码执行到这里，说明for/in循环不会枚举测试对象的toString属性</span></span><br><span class="line">    <span class="comment">// 因此返回另一个版本的extend()函数，这个函数显式测试</span></span><br><span class="line">    <span class="comment">// Object.prototype中的不可枚举属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patched_extend</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> source = <span class="built_in">arguments</span>[i];</span><br><span class="line">            <span class="comment">// 复制所有的可枚举属性</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> source) &#123;</span><br><span class="line">                o[prop] = source[prop];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在检查特殊属性</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; protoprops.length; j++) &#123;</span><br><span class="line">                prop = protoprops[j];</span><br><span class="line">                <span class="keyword">if</span> (source.hasOwnProperty(prop)) &#123;</span><br><span class="line">                    o[prop] = source[prop];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个列表列出了需要检查的特殊属性</span></span><br><span class="line">    <span class="keyword">var</span> protoprops = [<span class="string">'toString'</span>, <span class="string">'valueOf'</span>, <span class="string">'constructor'</span>, <span class="string">'hasOwnProperty'</span>, <span class="string">'isPrototypeOf'</span>, <span class="string">'propertyIsEnumerable'</span>, <span class="string">'toLocaleString'</span>];</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><hr><h3 id="七、闭包"><a href="#七、闭包" class="headerlink" title="七、闭包"></a>七、闭包</h3><p>和其他大多数现代编程语言一样，JavaScript也采用词法作用域（<code>lexical scoping</code>），也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现这种词法作用域，JavaScript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为 “<strong>闭包</strong>”。</p><p>从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链。定义大多数函数时的作用域链在调用函数时依然有效，但这并不影响闭包。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，事件就变得非常微妙。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数必报，以至于这种编程模式在JavaScript中非常常见。</p><p>理解闭包首先要了解嵌套函数的词法作用域规则，看一下这段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;                                 <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;                              <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;                                       <span class="comment">// 在作用域中返回这个值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();                                               <span class="comment">// =&gt; 'local scope'</span></span><br></pre></td></tr></table></figure><p><code>checkscope()</code>函数声明了一个局部变量，并定义了一个函数<code>f()</code>，函数<code>f()</code>返回了这个变量的值，最后将函数<code>f()</code>的执行结果返回。我们应当非常清楚为什么调用<code>checkscope()</code>会返回“<code>local scope</code>”。现在我们对这段代码做一点改动，看看会返回什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;                                 <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;                              <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;                                       <span class="comment">// 在作用域中返回这个值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();                                             <span class="comment">// 返回值是什么？</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们将函数内的一对圆括号移动到了<code>checkscope()</code>之后，<code>checkscope()</code>现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对圆括号）会发生什么事情呢？</p><p>回想一下词法作用域的基本规则：JavaScript函数的执行涌动阿勒作用域链，这个作用域链是函数定义的时候创建的。嵌套的函数定义在这个作用域链里，其中的变量<code>scope</code>一定是局部变量，不管在何时何地执行函数<code>f()</code>，这种绑定在执行<code>f()时</code>依然有效。因此最后一行代码返回<code>&quot;local scope&quot;</code>，而不是<code>&quot;global scope&quot;</code>。简而言之，闭包的这个恶性强大到让人吃惊：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了在其中定义它们的外部函数。</p><blockquote><p><strong>实现闭包</strong></p><p>如果我们理解了词法作用域的规则，我们就能很容易地理解闭包：函数定义时的作用域链到函数执行时依然有效。我们将作用域链描述为一个对象列表，不是绑定的栈。每次调用JavaScript函数的时候，都会为之创建一个新的对象用来保存局部变量，把这个对象添加至作用域链中。当函数返回的时候，就从作用域链中将这个绑定变量的对象删除。如果不存在嵌套的函数，也没有其他引用指向这个绑定对象，它就会被当作垃圾回收掉。如果定义了嵌套的函数，每个嵌套的函数都各自对应一个作用域链，并且这个作用域链指向一个变量绑定对象。但如果这些嵌套的函数对象在外部函数中保存下来，那么它们也会和所指向的变量绑定对象一样当作垃圾回收。但是如果这个函数定义了嵌套的函数，并将它作为返回值返回或者存储在某处的属性里，这时就会有一个外部引用指向这个嵌套的函数。它就不会被当作垃圾回收，并且它所指向的变量绑定对象也不会被当作垃圾回收。</p></blockquote><p>在前文定义的<code>uniqueInteger()</code>函数中，这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟踪上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致<code>uniqueInteger()</code>函数不一定能产生“唯一”的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用作私有状态。我们可以利用闭包这样重写<code>uniqueInteger()</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniqueInteger = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                           <span class="comment">// 定义函数并立即调用</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;                                        <span class="comment">// 函数的私有状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>粗略来看，第一行代码看起来像将函数赋值给一个变量<code>uniqueInteger</code>，实际上，这段代码定义了一个立即调用的函数（函数的开始带有左圆括号），因此是这个函数的返回值赋值给变量<code>uniqueInteger</code>。现在，我们来看函数体，这个函数返回另外一个函数，这是一个嵌套的函数，我们将它赋值给变量<code>uniqueInteger</code>，嵌套的函数是可以访问作用域内的变量的，而且可以访问外部函数中定义的<code>counter</code>变量。当外部函数返回之后，其他任何代码都无法访问<code>counter</code>变量，只有内部的函数才能访问到它。</p><p>像<code>counter</code>一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数定定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n++;</span><br><span class="line">        &#125;,</span><br><span class="line">        reset: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = counter(), d = counter();                           <span class="comment">// 创建两个计数器</span></span><br><span class="line">c.count();                                                  <span class="comment">// =&gt; 0</span></span><br><span class="line">d.count();                                                  <span class="comment">// =&gt; 0  它们互不干扰</span></span><br><span class="line">c.reset();                                                  <span class="comment">// reset()和count()方法共享状态</span></span><br><span class="line">c.count();                                                  <span class="comment">// =&gt; 0  因为我们重置了c</span></span><br><span class="line">d.count();                                                  <span class="comment">// =&gt; 1  没有重置d</span></span><br></pre></td></tr></table></figure><p><code>counter()</code>函数返回了一个“计数器”对象，这个对象包含两个方法：<code>count()</code>返回下一个整数，<code>reset()</code>将计数器重置为内部状态。首先要理解，这两个方法都可以访问私有变量<code>n</code>。再者，每次调用<code>counter()</code>都会创建爱你一个新的作用域链和一个新的私有变量。因此，如果调用<code>counter()</code>两次，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的<code>count()</code>或<code>reset()</code>不会影响到另外一个对象。</p><p>从技术角度看，其实可以将这个闭包合并为属性存取器方法<code>getter</code>和<code>setter</code>。下面这段代码所示的<code>counter()</code>函数，这里私有状态的实现是利用了闭包，而不是利用普通的对象属性来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">n</span>) </span>&#123;                                       <span class="comment">// 函数参数n是一个私有变量</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        get count() &#123;                                       <span class="comment">// 属性getter方法返回并给私有计数器递增1</span></span><br><span class="line">            <span class="keyword">return</span> n++;</span><br><span class="line">        &#125;,</span><br><span class="line">        set count(m) &#123;                                      <span class="comment">// 属性setter不允许n递减</span></span><br><span class="line">            <span class="keyword">if</span> (m &gt;= n)</span><br><span class="line">                n = m;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'count can only be set to a larger value'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = counter(<span class="number">1000</span>);</span><br><span class="line">c.count;                                                    <span class="comment">// =&gt; 1000</span></span><br><span class="line">c.count;                                                    <span class="comment">// =&gt; 1001</span></span><br><span class="line">c.count = <span class="number">2000</span>;</span><br><span class="line">c.count;                                                    <span class="comment">// =&gt; 2000</span></span><br><span class="line">c.count;                                                    <span class="comment">// =&gt; 2001</span></span><br><span class="line">c.count = <span class="number">2000</span>;                                             <span class="comment">// =&gt; Error!</span></span><br></pre></td></tr></table></figure><p>需要注意的是，这个版本的<code>counter()</code>函数并未生命局部变量，而只是使用参数<code>n</code>来保存私有状态，属性存取器方法可以访问<code>n</code>。这样的话，调用<code>counter()</code>的函数就可以指定私有变量的初始值了。</p><p>下文示例是使用闭包技术来共享私有状态的通用做法。这个例子定义了<code>addPrivateProperty()</code>函数，这个函数定义了一个私有变量，以及两个嵌套的函数用来获取和设置这个私有变量的值。它将这些嵌套函数添加为所指定对象的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数给对象o增加了属性存取器方法</span></span><br><span class="line"><span class="comment">// 方法名称为get&lt;name&gt;和set&lt;name&gt;。如果提供了一个判定函数</span></span><br><span class="line"><span class="comment">// setter方法就会用它来检测参数的合法性，然后再存储它</span></span><br><span class="line"><span class="comment">// 如果判定函数返回false，setter方法会抛出一个异常</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这个函数有一个非同寻常之处，就是getter和setter函数</span></span><br><span class="line"><span class="comment">// 所操作的属性值并没有存储在对象o中</span></span><br><span class="line"><span class="comment">// 相反，这个值仅仅是保存在函数的局部变量中</span></span><br><span class="line"><span class="comment">// getter和setter方法同样是局部函数，因此可以访问这个局部变量</span></span><br><span class="line"><span class="comment">// 也就是说，对于两个存取器方法来说这个变量是私有的</span></span><br><span class="line"><span class="comment">// 没有办法绕过存取器方法来设置或修改这个值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPrivateProperty</span>(<span class="params">o, name, predicate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value;                                              <span class="comment">// 这是一个属性值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter方法简单地将其返回</span></span><br><span class="line">    o[<span class="string">'get'</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter方法首先检查值是否合法，若不合法就抛出异常</span></span><br><span class="line">    o[<span class="string">'set'</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate &amp;&amp; !predicate(v))</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'set'</span> + name + <span class="string">': invalid value '</span> + v);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            value = v;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码展示了addPrivateProperty()方法</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;                                                 <span class="comment">// 设置一个空对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加属性存取器方法getName()和setName()</span></span><br><span class="line"><span class="comment">// 确保只允许字符串值</span></span><br><span class="line">addPrivateProperty(o, <span class="string">'Name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.setName(<span class="string">'Frank'</span>);                                         <span class="comment">// 设置属性值</span></span><br><span class="line"><span class="built_in">console</span>.log(o.getName());                                   <span class="comment">// 得到属性值</span></span><br><span class="line">o.setName(<span class="number">0</span>);                                               <span class="comment">// 试图设置一个错误类型的值</span></span><br></pre></td></tr></table></figure><p>我们已经给出了很多例子，在同一个作用域链中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是一种非常重要的技术，但还是要特别小心那些不希望共享的变量往往不经意间共享给了其他的闭包，了解这一点也很重要，看看下面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数返回一个总是返回v的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfunc</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个数组用来存储常数函数</span></span><br><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs[i] = constfunc(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第5个位置的元素所表示的函数返回值为5</span></span><br><span class="line">funcs[<span class="number">5</span>]();                                                 <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure><p>这段代码利用循环创建了很多个闭包，当写类似这种代码的时候往往会犯一个错误：那就是试图将循环代码移入定义这个闭包的函数之内，看一下这段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个函数组成的数组，它们的返回值是0~9</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfuncs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> funcs = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        funcs[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcs = constfuncs();</span><br><span class="line">funcs[<span class="number">5</span>]();                                                 <span class="comment">// 返回值是什么？</span></span><br></pre></td></tr></table></figure><p>上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些必报都是在同一个函数调用中定义的，因此它们可以共享变量<code>i</code>。当<code>constfuncs()</code>返回时，变量<code>i</code>的值是10，所有的闭包够共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是我们想要的结果。关联到闭包的作用域链都是“活动的”，记住这一点非常重要。嵌套的函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照（<code>static snapshot</code>）。</p><p>书写闭包的时候还需注意一件事情，<code>this</code>是JavaScript的关键字，而不是变量。正如之前讨论的，每个函数调用都包含一个<code>this</code>值，如果闭包在外部函数里是无法访问<code>this</code>的，除非外部函数将<code>this</code>转存为一个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;                                            <span class="comment">// 将this保存至一个变量中</span></span><br></pre></td></tr></table></figure><p>绑定<code>arguments</code>的问题与之类似，<code>arguments</code>并不是一个关键字，但在调用每个函数时都会自动声明它，由于闭包具有自己所绑定的<code>arguments</code>，因此闭包内无法直接访问外部函数的参数数组，除非外部函数将参数数组保存到另外一个变量中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outerArguments = <span class="built_in">arguments</span>;                             <span class="comment">// 保存起来以便嵌套的函数能使用它</span></span><br></pre></td></tr></table></figure><hr><h3 id="八、函数属性、方法和构造函数"><a href="#八、函数属性、方法和构造函数" class="headerlink" title="八、函数属性、方法和构造函数"></a>八、函数属性、方法和构造函数</h3><p>我们看到在JavaScript程序中，函数是值。对函数执行<code>typeof</code>运算符会返回字符串“<code>function</code>”，但是函数是JavaScript中特殊的对象。因为函数也是对象，它们也可以拥有属性和方法，就像普通的对象可以拥有属性和方法一样。甚至可以用<code>Function()</code>构造函数来创建新的对象。</p><h4 id="1-length属性"><a href="#1-length属性" class="headerlink" title="1. length属性"></a>1. length属性</h4><p>在函数体里，<code>arguments.length</code>表示传入函数的实参的个数。而函数本身的<code>length</code>属性则由不同含义。函数的<code>length</code>属性是只读属性，它代表函数实参的数量，这里的参数指的是“形参”而非“实参”，也就是在函数定义时给出的实参个数，通常也是在函数调用时期望传入函数的实参个数。</p><p>下面的代码定义了一个名叫<code>check()</code>的函数，从另外一个函数给它传入<code>arguments</code>数组，它比较<code>arguments.length</code>（实际传入的实参个数）和<code>arguments.callee.length</code>（期望传入的实参个数）来判断所传入的实参个数是否正确。如果个数不正确，则抛出异常。<code>check()</code>函数之后定义一个测试函数<code>f()</code>，用来展示<code>check()</code>的用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数使用arguments.callee，因此它不能在严格模式下工作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> actual = args.length;                               <span class="comment">// 实参的真实个数</span></span><br><span class="line">    <span class="keyword">var</span> expected = args.callee.length;                      <span class="comment">// 期望的实参个数</span></span><br><span class="line">    <span class="keyword">if</span> (actual !== expected) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Expeced '</span> + expected + <span class="string">' args; got '</span> + actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    check(<span class="built_in">arguments</span>);                                       <span class="comment">// 检查实参个数和期望的实参个数是否一致</span></span><br><span class="line">    <span class="keyword">return</span> x + y + z;                                       <span class="comment">// 再执行函数的后续逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-prototype属性"><a href="#2-prototype属性" class="headerlink" title="2. prototype属性"></a>2. prototype属性</h4><p>每一个函数都包含一个<code>prototype</code>属性，这个属性是指向一个对象的引用，这个对象称作“原型对象”（<code>prototype object</code>）。每一个函数都包含不同的原型对象，当将函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。</p><h4 id="3-call-方法和apply-方法"><a href="#3-call-方法和apply-方法" class="headerlink" title="3. call()方法和apply()方法"></a>3. call()方法和apply()方法</h4><p>我们可以将<code>call()</code>和<code>apply()</code>看作是某个对象的方法，通过调用方法的形式来间接调用函数。<code>call()</code>和<code>apply()</code>的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内通过<code>this</code>来获得对它的引用。要想以对象<code>o</code>的方法来调用函数<code>f()</code>，可以这样使用<code>call()</code>和<code>apply()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.call(o);</span><br><span class="line">f.apply(o);</span><br></pre></td></tr></table></figure><p>每行代码和下面代码的功能类似（假设对象<code>o</code>中预先不存在名为<code>m</code>的属性）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o.m = f;                                                    <span class="comment">// 将f存储为o的临时方法</span></span><br><span class="line">o.m();                                                      <span class="comment">// 调用它，不传入参数</span></span><br><span class="line"><span class="keyword">delete</span> o.m;                                                 <span class="comment">// 将临时方法删除</span></span><br></pre></td></tr></table></figure><p>在ES5的严格模式中，<code>call()</code>和<code>apply()</code>的第一个实参都会变为<code>this</code>的值，哪怕传入的实参是原始值甚至是<code>null</code>或<code>undefined</code>。在ES3和非严格模式中，传入的<code>null</code>和<code>undefined</code>都会被全局对象替代，而其他原始值则会被相应的包装对象（<code>wrapper object</code>）所替代。</p><p>对于<code>call()</code>来说，第一个调用上下文实参之后的所有实参就是要传入待调用函数的值。比如，以对象<code>o</code>的方法的形式调用函数<code>f()</code>，并传入两个参数，可以使用这样的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.call(o, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><code>apply()</code>方法和<code>call()</code>类似，但传入实参的形式和<code>call()</code>有所不同，它的实参都放入一个数组当中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.apply(o, [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>如果一个函数的实参可以是任意数量，给<code>apply()</code>传入的参数数组可以是任意长度的。比如，为了找出数组中最大的数值元素，调用<code>Math.max()</code>方法的时候可以给<code>apply()</code>传入一个包含任意元素的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> biggest = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, array_of_numbers);</span><br></pre></td></tr></table></figure><p>需要注意的是，传入<code>apply()</code>的参数数组可以是类数组对象也可以是真实数组。实际上，可以将当前函数的<code>arguments</code>数组直接传入（另一个函数的）<code>apply()</code>来调用另一个函数，参考如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将对象o中名为m()的方法替换为另一个方法</span></span><br><span class="line"><span class="comment">// 可以在调用原始的方法之前和之后记录日志消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>(<span class="params">o, m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> original = o[m];                                <span class="comment">// 在闭包中保存原始方法</span></span><br><span class="line">    o[m] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">'Entering:'</span>, m);        <span class="comment">// 输出日志消息</span></span><br><span class="line">        <span class="keyword">var</span> resut = original.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);    <span class="comment">// 调用原始函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">'Existing:'</span>, m);        <span class="comment">// 输入日志消息</span></span><br><span class="line">        <span class="keyword">return</span> result;                                  <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>trace()</code>函数接收两个参数，一个对象和一个方法名，它将指定的方法替换为一个新方法，这个新方法是“包裹”原始方法的另一个泛函数。这种动态修改已有方法的做法有时称作“<code>monkey-patching</code>”。</p><h4 id="4-bind-方法"><a href="#4-bind-方法" class="headerlink" title="4. bind()方法"></a>4. bind()方法</h4><p><code>bind()</code>是在ES5中新增的方法，但在ES3中可以轻易模拟<code>bind()</code>。从名字就可以看出，这个方法的主要作用就是将函数绑定至某个对象。当在函数<code>f()</code>上调用<code>bind()</code>方法并传入一个对象<code>o</code>作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数<code>f()</code>当作<code>o</code>的方法来调用。传入新函数的任何实参都将传入原始函数，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + y;                                  <span class="comment">// 这是个待绑定的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;                                       <span class="comment">// 将要绑定的对象</span></span><br><span class="line"><span class="keyword">var</span> g = f.bind(o);                                      <span class="comment">// 通过调用g(x)来调用o.f(x);</span></span><br><span class="line">g(<span class="number">2</span>);                                                   <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><p>可以通过如下代码轻易地实现这种绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个函数，通过调用它来调用o中的方法f()，传递它所有的实参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">f, o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f.bind) &#123;</span><br><span class="line">        <span class="keyword">return</span> f.bind(o);                               <span class="comment">// 如果bind()方法存在的话，使用bind()方法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> f.apply(o, <span class="built_in">arguments</span>);               <span class="comment">// 否则，这样绑定</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES5中的<code>bind()</code>方法不仅仅是将函数绑定至一个对象，它还附带一些其他应用：除了第一个实参之外，传入<code>bind()</code>的实参也会绑定至<code>this</code>，这个附带的应用是一种常见的函数式编程技术，有时也被称为“柯里化”（<code>currying</code>）。参照下面这个例子中的<code>bind()</code>方法的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;                                       <span class="comment">// 返回两个实参的和</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个类似sum的新函数，但this的值绑定到null</span></span><br><span class="line"><span class="comment">// 并且第一个参数绑定到1，这个新的函数期望只传入一个实参</span></span><br><span class="line"><span class="keyword">var</span> succ = sum.bind(<span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line">succ(<span class="number">2</span>);                                                <span class="comment">// =&gt; 3  x绑定到1，并传入2作为实参y</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + y + z;                              <span class="comment">// 另外一个做累加计算的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, <span class="number">2</span>);                              <span class="comment">// 绑定this和y</span></span><br><span class="line">g(<span class="number">3</span>);                                                   <span class="comment">// =&gt; 6  this.x绑定到1，y绑定到2，z绑定到3</span></span><br></pre></td></tr></table></figure><p>我们可以绑定<code>this</code>的值并在ES3中实现这个附带的应用，下面代码就模拟实现标准的<code>bind()</code>方法。注意我们将这个方法另存为<code>Function.prototype.bind</code>，以便所有的函数对象都继承它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">o <span class="regexp">/*, args */</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将this和arguments的值保存至变量中</span></span><br><span class="line">        <span class="comment">// 以便在后面嵌套的函数中可以使用它们</span></span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>, boundArgs = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bind()方法的返回值是一个函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 创建一个实参列表，将传入bind()的第二个及后续的实参都传入这个函数</span></span><br><span class="line">            <span class="keyword">var</span> args = [], i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; boundArgs.length; i++) &#123;</span><br><span class="line">                args.push(boundArgs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在将self作为o的方法来调用，传入这些实参</span></span><br><span class="line">            <span class="keyword">return</span> self.apply(o, args);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到，<code>bind()</code>方法返回的函数是一个闭包，在这个闭包的外部函数中声明了<code>self</code>和<code>boundArgs</code>变量，这两个变量在闭包里用到。尽管定义闭包的内部函数已经从外部函数中返回，而且调用这个闭包逻辑的时刻要在外部函数返回之后（在闭包中照样可以正确访问这两个变量）。</p><p>ES5定义的<code>bind()</code>方法也有一些特性是上述ES3代码无法模拟的。首先，真正的<code>bind()</code>方法返回的是一个函数对象，这个函数对象的<code>length</code>属性是绑定函数的形参个数减去绑定实参的个数（<code>length</code>的值不能小于0）。再者，ES5的<code>bind()</code>方法可以顺带用作构造函数。如果<code>bind()</code>返回的函数用作构造函数，将忽略传入<code>bind()</code>的<code>this</code>，原始函数就会以构造函数的形式调用，其实参也已经绑定。由<code>bind()</code>方法所返回的函数并不包含<code>prototype</code>属性（普通函数固有的<code>prototype</code>属性是不能删除的），并且将这些绑定的函数用作构造函数时所创建的对象从原始的未绑定的构造函数中继承<code>prototype</code>。同样，在使用<code>instanceof</code>运算符时，绑定构造函数和未绑定构造函数并无两样。</p><h4 id="5-toString-方法"><a href="#5-toString-方法" class="headerlink" title="5. toString()方法"></a>5. toString()方法</h4><p>和所有的JavaScript对象一样，函数也有<code>toString()</code>方法，ES规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数的<code>toString()</code>方法的实现都返回函数的完整源码。内置函数往往返回一个类似“<code>[native code]</code>”的字符串作为函数体。</p><h4 id="6-Function-构造函数"><a href="#6-Function-构造函数" class="headerlink" title="6. Function()构造函数"></a>6. Function()构造函数</h4><p>不管是通过函数定义语句还是函数直接量表达式，函数的定义都要使用<code>function</code>关键字。但函数还是可以通过<code>Function()</code>构造函数来定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x * y;'</span>);</span><br></pre></td></tr></table></figure><p>这行代码创建一个新的函数，这个函数和通过下面代码定义的函数几乎等价</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x * y; &#125;;</span><br></pre></td></tr></table></figure><p><code>Function()</code>构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体：它可以包含任意的JavaScript语句，每两条语句之间用分号分隔。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只需给构造函数简单地传入一个字符串——函数体——即可。</p><p>注意，<code>Function()</code>构造函数并不需要通过传入实参以指定函数名。就像函数直接量一样，<code>Function()</code>构造函数创建一个匿名函数。</p><p>关于<code>Function()</code>构造函数有几点需要特别注意：</p><ul><li><p><code>Function()</code>构造函数允许JavaScript在运行时动态地创建并编译函数。</p></li><li><p>每次调用<code>Function()</code>构造函数都会解析函数体，并创建新的函数对象。如果是在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响。相比之下，循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译。</p></li><li><p>最后一点，也是关于<code>Function()</code>构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译总是会在顶层函数执行，正如下面代码所示</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">'local'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'return scope;'</span>);               <span class="comment">// 无法捕获局部作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一行代码返回global，因为通过Function()构造函数</span></span><br><span class="line"><span class="comment">// 所返回的函数使用的不是局部作用域</span></span><br><span class="line">constructionFunction()();                               <span class="comment">// =&gt; 'global'</span></span><br></pre></td></tr></table></figure><p>我们可以将<code>Function()</code>构造函数认为是在全局作用域中执行的<code>eval()</code>，<code>eval()</code>可以在自己的私有作用域内定义新变量和函数，<code>Function()</code>构造函数在实际编程过程中很少会用到。</p><h4 id="7-可调用的对象"><a href="#7-可调用的对象" class="headerlink" title="7. 可调用的对象"></a>7. 可调用的对象</h4><p>我们在前面提到的“类数组对象”并不是真正的数组，但大部分场景下可以将其当作数组来对待。对于函数也存在类似的情况。“可调用对象”（<code>callable object</code>）是一个对象，可以在函数调用表达式中调用这个对象。所有的函数都是可调用的，但并非所有的可调用对象都是函数。</p><p>截至目前，可调用对象在两个JavaScript实现中不能算作函数：</p><ul><li><p>1) IE8及之前的版本实现了客户端方法（<code>window.alert()</code>和<code>document.getElementById()</code>），使用了可调用的宿主对象，而不是内置函数对象。IE中的这些方法在其他浏览器中也都存在，但它们本质上不是<code>Function</code>对象。IE9将它们实现为真正的函数，因此这类可调用的对象越来越罕见。</p></li><li><p>2) <code>RegExp</code>对象，可以直接调用<code>RegExp</code>对象，这比调用它的<code>exec()</code>方法更快捷一些。在JavaScript中这是一个彻头彻尾的非标准特性，代码最好不要对可调用的<code>RegExp</code>对象由太多依赖，这个特性在不久的将来可能会废弃并删除。</p></li></ul><p>如果想检测一个对象是否是真正的函数对象（并且具有函数方法），可以检测它的<code>class</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(x) === <span class="string">'[object Function]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="九、函数式编程"><a href="#九、函数式编程" class="headerlink" title="九、函数式编程"></a>九、函数式编程</h3><p>和Lisp、Haskell不同，JavaScript并非函数式编程语言，但在JavaScript中可以像操控对象一样操控函数，也就是说可以在JavaScript中应用函数式编程技术。ES5中的数组方法（诸如<code>map()</code>和<code>reduce()</code>）就可以非常适合用于函数式编程风格。</p><h4 id="1-使用函数处理数组"><a href="#1-使用函数处理数组" class="headerlink" title="1. 使用函数处理数组"></a>1. 使用函数处理数组</h4><p>假设有一个数组，数组元素都是数字，我们想要计算这些元素的平均值和标准差。若使用非函数式编程风格的话，代码会是这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>];                             <span class="comment">// 待处理数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平均数是所有元素的累加和值除以元素个数</span></span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    total += data[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mean = total / data.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算标准差，首先计算每个数据减去平均数之后偏差的平方然后求和</span></span><br><span class="line">total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> deviation = data[i] - mean;</span><br><span class="line">    total += deviation * deviation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stddev = <span class="built_in">Math</span>.sqrt(total / (data.length - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>可以使用数组方法<code>map()</code>和<code>reduce()</code>来实现同样的计算，这种实现极其简洁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先定义两个简单的函数</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x &#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将这些函数和数组方法配合使用计算出平均数和标准差</span></span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> mean = data.reduce(sum) / data.length;</span><br><span class="line"><span class="keyword">var</span> deviations = data.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x - mean; &#125;);</span><br><span class="line"><span class="keyword">var</span> stddev = <span class="built_in">Math</span>.sqrt(deviations.map(square).reduce(sum) / (data.length - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>如果我们基于ES3来如何实现呢？因为ES3中并不包含这些数组方法，如果不存在内置方法的话我们可以自定义<code>map()</code>和<code>reduce()</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个数组元素调用f()，并返回一个结果数组</span></span><br><span class="line"><span class="comment">// 如果Array.prototype.map定义了的话，就使用这个方法</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="built_in">Array</span>.prototype.map ? </span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a, f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.map(f);</span><br><span class="line">    &#125;:</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a, f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> results = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = a.length; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i <span class="keyword">in</span> a) &#123;</span><br><span class="line">                results[i] = f.call(<span class="literal">null</span>, a[i], i, a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数f()和可选的初始值将数组a减至一个值</span></span><br><span class="line"><span class="comment">// 如果Array.prototype.reduce存在的话，就使用这个方法</span></span><br><span class="line"><span class="keyword">var</span> reduce = <span class="built_in">Array</span>.prototype.reduce ?</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a, f, initial</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.reduce(f, initial);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.reduce(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;:</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">a, f, initial</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span>, len = a.length, accumulator;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以特定的初始值开始，否则第一个值取自a</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            accumulator = initial;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i <span class="keyword">in</span> a) &#123;</span><br><span class="line">                    accumulator = a[i++];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == len) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于数组中剩下的元素依次调用f()</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i <span class="keyword">in</span> a) &#123;</span><br><span class="line">                accumulator = f.call(<span class="literal">undefined</span>, accumulator, a[i], i, a);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用定义的<code>map()</code>和<code>reduce()</code>函数，计算平均值和标准差的代码看起来像这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> mean = reduce(data, sum) / data.length;</span><br><span class="line"><span class="keyword">var</span> deviations = map(data, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - mean;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> stddev = <span class="built_in">Math</span>.sqrt(reduce(map(deviations, square), sum) / (data.length - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2. 高阶函数"></a>2. 高阶函数</h4><p>所谓高阶函数（<code>higher-order function</code>）就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个高阶函数返回一个新的函数，这个新函数将它的实参传入f()</span></span><br><span class="line"><span class="comment">// 并返回f的返回值的逻辑非</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">not</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = f.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);          <span class="comment">// 调用f()</span></span><br><span class="line">        <span class="keyword">return</span> !result;                                 <span class="comment">// 对结果求反</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> even = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> odd = not(even);                                    <span class="comment">// 一个新函数，所做的事情和even()相反</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>].every(odd);                             <span class="comment">// =&gt; true  每个元素都是奇数</span></span><br></pre></td></tr></table></figure><p>上面的<code>not()</code>函数就是一个高阶函数，因为它接收一个函数作为参数，并返回一个新函数。另外一个例子，来看下面的<code>mapper()</code>函数，它也是接收一个函数作为参数，并返回一个新函数，这个新函数将一个数组映射到另一个使用这个函数的数组上。这个函数使用了之前定义的<code>map()</code>函数，但要首先理解这两个函数有哪些不同，这一点至关重要</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所返回的函数的参数应当是一个实参数组，并对每个数组元素执行函数f()</span></span><br><span class="line"><span class="comment">// 并返回所有计算结果组成的数组</span></span><br><span class="line"><span class="comment">// 可以对比一下这个函数和上文提到的map()函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapper</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map(a, f);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increment = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> incrementer = mapper(increment);</span><br><span class="line"></span><br><span class="line">incrementer([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);                                 <span class="comment">// =&gt; [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>这里是一个更常见的例子，它接收两个函数<code>f()</code>和<code>g()</code>，并返回一个新的函数用以计算<code>f(g())</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个新的可以计算f(g(...))的函数</span></span><br><span class="line"><span class="comment">// 返回的函数h()将它所有的实参传入g()，然后将g()的返回值传入f()</span></span><br><span class="line"><span class="comment">// 调用f()和g()时的this值和调用h()时的this值是同一个this</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">f, g</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 需要给f()传入一个参数，所以使用f()的call()方法</span></span><br><span class="line">        <span class="comment">// 需要给g()传入很多参数，所以使用g()的apply()方法</span></span><br><span class="line">        <span class="keyword">return</span> f.call(<span class="keyword">this</span>, g.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> squareofsum = compose(square, sum);</span><br><span class="line"></span><br><span class="line">squareofsum(<span class="number">2</span>, <span class="number">3</span>);                                      <span class="comment">// =&gt; 25</span></span><br></pre></td></tr></table></figure><h4 id="3-不完全函数"><a href="#3-不完全函数" class="headerlink" title="3. 不完全函数"></a>3. 不完全函数</h4><p>函数<code>f()</code>的<code>bind()</code>方法返回一个新函数，给新函数传入特定的上下文和一组指定的参数，然后调用函数<code>f()</code>。我们说它把函数“绑定至”对象并传入一部分参数。<code>bind()</code>方法只是将实参放在（完整实参列表的）左侧，也就是说<code>bind()</code>的实参都是放在传入原始函数的实参列表开始的位置，但有时我们期望将传入<code>bind()</code>的实参放在（完整实参列表的）右侧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个工具函数将类数组对象（或对象）转换为真正的数组</span></span><br><span class="line"><span class="comment">// 在后面的示例代码中用到了这个方法将arguments对象转换为真正的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">array</span>(<span class="params">a, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(a, n || <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实参传递至左侧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialLeft</span>(<span class="params">f <span class="regexp">/*, ...*/</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;                               <span class="comment">// 保存外部的实参数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = array(args, <span class="number">1</span>);                         <span class="comment">// 开始处理外部的第一个args</span></span><br><span class="line">        a = a.concat(array(<span class="built_in">arguments</span>));                 <span class="comment">// 然后增加所有的内部实参</span></span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="keyword">this</span>, a);                        <span class="comment">// 然后基于这个实参列表调用f()</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实参传递至右侧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialRight</span>(<span class="params">f <span class="regexp">/*, ...*/</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;                               <span class="comment">// 保存外部实参数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = array(<span class="built_in">arguments</span>);                       <span class="comment">// 从内部参数开始</span></span><br><span class="line">        a = a.concat(array(args, <span class="number">1</span>));                   <span class="comment">// 然后从外部第一个args开始添加</span></span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="keyword">this</span>, a);                        <span class="comment">// 最后基于这个实参列表调用f()</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实参被用作模板</span></span><br><span class="line"><span class="comment">// 实参列表中的undefined值都被填充</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">f <span class="regexp">/*, ...*/</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;                               <span class="comment">// 保存外部实参数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = array(args, <span class="number">1</span>);                         <span class="comment">// 从外部args开始</span></span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历args，从内部实参填充undefined值</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                a[i] = <span class="built_in">arguments</span>[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 现在将剩下的内部实参都追加进去</span></span><br><span class="line">        a = a.concat(array(<span class="built_in">arguments</span>, j));</span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="keyword">this</span>, a);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数带有三个实参</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * (y - z);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个不完全调用</span></span><br><span class="line">partialLeft(f, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>);                                <span class="comment">// =&gt; -2  绑定第一个实参：2*(3-4)</span></span><br><span class="line">partialRight(f, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>);                               <span class="comment">// =&gt; 6  绑定最后一个实参：3*(4-2)</span></span><br><span class="line">partial(f, <span class="literal">undefined</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>);                         <span class="comment">// =&gt; -6  绑定中间的实参：3*(2-4)</span></span><br></pre></td></tr></table></figure><p>利用这种不完全函数的编程技巧，可以编写一些有意思的代码，利用已有的函数来定义新的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> increment = partialLeft(sum, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> cuberoot = partialRight(<span class="built_in">Math</span>.pow, <span class="number">1</span>/<span class="number">3</span>);</span><br><span class="line"><span class="built_in">String</span>.prototype.first = partial(<span class="built_in">String</span>.prototype.charAt, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">String</span>.prototype.last = partial(<span class="built_in">String</span>.prototype.substr, <span class="number">-1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当将不完全调用和其他高阶函数整合在一起的时候，事情就变得格外有趣了。比如，这里的例子定义了<code>not()</code>函数，它用到了刚才提到的不完全调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> not = partialLeft(compose, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !x;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> even = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> odd = not(even);</span><br><span class="line"><span class="keyword">var</span> isNumber = not(<span class="built_in">isNaN</span>);</span><br></pre></td></tr></table></figure><p>我们也可以使用不完全调用的组合来重新组织求平均数和标准差的代码，这种编码风格是非常纯粹的函数式编程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>];                                 <span class="comment">// 待处理的数据</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;                                  <span class="comment">// 两个初等函数</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> product = functon(x, y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> neg = partial(product, <span class="number">-1</span>);                             <span class="comment">// 定义其他函数</span></span><br><span class="line"><span class="keyword">var</span> square = partial(<span class="built_in">Math</span>.pow, <span class="literal">undefined</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> sqrt = partial(<span class="built_in">Math</span>.pow, <span class="literal">undefined</span>, <span class="number">.5</span>);</span><br><span class="line"><span class="keyword">var</span> reciprocal = partial(<span class="built_in">Math</span>.pow, <span class="literal">undefined</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在计算平均值和标准差，所有的函数调用都不带运算符</span></span><br><span class="line"><span class="keyword">var</span> mean = product(reduce(data, sum), reciprocal(data.length));</span><br><span class="line"><span class="keyword">var</span> stddev = sqrt(product(reduce(map(data, </span><br><span class="line">                                    compose(square, </span><br><span class="line">                                            partial(sum, neg(mean)))), </span><br><span class="line">                                sum), </span><br><span class="line">                        reciprocal(sum(data.length, <span class="number">-1</span>))));</span><br></pre></td></tr></table></figure><h4 id="4-记忆"><a href="#4-记忆" class="headerlink" title="4. 记忆"></a>4. 记忆</h4><p>在函数式编程中，采用缓存的方式记录结果的技巧称为“记忆”（<code>memorization</code>）。下面的代码展示了一个高阶函数，<code>memorize()</code>接收一个函数作为实参，并返回带有记忆能力的函数。</p><blockquote><p>需要注意的是，记忆只是一种编程技巧，本质上是牺牲算法的空间复杂度以换取更优的时间复杂度，在客户端JavaScript中代码的执行时间复杂度往往成为瓶颈，因此在大多数场景下，这种牺牲空间换取时间的做法以提升程序执行效率的做法是非常可取的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回f()的带有记忆功能的版本</span></span><br><span class="line"><span class="comment">// 只有当f()的实参的字符串表示都不相同时它才会工作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;                                         <span class="comment">// 将值保存在闭包内</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将实参转换为字符串形式，并将其用作缓存的键</span></span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">arguments</span>.length + <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">','</span>);</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[key];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[key] = f.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>memorize()</code>函数创建一个新的对象，这个对象被当作缓存（的宿主）并赋值给一个局部变量，因此对于返回的函数来说它是私有的（在闭包中）。所返回的函数将它的实参数组转换成字符串，并将字符串用作缓存对象的属性名。如果在缓存中存在这个值，则直接返回它。</p><p>否则，就调用既定的函数对实参进行计算，将计算结果换存起来并返回，下面的代码展示了如何使用<code>memorize()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回两个整数的最大公约数</span></span><br><span class="line"><span class="comment">// 使用欧几里德算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        t = b;</span><br><span class="line">        b = a;</span><br><span class="line">        a = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>) &#123;</span><br><span class="line">        t = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gcdmemo = memorize(gcd);</span><br><span class="line">gcdmemo(<span class="number">85</span>, <span class="number">187</span>);                                           <span class="comment">// =&gt; 187</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，当我们写一个递归函数时，往往需要实现记忆功能</span></span><br><span class="line"><span class="comment">// 我们更希望调用实现了记忆功能的递归函数，而不是原递归函数</span></span><br><span class="line"><span class="keyword">var</span> factorial = memorize(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>);                                               <span class="comment">// =&gt; 120  对于4~1的值也有缓存</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数是这样的一段JavaScript代码，它只定义一次，但可能被执行或调用任意次。JavaScript函数是参数化的：函数的定义会包括一个称为形参（&lt;code&gt;parameter&lt;/code&gt;）的标识符列表，这些参数在函数体中像局部变量一样工作。函数调用会为形参提供实参的值。函数使用它们实参的值来计算返回值，称为该函数调用表达式的值。除了实参之外，每次调用还会拥有另外一个值——本次调用的上下文——就是&lt;code&gt;this&lt;/code&gt;关键字的值。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript数组" scheme="http://www.xiaoleon.cn/tags/JavaScript%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JS(3) 数组</title>
    <link href="http://www.xiaoleon.cn/2018/01/27/js-3/"/>
    <id>http://www.xiaoleon.cn/2018/01/27/js-3/</id>
    <published>2018-01-27T09:48:25.000Z</published>
    <updated>2018-01-28T15:07:22.340Z</updated>
    
    <content type="html"><![CDATA[<p>数组是值的有序集合，每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。JavaScript数组的索引是基于零的32位数，第一个元素的索引为0，最大可能的索引为<code>4 294 967 294</code>（<code>2e32-2</code>），数组最大能容纳<code>4 294 967 295</code>个元素。</p><a id="more"></a><p>JavaScript数组可能是稀疏的：数组元素的索引不一定要连续的，它们之间可以有空缺。每个JavaScript数组都有一个<code>length</code>属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，<code>length</code>比所有元素的索引要大。</p><p>JavaScript数组是JavaScript对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。我们将在本文的其他地方更多地讨论特殊化的数组。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。</p><h3 id="一、创建数组"><a href="#一、创建数组" class="headerlink" title="一、创建数组"></a>一、创建数组</h3><p>使用数组直接量是创建数组最简单的方法，在方括号中将数组元素用逗号隔开即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = [];</span><br><span class="line"><span class="keyword">var</span> primes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> misc = [<span class="number">1.1</span>, <span class="literal">true</span>, <span class="string">'a'</span>, ];</span><br></pre></td></tr></table></figure><p>数组直接量中的值不一定要是常量，它们可以是任意的表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> base = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">var</span> table = [table, base+<span class="number">1</span>, base+<span class="number">2</span>, base+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = [[<span class="number">1</span>, &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;], [<span class="number">2</span>, &#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>:<span class="number">4</span>&#125;]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = [<span class="number">1</span>, ,<span class="number">3</span>];        <span class="comment">// 数组有3个元素，中间那个元素值为undefined</span></span><br><span class="line"><span class="keyword">var</span> undefs = [,,];          <span class="comment">// 数组有2个元素，都是undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>数组直接量的语法允许有可选的结尾的逗号，故<code>[,,]</code>只有两个元素而非三个。</p></blockquote><p>调用构造函数<code>Array()</code>是创建数组的另一种方法。可以用三种方式调用构造函数。</p><ul><li><p>调用时没有参数</p><p>  该方法创建一个没有任何元素的空数组，等同于数组直接量<code>[]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br></pre></td></tr></table></figure></li><li><p>调用时有一个数值参数，它指定长度</p><p>  该方法创建指定长度的数组。当预先知道所需元素个数时，这种形式的Array构造函数可以用来预分配一个数组空间。注意，数组中没有存储值，甚至数组的索引属性还未定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><p>显示指定两个或多个数组元素或者数组的一个非数值元素</p><p>  以这种形式，构造函数的参数将会称为新数组的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">'testing, testing'</span>);</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="二、数组元素的读和写"><a href="#二、数组元素的读和写" class="headerlink" title="二、数组元素的读和写"></a>二、数组元素的读和写</h3><p>使用<code>[]</code>操作符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。因此，下方代码都是合法的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'world'</span>];</span><br><span class="line"><span class="keyword">var</span> value = a[<span class="number">0</span>];</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">3.14</span>;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">a[i] = <span class="number">3</span>;</span><br><span class="line">a[i+<span class="number">1</span>] = <span class="string">'hello'</span>;</span><br><span class="line">a[a[i]] = a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><blockquote><p><strong>请记住，数组是对象的特殊形式</strong></p></blockquote><p>使用方括号访问数组元素就像用方括号访问对象的属性一样。JavaScript将指定的数字索引值转换成字符串——索引值<code>1</code>变成<code>“1”</code>——然后将其作为属性名来使用。关于索引值从数字转换为字符串没什么特别之处：对常规对象也可以这么做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o[<span class="number">1</span>] = <span class="string">'one'</span>;</span><br></pre></td></tr></table></figure><p>数组的特别之处在于，当使用小于<code>2e32</code>的非负整数作为属性名时，数组会自动维护其<code>length</code>属性值。</p><p>清晰地区分数组的索引和对象的属性名是非常有用的。所有的索引都是属性名，但只有<code>0~2e32-2</code>之间的整数属性名才是索引。所有的数组都是对象，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的<code>length</code>属性值。</p><p>注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当作常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负整数的字符串，它就当作数组索引，而非对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这将创建一个名为“-1.23”的属性</span></span><br><span class="line">a[<span class="number">-1.23</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 这是数组的第1001个元素</span></span><br><span class="line">a[<span class="string">'1000'</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 和a[1]相等</span></span><br><span class="line">a[<span class="number">1.000</span>];</span><br></pre></td></tr></table></figure><p>事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着JavaScript数组没有“越界”错误的概念。当试图查询任意对象中不存在的属性时，不会报错，只会得到<code>undefined</code>值。</p><p>既然数组是对象，那么它们可以从原型中继承元素。ES5中，数组可以定义元素的<code>getter</code>和<code>setter</code>方法。如果一个数组确实继承了元素或使用了元素的<code>getter</code>和<code>setter</code>方法，我们应该期望它使用非优化的代码路径：访问者中数组的元素的时间会与常规对象属性的查找时间相近。</p><hr><h3 id="三、稀疏数组"><a href="#三、稀疏数组" class="headerlink" title="三、稀疏数组"></a>三、稀疏数组</h3><p>稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的<code>length</code>属性值代表数组中元素的个数。如果数组是稀疏的，<code>length</code>属性值大于元素的个数。可以用<code>Array()</code>构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);       <span class="comment">// 数组没有元素，但是a.length=5</span></span><br><span class="line">a = [];                 <span class="comment">// 创建一个空数组，length=0</span></span><br><span class="line">a[<span class="number">1000</span>] = <span class="number">0</span>;            <span class="comment">// 赋值添加一个元素，但是length=1001</span></span><br></pre></td></tr></table></figure><p>足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。</p><p>需要注意的是，当省略数组直接量中的值时（使用连续的逗号，比如<code>[1,,3]</code>），这时所得到的数组也是稀疏数组，省略掉的值是不存在的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = [,,,];</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a1;                    <span class="comment">// false a1在索引0处有一个元素</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a2;                    <span class="comment">// false a2在索引0处没有元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、数组长度"><a href="#四、数组长度" class="headerlink" title="四、数组长度"></a>四、数组长度</h3><p>每个数组都有一个<code>length</code>属性，就是这个属性使其区别于常规的JavaScript对象。针对稠密数组（非稀疏数组），<code>length</code>属性值代表数组中元素的个数。其值比数组中最大的索引大1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[].length;                  <span class="comment">// 0 数组没有元素</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].length      <span class="comment">// 3 最大索引值为2，length=3</span></span><br></pre></td></tr></table></figure><p>在数组中肯定找不到一个元素的索引值大于或等于它的长度，为了维持此规则不变化，数组有两个特殊的行为</p><ul><li><p>如果为一个数组元素赋值，它的索引<code>i</code>大于或等于现有数组的长度是，<code>length</code>属性的值将设置为<code>i+1</code></p></li><li><p>设置<code>length</code>属性为一个小于当前长度的非负整数<code>n</code>时，当前数组中那些索引值大于或等于<code>n</code>的元素将从中删除</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.length = <span class="number">3</span>;               <span class="comment">// a = [1, 2, 3]</span></span><br><span class="line">a.length = <span class="number">0</span>;               <span class="comment">// a = []</span></span><br><span class="line">a.length = <span class="number">5</span>;               <span class="comment">// 长度为5，但是没有元素，就像new Array(5)</span></span><br></pre></td></tr></table></figure><p>还可以将数组的<code>length</code>属性值设置为大于其当前的长度，实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个空的区域。</p><p>在ES5中，可用用<code>Object.defineProperty()</code>让数组的<code>length</code>属性变成只读的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'length'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a.length = <span class="number">0</span>;               <span class="comment">// a不会改变</span></span><br></pre></td></tr></table></figure><p>类似的，如果让一个数组元素不能配置，就不能删除它。如果不能删除它，<code>length</code>属性就不能设置为小于不可配置元素的索引值。</p><hr><h3 id="五、数组元素的添加和删除"><a href="#五、数组元素的添加和删除" class="headerlink" title="五、数组元素的添加和删除"></a>五、数组元素的添加和删除</h3><ul><li><p>push()</p><p>我们可以使用<code>push()</code>方法在数组末尾增加一个或多个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [];</span><br><span class="line">a.push(<span class="string">'zero'</span>);             <span class="comment">// a = ['zero']</span></span><br><span class="line">a.push(<span class="string">'one'</span>, <span class="string">'two'</span>);       <span class="comment">// a = ['zero', 'one', 'two']</span></span><br></pre></td></tr></table></figure><p>在数组尾部压入一个元素与给数组<code>a[a.length]</code>赋值是一样的。</p></li><li><p>unshift()</p><p>可以使用<code>unshift()</code>方法在数组的首部插入一个元素，并且将其他元素依次移到更高的索引处。</p></li><li><p>delete</p><p>可以像删除对象属性一样使用<code>delete</code>运算符来删除数组元素。</p><p>删除数组元素与为其赋值<code>undefined</code>值是类似的（但有一些微妙的区别）。</p><p>注意，对一个数组元素使用<code>delete</code>不会修改数组的<code>length</code>属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，它就变成稀疏数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];</span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> a;                     <span class="comment">// false 数组索引1并未在数组中定义</span></span><br><span class="line">a.length;                   <span class="comment">// 3 delete操作不影响数组长度</span></span><br></pre></td></tr></table></figure></li><li><p>pop()</p><p>可以使用<code>pop()</code>方法，使长度减少1并返回被删除元素的值</p></li><li><p>shift()</p><p>可以使用<code>shift()</code>方法，从数组头部删除一个元素，和<code>delete</code>不同的是，<code>shift()</code>方法将所有元素下移到比当前索引低<code>1</code>的地方</p></li><li><p>splice()</p><p>可以使用<code>splice()</code>方法来插入、删除或替换数组元素，它会根据需要修改<code>length</code>属性并移动元素到更高或更低的索引处</p></li></ul><hr><h3 id="六、数组遍历"><a href="#六、数组遍历" class="headerlink" title="六、数组遍历"></a>六、数组遍历</h3><p>使用<code>for</code>循环是遍历数组元素最常见的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(o);</span><br><span class="line"><span class="keyword">var</span> values = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i= <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i];</span><br><span class="line">    values[i] = o[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在嵌套循环或其他性能非常重要的上下文中，可以看到这种基本的数组遍历需要优化，数组的长度应该只查询一次而非每次循环都要查询</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 循环体不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些例子假设数组是稠密的，并且所有的元素都是合法数组。否则，使用数组元素之前应该先检测它们。如果想要排除<code>null</code>、<code>undefined</code>和不存在的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!a[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果只想跳过undefined和不存在的元素</span></span><br><span class="line">    <span class="keyword">if</span> (a[i] === <span class="literal">undefined</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果只想跳过不存在的元素，仍然要处理存在的undefined元素</span></span><br><span class="line">    <span class="keyword">if</span> (!(i <span class="keyword">in</span> a)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用<code>for/in</code>循环处理稀疏数组。循环每次将一个可枚举的属性名（包括数组索引）赋值给循环变量，不存在索引将不会遍历到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> sparseArray) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = sparseArray[index];</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是由于<code>for/in</code>循环能够枚举继承的属性名，如添加到<code>Array.prototype</code>中的方法，在数组上不应该使用<code>for/in</code>循环，除非使用额外的检测方法来过滤不想要的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="comment">// 跳过继承的属性</span></span><br><span class="line">    <span class="keyword">if</span> (!a.hasOwnProperty(i)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="comment">// 跳过不是非负整数的属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">String</span>(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(i)))) !== i) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES规范允许<code>for/in</code>循环以不同的顺序遍历对象的属性，通常数组元素的遍历实现是升序的，但不能保证一定是这样。特别的，如果数序同时拥有对象属性和数组元素，返回的属性名很可能是按照创建的顺序而非数值的大小顺序。如何处理这个问题的实现各不相同，如果算法依赖于遍历的顺序，那么最好不要使用<code>for/in</code>而用常规的<code>for</code>循环。</p><p>ES5定义了一些遍历数组元素的新方法，按照索引的顺序按个传递给定义的一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sumOfSquares = <span class="number">0</span>;</span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    sumOfSquares += x * x;</span><br><span class="line">&#125;)</span><br><span class="line">sumOfSquares;</span><br></pre></td></tr></table></figure><hr><h3 id="七、多维数组"><a href="#七、多维数组" class="headerlink" title="七、多维数组"></a>七、多维数组</h3><p>JavaScript不支持真正的多维数组，但可以用数组的数组来近似。访问数组的数组中的元素，只要简单地使用两次<code>[]</code>操作符即可。例如，假设变量<code>matrix</code>是一个数组的数组，它的基本元素是数值，那么<code>matrix[x]</code>的每个元素是包含一个数值数组，访问数组中特定数值的代码为<code>matrix[x][y]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> row = <span class="number">0</span>; row &lt; table.length; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (col = <span class="number">0</span>; col &lt; table[row].length; col++) &#123;</span><br><span class="line">        table[row][col] = row * col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> product = table[<span class="number">5</span>][<span class="number">7</span>];              <span class="comment">// =&gt; 35</span></span><br></pre></td></tr></table></figure><hr><h3 id="八、数组方法"><a href="#八、数组方法" class="headerlink" title="八、数组方法"></a>八、数组方法</h3><p>ES3在<code>Array.prototype</code>中定义了一些很有用的操作数组的函数，这意味着这些函数作为任何数组的方法都是可用的。</p><ul><li><p>join()</p><p><code>Array.join()</code>方法将数组中的所有元素都转化为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生成的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。</p><p><code>Array.join()</code>是<code>String.split()</code>方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.join();                               <span class="comment">// =&gt; '1,2,3'</span></span><br><span class="line">a.join(<span class="string">' '</span>);                            <span class="comment">// =&gt; '1 2 3'</span></span><br><span class="line">a.join(<span class="string">''</span>);                             <span class="comment">// =&gt; '123'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line">b.join(<span class="string">'-'</span>);                            <span class="comment">// =&gt; '---------'</span></span><br></pre></td></tr></table></figure></li><li><p>reverse()</p><p><code>Array.reverse()</code>方法将数组中的元素颠倒顺序，返回逆序的数组。它采取了替换，换句话说，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列它们</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.reverse();                    <span class="comment">// =&gt; [3, 2, 1]</span></span><br><span class="line">a == b;                                 <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure></li><li><p>sort()</p><p><code>Array.sort()</code>方法将数组中的元素排序并返回排序后的数组，当不带参数调用<code>sort()</code>时，数组元素以字母表顺序排序（如有必要将临时转化为字符串进行比较）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'banana'</span>, <span class="string">'cherry'</span>, <span class="string">'apple'</span>);</span><br><span class="line">a.sort();</span><br><span class="line"><span class="keyword">var</span> s = a.join(<span class="string">','</span>);                    <span class="comment">// 'apple,banana,cherry'</span></span><br></pre></td></tr></table></figure><p>如果数组包含<code>undefined</code>元素，它们会被排到数组的尾部。</p><p>为了按照其他方式而非字母顺序进行数组排序，必须给<code>sort()</code>方法传递一个比较函数，该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小于0的数值。反之，假设第一个参数应该在后，函数应该返回一个大于0的数值。并且，假设两个值相等（也就是说，它们的顺序无关紧要），函数应该返回0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">33</span>, <span class="number">4</span>, <span class="number">1111</span>, <span class="number">222</span>];</span><br><span class="line">a.sort();                               <span class="comment">// [1111, 222, 33, 4]</span></span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);                                     <span class="comment">// [4, 33, 222, 1111]</span></span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b - a;               </span><br><span class="line">&#125;);                                     <span class="comment">// [1111, 222, 33, 4]</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意，这里使用匿名函数表达式非常方便，既然比较函数只使用一次，就没必要给它们命名了</p></blockquote><h4 id="4-concat"><a href="#4-concat" class="headerlink" title="4. concat()"></a>4. concat()</h4><p>Array.concat()方法创建并返回一个新书组，它的元素包括调用concat()的原是数组的元素和concat()的每个参数。如果这些参数中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，concat()不会递归扁平化的数组，concat()也不会修改调用的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.concat(<span class="number">4</span>, <span class="number">5</span>);                         <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>, <span class="number">5</span>]);                       <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>]);               <span class="comment">// [1,2,3,4,5,6,7]</span></span><br><span class="line">a.concat(<span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]]);               <span class="comment">// [1,2,3,4,5,[6,7]]</span></span><br></pre></td></tr></table></figure><h4 id="5-slice"><a href="#5-slice" class="headerlink" title="5. slice()"></a>5. slice()</h4><p>Array.slice()方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束位置。返回的数组包含第一个参数指定的位置和所有到但不含第二个参数指定的位置之间的所有数组元素。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如参数中出现负数，它表示相对于数组的最后一个元素的位置。</p><p>注意，slice()方法不会修改调用的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.slice(<span class="number">0</span>, <span class="number">3</span>);                          <span class="comment">// [1,2,3]</span></span><br><span class="line">a.slice(<span class="number">3</span>);                             <span class="comment">// [4,5]</span></span><br><span class="line">a.slice(<span class="number">1</span>, <span class="number">-1</span>);                         <span class="comment">// [2,3,4]</span></span><br><span class="line">a.slice(<span class="number">-3</span>, <span class="number">-2</span>);                        <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure><h4 id="6-splice"><a href="#6-splice" class="headerlink" title="6. splice()"></a>6. splice()</h4><p>Array.splice()方法是在数组中插入或删除元素的通用方法，不同于slice()和concat()，splice()会修改调用的数组。</p><p>splice()能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其它部分仍然保持连续的。splice()第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素的个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。splice()返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">a.splice(<span class="number">4</span>);                            <span class="comment">// return [5,6,7,8]  a = [1,2,3,4]</span></span><br><span class="line">a.splice(<span class="number">1</span>, <span class="number">2</span>);                         <span class="comment">// return [2,3]  a = [1,4]</span></span><br><span class="line">a.splice(<span class="number">1</span>, <span class="number">1</span>);                         <span class="comment">// return [4]  a = [1]</span></span><br></pre></td></tr></table></figure><p>splice()的前两个参数指定了需要删除的数组元素，紧随其后的任意个数的参数指定了需要插入到数组的元素，从第一个参数指定的位置开始插入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'b'</span>);               <span class="comment">// return []  a = [1,2,'a','b',3,4,5]</span></span><br><span class="line">a.splice(<span class="number">2</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>);              <span class="comment">// return ['a', 'b']  a = [1,2,[1,2],3,3,4,5]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，区别于concat()，splice()会插入数组本身，而非数组的元素</p></blockquote><h4 id="7-push-和pop"><a href="#7-push-和pop" class="headerlink" title="7. push()和pop()"></a>7. push()和pop()</h4><p>push()和pop()方法允许将数组当作栈来使用。push()方法在数组的尾部添加一个或多个元素，并返回数组新的长度。pop()方法则相反，它删除数组的最后一个元素，减小数组长度并返回它删除的值。组合使用push()和pop()能够用JavaScript数组实现先进后出的栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = [];</span><br><span class="line">stack.push(<span class="number">1</span>, <span class="number">2</span>);                       <span class="comment">// return 2  stack = [1,2]</span></span><br><span class="line">stack.pop();                            <span class="comment">// return 2  stack = [1]</span></span><br><span class="line">stack.push(<span class="number">3</span>);                          <span class="comment">// return 2  stack = [1,3]</span></span><br><span class="line">stack.pop();                            <span class="comment">// return 3  stack = [1]</span></span><br><span class="line">stack.push([<span class="number">4</span>, <span class="number">5</span>]);                     <span class="comment">// return 2  stack = [1,[4,5]]</span></span><br><span class="line">stack.pop();                            <span class="comment">// return [4,5]  stack = [1]</span></span><br><span class="line">stack.pop();                            <span class="comment">// return 1  stack = []</span></span><br></pre></td></tr></table></figure><h4 id="8-unshift-和shift"><a href="#8-unshift-和shift" class="headerlink" title="8. unshift()和shift()"></a>8. unshift()和shift()</h4><p>unshift()和shift()方法的行为类似于push()和pop()，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">a.unshift(<span class="number">1</span>);                           <span class="comment">// return 1  a = [1]</span></span><br><span class="line">a.unshift(<span class="number">22</span>);                          <span class="comment">// return 2  a = [22,1]</span></span><br><span class="line">a.shift();                              <span class="comment">// return 22  a = [1]</span></span><br><span class="line">a.unshift(<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]);                   <span class="comment">// return 3  a = [3,[4,5],1]</span></span><br><span class="line">a.shift();                              <span class="comment">// return 3  a = [[4,5],1]</span></span><br><span class="line">a.shift();                              <span class="comment">// return [4,5]  a = [1]</span></span><br><span class="line">a.shift();                              <span class="comment">// return 1  a = []</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，当使用多个参数调用unshift()时，参数是一次性插入的，而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致。</p></blockquote><h4 id="9-toString-和toLocaleString"><a href="#9-toString-和toLocaleString" class="headerlink" title="9. toString()和toLocaleString()"></a>9. toString()和toLocaleString()</h4><p>数组和其他JavaScript对象一样拥有toString()方法。针对数组，该方法将其每个元素转化为字符串（如有必要将调用元素的toString()方法）并且输出用逗号分隔的字符串列表。注意，输出不包括方括号或其他任何形式的包裹数组值的分隔符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toString();                     <span class="comment">// '1,2,3'</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].toString();               <span class="comment">// 'a,b,c'</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, <span class="string">'c'</span>]].toString();                 <span class="comment">// '1,2,c'</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，这里与不使用任何参数调用join()方法返回的字符串是一样的</p></blockquote><p>toLocaleString()是toString()方法的本地化版本，它调用元素的toLocaleString()方法将每个数组元素转化为字符串，并且使用本地化（和自定义实现的）分隔符将这些字符串连接起来生成最终的字符串</p><hr><h3 id="九、ES5中的数组方法"><a href="#九、ES5中的数组方法" class="headerlink" title="九、ES5中的数组方法"></a>九、ES5中的数组方法</h3><p>ES5定义了9个新的数组方法来遍历、映射、过滤、检测、简化和搜索数组。</p><p>ES5数组方法大多数的第一个参数接收一个函数，并且对数组的每个元素调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。在大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。第二个参数是可选的，如果由第二个参数，则调用的函数被看作是第二个参数的方法，也就是说，在调用函数时传递进度的第二个参数作为它的this关键字的值来使用。</p><h4 id="1-forEach"><a href="#1-forEach" class="headerlink" title="1. forEach()"></a>1. forEach()</h4><p>forEach()方法从头至尾遍历数组，为每个元素调用指定的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    sum += value;</span><br><span class="line">&#125;);</span><br><span class="line">sum;                                        <span class="comment">// =&gt; 15</span></span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v, i, a</span>) </span>&#123;</span><br><span class="line">    a[i] = v + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">data;                                       <span class="comment">// =&gt; [2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，forEach()无法在所有元素都传递给调用的函数之前中止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach()方法放在一个try块中，并能抛出一个异常。如果forEach()调用的函数抛出foreach.break异常，循环会提前终止</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foreach</span>(<span class="params">a, f, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        a.forEach(f, t);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e === foreach.break)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach.break = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'StopIteration'</span>);</span><br></pre></td></tr></table></figure><h4 id="2-map"><a href="#2-map" class="headerlink" title="2. map()"></a>2. map()</h4><p>map()方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">b = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);                                         <span class="comment">// b = [1,4,9]</span></span><br></pre></td></tr></table></figure><p>传递给map()的函数的调用方式和传递给forEach()的函数的调用方式一样。但传递给map()的函数应该由返回值。注意，map()返回的是新书组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素。</p><h4 id="3-filter"><a href="#3-filter" class="headerlink" title="3. filter()"></a>3. filter()</h4><p>filter()方法返回的数组元素是调用的数组的一个子集。传递的函数用来逻辑判定的：该函数返回true或false。调用判定函数就像调用forEach()和map()一样。如果返回值为true或能转化为true的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">smallvalues = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">3</span>; &#125;);          <span class="comment">// [2,1]</span></span><br><span class="line">everyother = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x, i</span>) </span>&#123; <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>; &#125;);   <span class="comment">// [5,3,1]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，filter()会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺，代码如下</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dense = sparse.filter(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;);</span><br></pre></td></tr></table></figure><p>甚至，压缩空缺并删除undefined和null元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x !== <span class="literal">undefined</span> &amp;&amp; x !== <span class="literal">null</span>; &#125;);</span><br></pre></td></tr></table></figure><h4 id="4-every-和some"><a href="#4-every-和some" class="headerlink" title="4. every()和some()"></a>4. every()和some()</h4><p>every()和some()方法是数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回true或false。</p><p>every()方法就像数学中的“针对所有”的量词：当且仅当针对数组中的所有元素调用判定方法都返回true，它才返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">10</span>; &#125;);        <span class="comment">// true  所有值都&lt;10</span></span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>; &#125;);   <span class="comment">// false  不是所有值都是偶数</span></span><br></pre></td></tr></table></figure><p>some()方法就像数学中的“存在”的量词：当数组中至少有一个元素调用判定函数返回true，它就返回true；并且当且仅当数值中的所有元素调用判定函数都返回false，它才返回false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span>; &#125;);    <span class="comment">// true  a含有偶数值</span></span><br><span class="line">a.some(<span class="built_in">isNaN</span>);                                  <span class="comment">// false  a不包含非数值元素</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，一旦every()和some()确认该返回什么值它们就会停止遍历数组元素。some()在判定函数第一次返回true后就返回true，但如果判定函数一直返回false，它将会遍历整个数组。every()恰好相反：它在判定函数第一次返回false后就返回false，但如果判定函数一直返回true，它将会遍历整个数组。</p><p>根据数学上的惯例，在空数组上调用时，every()返回true，some()返回false</p></blockquote><h4 id="5-reduce-和reduceRight"><a href="#5-reduce-和reduceRight" class="headerlink" title="5. reduce()和reduceRight()"></a>5. reduce()和reduceRight()</h4><p>reduce()和reduceRight()方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作，也可以称为“注入”和“折叠”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;, <span class="number">0</span>);        <span class="comment">// 数组求和</span></span><br><span class="line"><span class="keyword">var</span> product = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x * y; &#125;, <span class="number">1</span>);    <span class="comment">// 数组求积</span></span><br><span class="line"><span class="keyword">var</span> max = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> (x &gt; y) ? x: y; &#125;);  <span class="comment">// 求最大值</span></span><br></pre></td></tr></table></figure><p>reduce()需要两个参数，第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简后的值。上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的参数是一个传递给函数的初始值。</p><p>当不指定初始值调用reduce()时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就是用了第一个和第二个数组元素作为其第一个和第二个参数。在上面求和与求积的例子中，可以省略初始值参数。</p><p>在空数组上，不带初始值参数调用reduce()将导致类型错误异常。如果调用它的时候只有一个值——数组只有一个元素并且没有指定初始值，或者有一个空数组并且指定一个初始值——reduce()只是简单地返回那个值而不会调用化简函数。</p><p>reduceRight()的工作原理和reduce()一样，不同的是它按照数组索引从高到低处理数组，而不是从低到高。</p><p>在对象章节中，我们定义了一个union()函数，它计算两个对象的“并集”，并返回另一个新对象，新对象具有二者的属性。该函数期待两个对象并返回另一个对象，所以它的工作原理和一个化简函数一样，并且可以使用reduce()来把它一般化，计算任意数目的对象的“并集”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">y</span>:<span class="number">2</span>&#125;, &#123;<span class="attr">z</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> merged = objects.reduce(union);                     <span class="comment">// &#123;x:1, y:2, z:3&#125;</span></span><br></pre></td></tr></table></figure><p>当两个对象拥有同名的属性时，union()函数使用了第一个参数的属性值，这样，reduce()和reduceRight()在使用union()时给出了不同的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">a</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">y</span>:<span class="number">2</span>, <span class="attr">a</span>:<span class="number">2</span>&#125;, &#123;<span class="attr">z</span>:<span class="number">3</span>, <span class="attr">a</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> leftunion = objects.reduce(union);                  <span class="comment">// &#123;x:1, y:2, z:3, a:1&#125;</span></span><br><span class="line"><span class="keyword">var</span> rightunion = objects.reduce(union);                 <span class="comment">// &#123;x:2, y:2, z:3, a:3&#125;</span></span><br></pre></td></tr></table></figure><h4 id="6-indexOf-和lastIndexOf"><a href="#6-indexOf-和lastIndexOf" class="headerlink" title="6. indexOf()和lastIndexOf()"></a>6. indexOf()和lastIndexOf()</h4><p>indexOf()和lastIndexOf()搜索整个数组中具有给定值的元素，返回找到的第一个或最后一个元素的索引，如果没有找到就返回-1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>];</span><br><span class="line">a.indexOf(<span class="number">1</span>);                               <span class="comment">// 1  a[1] == 1</span></span><br><span class="line">a.lastIndexOf(<span class="number">1</span>);                           <span class="comment">// 3  a[3] == 1</span></span><br><span class="line">a.indeOf(<span class="number">3</span>);                                <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p>indexOf()和lastIndexOf()方法不接收函数作为其参数，第一个参数是需要搜索的值，第二个参数是可选的，它指定数组中的一个索引，从指定位置开始搜索。第二个参数也可以是负数，它代表数组末尾的偏移量。</p><blockquote><p>注意，字符串也有indexOf()和lastIndexOf()方法，它们和数组方法的功能类似</p></blockquote><hr><h3 id="十、数组类型"><a href="#十、数组类型" class="headerlink" title="十、数组类型"></a>十、数组类型</h3><p>在ES5中，可以使用Array.isArray()函数来判断未知的对象是否为数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([]);                          <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;);                          <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>ES5以前，要区分数组和非数组对象却令人惊讶地困难。typeof操作符对数组返回“对象”（并且对于除了函数以外的所有对象都是如此）。instanceof操作符只能用于简单的情形</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>;                        <span class="comment">// true</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Array</span>;                      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>使用instanceof的问题是在web浏览器中有可能由多个窗口或窗体(frame)存在，每个窗口都有自己的JavaScript环境，有自己的全局对象。并且，每个全局对象有自己的一组构造函数。因此一个窗体中的对象将不可能是另外窗体中的构造函数的实例。窗体之间的混淆不常发生，但这个问题足以证明instanceof操作符不能视为一个可靠的数组检测方法。</p><p>解决方案是检查对象的类属性，对数组而言该属性的值总是“Array”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = <span class="built_in">Function</span>.isArray || <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> o === <span class="string">'object'</span> &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(o) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="十一、类数组对象"><a href="#十一、类数组对象" class="headerlink" title="十一、类数组对象"></a>十一、类数组对象</h3><p>我们已经看到，JavaScript数组的有一些特性是其他对象所没有的：</p><ul><li><p>当有新的元素添加到列表中时，自动更新length属性</p></li><li><p>设置length为一个较小值将截断数组</p></li><li><p>从Array.prototype中继承一些有用的方法</p></li><li><p>其类属性为“Array”</p></li></ul><p>这些特性让JavaScript数组和常规的对象有明显的区别，但是它们不是定义数组的本质特性。一种常常完全合理的看法把拥有一个数值length属性和对应非负整数属性的对象看作一种类型的数组。</p><p>实践中这些“类数组”对象实际上偶尔出现，虽然不能在它们之上直接调用数组方法或者期望length属性有什么特殊的行为，但是仍然可以用针对真正数组遍历的代码来遍历它们。结论就是很多数组算法针对类数组对象工作得很好，就像针对真正的数组一样。如果算法把数组看成只读的或者如果它们至少保持数组长度不变，也尤其是这种情况。以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的“元素”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="comment">// 添加一些属性，称为“类数组”</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">a.length = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，当作真正的数组遍历它</span></span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">    total += a[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，Arguments对象就是一个类数组对象。在客户端JavaScript中，一些dom方法（如document.getElementsByTagName()）也返回类数组对象。下面有一个函数可以用来检测类数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判定o是否是一个类数组对象</span></span><br><span class="line"><span class="comment">字符串和函数有length属性，但是它们可以用typeof检测将其排除。</span></span><br><span class="line"><span class="comment">在客户端JavaScript中，dom文本节点也有length属性，需要用额外判断o.nodeType != 3将其排除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp;                                        <span class="comment">// o不是null、undefined</span></span><br><span class="line">        <span class="keyword">typeof</span> o === <span class="string">'object'</span> &amp;&amp;                    <span class="comment">// o是对象</span></span><br><span class="line">        <span class="built_in">isFinite</span>(o.length) &amp;&amp;                       <span class="comment">// o.length是有限数值</span></span><br><span class="line">        o.length &gt;= <span class="number">0</span> &amp;&amp;                            <span class="comment">// o.length为非负值</span></span><br><span class="line">        o.length === <span class="built_in">Math</span>.floor(o.length) &amp;&amp;        <span class="comment">// o.length是整数</span></span><br><span class="line">        o.length &lt; <span class="number">4294967296</span>&gt;)                     <span class="comment">// o.length &lt; 2e32</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后文中我们可以看到在ES5中字符串的行为与数组类似，然而，类似上述的类数组对象的检测方法针对字符串常常返回false——它们最好当作字符串处理，而非数组。</p><p>JavaScript数组方法是特意定义为通用的，因此它们不仅应用在真正的数组而且在类数组对象上都能正确工作。除了toString()和toLocaleString()以外的方法都是通用的。</p><p>concat()方法是一个特例，虽然可以用在类数组对象上，但它没有将那个对象扩充进返回的数组中。</p><p>既然类数组对象没有继承自Array.prototype，那就不能在它们上面直接调用数组方法。尽管如此，可以间接地使用Function.call方法调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="string">'0'</span>: <span class="string">'a'</span>, <span class="string">'1'</span>: <span class="string">'b'</span>, <span class="string">'3'</span>: <span class="string">'c'</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(a, <span class="string">'+'</span>);                  <span class="comment">// 'a+b+c'</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(a, <span class="number">0</span>);                   <span class="comment">// ['a','b','c']  真正数组的副本</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.map.call(a, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.toUpperCase();</span><br><span class="line">&#125;);                                                 <span class="comment">// ['A','B','C']</span></span><br></pre></td></tr></table></figure><hr><h3 id="十二、作为数组的字符串"><a href="#十二、作为数组的字符串" class="headerlink" title="十二、作为数组的字符串"></a>十二、作为数组的字符串</h3><p>在ES5中，字符串的行为类似于只读的数组。除了用charAt()方法来访问单个的字符以外，还可以使用方括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'test'</span>;</span><br><span class="line">s.charAt(<span class="number">0</span>);                                    <span class="comment">// 't'</span></span><br><span class="line">s[<span class="number">1</span>];                                           <span class="comment">// 'e'</span></span><br></pre></td></tr></table></figure><p>当然，针对字符串的typeof操作符仍然返回”string”，但是如果给Array.isArray()传递字符串，它将会返回false。</p><p>可索引的字符串的最大的好处就是简单，用方括号代替了charAt()调用，这样更加简洁、可读并且可能更高效。不仅如此，字符串的行为类似于数组的事实使得通用的数组方法可以应用到字符串上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'JavaScript'</span>;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(s, <span class="string">' '</span>);              <span class="comment">// 'J a v a S c r i p t'</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.filter.call(s, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.match(<span class="regexp">/[^aeiou]/</span>);                 <span class="comment">// 只匹配非元音字母</span></span><br><span class="line">&#125;).join(<span class="string">''</span>);                                    <span class="comment">// 'JvScrpt'</span></span><br></pre></td></tr></table></figure><p>请记住，字符串是不可变值，故当把它们作为数组看待时，它们是只读的。如push()、sort()、reverse()和splice()等数组方法会修改数组，它们在字符串上是无效的。不仅如此，使用数组方法来修改字符串会导致错误：出错的时候没有提示。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组是值的有序集合，每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。JavaScript数组的索引是基于零的32位数，第一个元素的索引为0，最大可能的索引为&lt;code&gt;4 294 967 294&lt;/code&gt;（&lt;code&gt;2e32-2&lt;/code&gt;），数组最大能容纳&lt;code&gt;4 294 967 295&lt;/code&gt;个元素。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript数组" scheme="http://www.xiaoleon.cn/tags/JavaScript%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JS(2) 对象</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/js-2/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/js-2/</id>
    <published>2018-01-22T14:27:54.000Z</published>
    <updated>2018-01-28T15:07:26.195Z</updated>
    
    <content type="html"><![CDATA[<p>对象是JavaScript的基本数据类型。对象是一种复合值：它将很多值（原始值或者其他对象）聚合在一起，可以通过名字访问这些值。对象也可看作是属性的无序集合，每个属性都是一个名值对，属性名是字符串，因此我们可以把对象看成是从字符串到值的映射。</p><a id="more"></a><p>JavaScript对象还可以从一个称为原型的对象继承属性，对象的方法通常是继承的属性，这种原型式继承（<code>prototypal inheritance</code>）是JavaScript的核心特征。</p><p>对象最常见的用法是创建（<code>create</code>）、设置（<code>set</code>）、查找（<code>query</code>）、删除（<code>delete</code>）、检测（<code>test</code>）和枚举（<code>enumerate</code>）它的属性。属性包括名字和值，属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性，值可以是任意JavaScript值，或者可以是一个<code>getter</code>或<code>setter</code>函数。除了名字和值以外，每个属性还有一些与之相关的值，称为“属性特征”（<code>property attribute</code>）。</p><ul><li><p>可写（<code>writable attribute</code>），表明是否可以设置该属性的值。</p></li><li><p>可枚举（<code>enumerable attribute</code>），表明是否可以通过<code>for/in</code>循环返回该属性。</p></li><li><p>可配置（<code>configurable attribute</code>），表明是否可以删除或修改该属性。</p></li></ul><p>除了包含属性之外，每个对象还拥有三个相关的对象特性（<code>object attribute</code>）：</p><ul><li><p>对象的原型（<code>prototype</code>）指向另外一个对象，本对象的属性继承自它的原型对象。</p></li><li><p>对象的类（<code>class</code>）是一个标识对象类型的字符串。</p></li><li><p>对象的扩展标记（<code>extensible flag</code>）指明了是否可以向该对象添加新属性。</p></li></ul><p>最后，我们用下面这些术语来对三类JavaScript对象和两类属性作区分：</p><ul><li><p>内置对象（<code>native object</code>）是由ECMAScript规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。</p></li><li><p>宿主对象（<code>host object</code>）是由JavaScript解释器所嵌入的宿主环境（比如Web浏览器）定义的。客户端JavaScript中表示网页结构的<code>HTMLElement</code>对象均是宿主对象。既然宿主环境定义的方法可以当成普通的JavaScript函数对象，那么宿主对象也可以当成内置对象。</p></li><li><p>自定义对象（<code>user-defined object</code>）是由运行中的JavaScript代码创建的对象。</p></li><li><p>自有属性（<code>own property</code>）是直接在对象中定义的属性。</p></li><li><p>继承属性（<code>inherited property</code>）是在对象的原型对象中定义的属性。</p></li></ul><h3 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h3><p>可以通过对象直接量、关键字<code>new</code>和<code>Object.create()</code>函数来创建对象。</p><h4 id="1-对象直接量"><a href="#1-对象直接量" class="headerlink" title="1. 对象直接量"></a>1. 对象直接量</h4><p>创建对象最简单的方式就是在JavaScript代码中使用对象直接量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emtpy = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> point = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="string">"main title"</span>: <span class="string">"Javascript"</span>,</span><br><span class="line">    <span class="string">'sub-title'</span>: <span class="string">'The Definitive Guide'</span>,</span><br><span class="line">    author: &#123;</span><br><span class="line">        firstname: <span class="string">'David'</span>,</span><br><span class="line">        surname: <span class="string">'Flanagan'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象直接量是一个表达式，这个表达式的每次运算都会创建并初始化一个新的对象。每次计算对象直接量的时候，也都会计算它的每个属性的值。也就是说，如果在一个重复调用的函数中的循环体内使用了对象直接量，它将创建很多新对象，并且每次创建的对象的属性值也有可能不同。</p><h4 id="2-通过new创建对象"><a href="#2-通过new创建对象" class="headerlink" title="2. 通过new创建对象"></a>2. 通过new创建对象</h4><p>new运算符创建并初始化一个新对象。关键字<code>new</code>后跟随一个函数调用。这里的函数称作构造函数（<code>constructor</code>），构造函数用以初始化一个新创建的对象。JavaScript语言核心中的原始类型都包含内置构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'js'</span>);</span><br></pre></td></tr></table></figure><h4 id="3-原型"><a href="#3-原型" class="headerlink" title="3. 原型"></a>3. 原型</h4><p>每一个JavaScript对象（<code>null</code>除外）都和另一个对象相关联。“另一个”对象就是我们熟知的原型，每一个对象都从原型继承属性。</p><p>所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过JavaScript代码<code>Object.prototype</code>获得原型对象的引用。通过关键字<code>new</code>和构造函数调用创建的对象的原型就是构造函数的<code>prototype</code>属性的值。因此，同使用<code>{}</code>创建对象一样，通过<code>new Object()</code>创建的对象也继承自<code>Object.prototype</code>。同样，通过<code>new Array()</code>创建的对象的原型就是<code>Array.prototype</code>，通过<code>new Date()</code>创建的对象的原型就是<code>Date.prototype</code>。</p><p>没有原型的对象不多，<code>Object.prototype</code>就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自<code>Object.prototype</code>的原型。例如，<code>Date.prototype</code>的属性继承自<code>Object.prototype</code>，因此由<code>new Date()</code>创建的<code>Date</code>对象的属性同时继承自<code>Date.prototype</code>和<code>Object.prototype</code>。这一系列链接的原型对象就是所谓的“原型链”（<code>prototype chain</code>）。</p><h4 id="4-Object-create"><a href="#4-Object-create" class="headerlink" title="4. Object.create()"></a>4. Object.create()</h4><p>ECMAScript5定义了一个<code>Object.create()</code>方法，它创建一个新对象，其中第一个参数是这个对象的原型，并提供第二个可选参数，用以对对象的属性进行进一步描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// o1继承了属性x和y</span></span><br><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p>可以通过传入参数<code>null</code>来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如<code>toString()</code>，也就是说，它将不能和<code>“+”</code>运算符一起正常工作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// o2不继承任何属性和方法</span></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>如果想创建一个普通的空对象（比如通过<code>{}</code>或<code>new Object()</code>创建的对象），需要传入<code>Object.prototype</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// o3和&#123;&#125;和new Object()一样</span></span><br><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure><blockquote><p><strong>可以通过任意原型创建新对象（换句话说，可以使任意对象可继承），这是一个强大的特性。</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inherit()返回一个继承自原型对象p的属性的新对象</span></span><br><span class="line"><span class="comment">// 这里使用ECMAScript5中的Object.create()函数（如果存在的话）</span></span><br><span class="line"><span class="comment">// 如果不存在，则退化使用其他方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// p是一个对象，但不能是null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>();              </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.create)</span><br><span class="line">        <span class="comment">// 如果Object.create()存在，直接使用它</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(p);</span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> p;</span><br><span class="line">    <span class="keyword">if</span> (t !== <span class="string">'object'</span> &amp;&amp; t !== <span class="string">'function'</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    <span class="comment">// 定义一个空构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 将其原型属性设置为p</span></span><br><span class="line">    f.prototype = p;</span><br><span class="line">    <span class="comment">// 使用f()创建p的继承对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，<code>inherit()</code>方法并不能完全代替<code>Object.create()</code>，它不能通过传入<code>null</code>原型来创建对象，而且不能接收可选的第二个参数。</p></blockquote><p><code>inherit()</code>函数的其中一个用途就是防止库函数无意间（非恶意地）修改那些不受控制的对象。不是将对象直接作为参数传入函数，而是将它的继承对象传入函数。当函数读取继承对象的属性时，实际上读取的是继承来的值。如果给继承对象的属性赋值，则这些属性只会影响这个继承对象自身，而不是原始对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="string">"don't change this value"</span> &#125;;</span><br><span class="line"><span class="comment">// 防止对o的意外修改</span></span><br><span class="line">library_function(inherit(o));</span><br></pre></td></tr></table></figure><hr><h3 id="二、属性的查询和设置"><a href="#二、属性的查询和设置" class="headerlink" title="二、属性的查询和设置"></a>二、属性的查询和设置</h3><p>对象可以通过点（<code>.</code>）或方括号（<code>[]</code>）运算符来获取属性的值。运算符左侧应当是一个表达式，它返回一个对象。对于点（<code>.</code>）来说，右侧必须是一个以属性名称命名的简单标识符。对于方括号来说（<code>[]</code>），方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> author = book.author;</span><br><span class="line"><span class="keyword">var</span> name = author.surname;</span><br><span class="line"><span class="keyword">var</span> title = book[<span class="string">'main title'</span>];</span><br></pre></td></tr></table></figure><p>当使用方括号时，严格来讲，表达式必须返回字符串或者返回一个可以转换为字符串的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> author = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">'John'</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">'Green'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(author[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h4 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h4><p>JavaScript对象具有“自有属性”（<code>own property</code>），也有一些属性是从原型对象继承而来的。假设要查询对象<code>o</code>的属性<code>x</code>，如果<code>o</code>中不存在<code>x</code>，那么将会继续在<code>o</code>的原型对象中查询属性<code>x</code>。如果原型对象中也没有<code>x</code>，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到<code>x</code>或者查到一个原型是<code>null</code>的对象为止。可以看到，对象的原型属性构成了一个“链”，通过这个“链”可以实现属性的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;             <span class="comment">// o从Object.prototype继承对象的方法</span></span><br><span class="line">o.x = <span class="number">1</span>;                <span class="comment">// 给o定义一个属性x</span></span><br><span class="line"><span class="keyword">var</span> p = inherit(o);     <span class="comment">// p继承o和Object.prototype</span></span><br><span class="line">p.y = <span class="number">2</span>;                <span class="comment">// 给p定义一个属性y</span></span><br><span class="line"><span class="keyword">var</span> q = inherit(p);     <span class="comment">// q继承p、o和Object.prototype</span></span><br><span class="line">q.z = <span class="number">3</span>;                <span class="comment">// 给q定义一个属性z</span></span><br><span class="line"><span class="keyword">var</span> s = q.toString()    <span class="comment">// toString继承自Object.prototype</span></span><br><span class="line">q.x + q.y               <span class="comment">// =&gt; 3  x和y分别继承自o和p</span></span><br></pre></td></tr></table></figure><p>现在假设给对象<code>o</code>的属性<code>x</code>赋值，如果<code>o</code>中已经有属性<code>x</code>（这个属性不是继承来的），那么这个赋值操作只改变这个已有属性<code>x</code>的值。如果<code>o</code>中不存在属性<code>x</code>，那么赋值操作给<code>o</code>添加一个新属性<code>x</code>。如果之前<code>o</code>继承自属性<code>x</code>，那么这个继承的属性就被新创建的同名属性覆盖了。</p><p>属性赋值操作首先检查原型链，以此判定是否允许赋值操作。例如，如果<code>o</code>继承自一个只读属性x，那么赋值操作是不允许的。如果允许属性赋值操作，它也总是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链。在Javascript中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关，这是JavaScript的一个重要特性，该特性让程序员可以有选择地覆盖（<code>override</code>）继承的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unitcircle = &#123; <span class="attr">r</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> c = inherit(unitcircle);</span><br><span class="line">c.x = <span class="number">1</span>; c.y = <span class="number">1</span>;</span><br><span class="line">c.r = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(unitcircle.r);      <span class="comment">// =&gt; 1，原型对象没有修改</span></span><br></pre></td></tr></table></figure><p>属性赋值要么失败，要么创建一个属性，要么在原始对象中设置属性，但有一个例外，如果<code>o</code>继承自属性<code>x</code>，而这个属性是一个具有<code>setter</code>方法的<code>accessor</code>属性，那么这时将调用<code>setter</code>方法而不是给<code>o</code>创建一个属性。需要注意的是，<code>setter</code>方法是由对象<code>o</code>调用的，而不是定义这个属性的原型对象调用的。因此如果<code>setter</code>方法定义在原型上，这个操作只针对<code>o</code>本身，并不会修改原型链。</p><h4 id="2-属性访问错误"><a href="#2-属性访问错误" class="headerlink" title="2. 属性访问错误"></a>2. 属性访问错误</h4><p>属性访问并不总是返回或设置一个值。查询一个不存在的属性并不会报错，如果在对象o自身的属性或继承的属性中均为找到属性x，属性访问表达式<code>o.x</code>返回<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.subtitle;      <span class="comment">// =&gt; undefined，属性不存在</span></span><br></pre></td></tr></table></figure><p>但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错，<code>null</code>和<code>undefined</code>值都没有属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> len = book.subtitle.length;     <span class="comment">// 抛出类型错误异常，undefined没有length属性</span></span><br></pre></td></tr></table></figure><p>除非确定<code>book</code>和<code>book.subtitle</code>都是对象，否则不能这样书写，应采用如下方法避免出错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">var</span> len = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (book) &#123;</span><br><span class="line">    <span class="keyword">if</span> (book.subtitle) &#123;</span><br><span class="line">        len = book.subtitle.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length;</span><br></pre></td></tr></table></figure><p>当然，给<code>null</code>和<code>undefined</code>设置属性也会报类型错误，给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性，但让人颇感意外的是，这些设置属性的失败操作不会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype = <span class="number">0</span>;       <span class="comment">// 赋值失败，但没报错，Object.prototype没有修改</span></span><br></pre></td></tr></table></figure><p>严格模式下，任何失败的属性设置操作都会抛出一个类型错误异常。</p><p>在以下场景下给对象<code>o</code>设置属性p会失败：</p><ul><li><p><code>o</code>中的属性p是只读的：不能给只读属性重新赋值（<code>defineProperty()</code>方法中有一个例外，可以对可配置的只读属性重新赋值）。</p></li><li><p><code>o</code>中的属性p是继承属性，且它是只读的：不能通过同名自有属性覆盖只读的继承属性。</p></li><li><p><code>o</code>中不存在自有属性<code>p</code>：<code>o</code>没有使用<code>setter</code>方法继承属性<code>p</code>，并且<code>o</code>的可扩展性（<code>extensible attribute</code>）是<code>false</code>。如果<code>o</code>中不存在<code>p</code>，而且没有<code>setter</code>方法可供调用，则<code>p</code>一定会添加至<code>o</code>中。但如果<code>o</code>不是可扩展的，那么在<code>o</code>中不能定义新属性。</p></li></ul><hr><h3 id="三、删除属性"><a href="#三、删除属性" class="headerlink" title="三、删除属性"></a>三、删除属性</h3><p><code>delete</code>运算符可以删除对象的属性。让人感到意外的是，<code>delete</code>只是断开属性和宿主对象的联系，而不会去操作属性中的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> book.author;</span><br><span class="line"><span class="keyword">delete</span> book[<span class="string">'main title'</span>];</span><br></pre></td></tr></table></figure><p><code>delete</code>运算符只能删除自有属性，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象）。</p><p>当<code>delete</code>表达式删除成功或没有任何副作用（比如删除不存在的属性）时，它返回<code>true</code>。如果<code>delete</code>后不是一个属性访问表达式，<code>delete</code>同样返回<code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// 删除x，返回true</span></span><br><span class="line"><span class="keyword">delete</span> o.x;</span><br><span class="line"><span class="comment">// 什么都没做，返回true</span></span><br><span class="line"><span class="keyword">delete</span> o.x;</span><br><span class="line"><span class="comment">// 什么都没做（toString是继承来的），返回true</span></span><br><span class="line"><span class="keyword">delete</span> o.toString();</span><br><span class="line"><span class="comment">// 无意义，返回true</span></span><br><span class="line"><span class="keyword">delete</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><code>delete</code>不能删除那些可配置性为<code>false</code>的属性（尽管可以删除不可扩展对象的可配置属性）。某些内置对象的属性是不可配置的，比如通过变量声明和函数声明创建的全局对象的属性。</p><p>在非严格模式中，以下情况的<code>delete</code>操作会返回<code>false</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能删除，属性是不可配置的</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype;</span><br><span class="line"><span class="comment">// 声明一个全局变量</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 不能删除这个属性</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.x;</span><br><span class="line"><span class="comment">// 声明一个全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 不能删除这个全局函数</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.f;</span><br></pre></td></tr></table></figure><p>当在非严格模式中删除全局对象的可配置属性时，可以省略对全局对象的引用，直接在<code>delete</code>操作符后跟随要删除的属性名即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个可配置的全局属性（没有用var）</span></span><br><span class="line"><span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 删除属性，返回true</span></span><br><span class="line"><span class="keyword">delete</span> x;</span><br></pre></td></tr></table></figure><p>然而在严格模式下，<code>delete</code>后跟随一个非法的操作数（比如x），则会报一个语法错误，因此必须显式指定对象及其属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格模式下报语法错误</span></span><br><span class="line"><span class="keyword">delete</span> x;</span><br><span class="line"><span class="comment">// 正常工作</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.x;</span><br></pre></td></tr></table></figure><hr><h3 id="四、检测属性"><a href="#四、检测属性" class="headerlink" title="四、检测属性"></a>四、检测属性</h3><p>JavaScript对象可以看作属性的集合，我们经常会检测集合中成员的所属关系——判断某个属性是否存在于某个对象中。可以通过<code>in</code>运算符、<code>hasOwnProperty()</code>和<code>propertyIsEnumerable()</code>方法来完成这个工作，甚至仅通过属性查询也可以做到这一点。</p><p><code>in</code>运算符的左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;           <span class="comment">// true</span></span><br><span class="line"><span class="string">"y"</span> <span class="keyword">in</span> o;           <span class="comment">// false</span></span><br><span class="line"><span class="string">"toString"</span> <span class="keyword">in</span> o;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>对象的<code>hasOwnProperty()</code>方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将会返回<code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">o.hasOwnProperty(<span class="string">"x"</span>);          <span class="comment">// true</span></span><br><span class="line">o.hasOwnProperty(<span class="string">"y"</span>);          <span class="comment">// false</span></span><br><span class="line">o.hasPownProperty(<span class="string">'toString'</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>propertyIsEnumerable()</code>是<code>hasOwnProperty()</code>的增强版，只有检测到是自有属性且这个属性的可枚举性（<code>enumerable attribute</code>）为<code>true</code>时它才返回<code>true</code>。某些内置属性是不可枚举的。通常由JavaScript代码创建的属性都是可枚举的，除非在ECMAScript5中使用一个特殊的方法来改变属性的可枚举性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = inherit(&#123; <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br><span class="line">o.x = <span class="number">1</span>;</span><br><span class="line">o.propertyIsEnumerable(<span class="string">'x'</span>);            <span class="comment">// true</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">'y'</span>);            <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.propertyIsEnumerable(<span class="string">'toString'</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>除了使用in运算符之外，另一种更简便的方法是使用<code>“!==”</code>判断一个属性是否是<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line">o.x !== <span class="literal">undefined</span>;          <span class="comment">// true</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>;          <span class="comment">// false</span></span><br><span class="line">o.toString !== <span class="literal">undefined</span>    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是有一种场景只能使用in运算符而不能使用上述属性访问的方式。in可以区分不存在的属性和存在但值为<code>undefined</code>的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">o.x !== <span class="literal">undefined</span>;          <span class="comment">// false</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>;          <span class="comment">// false</span></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;                   <span class="comment">// true</span></span><br><span class="line"><span class="string">"y"</span> <span class="keyword">in</span> o;                   <span class="comment">// false</span></span><br><span class="line"><span class="keyword">delete</span> o.x;                 <span class="comment">// true</span></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;                   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，上述代码中使用的是<code>“!==”</code>运算符，而不是<code>“!=”</code>。<code>“!==”</code>可以区分<code>undefined</code>和<code>null</code></p></blockquote><hr><h3 id="五、枚举属性"><a href="#五、枚举属性" class="headerlink" title="五、枚举属性"></a>五、枚举属性</h3><p>除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用<code>for/in</code>循环便利，ECMAScript5提供了两个更好用的替代方案。</p><p><code>for/in</code>循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承属性），把属性名称赋值给循环变量。对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的（除非使用下文中提到的一个方法将它们转换为不可枚举的）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;;</span><br><span class="line">o.propertyIsEnumerable(<span class="string">'toString'</span>);     <span class="comment">// false</span></span><br><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p);                     <span class="comment">// 输出x、y和z，不会输出toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有许多实用工具库给<code>Object.prototype</code>添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。然而在ECMAScript5之前，这些新添加的方法是不能定义为不可枚举的，因此它们都可以在<code>for/in</code>循环中枚举出来，因此需要过滤<code>for/in</code>循环中的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!o.hasOwnProperty(p))</span><br><span class="line">        <span class="comment">// 跳过继承的属性</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> o[p] === <span class="string">'function'</span>)</span><br><span class="line">        <span class="comment">// 跳过方法</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下方工具函数用来控制对象的属性，这些函数用到了<code>for/in</code>循环。实际上<code>extend()</code>函数经常出现在JavaScript实用工具库中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">把p中的可枚举属性复制到o中，并返回o</span></span><br><span class="line"><span class="comment">如果o和p中含有同名属性，则覆盖o中的属性</span></span><br><span class="line"><span class="comment">这个函数并不处理getter和setter以及复制属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历p中的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> p) &#123;</span><br><span class="line">        <span class="comment">// 将属性添加至o中</span></span><br><span class="line">        o[prop] = p[prop]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将p中的可枚举属性复制到o中，并返回o</span></span><br><span class="line"><span class="comment">如果o和p中有同名的属性，o中的属性将不受影响</span></span><br><span class="line"><span class="comment">这个函数并不处理getter和setter以及复制属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历p中的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> p) &#123;</span><br><span class="line">        <span class="comment">// 过滤掉已经在o中存在的属性</span></span><br><span class="line">        <span class="keyword">if</span> (o.hasOwnProperty(prop))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 将属性添加至o中</span></span><br><span class="line">        o[prop] = p[prop];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果o中的属性在p中没有同名属性，则从o中删除这个属性，并返回o</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restrict</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历p中的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="comment">// 如果在p中不存在，则删除</span></span><br><span class="line">        <span class="keyword">if</span> (!(prop <span class="keyword">in</span> p))</span><br><span class="line">            <span class="keyword">delete</span> o[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果o中的属性在p中存在同名属性，则从o中删除这个属性，并返回o</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历p中的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> p) &#123;</span><br><span class="line">        <span class="comment">// 从o中删除（删除一个不存在的属性不会报错）</span></span><br><span class="line">        <span class="keyword">delete</span> o[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回一个新对象，这个对象同时拥有o的属性和p的属性，</span></span><br><span class="line"><span class="comment">如果o和p中有重名属性，使用p中的属性值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> extend(extend(&#123;&#125;, o), p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回一个新对象，这个对象拥有同时在o和p中出现的属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restrict(extend(&#123;&#125;, o), p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回一个数组，这个数组包含的是o中可枚举的自有属性的名字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keys</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 参数必须是对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> o !== <span class="string">'object'</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="comment">// 判断是否是自有属性</span></span><br><span class="line">        <span class="keyword">if</span> (o.hasOwnProperty(prop)) &#123;</span><br><span class="line">            result.push(prop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了<code>for/in</code>循环之外，ECMAScript5定义了两个用以枚举属性名称的函数</p><ul><li><p>第一个是<code>Object.keys()</code>，它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。</p></li><li><p>第二个是<code>Object.getOwnPropertyNames()</code>，它和<code>Object.keys()</code>类似，只是它返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。</p></li></ul><hr><h3 id="六、属性getter和setter"><a href="#六、属性getter和setter" class="headerlink" title="六、属性getter和setter"></a>六、属性getter和setter</h3><p>对象属性是由名字、值和一对特性（<code>attribute</code>）构成的，在ES5中，属性值可以用一个或两个方法替代，这两个方法就是<code>getter</code>和<code>setter</code>。由<code>getter</code>和<code>setter</code>定义的属性称作“存取器属性”（<code>accessor property</code>），它不同于“数据属性”（<code>data property</code>），数据属性只有一个简单的值。</p><p>当程序查询存取器属性的值时，JavaScript调用<code>getter</code>方法。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript调用<code>setter</code>方法，将赋值表达式右侧的值当作参数传入<code>setter</code>。从某种意义上讲，这个方法负责“设置”属性值，可以忽略<code>setter</code>方法的返回值。</p><p>和数据属性不同，存取器属性不具有可写性（<code>writable attribute</code>）。如果属性同时具有<code>getter</code>和<code>setter</code>方法，那么它是一个读/写属性。如果它只有<code>getter</code>方法，那么它是一个只读属性。如果它只有<code>setter</code>方法，那么它是一个只写属性（数据属性中有一些例外），读取只写属性总是返回<code>undefined</code>。</p><p>定义存取器属性最简单的方法是使用对象直接量语法的一种扩展写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    data_prop: value,</span><br><span class="line"></span><br><span class="line">    get accessor_prop() &#123;</span><br><span class="line">        <span class="comment">// 函数体</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set accessor_prop(value) &#123;</span><br><span class="line">        <span class="comment">// 函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和数据属性一样，存取器属性是可以继承的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = inherit(o);</span><br><span class="line"><span class="built_in">console</span>.log(p.accessor_prop);</span><br></pre></td></tr></table></figure><p>还有很多场景可以用到存取器属性，比如智能检测属性的写入值以及在每次属性读取时返回不同值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个对象产生严格自增的序列号</span></span><br><span class="line"><span class="keyword">var</span> serialnum = &#123;</span><br><span class="line">    <span class="comment">// 这个数据属性包含下一个序列号</span></span><br><span class="line">    <span class="comment">// $符号暗示这个属性是一个私有属性</span></span><br><span class="line">    $n: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前值，然后自增</span></span><br><span class="line">    get next() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给n设置新的值，但只有当它比当前值大时才能设置成功</span></span><br><span class="line">    set next(n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="keyword">this</span>.$n)</span><br><span class="line">            <span class="keyword">this</span>.$n = n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="string">'序列号的值不能比当前值小'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="七、属性的特性"><a href="#七、属性的特性" class="headerlink" title="七、属性的特性"></a>七、属性的特性</h3><p>除了包含名字和值之外，属性还包含一些标识它们可写、可枚举和可配置的特性。本节将讲述ES5中查询和设置这些属性特性的API</p><ul><li><p>可以通过这些API给原型对象添加方法，并将它们设置成不可枚举的，这让它们看起来更像内置方法</p></li><li><p>可以通过这些API给对象定义不能修改或删除的属性，借此“锁定”这个对象</p></li></ul><p>我们将存取器属性的<code>getter</code>和<code>setter</code>方法看成是属性的特性，按照这个逻辑，我们也可以把数据属性的值同样看作属性的特性。因此，可以认为一个属性包含一个名字和4个特性。</p><p><strong><em>数据属性的4个特性分别是它的值（<code>value</code>）、可写性（<code>writable</code>）、可枚举性（<code>enumerable</code>）和可配置性（<code>configurable</code>）</em></strong></p><p>存取器属性不具有值（<code>value</code>）特性和可写性，它们的可写性是由<code>setter</code>方法存在与否决定的。因此存取器属性的4个特性是读取（<code>get</code>）、写入（<code>set</code>）、可枚举性和可配置性。</p><p>为了实现属性特性的查询和设置操作，ES5定义了一个名为“属性描述符”（<code>property descriptor</code>）的对象，这个对象代表那4个特性。描述符对象的属性有<code>value</code>、<code>writable</code>、<code>enumerable</code>和<code>configurable</code>。存取器属性的描述符对象则用<code>get</code>属性和<code>set</code>属性代替<code>value</code>和<code>writable</code>。其中<code>writable</code>、<code>enumerable</code>和<code>configurable</code>都是布尔值，当然，<code>get</code>属性和<code>set</code>属性是函数值。</p><p>通过调用<code>Object.getOwnPropertyDescriptor()</code>可以获得某个对象特定属性的属性描述符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, <span class="string">'x'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return &#123;get: /*func*/, set: undefined, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    get accessor_prop() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">'accessor_prop'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return undefined 没有这个属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">'x'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return undefined 继承属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">'toString'</span>);</span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptor()</code>只能得到自有属性的描述符，如果想要获得继承属性的特性，需要遍历原型链。如果想要设置属性的特性，或者想让新建属性具有某种特性，则需要调用<code>Object.defineProperty()</code>，传入要修改的对象、要创建或修改的属性的名称以及属性描述符对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个不可枚举的属性x，并赋值为1</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'x'</span>, &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.x;        <span class="comment">// =&gt; 1 属性存在</span></span><br><span class="line">o.keys();   <span class="comment">// =&gt; [] 属性不可枚举</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改属性x，变为只读</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'x'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.x = <span class="number">2</span>;    <span class="comment">// 操作失败但不报错，严格模式中会抛出异常</span></span><br><span class="line">o.x;        <span class="comment">// =&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性依然可配置，因此可以通过这种方式进行修改</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'x'</span>, &#123;</span><br><span class="line">    value: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line">o.x;        <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改x从数据属性变为存取器属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'x'</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;);</span><br><span class="line">o.x;        <span class="comment">// =&gt; 0</span></span><br></pre></td></tr></table></figure><p>传入<code>Object.defineProperty()</code>的属性描述符对象不必包含所有4个特性，对于新创建的属性来说，默认的特性值是<code>false</code>或<code>undefined</code>。对于修改的已有属性来说，默认的特性值没有做任何修改。注意，这个方法要么修改已有属性要么新建自有属性，但不能修改继承属性。</p><p>如果要同时修改或创建多个属性，则需要使用<code>Object.defineProperties()</code>。第一个参数是要修改的对象，第二个参数是一个映射表，它包含要新建或修改的属性的名称，以及它们的属性描述符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">    x: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    y: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    r: &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="keyword">this</span>.x * <span class="keyword">this</span>.x + <span class="keyword">this</span>.y * <span class="keyword">this</span>.y); &#125;,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段代码从一个空对象开始，然后给它添加两个数据属性和一个只读存取器属性。最终<code>Object.defineProperties()</code>返回修改后的对象（和<code>Object.defineProperty()</code>一样）。</p><p>对于那些不允许创建或修改的属性来说，如果用<code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>对其操作就会抛出类型错误异常，比如给一个不可扩展的对象新增属性就会抛出类型错误异常。造成这些方法抛出类型错误异常的其他原因则和特性本身相关。可写性控制着对值特性的修改。可配置性控制着对其他特性（包括属性是否可以删除）的修改。然而规则远不止这么简单，例如，如果属性是可配置的话，则可以修改不可写属性的值。同样，如果属性是不可配置的，仍然可以将可写属性修改为不可写属性。下面是完整规则，任何对<code>Object.defineProperty()</code>或<code>Object.defineProperties()</code>违反规则的使用都会抛出类型错误异常</p><ul><li><p>如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性</p></li><li><p>如果属性是不可配置的，则不能修改它的可配置性和可枚举性</p></li><li><p>如果存取器属性是不可配置的，则不能修改其<code>getter</code>和<code>setter</code>方法，也不能将它转换为数据属性</p></li><li><p>如果数据属性是不可配置的，则不能将它转换为存取器属性</p></li><li><p>如果数据属性是不可配置的，则不能将它的可写性从<code>false</code>修改为<code>true</code>，但可以从<code>true</code>修改为<code>false</code></p></li><li><p>如果数据属性是不可配置且不可写的，则不能修改它的值。然而可配置但不可写属性的值是可以修改的（实际上是先将它标记为可写的，然后修改它的值，最后转换为不可写的）。</p></li></ul><p>上文中的<code>extend()</code>函数，只是简单的复制属性名和值，没有复制属性的特性，而且也没有复制存取器属性的<code>getter</code>和<code>setter</code>方法，只是将它们简单的转换为静态的数据属性。下面给出改进的<code>extend()</code>，它使用<code>Object.getOwnPropertyDescriptor()</code>和<code>Object.defineProperty()</code>对属性的所有特性进行复制。新的<code>extend()</code>作为不可枚举属性添加到<code>Object.prototype</code>中，因此它是<code>Object</code>上定义的方法，而不是一个独立的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给Object.prototype添加一个不可枚举的extend()方法</span></span><br><span class="line"><span class="comment">这个方法继承自调用它的对象，将作为参数传入的对象的属性一一复制</span></span><br><span class="line"><span class="comment">除了值以外，也复制属性的所有特性，除非在目标对象中存在同名的属性</span></span><br><span class="line"><span class="comment">参数对象的所有自由对象（包括不可枚举的属性）也会一一复制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'extend'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 得到所有的自有属性，包括不可枚举属性</span></span><br><span class="line">        <span class="keyword">var</span> names = <span class="built_in">Object</span>.getOwnPropertyNames(o);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.length; i++ ) &#123;</span><br><span class="line">            <span class="comment">// 如果属性存在，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (names[i] <span class="keyword">in</span> <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 获得o中的属性描述符</span></span><br><span class="line">            <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, names[i]);</span><br><span class="line">            <span class="comment">// 用它给this创建一个属性</span></span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, names[i], desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="1-getter和setter的老式API"><a href="#1-getter和setter的老式API" class="headerlink" title="1. getter和setter的老式API"></a>1. getter和setter的老式API</h4><p>通过对象直接量语法给新对象定义存取器属性时，不能通过查询属性的方式获取<code>getter</code>和<code>setter</code>方法，或给已有的对象添加新的存取器属性。在ES5中，可以通过<code>Object.getOwnPropertyDescriptor()</code>和<code>Object.defineProperty()</code>来完成这些工作。</p><p>在ES5标准被采纳前，大多数Javascript的实现已经可以支持对象直接量语法中的<code>get</code>和<code>set</code>写法，这些实现提供了非标准的老式API用来查询和设置<code>getter</code>和<code>setter</code>，这些API由4个方法组成，所有对象都拥有这些方法。</p><ul><li><p><code>__lookupGetter__()</code>和<code>__lookupSetter__()</code>用以返回一个命名属性的<code>getter</code>和<code>setter</code>方法</p></li><li><p><code>__defineGetter__()</code>和<code>__defineSetter__()</code>用以定义<code>getter</code>和<code>setter</code>，这两个函数的第一个参数是属性名字，第二个参数是<code>getter</code>和<code>setter</code>方法。</p></li><li><p>这四个方法都是以两条下划线作前缀，两条下划线作后缀，以表明它们是非标准的方法。</p></li></ul><hr><h3 id="八、对象的三个属性"><a href="#八、对象的三个属性" class="headerlink" title="八、对象的三个属性"></a>八、对象的三个属性</h3><p>每一个对象都有与之相关的原型（<code>prototype</code>）、类（<code>class</code>）和可扩展性（<code>extensible attribute</code>）</p><h4 id="1-原型属性"><a href="#1-原型属性" class="headerlink" title="1. 原型属性"></a>1. 原型属性</h4><p>对象的原型属性是用来继承属性的，原型属性是在实例对象创建之初就设置好的。在ES5中，将对象作为参数传入<code>Object.getPrototypeOf()</code>可以查询它的原型。在ES3中，没有与之等价的函数，但经常使用表达式<code>o.constructor.prototype</code>来检测一个对象的原型。通过<code>new</code>表达式创建的对象，通常继承一个<code>constructor</code>属性，这个属性指代创建这个对象的构造函数。注意，通过对象直接量或<code>Object.create()</code>创建的对象包含一个名为<code>constructor</code>的属性，这个属性指代<code>Object()</code>构造函数。因此，<code>constructor.prototype</code>才是对象直接量的真正的原型，但对于通过<code>Object.create()</code>创建的对象则往往不是这样。</p><p>要想检测一个对象是否是另一个对象的原型（或处于原型链中），可以使用<code>isPrototypeOf()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(p);</span><br><span class="line">p.isPrototypeOf(o);         <span class="comment">// =&gt; true o继承自p</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(o)   <span class="comment">// =&gt; true p继承自Object.prototype</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>isPrototypeOf()</code>函数实现的功能和<code>instanceof</code>运算符非常类似。</p><blockquote><p>Mozilla实现的JavaScript对外暴露了一个专门命名为<code>__proto__</code>的属性，用以直接查询/设置对象的原型。但并不推荐使用<code>__proto__</code>，因为尽管Safari和Chrome的当前版本都支持它，但IE和Opera并为实现。实现了ES5的Firefox支持<code>__proto__</code>，但对修改不可扩展对象的原型做了限制。</p></blockquote><h4 id="2-类属性"><a href="#2-类属性" class="headerlink" title="2. 类属性"></a>2. 类属性</h4><p>对象的类属性（<code>class attribute</code>）是一个字符串，用以表示对象的类型信息。ES3和ES5都未提供设置这个属性的方法，并只有一种简介的方法可以查询它。默认的<code>toString()</code>方法（继承自<code>Object.prototype</code>）返回了如下这种格式的字符串<code>[object class]</code>。</p><p>因此，想要获得对象的类，可以调用对象的<code>toString()</code>方法，然后提取已返回字符串中的字符。不过让人感觉棘手的是，很多对象继承的<code>toString()</code>方法重写了，为了能调用正确的<code>toString()</code>版本，必须间接地调用<code>Function.call()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classof</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Null'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Undefined'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>classof()</code>函数可以传入任何类型的参数。数字、字符串和布尔值可以直接调用<code>toString()</code>方法，就和对象调用<code>toString()</code>方法一样，并且这个函数包含了对<code>null</code>和<code>undefined</code>的特殊处理（ES5中不需要进行特殊处理）。通过内置构造函数（比如<code>Array</code>和<code>Date</code>）创建的对象包含“类属性”（<code>class attribute</code>），它与构造函数名称相匹配。宿主对象也包含有意义的“类属性”，但这和具体的JavaScript实现有关。</p><p>对于自定义的类来说，没办法通过类属性来区分对象的类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">classof(<span class="literal">null</span>)       <span class="comment">// =&gt; 'Null'</span></span><br><span class="line">classof(<span class="number">1</span>)          <span class="comment">// =&gt; 'Number'</span></span><br><span class="line">classof(<span class="string">""</span>)         <span class="comment">// =&gt; 'String'</span></span><br><span class="line">classof(<span class="literal">false</span>)      <span class="comment">// =&gt; 'Boolean'</span></span><br><span class="line">classof(&#123;&#125;)         <span class="comment">// =&gt; 'Object'</span></span><br><span class="line">classof([])         <span class="comment">// =&gt; 'Array'</span></span><br><span class="line">classof(<span class="regexp">/./</span>)        <span class="comment">// =&gt; 'Regexp'</span></span><br><span class="line">classof(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">// =&gt; 'Date'</span></span><br><span class="line">classof(<span class="built_in">window</span>)     <span class="comment">// =&gt; 'Window'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">classof(<span class="keyword">new</span> f())    <span class="comment">// =&gt; 'Object'</span></span><br></pre></td></tr></table></figure><h4 id="3-可扩展性"><a href="#3-可扩展性" class="headerlink" title="3. 可扩展性"></a>3. 可扩展性</h4><p>对象的可扩展性用以表示是否可以给对象添加新属性。所有内置对象和自定义对象都是显示可扩展的，宿主对象的可扩展性是由JavaScript引擎定义的。在ES5中，所有的内置对象和自定义对象都是可扩展的，除非将它们转换为不可扩展的，同样，宿主对象的可扩展性也是由实现ES5的JavaScript引擎定义的。</p><p>ES5定义了用来查询和设置对象可扩展性的函数，通过将对象传入<code>Object.isExtensible()</code>，来判断该对象是否是可扩展的。如果想将对象转换为不可扩展的，需要调用<code>Object.preventExtensions()</code>，将待转换的对象作为参数穿进去。注意，一旦将对象转换为不可扩展的，就无法再将其转换回可扩展的了。同样需要注意的是，<code>preventExtensions()</code>只影响到对象本身的可扩展性。如果给一个不可扩展的对象的原型添加属性，这个不可扩展的对象同样会继承这些新属性。</p><p>可扩展属性的目的是将对象“锁定”，以避免外界的干扰。对象的可扩展性通常和属性的可配置性与可写性配合使用，ES5定义的一些函数可以更方便的设置多种属性。</p><p><code>Object.seal()</code>和<code>Object.preventExtensions()</code>类似，除了能够将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置的。也就是说，不能给这个对象添加新属性，而且它已有的属性也不能删除或配置，不过它已有的科协属性依然可以设置。对于那些已经封闭（<code>sealed</code>）起来的对象是不能解封的。可以使用<code>Object.isSealed()</code>来检测对象是否封闭。</p><p><code>Object.freeze()</code>将更加严格地锁定对象——“冻结”（<code>frozen</code>）。除了将对象设置为不可扩展的和将其属性设置为不可配置的之外，还可以将它自有的所有数据属性设置为只读（如果对象的存取器属性具有<code>setter</code>方法，存取器属性将不受影响，人可以通过给属性赋值调用它们）。使用<code>Object.isFrozen()</code>来检测对象是否冻结。</p><p><code>Object.preventExtensions()</code>、<code>Object.seal()</code>、<code>Object.freeze()</code>都返回传入的对象，也就是说，可以通过函数嵌套的方式调用它们</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个封闭对象，包括一个冻结的原型和一个不可枚举的属性</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.seal(<span class="built_in">Object</span>.create(<span class="built_in">Object</span>.freeze(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;), &#123;</span><br><span class="line">    y: &#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><hr><h3 id="九、序列化对象"><a href="#九、序列化对象" class="headerlink" title="九、序列化对象"></a>九、序列化对象</h3><p>对象序列化（<code>serialization</code>）是指将对象的状态转换为字符串，也可将字符串还原为对象。ES5提供了内置函数<code>JSON.stringfigy()</code>和<code>JSON.parse()</code>用来序列化和还原JavaScript对象。这些方法都是用JSON作为数据交换格式。</p><p>JSON的语法是JavaScript语法的子集，它并不能表示JavaScript离的所有值，支持对象、数组、字符串、无穷大数字、<code>true</code>、<code>false</code>和<code>null</code>，并且它们可以序列化和还原。<code>NaN</code>、<code>Infinity</code>和<code>-Infinity</code>序列化的结果是<code>null</code>，日期对象序列化的结果是ISO格式的日期字符串（参照<code>Date.toJson()</code>函数），但<code>JSON.parse()</code>依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、<code>RegExp</code>、<code>Error</code>对象和<code>undefined</code>值不能序列化和还原。</p><blockquote><p><strong><code>JSON.stringfy()</code>只能序列化对象可枚举的自有属性</strong></p></blockquote><p>对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。<code>JSON.stringify()</code>和<code>JSON.parse()</code>都可以接收第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。</p><hr><h3 id="十、对象方法"><a href="#十、对象方法" class="headerlink" title="十、对象方法"></a>十、对象方法</h3><p>所有的JavaScript对象都从<code>Object.prototype</code>继承属性（除了那些不通过原型显示创建的对象）。这些继承属性主要是方法，我们已经讨论过<code>hasOwnProperty()</code>、<code>propertyIsEnumerable()</code>、<code>isPrototypeOf()</code>三个方法，以及在Object构造函数里定义的静态函数<code>Object.create()</code>和<code>Object.getPrototypeOf()</code>等。本节将对定义在<code>Object.prototype</code>里的对象方法展开讲解，这些方法非常好用而且使用广泛，但一些特定的类会重写这些方法。</p><h4 id="1-toString-方法"><a href="#1-toString-方法" class="headerlink" title="1. toString()方法"></a>1. toString()方法</h4><p><code>toString()</code>方法没有参数，它返回一个表示调用这个方法的对象值的字符串。在需要将对象转换为字符串的时候，JavaScript都会调用这个方法。比如，当使用“+”运算符连接一个字符串和一个对象时或者在希望使用字符串的方法中使用了对象时都会调用<code>toString()</code>。</p><p>默认的<code>toString()</code>方法的返回值带有的信息量很少。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>&#125;.toString();        <span class="comment">// "[object Object]"</span></span><br></pre></td></tr></table></figure><p>由于默认的<code>toString()</code>方法并不会输出很多有用的信息，因此很多类都带有自定义的<code>toString()</code>。例如，当数组转换为字符串的时候，结果实一个数组元素列表，只是每个元素都换成了字符串，再比如，当函数转换为字符串的时候，得到函数的源代码。</p><h4 id="2-toLocaleString-方法"><a href="#2-toLocaleString-方法" class="headerlink" title="2. toLocaleString()方法"></a>2. toLocaleString()方法</h4><p>除了基本的<code>toString()</code>方法之外，对象都包含<code>toLocaleString()</code>方法，这个方法返回一个表示这个对象的本地化字符串。<code>Object</code>中默认的<code>toLocaleString()</code>方法并不做任何本地化自身的操作，它仅调用<code>toString()</code>方法并返回对应值。<code>Date</code>和<code>Number</code>类对<code>toLocaleString()</code>方法做了定制，可以用它对数字、日期和时间做本地化的转换。<code>Array</code>类的<code>toLocaleString()</code>方法和<code>toString()</code>方法很像，唯一的不同是每个数组元素会调用<code>toLocaleString()</code>方法转换为字符串，而不是调用各自的<code>toString()</code>方法。</p><h4 id="3-toJSON-方法"><a href="#3-toJSON-方法" class="headerlink" title="3. toJSON()方法"></a>3. toJSON()方法</h4><p><code>Object.prototype</code>实际上没有定义<code>toJSON()</code>方法，但对于需要执行序列化的对象来说，<code>JSON.stringify()</code>方法会调用<code>toJSON()</code>方法。如果在待序列化的对象中存在这个方法，则调用它，返回值即是序列化的结果，而不是原始的对象。</p><h4 id="4-valueOf-方法"><a href="#4-valueOf-方法" class="headerlink" title="4. valueOf()方法"></a>4. valueOf()方法</h4><p><code>valueOf()</code>方法和<code>toString()</code>方法非常类似，但往往当JavaScript需要将对象转换为某种原始值而非字符串的时候才会调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript就会自动调用这个方法。默认的<code>valueOf()</code>方法不足为奇，但有些内置类自定义了<code>valueOf()</code>方法（比如<code>Date.valueOf()</code>）。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《JavaScript权威指南（第6版）》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对象是JavaScript的基本数据类型。对象是一种复合值：它将很多值（原始值或者其他对象）聚合在一起，可以通过名字访问这些值。对象也可看作是属性的无序集合，每个属性都是一个名值对，属性名是字符串，因此我们可以把对象看成是从字符串到值的映射。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript对象" scheme="http://www.xiaoleon.cn/tags/JavaScript%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JS(1) 实现继承</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/js-1/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/js-1/</id>
    <published>2018-01-22T14:20:10.000Z</published>
    <updated>2018-01-28T15:07:28.095Z</updated>
    
    <content type="html"><![CDATA[<p>JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。那么如何在JS中实现继承呢？让我们拭目以待。</p><a id="more"></a><hr><h3 id="一、类式继承"><a href="#一、类式继承" class="headerlink" title="一、类式继承"></a>一、类式继承</h3><p>类式继承的主要思路是：<strong>采用构造函数实例化对象，通过原型链将实例对象关联起来</strong>。</p><h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h4><p>JavaScript使用原型链作为实现继承的主要方法，实现的本质是重写原型对象，代之以一个新类型的实例。下面的代码中，原来存在于<code>Super</code>的实例对象中的属性和方法，现在也存在于<code>Sub.prototype</code>中了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sub继承自Super</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getValue());           <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>原型链最主要的问题在于包含引用类型值的原型属性会被所有实例共享，而这也是为什么要在构造函数中，而不是在原型对象中定义属性的原因。通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章的变成了现在的原型属性了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub();</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);              <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);              <span class="comment">// 'red, blue, green, black'</span></span><br></pre></td></tr></table></figure><p>原型链的第二个问题是，在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有实例的情况下，给超类型的构造函数传递参数。再加上包含引用类型值的原型属性会被所有实例共享的问题，在实践中很少会单独使用原型链继承。</p><h4 id="2-借用构造函数继承"><a href="#2-借用构造函数继承" class="headerlink" title="2. 借用构造函数继承"></a>2. 借用构造函数继承</h4><p>借用构造函数的技术（有时候也叫做伪类继承或经典继承）。基本思想比较简单，即在子类型构造函数的内部调用超类型构造函数，通过使用<code>apply()</code>和<code>call()</code>方法在新创建的对象上执行构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>); <span class="comment">// 继承了Super</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub();</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);              <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);              <span class="comment">// 'red, blue, green'</span></span><br></pre></td></tr></table></figure><p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型中向超类型构造函数传递参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, <span class="string">'xiaozhang'</span>); <span class="comment">// 继承父类，同时传递参数</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="string">'28'</span>; <span class="comment">// 实例属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance.name);                 <span class="comment">// 'xiaozhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age);                  <span class="comment">// '28'</span></span><br></pre></td></tr></table></figure><p>但是，如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。</p><h4 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h4><p>组合集成有时也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub(<span class="string">'xiaozhang'</span>, <span class="number">28</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);          <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getName());       <span class="comment">// 'xiaozhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getAge());        <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub(<span class="string">'leon'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);          <span class="comment">// 'red, blue, green'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getName());       <span class="comment">// 'leon'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getAge());        <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>组合继承有它自己的问题。那就是无论什么情况下，都会调用两次父类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含父类型对象的全部实例属性，但不得不在调用子类型构造函数时重写这些属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第二次调用Super()，Sub.prototype再次获得name和colors两个属性，并对前一次的属性值进行覆盖</span></span><br><span class="line">    Super.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用Super()，Sub.prototype获得name和colors两个属性</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-寄生组合继承"><a href="#4-寄生组合继承" class="headerlink" title="4. 寄生组合继承"></a>4. 寄生组合继承</h4><p>解决两次调用父类型构造函数的方法是使用寄生组合式继承。计生组合式继承与组合继承相似，都是通过借用构造函数来继承不可共享的属性，通过原型链的混成形式来继承方法和可共享的属性。只不过把原型继承的形式变成了寄生式继承。使用寄生组合式继承可以不必为了指定子类型的原型而调用父类型的构造函数，从而寄生式继承只继承了父类型的原型属性，而父类型的实例属性是通过借用构造函数的方式来得到的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">proto</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">        F.prototype = proto;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub(<span class="string">'xiaozhang'</span>, <span class="number">28</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);          <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getName());       <span class="comment">// 'xiaozhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getAge());        <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub(<span class="string">'leon'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);          <span class="comment">// 'red, blue, green'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getName());       <span class="comment">// 'leon'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getAge());        <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>这个例子的高效率体现在它只调用了一次<code>Super</code>构造函数，并且因此避免了在<code>Sub.prototype</code>上面创建不必要的、多余的属性。与此同时，原型链还保持不变。因此，开发人员普遍认为寄生组合式继承是引用类型最理想的继承方式。</p><h4 id="5-ES6中的class"><a href="#5-ES6中的class" class="headerlink" title="5. ES6中的class"></a>5. ES6中的class</h4><p>采用ES6中的<code>class</code>语法糖，则上面代码修改如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getAge() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub(<span class="string">'xiaozhang'</span>, <span class="number">28</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);              <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getName());           <span class="comment">// 'xiaozhang'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getAge());            <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub(<span class="string">'leon'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);              <span class="comment">// 'red, blue, green'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getName());           <span class="comment">// 'leon'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getAge());            <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>ES6的<code>class</code>语法糖隐藏了许多技术细节，在实现同样功能的前提下，代码却优雅不少。</p><hr><h3 id="二、原型继承"><a href="#二、原型继承" class="headerlink" title="二、原型继承"></a>二、原型继承</h3><h4 id="1-原型继承"><a href="#1-原型继承" class="headerlink" title="1. 原型继承"></a>1. 原型继承</h4><p>原型继承，又称为委托继承。道格拉斯·克罗克福德（Douglas Crockford）在2006年谢了一篇文章，《Javascript中的原型式继承》。在这篇文章中，他介绍了一种实现继承的方式，这种方式并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象来创建新对象，同时不必因此创建自定义类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj = object(superObj);</span><br><span class="line">subObj.init(<span class="string">'sub'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subObj.getValue()); <span class="comment">// 'sub'</span></span><br></pre></td></tr></table></figure><p>在<code>object</code>函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的新实例。从本质上将，<code>object</code>方法对传入其中的对象执行了一次浅复制。ES5通过新增<code>Object.create</code>方法规范了原型式继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj = <span class="built_in">Object</span>.create(superObj);</span><br><span class="line">subObj.init(<span class="string">'sub'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subObj.getValue()); <span class="comment">// 'sub'</span></span><br></pre></td></tr></table></figure><h4 id="2-与原型链继承的关系"><a href="#2-与原型链继承的关系" class="headerlink" title="2. 与原型链继承的关系"></a>2. 与原型链继承的关系</h4><p>原型继承虽然只是看上去将原型链继承的一些程序性步骤包裹在函数里而已。但是，它们的一个重要区别是父类型的实例对象不再作为子类型的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用原型链继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance.value);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 使用原型继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(instance.value);</span><br></pre></td></tr></table></figure><p>原型继承中子类可以继承父类原型上的属性，但不可以继承父类的实例上的属性。原型继承与原型链继承都存在着子例共享父例引用类型值的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    colors: [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj1 = <span class="built_in">Object</span>.create(superObj);</span><br><span class="line">subObj1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj2 = <span class="built_in">Object</span>.create(superObj);</span><br><span class="line">subObj2.colors.push(<span class="string">'white'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(superObj.colors);           <span class="comment">// 'red, blue, green, black, white'</span></span><br><span class="line"><span class="built_in">console</span>.log(subObj1.colors);            <span class="comment">// 'red, blue, green, black, white'</span></span><br><span class="line"><span class="built_in">console</span>.log(subObj2.colors);            <span class="comment">// 'red, blue, green, black, white'</span></span><br></pre></td></tr></table></figure><h4 id="3-寄生式继承"><a href="#3-寄生式继承" class="headerlink" title="3. 寄生式继承"></a>3. 寄生式继承</h4><p>寄生式继承（<code>parasitic</code>）是与原型继承紧密相关的一种思路，并且同样是由道格拉斯·克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，最后再返回对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parasite</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(original); <span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 以某种方式来增强这个对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    colors: [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj1 = parasite(superObj);</span><br><span class="line">subObj1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj2 = parasite(superObj);</span><br><span class="line">subObj2.colors.push(<span class="string">'white'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(superObj.colors);           <span class="comment">// 'red, blue, green, black, white'</span></span><br><span class="line"><span class="built_in">console</span>.log(subObj1.colors);            <span class="comment">// 'red, blue, green, black, white'</span></span><br><span class="line"><span class="built_in">console</span>.log(subObj2.colors);            <span class="comment">// 'red, blue, green, black, white'</span></span><br></pre></td></tr></table></figure><p>由于原型继承存在着引用类型的值被共享的问题，所以使用的并不多，只在一些简单的应用场景下使用。如果需要解决该问题，则需要借用构造函数，与原型继承的初衷相违背，相当于使用了类式继承的终极写法——寄生组合继承。</p><hr><h3 id="三、拷贝继承"><a href="#三、拷贝继承" class="headerlink" title="三、拷贝继承"></a>三、拷贝继承</h3><p>拷贝继承又称为混入继承，<code>jQuery</code>中使用的就是拷贝继承。拷贝继承不需要改变原型链，通过拷贝函数将父例的属性和方法拷贝到子例即可。</p><h4 id="1-拷贝函数"><a href="#1-拷贝函数" class="headerlink" title="1. 拷贝函数"></a>1. 拷贝函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj, cloneObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj != <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cloneObj = cloneObj || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">            cloneObj[i] = (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">            <span class="built_in">arguments</span>.callee(obj[i], cloneObj[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneObj[i] = obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = extend(obj1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.c);            <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.c);            <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line">obj2.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.c);            <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.c);            <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><h4 id="2-对象间的拷贝继承"><a href="#2-对象间的拷贝继承" class="headerlink" title="2. 对象间的拷贝继承"></a>2. 对象间的拷贝继承</h4><p>由于拷贝继承解决了引用类型值共享的问题，所以其完全可以脱离构造函数实现对象间的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj, cloneObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj != <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cloneObj = cloneObj || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">            cloneObj[i] = (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">            <span class="built_in">arguments</span>.callee(obj[i], cloneObj[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneObj[i] = obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">    arrayValue: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subObj = extend(superObj);</span><br><span class="line">subObj.arrayValue.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(subObj.arrayValue);         <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(superObj.arrayValue);       <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><h4 id="3-使用构造函数的拷贝组合继承"><a href="#3-使用构造函数的拷贝组合继承" class="headerlink" title="3. 使用构造函数的拷贝组合继承"></a>3. 使用构造函数的拷贝组合继承</h4><p>如果要使用构造函数，则属性可以使用借用构造函数的方法，而引用类型属性和方法使用拷贝继承。相当于不再通过原型链来建立对象之间的联系，而通过复制来得到对象的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj, cloneObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj != <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cloneObj = cloneObj || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">            cloneObj[i] = (obj[i] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">            <span class="built_in">arguments</span>.callee(obj[i], cloneObj[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneObj[i] = obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = extend(Super.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Sub(<span class="string">'xiaozhang'</span>, <span class="number">28</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);          <span class="comment">// 'red, blue, green, black'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Sub(<span class="string">'leon'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);          <span class="comment">// 'red, blue, green'</span></span><br></pre></td></tr></table></figure><hr><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>本文介绍的 <strong>类式继承</strong> 、<strong>原型继承</strong>、<strong>拷贝继承</strong> 三种继承方式中，类式继承用的最普遍，由于ES6中<code>class</code>语法糖，使其代码复杂度大大降低；原型继承由于无法处理引用类型值共享的问题，使用较少，但是原型继承引申出的寄生组合继承是类式继承的规范式方法；拷贝继承使用范围最广泛，不仅可以实现原型之间的继承，也可以脱离构造函数，直接实现对象间的继承。</p><p>总之，继承主要就是处理父例和子例之间的两个问题，即是否使用构造函数，及如何建立联系。</p><ul><li><p>类式继承的核心就是使用构造函数，通过原型链来建立联系</p></li><li><p>原型继承不使用构造函数，通过<code>Object.create()</code>来建立联系</p></li><li><p>拷贝继承使用或者不使用构造函数都可以，通过复制来建立联系</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://geek.csdn.net/news/detail/246690" target="_blank" rel="noopener">《Javascript面向对象系列》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。那么如何在JS中实现继承呢？让我们拭目以待。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript抄书笔记" scheme="http://www.xiaoleon.cn/categories/JavaScript%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="类式继承" scheme="http://www.xiaoleon.cn/tags/%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF/"/>
    
      <category term="原型继承" scheme="http://www.xiaoleon.cn/tags/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/"/>
    
      <category term="拷贝继承" scheme="http://www.xiaoleon.cn/tags/%E6%8B%B7%E8%B4%9D%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>Web(1) 域名发散与域名收敛</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/web-1/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/web-1/</id>
    <published>2018-01-22T14:15:55.000Z</published>
    <updated>2018-01-27T09:03:40.571Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器对于同一域名下允许的并发请求做了限制，通常同一域名下最大并发请求数量为6个</p><a id="more"></a><ul><li><p>为了适应当时服务器的负载能力；之前的服务器的负载能力并没有这么强，高并发的请求可能会导致服务器无法正常提供服务甚至崩溃</p></li><li><p>如果浏览器允许的最大并发请求数较大，容易造成<code>DDoS(Distributed Denial of Service)</code>攻击等安全隐患</p></li><li><p>过多的并发请求可能会造成浏览器阻塞，使之处于“假死”的无响应状态</p></li><li><p>浏览器目前已经支持了长连接，可以在同一个<code>TCP</code>连接中完成多个请求，没有必要再进行代价较大的重新开启新请求的操作</p></li></ul><hr><h3 id="一、域名发散"><a href="#一、域名发散" class="headerlink" title="一、域名发散"></a>一、域名发散</h3><p>域名发散就是为了突破浏览器对于同一域名并发请求数的限制，使用域名发散为同一个服务申请多个域名，从而可以一定程度上提高并发量；当然，由于建立新的请求需要一定的代价，因此需要在域名发散与域名收敛之间进行<code>trade off</code>，通常发散的域名个数为2-4个。</p><hr><h3 id="二、域名收敛"><a href="#二、域名收敛" class="headerlink" title="二、域名收敛"></a>二、域名收敛</h3><p>域名收敛就是将静态资源放在一个域名下不进行发散，这主要是为了适应移动端的发展需求；通常DNS是一个开销较大的操作，而移动端由于网络带宽和实时性、资源等的限制，这些开销对于移动端的用户体验是致命的，因此需要进行域名收敛。</p><hr><h3 id="三、SPDY"><a href="#三、SPDY" class="headerlink" title="三、SPDY"></a>三、SPDY</h3><p><code>SPDY</code>是谷歌的一个商标，是由Google提出的一种更加快捷的应用层协议，可以说是对<code>HTTP</code>协议的一种补充，同时也推动了<code>HTTP/2</code>的发展。</p><p><code>SPDY</code>的提出也给无线端/移动端优化提供进一步的方案。</p><p>它并不是一种<code>HTTP</code>的替代，而是修改了<code>HTTP</code>请求和相应的发送方式；能够有效降低网页加载延时并提高网络安全性；可以通过<code>HTTP</code>头部压缩、多路复用、请求优先级排序降低加载延时；<code>SPDY</code>中使用<code>SSL/TLS</code>加密提高了网络安全性，同时向后兼容<code>TCP</code>；另外，服务器在页面请求后可以主动将需要的静态资源发送到客户端而不需要客户端再次请求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器对于同一域名下允许的并发请求做了限制，通常同一域名下最大并发请求数量为6个&lt;/p&gt;
    
    </summary>
    
      <category term="Web抄书笔记" scheme="http://www.xiaoleon.cn/categories/Web%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript对象" scheme="http://www.xiaoleon.cn/tags/JavaScript%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(10) 补充样式和属性</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-10/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-10/</id>
    <published>2018-01-22T14:05:03.000Z</published>
    <updated>2018-01-27T09:01:35.522Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要对CSS3中的一些内容比较少，但也非常重要的样式和属性进行简要介绍。</p><a id="more"></a><p>主要内容如下：</p><ul><li><p>掌握css3中与颜色相关的样式，掌握<code>alpha</code>通道的使用方法，掌握css3中新增的<code>rgba</code>颜色、<code>hsl</code>颜色与<code>hsla</code>颜色的概念盒使用方法</p></li><li><p>掌握<code>opacity</code>属性的含义盒使用方法，了解使用<code>alpha</code>来指定透明度与使用<code>opacity</code>属性来指定透明度这两者之间的区别，掌握<code>transparent</code>颜色值的含义及其使用方法</p></li><li><p>掌握<code>outline</code>属性的含义及其使用方法，能够使用<code>outline</code>属性在元素周围绘制一条轮廓线并指定该轮廓线的线宽、颜色、线的样式，以及线与边框的位移距离</p></li><li><p>掌握<code>resize</code>属性的含义及其使用方法，能够使用<code>resize</code>属性来定义一个允许用户自己调节尺寸的元素</p></li><li><p>掌握<code>initial</code>属性值的含义及其使用方法，能够使用<code>initial</code>属性来取消对元素的样式设定</p></li></ul><h3 id="一、颜色相关样式"><a href="#一、颜色相关样式" class="headerlink" title="一、颜色相关样式"></a>一、颜色相关样式</h3><p>在css3之前，在样式中指定的颜色值只能为<code>rgb</code>颜色值，并且只能通过<code>opacity</code>属性来设置元素的透明度。css3中增加了3种颜色中——<code>rgba</code>颜色值、<code>hsl</code>颜色值及<code>hsla</code>颜色值，并且允许通过对<code>rgba</code>颜色值和<code>hsla</code>颜色值设定<code>alpha</code>通道的方法来更加容易地实现将半透明文字与图像互相重叠的效果。</p><h4 id="1-利用alpha通道设定颜色"><a href="#1-利用alpha通道设定颜色" class="headerlink" title="1. 利用alpha通道设定颜色"></a>1. 利用alpha通道设定颜色</h4><p>1) 对rgb颜色设定alpha通道</p><p>在css3中，可以通过对<code>rgb</code>颜色设定<code>alpha</code>通道的方法来定义<code>rgba</code>颜色。所谓<code>rgba</code>颜色，是指利用红色值（<code>R</code>）、绿色值（<code>G</code>）、蓝色值（<code>B</code>）、<code>alpha</code>通道值（<code>A</code>）来定义的颜色。其中，<code>alpha</code>通道值的范围是0-1.0，0表示完全透明，1表示不透明。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">rgba</span>(255, 0, 0, 0<span class="selector-class">.5</span>);</span><br></pre></td></tr></table></figure><p>2) 对hsl颜色设定alpha通道</p><p>在css3中，除了可以使用<code>rgb</code>颜色外，还可以使用<code>hsl</code>颜色。<code>hsl</code>颜色使用色调（<code>H</code>）、饱和度（<code>S</code>）、亮度（<code>L</code>）来定义颜色。其中，色调值中用0或360表示红色，120表示绿色，240表示蓝色，当取值大于360时，实际的值等于该值除以360之后的余数。例如，如果色调值为480，则实际的颜色值为480除以360之后的余数，等于120。饱和度盒亮度的取值范围均为0%-100%。可以通过对<code>hsl</code>颜色设定<code>alpha</code>通道的方法来定义<code>hsla</code>颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">hsla</span>(120, 100%, 50%, 0<span class="selector-class">.5</span>);</span><br></pre></td></tr></table></figure><h4 id="2-alpha和opacity的区别"><a href="#2-alpha和opacity的区别" class="headerlink" title="2. alpha和opacity的区别"></a>2. alpha和opacity的区别</h4><p>在css3中，除了使用<code>alpha</code>通道的方法来设定透明度外，也可以通过<code>opacity</code>属性来设定透明度。</p><p><code>opacity</code>属性是css中专门用来指定透明度的一个属性，取值范围也在0-1之间，0表示完全透明，1表示不透明。使用<code>alpha</code>通道对元素设定透明度时，可以单独针对元素的背景色和文字颜色等来指定透明度，而<code>opacity</code>属性只能指定整个元素的透明度。</p><p>下方示例中有4个<code>div</code>元素，其背景色均为绿色，其中第1个<code>div</code>元素不指定透明度，第2个<code>div</code>元素使用<code>alpha</code>通道指定背景色的透明度为0.5，第3个<code>div</code>元素使用<code>alpha</code>通道指定背景色与文字颜色的透明度均为0.5，第4个<code>div</code>元素使用<code>opacity</code>属性指定元素的透明度为0.5</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">48px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div1</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(0, 255, 100);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(255, 255, 255);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div2</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0, 255, 100, 0.5);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rbg</span>(255, 255, 255);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div3</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0, 255, 100, 0.5);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(255, 255, 255, 0.5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div4</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rbg</span>(0, 255, 100);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(255, 255, 255);</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span>aaaaaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span>bbbbbb<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div3"</span>&gt;</span>cccccc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div4"</span>&gt;</span>dddddd<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码中我们可以看出，对第2个<code>div</code>元素的背景色使用<code>alpha</code>通道时，并不会对文字产生影响，如果要让该元素的文字颜色也变成半透明，需要像第3个<code>div</code>元素那样同时对背景色和文字颜色使用<code>alpha</code>通道。但是，在第4个<code>div</code>元素的样式代码中，因为使用一次<code>opacity</code>属性，文字颜色和背景色都变成半透明的了。</p><h4 id="3-指定颜色值为transparent"><a href="#3-指定颜色值为transparent" class="headerlink" title="3. 指定颜色值为transparent"></a>3. 指定颜色值为transparent</h4><p>如果将颜色值指定为<code>transparent</code>，则会将背景、文字或边框等的颜色设定为完全透明，相当于使用了值为0的<code>alpha</code>通道。</p><hr><h3 id="二、用户界面相关样式"><a href="#二、用户界面相关样式" class="headerlink" title="二、用户界面相关样式"></a>二、用户界面相关样式</h3><h4 id="1-outline属性"><a href="#1-outline属性" class="headerlink" title="1. outline属性"></a>1. outline属性</h4><p>css3中定义了一个<code>outline</code>属性，用来在元素周围绘制一条轮廓线，可以起到突出元素的作用。例如，可以在原本没有边框的<code>radio</code>单选框外围加上一条轮廓线，使其在页面上显得更加突出，也可以在一组<code>radio</code>单选框中只对某个单选框加上轮廓线，使其区别于别的单选框。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">outline</span>: <span class="selector-tag">outline-color</span> <span class="selector-tag">outline-style</span> <span class="selector-tag">outline-width</span></span><br></pre></td></tr></table></figure><ul><li><p><code>outline-color</code>参数表示轮廓线的颜色，属性值为css中定义的颜色值</p></li><li><p><code>outline-style</code>参数表示轮廓线的样式，属性值为css中定义的线的样式</p></li><li><p><code>outline-width</code>参数表示轮廓线的宽度，属性值可以为一个宽度值</p></li></ul><p><code>outline</code>属性的三个参数的顺序可以呼唤，也可以分开书写成三个属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">outline-color</span>: red;</span><br><span class="line">    <span class="attribute">outline-style</span>: solid;</span><br><span class="line">    <span class="attribute">outline-width</span>: thin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-out-offset属性"><a href="#2-out-offset属性" class="headerlink" title="2. out-offset属性"></a>2. out-offset属性</h4><p>在默认情况下，对带有边框的元素来说，使用<code>outline</code>属性将紧贴着边框外围绘制一条轮廓线。有时，我们不想让这条轮廓线紧贴着边框外围，想让轮廓线稍微向外偏离几个像素，以绘制出双层边框的效果。针对这种情况，css3新增了一个<code>outline-offset</code>属性，可以使用该属性实现这个效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: blue solid thin;</span><br><span class="line">    <span class="attribute">outline</span>: red solid thin;</span><br><span class="line">    <span class="attribute">outline-offset</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以给<code>outline-offset</code>属性指定一个为负数的属性值，指定为负数的属性值后，轮廓线将向内偏移，绘制在边框内部。</p><h4 id="3-resize属性"><a href="#3-resize属性" class="headerlink" title="3. resize属性"></a>3. resize属性</h4><p>为了增强用户体验，css3增加了很多新的属性，其中一个重要的属性就是<code>resize</code>，它允许用户通过拖动的方式来修改元素的尺寸，到目前为止，主要用于可以使用<code>overflow</code>属性的任何容器元素中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">    <span class="attribute">resize</span>: both;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resize</code>属性的值分为以下几种：</p><ul><li><p><code>none</code>：用户不能修改元素尺寸</p></li><li><p><code>both</code>：用户可以修改元素的宽度和高度</p></li><li><p><code>horizontal</code>：用户可以修改元素的宽度，但不能修改元素的高度</p></li><li><p><code>vertical</code>：用户可以修改元素的高度，但不能修改元素的宽度</p></li><li><p><code>inherit</code>：继承父元素的resize属性值</p></li></ul><h4 id="4-initial属性值"><a href="#4-initial属性值" class="headerlink" title="4. initial属性值"></a>4. initial属性值</h4><p>要取消对元素的样式指定，可以通过几种方法来达到这个目的，其中最简单的方法时直接在样式表中删除设定该样式的代码。但是，在大多数情况下，一个样式写好了以后会对很多页面中的元素指定这个样式。所以，如果对单个元素取消其样式的指定时，这种做法是不可取的。</p><p>第二种方法是目前采用的使用<code>class</code>的方法，要取消对单个元素的样式指定，只要把这个元素的<code>class</code>属性取消掉就可以了，但是<code>class</code>属性本身是一个多余的、没有任何语义的属性。同时，如果多个元素使用同一个样式，还必须为每一个元素增加同样的<code>class</code>属性；如果要删除一个样式，还要逐个删除这些元素的<code>class</code>属性，所以很不实用。css3中已经不推荐使用它，取而代之的是将样式与元素或元素<code>id</code>直接绑定的做法。所以，第二种方法在下一代Web平台中使用的机会也会越来越少，直到最终随着<code>class</code>属性一起被废弃掉。</p><p>针对这种情况，css3中新增了一个<code>initial</code>属性值，使用这个<code>initail</code>属性值可以直接取消对某个元素的样式指定。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#div1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: initial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span>aaaaaaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span>bbbbbbb<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div3"</span>&gt;</span>ccccccc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>initial</code>属性值的作用是让各种属性使用默认值，在浏览器中文字的颜色默认值是黑色，所以<code>id</code>为“div1”的元素中的文字会变成黑色。</p><p><strong>使用initial属性值的特例</strong></p><p>个别情况下，对元素使用<code>initial</code>属性值后的显示结果并不等于该元素的样式设定直接删除后的结果。在浏览器中，为了使一些元素变得更容易阅读，浏览器可以自行对该元素使用一些样式，例如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在样式中对<code>h1</code>元素重新定义，例如对<code>h1</code>元素定义如下样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，在这段样式后面追加一段<code>h1</code>元素使用的样式，对上面文字的字号和字体粗细均使用<code>initial</code>属性值，追加后的样式如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: initial;</span><br><span class="line">    <span class="attribute">font-weight</span>: initial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后我们会发现，<code>h1</code>元素在浏览器中的显示结果与最初不设定时并不相同。</p><p>为什么在<code>h1</code>元素的样式代码中追加了<code>initial</code>属性值后的显示结果与不使用任何样式设定时的显示结果会不一样呢？因为追加了<code>initial</code>属性值的样式设定后，<code>h1</code>元素的字号和字体粗细均使用css中对子号和字体粗细属性设定的默认值，并不考虑浏览器对<code>h1</code>元素追加了什么样式。而在css中，字号的默认值为<code>medium</code>，字体粗细的默认值是<code>normal</code>，与浏览器对<code>h1</code>元素使用的样式并不一致，如果想要让<code>h1</code>元素的字号和字体粗细的默认值使用浏览器的默认值，还是不要在追加的样式代码中使用<code>initial</code>属性值，而是使用浏览器追加的默认样式中的属性值。在<a href="http://www.w3.org/TR/CSS21/sample.html" target="_blank" rel="noopener">http://www.w3.org/TR/CSS 21/sample.html</a>中可以查到浏览器对HTML4中元素所做的追加样式清单，目前各主流浏览器均遵照这个清单来对元素追加默认样式。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要对CSS3中的一些内容比较少，但也非常重要的样式和属性进行简要介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="颜色" scheme="http://www.xiaoleon.cn/tags/%E9%A2%9C%E8%89%B2/"/>
    
      <category term="outline" scheme="http://www.xiaoleon.cn/tags/outline/"/>
    
      <category term="out-offset" scheme="http://www.xiaoleon.cn/tags/out-offset/"/>
    
      <category term="resize" scheme="http://www.xiaoleon.cn/tags/resize/"/>
    
      <category term="initial" scheme="http://www.xiaoleon.cn/tags/initial/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(9) Media Queries相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-9/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-9/</id>
    <published>2018-01-22T14:02:35.000Z</published>
    <updated>2018-01-27T09:01:28.247Z</updated>
    
    <content type="html"><![CDATA[<p>在css3的众多模块中，有一个与各种媒体相关的重要模块——<code>Media Queries</code>，该模块中允许添加媒体查询表达式，用以指定媒体类型，然后根据媒体类型来选择应该使用的样式。换句话说，允许我们在不改变内容的情况下在样式中选择一种页面的布局以精确地适应不同的设备，从而改善用户体验。</p><a id="more"></a><h3 id="一、Media-Queries使用方法"><a href="#一、Media-Queries使用方法" class="headerlink" title="一、Media Queries使用方法"></a>一、Media Queries使用方法</h3><p><code>Media Queries</code>的使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@media 设备类型 and ( 设备特性 ) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p>在代码的开头必须要书写<code>“@media”</code>，然后指定设备类型，也可以称之为媒体类型。css定义了10种设备类型，在此处可以指定的值与该值所代表的设备类型如下所示。</p><table><thead><tr><th>可以指定的值</th><th>设备类型</th></tr></thead><tbody><tr><td>all</td><td>所有设备</td></tr><tr><td>screen</td><td>电脑显示器</td></tr><tr><td>print</td><td>打印用纸或打印预览视图</td></tr><tr><td>handheld</td><td>便携设备</td></tr><tr><td>tv</td><td>电视机类型的设备</td></tr><tr><td>speech</td><td>语音和音频合成器</td></tr><tr><td>braille</td><td>忙人用点字法触觉回馈设备</td></tr><tr><td>embossed</td><td>盲文打印机</td></tr><tr><td>projection</td><td>各种投影设备</td></tr><tr><td>tty</td><td>使用固定密度字母栅格的媒介，比如电传打字机和终端</td></tr></tbody></table><p>设备特性的书写方式与样式的书写方式很相似，分为两个部分，当中由冒号分割，冒号前书写设备的某种特性，冒号后书写该特性的具体值，如需要指定浏览器的窗口宽度大于400px时所使用的样式，书写方法如下：<code>( min-width: 400px )</code></p><p>css中的设备特性共有13种，是一个类似于css属性的集合，但与css属性不同的是，大部分设备特性的指定值接受<code>min/max</code>的前缀，用来表示大于等于或小于的逻辑，以此避免使用<code>&lt;</code>盒<code>&gt;</code>这些字符。</p><table><thead><tr><th>特性</th><th>可指定值</th><th>是否允许使用min/max前缀</th><th>特性说明</th></tr></thead><tbody><tr><td>width</td><td>带单位的长度数值，例如：400px</td><td>允许</td><td>浏览器窗口的宽度</td></tr><tr><td>height</td><td>带单位的长度数值，例如：200px</td><td>允许</td><td>浏览器窗口的高度</td></tr><tr><td>device-width</td><td>带单位的长度数值，例如：400px</td><td>允许</td><td>设备屏幕分辨率的宽度</td></tr><tr><td>device-height</td><td>带单位的宽度数值，例如：200px</td><td>允许</td><td>设备屏幕分辨率的高度</td></tr><tr><td>orientation</td><td>只能指定两个值：portrait或landscape</td><td>不允许</td><td>浏览器窗口的方向是纵向还是横向。当窗口的高度值大于等于宽度值时，该特性值为portrait，否则为landscape</td></tr><tr><td>aspect-ratio</td><td>比例值，例如：16/9</td><td>允许</td><td>浏览器窗口的纵横比，比例值为浏览器窗口的宽度值/高度值</td></tr><tr><td>device-aspect-ratio</td><td>比例值，例如：16/9</td><td>允许</td><td>屏幕分辨率的纵横比，比例值为设备屏幕分辨率的宽度值/高度值</td></tr><tr><td>color</td><td>整数值</td><td>允许</td><td>设备使用多少位的颜色值，如果不是彩色设备，该值为0</td></tr><tr><td>color-index</td><td>整数值</td><td>允许</td><td>色彩表中的色彩数</td></tr><tr><td>monochrome</td><td>整数值</td><td>允许</td><td>单色帧缓冲期中每像素的字节数</td></tr><tr><td>resolution</td><td>分辨率值，例如：300dpi</td><td>允许</td><td>设备的分辨率</td></tr><tr><td>scan</td><td>只能指定两个值：progressive或interlace</td><td>不允许</td><td>电视机类型设备的扫描方式。progressive表示逐行扫描，interlace表示隔行扫描</td></tr><tr><td>grid</td><td>只能指定两个值：0或1</td><td>不允许</td><td>设备是基于栅格还是基于位图。基于栅格时该值为1，否则该值为0</td></tr></tbody></table><p>使用<code>and</code>关键字来指定当某种设备类型的某种特性的值满足某个条件时所使用的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">639px</span>) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p>可以使用多条语句来将同一个样式应用到不同的设备类型和设备特性中，指定方式如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> handheld and (min-width: <span class="number">360px</span>), screen and (min-width: <span class="number">480px</span>) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p>可以在表达式中加上<code>not</code>关键字或<code>only</code>关键字，<code>not</code>关键字表示对后面的表达式执行取反操作，书写方法如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 除便携设备之外的其他设备或非彩色便携设备 */</span></span><br><span class="line">@<span class="keyword">media</span> not handheld and (color) &#123; 样式代码 &#125;</span><br><span class="line"><span class="comment">/* 所有非彩色设备 */</span></span><br><span class="line">@<span class="keyword">media</span> all and (not color) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p><code>only</code>关键字，让那些不支持<code>Media Queries</code>但是能够读取<code>Media Type</code>的设备的浏览器将表达式的样式隐藏起来。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (color) &#123; 样式代码 &#125;</span><br></pre></td></tr></table></figure><p>对于支持<code>Media Queries</code>的设备来说，将能够正确地应用央视，就仿佛<code>only</code>不存在一样；对于不支持<code>Media Queries</code>但能够读取<code>Media Type</code>的设备来说，由于先读取到<code>only</code>而不是<code>screen</code>，将忽略这个样式；对于不支持<code>Media Queries</code>的浏览器，无论是否有<code>only</code>，都将忽略这个样式。</p><p>css3中的<code>Media Queries</code>模块中也支持对外部样式表的引用，使用如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(color.css) screen and (min-width: <span class="number">1000px</span>);</span><br><span class="line"></span><br><span class="line">&lt;link rel="stylesheet" type="text/css" media="screen and (min-width: 1000px)" href="style.css"&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在css3的众多模块中，有一个与各种媒体相关的重要模块——&lt;code&gt;Media Queries&lt;/code&gt;，该模块中允许添加媒体查询表达式，用以指定媒体类型，然后根据媒体类型来选择应该使用的样式。换句话说，允许我们在不改变内容的情况下在样式中选择一种页面的布局以精确地适应不同的设备，从而改善用户体验。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="响应式布局" scheme="http://www.xiaoleon.cn/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    
      <category term="媒体查询" scheme="http://www.xiaoleon.cn/tags/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(8) 布局相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-8/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-8/</id>
    <published>2018-01-22T14:00:00.000Z</published>
    <updated>2018-01-27T09:01:21.394Z</updated>
    
    <content type="html"><![CDATA[<p>Web页面中的布局，是指在页面中如何对标题、导航栏、主要内容、脚注、表单等各种构成要素进行一个合理的编排。在css3之前，主要使用<code>float</code>属性或<code>position</code>属性进行页面中的简单布局，但是存在很多缺点，譬如两栏或多栏中如果元素的内容高度不一致则由底部很难对齐的问题。</p><a id="more"></a><h3 id="一、多栏布局"><a href="#一、多栏布局" class="headerlink" title="一、多栏布局"></a>一、多栏布局</h3><p>我们首先回顾以下css3之前是如何使用<code>float</code>属性或<code>position</code>属性进行页面中的简单布局的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20em</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#div1</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>float</code>属性或<code>position</code>属性进行页面布局时有一个比较明显的缺点，就是两个<code>div</code>元素是相互独立的，因此如果在第一个<code>div</code>元素中加入一些内容的话，将会使得两个元素的底部不能对其，导致页面中多出一块空白区域。</p><p>针对<code>float</code>属性或<code>position</code>属性的缺点，css3中加入了多栏布局方式，使用多栏布局可以将一个元素中的内容分为两栏或多栏显示，并且确保各栏中内容的底部对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50em</span>;</span><br><span class="line">    <span class="attribute">column-count</span>: <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>column-count</code>属性来使用多栏布局方式，该属性的含义是讲一个元素中的内容分为多栏进行显示。使用多栏布局的时候，需要将元素的宽度设置成多个栏目的总宽度，它与使用<code>float</code>属性和<code>position</code>属性时的区别是：使用两个属性时只需单独设定每个元素的宽度即可，而使用多栏布局时需要设定元素中多个栏目相加后的总的宽度。</p><p>我们也可以使用<code>column-width</code>属性单独设置每一栏的宽度而不设定元素的宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">column-count</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">column-width</span>: <span class="number">20em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>column-gap</code>属性来设定多栏之间的间隔距离。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">column-count</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">column-gap</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>column-rule</code>属性在栏与栏之间增加一条间隔线，并且设定该间隔线的宽度、颜色等，该属性的属性值的指定方法与css中<code>border</code>属性的属性值指定方法相同。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">column-count</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">column-rule</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、盒布局"><a href="#二、盒布局" class="headerlink" title="二、盒布局"></a>二、盒布局</h3><p>在css3中，除了多栏布局之外，还可以使用盒布局解决前面所说的使用<code>float</code>属性或<code>position</code>属性时左右两栏或多栏中底部不能对齐的问题。</p><p>接下来我们看一个示例，示例中有三个<code>div</code>元素，简单展示了网页中的左侧边栏、中间内容和右侧边栏。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#middle</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: limegreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span>, <span class="selector-id">#middle</span>, <span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>aaaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"middle"</span>&gt;</span>bbbb<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>cccc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例中如果<code>div</code>的内容变化时，<code>div</code>元素的底部会出现无法对齐的问题。</p><p>在css3中，我们可以通过<code>box</code>属性来使用盒布局，修改代码如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    <span class="attribute">display</span>: -moz-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#middle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: limegreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#left</span>, <span class="selector-id">#middle</span>, <span class="selector-id">#right</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>盒布局与多栏布局的区别</p><p>  使用多栏布局时，各栏宽度必须是相等的，在指定每栏宽度时，也只能为所有栏指定一个统一的宽度，栏与栏之间的宽度不可能是不一样的。另外，使用多栏布局时，也不可能具体指定什么栏中显示什么内容，因此比较适合使用在显示文章内容的时候，不适合用于安排整个网页中由个元素组成的网页结构时。</p></li></ul><ul><li><p>盒布局标准</p><p>  可以采用最新的<code>display: flex</code>属性，<code>-webkit-box</code>属于2009年的提案。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><p><a href="">《HTML5与CSS3权威指南》</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">《Flex 布局教程：语法篇》（阮一峰）</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web页面中的布局，是指在页面中如何对标题、导航栏、主要内容、脚注、表单等各种构成要素进行一个合理的编排。在css3之前，主要使用&lt;code&gt;float&lt;/code&gt;属性或&lt;code&gt;position&lt;/code&gt;属性进行页面中的简单布局，但是存在很多缺点，譬如两栏或多栏中如果元素的内容高度不一致则由底部很难对齐的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="layout" scheme="http://www.xiaoleon.cn/tags/layout/"/>
    
      <category term="多栏布局" scheme="http://www.xiaoleon.cn/tags/%E5%A4%9A%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    
      <category term="盒布局" scheme="http://www.xiaoleon.cn/tags/%E7%9B%92%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(7) 动画</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-7/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-7/</id>
    <published>2018-01-22T13:56:19.000Z</published>
    <updated>2018-01-27T09:01:14.651Z</updated>
    
    <content type="html"><![CDATA[<p>css3中，如果使用动画功能，可以使页面上的文字或画像具有动画效果，可以使背景色从一种颜色平滑过渡到另一种颜色。</p><a id="more"></a><p>css3中的动画功能分为<code>Transitions</code>功能与<code>Animations</code>功能，这两种功能都可以通过改变css的属性值来产生动画效果。</p><p>到目前为止，<code>Transitions</code>功能支持从一个属性值平滑过渡到另一个属性值，<code>Animations</code>功能支持通过关键帧的指定来在页面上产生更复杂的动画效果。</p><h3 id="一、Transitions功能"><a href="#一、Transitions功能" class="headerlink" title="一、Transitions功能"></a>一、Transitions功能</h3><p><code>Transitions</code>功能通过将元素的某个属性从一个属性值在指定的时间内平滑过渡到另一个属性值来实现动画功能，可通过<code>transitions</code>属性来使用<code>Transitions</code>功能。</p><p>使用方法如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">property</span> <span class="selector-tag">duration</span> <span class="selector-tag">timing-function</span></span><br></pre></td></tr></table></figure><p>其中<code>property</code>表示对哪个属性进行平滑过渡，<code>duration</code>表示在多长时间内完成属性值的平滑过渡，<code>timing-function</code>表示通过什么方法来进行平滑过渡。</p><p>我们看一个使用示例，页面中有一个<code>div</code>元素，背景色为黄色，通过<code>hover</code>属性指定当鼠标指针停留在<code>div</code>元素上时的背景色为浅蓝色，通过<code>transitions</code>属性指定：当鼠标指针移动到<code>div</code>元素上时，在1秒钟内让<code>div</code>元素的背景色从黄色平滑过度到浅蓝色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffff00</span>;</span><br><span class="line">    <span class="attribute">-webkit-transition</span>: background-color <span class="number">1s</span> linear;</span><br><span class="line">    <span class="attribute">-moz-transition</span>: background-color <span class="number">1s</span> linear;</span><br><span class="line">    <span class="attribute">-o-transition</span>: background-color <span class="number">1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#00ffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>css3中，还有另外一种使用<code>Transitions</code>功能的方法，就是将<code>transitions</code>属性中的三个参数改写成<code>transition-property</code>、<code>transition-duration</code>、<code>transition-timing-function</code>三个属性，这三个属性的含义与属性值的制定方法与<code>transitions</code>属性中的三个参数的含义及指定方法完全相同。</p><p><strong>使用Transitions功能同时平滑过渡多个属性值</strong></p><p>可以使用<code>Transitions</code>功能同时对多个属性值进行平滑过渡。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffff00</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000000</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">-webkit-transition</span>: background-color <span class="number">1s</span> linear, color <span class="number">1s</span> linear, width <span class="number">1s</span> linear;</span><br><span class="line">    <span class="attribute">-moz-transition</span>: background-color <span class="number">1s</span> linear, color <span class="number">1s</span> linear, width <span class="number">1s</span> linear;</span><br><span class="line">    <span class="attribute">-o-transition</span>: background-color <span class="number">1s</span> linear, color <span class="number">1s</span> linear, width <span class="number">1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#003366</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、Animations功能"><a href="#二、Animations功能" class="headerlink" title="二、Animations功能"></a>二、Animations功能</h3><p><code>Animations</code>功能与<code>Transitions</code>功能相同，都是通过改变元素的属性值来实现动画效果的。它们的区别在于：使用<code>Transitions</code>功能时只能通过指定属性的开始值与结束值，然后在这两个属性值之间进行平滑过渡的方式来实现动画效果，因此不能实现比较复杂的动画效果；而<code>Animations</code>则通过定义多个关键帧以及定义每个关键帧中元素的属性值来实现更为复杂的动画效果。</p><p>我们看一个代码使用示例，一个<code>div</code>元素背景色为红色，当鼠标指针移动到<code>div</code>元素上时，元素的背景色将经历从红色到深蓝色，从深蓝色到黄色，从黄色回到红色这样一系列的变化。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> mycolor &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">    40% &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: darkblue;</span><br><span class="line">    &#125;</span><br><span class="line">    70% &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="comment">/* 指定关键帧集合的名称 */</span></span><br><span class="line">    <span class="attribute">-webkit-animation-name</span>: mycolor;</span><br><span class="line">    <span class="comment">/* 指定完成整个动画的时间 */</span></span><br><span class="line">    <span class="attribute">-webkit-animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">    <span class="comment">/* 指定实现动画的方法 */</span></span><br><span class="line">    <span class="attribute">-webkit-animation-timing-function</span>: linear;</span><br><span class="line">    <span class="comment">/* 指定动画的播放次数 */</span></span><br><span class="line">    <span class="attribute">-webkit-animation-iteration-count</span>: infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码实现的动画中带有如下几个关键帧，通过这些关键帧之间的平滑过渡完成了动画的实现。</p><ul><li><p>开始帧：0%</p></li><li><p>背景色为深蓝色的关键帧：40%</p></li><li><p>背景色为黄色的关键帧：70%</p></li><li><p>结束帧：100%</p></li></ul><p><strong>实现动画的方法</strong></p><p>前面的使用示例中，我们只使用了一种实现动画的方法——<code>linear</code>。<code>linear</code>的含义是在动画从开始到结束时使用同样的速度进行各种属性值的改变，在一个动画中不改变各种属性值的改变速度。</p><table><thead><tr><th>方法</th><th>属性值的变化速度</th></tr></thead><tbody><tr><td>linear</td><td>在动画开始时到结束时以同样速度进行改变</td></tr><tr><td>ease-in</td><td>动画开始时速度很慢，然后速度沿曲线值进行加快</td></tr><tr><td>ease-out</td><td>动画开始时速度很快，然后沿曲线值进行放慢</td></tr><tr><td>ease</td><td>动画开始时速度很慢，然后速度沿曲线值进行加快，然后再沿曲线值放慢</td></tr><tr><td>ease-in-out</td><td>动画开始时速度很慢，然后沿曲线值进行加快，然后再沿曲线值放慢</td></tr></tbody></table><p>示例：实现网页的淡入效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> fadein &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: white;</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: white;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-animation-name</span>: fadein;</span><br><span class="line">    <span class="attribute">-webkit-animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">    <span class="attribute">-webkit-animation-timing-function</span>: linear;</span><br><span class="line">    <span class="attribute">-webkit-animation-iteration-count</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css3中，如果使用动画功能，可以使页面上的文字或画像具有动画效果，可以使背景色从一种颜色平滑过渡到另一种颜色。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Transitions" scheme="http://www.xiaoleon.cn/tags/Transitions/"/>
    
      <category term="Animations" scheme="http://www.xiaoleon.cn/tags/Animations/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(6) 变形处理</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-6/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-6/</id>
    <published>2018-01-22T13:53:57.000Z</published>
    <updated>2018-01-27T09:00:52.649Z</updated>
    
    <content type="html"><![CDATA[<p>在css3中，可以利用<code>transform</code>功能来实现文字或图像的旋转、缩放、倾斜、移动这四种类型的变形处理。</p><a id="more"></a><h3 id="一、缩放"><a href="#一、缩放" class="headerlink" title="一、缩放"></a>一、缩放</h3><p>使用<code>scale</code>方法实现文字或图像的缩放处理，在参数中指定缩放倍率。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 缩小50% */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以分别指定元素水平方向的放大倍率与垂直方向的放大倍率。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向缩小50%，垂直方向放大一倍 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.5, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、倾斜"><a href="#二、倾斜" class="headerlink" title="二、倾斜"></a>二、倾斜</h3><p>使用<code>skew</code>方法实现文字或图像的倾斜处理，在参数中分别指定水平方向上的倾斜角度与垂直方向上的倾斜角度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向倾斜30度，垂直方向倾斜30度 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(30deg, 30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>skew</code>方法中的两个参数可以修改成只使用一个参数，省略另一个参数——这种情况下视为只在水平方向上进行倾斜，垂直方向上不倾斜。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向倾斜30度，垂直方向不倾斜 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、移动"><a href="#三、移动" class="headerlink" title="三、移动"></a>三、移动</h3><p>使用<code>translate</code>方法来将文字或图像进行移动，在参数中分别指定水平方向上的移动距离与垂直方向上的移动距离。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向上移动50px，垂直方向上移动50px */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(50px, 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>translate</code>方法中的两个参数可以修改成只使用一个参数，省略另一个参数——这种情况下视为只在水平方向上移动，垂直方向上不移动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/* 水平方向上移动50px，垂直方向不移动 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、指定变形的基准点"><a href="#四、指定变形的基准点" class="headerlink" title="四、指定变形的基准点"></a>四、指定变形的基准点</h3><p>在使用<code>transform</code>方法进行文字或图像的变形时，是以元素的中心点为基准点进行的。使用<code>transform-origin</code>属性，可以改变变形的基准点。</p><p>指定<code>transform-origin</code>属性值的时候，采用“基准点在元素水平方向上的位置，基准点在元素垂直方向上的位置”的方法，其中“基准点在元素水平方向上的位置”中可以指定的值为<code>left</code>、<code>center</code>、<code>right</code>，“基准点在元素垂直方向上的位置”中可以指定的值为<code>top</code>、<code>center</code>、<code>bottom</code>。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在css3中，可以利用&lt;code&gt;transform&lt;/code&gt;功能来实现文字或图像的旋转、缩放、倾斜、移动这四种类型的变形处理。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="transform" scheme="http://www.xiaoleon.cn/tags/transform/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(5) 背景边框相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-5/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-5/</id>
    <published>2018-01-22T13:49:17.000Z</published>
    <updated>2018-01-27T09:00:45.815Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍CSS3中的背景和边框相关的一些样式，其中包括与背景相关的几个属性，如何在一个元素的背景中使用多个图像文件；如何绘制圆角边框；如何给元素添加图像边框。</p><a id="more"></a><p>在css3中，追加了一些与背景相关的属性，如下表所示</p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>background-clip</td><td>指定背景的显示范围</td></tr><tr><td>background-origin</td><td>指定绘制背景图像时的起点</td></tr><tr><td>background-size</td><td>指定背景中图像的尺寸</td></tr><tr><td>background-break</td><td>指定内联元素的背景图片进行平铺时的循环方式</td></tr></tbody></table><h3 id="一、指定背景的显示范围"><a href="#一、指定背景的显示范围" class="headerlink" title="一、指定背景的显示范围"></a>一、指定背景的显示范围</h3><p>在HTML页面中，一个具有背景的元素通常由元素的内容、内部补白（<code>padding</code>）、边框、外部补白（<code>margin</code>）构成。</p><p>元素背景的显示范围在css2、css2.1、css3中并不相同：</p><ul><li><p>css2中背景的显示范围是指内部补白之内的范围，不包括边框</p></li><li><p>css2.1至css3中，背景的显示范围是指包括边框在内的范围</p></li><li><p>css3中，可以使用<code>background-clip</code>来修改背景的显示范围，如果将<code>background-clip</code>设定为<code>border-box</code>，则背景范围包括边框区域，如果设定为<code>padding-box</code>或<code>content-box</code>，则不包括边框区域</p></li></ul><hr><h3 id="二、指定背景的绘制起点"><a href="#二、指定背景的绘制起点" class="headerlink" title="二、指定背景的绘制起点"></a>二、指定背景的绘制起点</h3><p>在绘制背景图像时，默认是从内部补白（<code>padding</code>）区域的左上角开始，但是可以利用<code>background-origin</code>属性来指定绘制时从边框的左上角开始，或者从内容的左上角开始。</p><blockquote><p>在firefox浏览器中，需要书写成“<code>-moz-background-origin</code>”形式；在safari浏览器或chrome浏览器中指定绘制起点时，需要书写成“<code>-webkit-background-origin</code>”形式。</p></blockquote><p><code>background-origin</code>属性为<code>border-box</code>、<code>padding-box</code>、<code>content-box</code>，分别代表从边框的左上角、内容补白区域的左上角或内容的左上角开始绘制。</p><hr><h3 id="三、指定背景图像的尺寸"><a href="#三、指定背景图像的尺寸" class="headerlink" title="三、指定背景图像的尺寸"></a>三、指定背景图像的尺寸</h3><p>在css3中，可以使用<code>background-size</code>属性来指定背景图像的尺寸。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-size</span>: 40<span class="selector-tag">px</span> 20<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p>其中第一个参数为图像的宽度，第二个参数为图像的高度，中间用半角空格进行分隔。如果要维持图像横纵比的话，可以将另一个参数设定为<code>auto</code>。</p><hr><h3 id="四、指定内联元素背景图片平铺循环方式"><a href="#四、指定内联元素背景图片平铺循环方式" class="headerlink" title="四、指定内联元素背景图片平铺循环方式"></a>四、指定内联元素背景图片平铺循环方式</h3><p>在css3中，可以使用<code>background-break</code>属性来指定平铺内联元素背景图像时的循环方式，可以指定<code>bounding-box</code>、<code>each-box</code>、<code>continuous</code>这三种循环方式。</p><p>将<code>background-break</code>属性指定为<code>bounding-box</code>时，背景图像在整个内联元素中进行平铺。指定为<code>each-box</code>时，背景图像在每一行中进行平铺。指定<code>continuous</code>的时候，下一行中的图像紧接着上一行中的图像继续平铺。</p><hr><h3 id="五、在一个元素中显示多个背景图像"><a href="#五、在一个元素中显示多个背景图像" class="headerlink" title="五、在一个元素中显示多个背景图像"></a>五、在一个元素中显示多个背景图像</h3><p>在css3中可以在一个元素里显示多个背景图像，还可以将多个背景图像进行重叠显示，从而使得背景图像中所用素材的调整变得更加容易。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(flower-red.png), <span class="built_in">url</span>(flower-green.png), <span class="built_in">url</span>(sky.jpg);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat, repeat-x, no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">3%</span> <span class="number">98%</span>, <span class="number">85%</span>, center center, top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>background-image</code>属性指定图像文件的时候，时按在浏览器中显示时图像叠放的顺序从上往下指定的，第一个图像文件是放在最上面的，最后制定的文件是放在最下面的。</p><p>允许多重制定并配合着多个图像文件一起利用的属性有如下几个：</p><p><code>background-image, background-repeat, background-position</code><br><code>background-clip, background-origin, background-size</code></p><hr><h3 id="六、border-radius属性"><a href="#六、border-radius属性" class="headerlink" title="六、border-radius属性"></a>六、border-radius属性</h3><p>在css3中，使用<code>border-radius</code>属性指定好圆角的半径，就可以绘制圆角边框了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">40px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用了<code>border-radius</code>属性但是把边框设定为不显示的时候，浏览器将把背景的四个角绘制为圆角。</p><p>使用了<code>border-radius</code>属性后，不管边框是什么种类，都会将边框沿着圆角曲线进行绘制。</p><hr><h3 id="七、border-image属性"><a href="#七、border-image属性" class="headerlink" title="七、border-image属性"></a>七、border-image属性</h3><p>css3中增加了一个<code>border-image</code>属性，可以让处于随时变化状态的元素的长或款的边框统一使用一个图像文件来绘制。使用<code>border-image</code>属性，会让浏览器在显示图像边框时，自动将所使用到的图像分割为9部分进行处理，这样就不需要页面再另外进行人工处理了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border-image</span>: <span class="built_in">url</span>(borderimage.png) <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> / <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>border-image</code>属性值中至少必须指定五个参数，其中第一个参数为边框所使用的图片文件的路径，后面四个参数表示当浏览器自动把边框所使用到的图像进行分隔时的上边距、右边距、下边距及左边距。</p><h4 id="1-指定边框宽度"><a href="#1-指定边框宽度" class="headerlink" title="1. 指定边框宽度"></a>1. 指定边框宽度</h4><p>在css3中，除了可以使用<code>border</code>属性或<code>border-width</code>属性来指定边框的宽度外，使用<code>border-image</code>属性同样可以指定边框的宽度。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image: url(图像文件的路径) A B C D / border-width</span><br></pre></td></tr></table></figure><p>下面代码中，指定了上边距、右边距、下边距和左边距为18px，4条边分别为5px、10px、15px、20px。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: solid;</span><br><span class="line">    <span class="attribute">border-image</span>: <span class="built_in">url</span>(borderimage.png) <span class="number">18</span> / <span class="number">5px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-中央图像的自动拉伸"><a href="#2-中央图像的自动拉伸" class="headerlink" title="2. 中央图像的自动拉伸"></a>2. 中央图像的自动拉伸</h4><p>浏览器将边框所用图像自动分割为9部分后，除了将<code>border-top-image</code>、<code>border-left-image</code>、<code>border-right-image</code>、<code>border-bottom-image</code>这四部分自动分配为四条边所用的图像之外，将位于中间部分的图像分配给元素边框所包围的中间区域，随着<code>div</code>元素内容变化的同时，或者在样式代码中修改div元素的宽度或高度的同时，中间部分的图像也会自动进行伸缩，以填满该中间区域。</p><h4 id="3-指定四条边中图像的显示方法"><a href="#3-指定四条边中图像的显示方法" class="headerlink" title="3. 指定四条边中图像的显示方法"></a>3. 指定四条边中图像的显示方法</h4><p>可以在<code>border-image</code>属性中指定元素四条边中的图像是以拉伸的方式显示，还是以平铺的方式显示</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image: url(文件路径) A B C D / border-width topbottom leftright</span><br></pre></td></tr></table></figure><p>其中，<code>topbottom</code>表示元素的上下两条边中图像的显示方法，<code>leftright</code>表示元素的左右两条边中的显示方法，显示方法中可以指定的值为<code>repeat</code>、<code>stretch</code>与<code>round</code>三种。</p><ul><li><p><code>repeat</code>：图像以平铺的方式进行显示</p></li><li><p><code>stretch</code>：图像以拉伸的方式进行显示</p></li><li><p><code>repeat+stretch</code>：将上下两条边中的图像的显示方式指定为平铺显示，左右两条边中的图像的显示方式指定为拉伸显示，或者上下两条边中的图像的显示方式指定为拉伸显示，左右两条边中的图像的显示方式指定为平铺显示。</p></li><li><p><code>round</code>：与<code>repeat</code>类似，都是将图像进行平铺显示，区别在于如果最后显示的衣服图像不能被完全显示，且能够现实的部分不到图像的一半，就不显示最后的图像，然后扩大前面的图像，使显示区域正好完整平铺全部图像；如果能够显示的部分超过图像的一半，就显示最后的图像，但是将全部显示的图像缩小，使显示区域正好完整平铺全部图像。</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍CSS3中的背景和边框相关的一些样式，其中包括与背景相关的几个属性，如何在一个元素的背景中使用多个图像文件；如何绘制圆角边框；如何给元素添加图像边框。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="background样式" scheme="http://www.xiaoleon.cn/tags/background%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="border样式" scheme="http://www.xiaoleon.cn/tags/border%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(4) 盒相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-4/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-4/</id>
    <published>2018-01-22T13:44:04.000Z</published>
    <updated>2018-01-27T09:00:36.114Z</updated>
    
    <content type="html"><![CDATA[<p>在css中，使用<code>display</code>属性来定义盒的类型。总体上来说，css的盒分为<code>block</code>类型与<code>inline</code>类型。</p> <a id="more"></a><h3 id="一、inline-block"><a href="#一、inline-block" class="headerlink" title="一、inline-block"></a>一、inline-block</h3><p><code>inline-block</code>是在css2.1中追加的一个盒类型，属于<code>block</code>类型盒的一种，但是在显示时具有<code>inline</code>类型盒的特点。</p><p>默认情况下使用<code>inline-block</code>类型时并列显示的元素的垂直对齐方式是底部对其，为了将垂直对齐方式改为顶部对齐，还需要在<code>div</code>元素的样式中加入<code>vertical-align</code>属性。</p><hr><h3 id="二、inline-table"><a href="#二、inline-table" class="headerlink" title="二、inline-table"></a>二、inline-table</h3><p>由于<code>table</code>元素属于<code>block</code>类型，所以不能与其他文字处于同一行中，但是如果将<code>table</code>元素修改wei<code>inline-table</code>类型，就可以让表格与其他文字处于同一行中了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-table;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#00aaff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在样式中利用<code>vertical-align</code>属性显示指定表格与文字的对齐方式。</p><hr><h3 id="三、list-item"><a href="#三、list-item" class="headerlink" title="三、list-item"></a>三、list-item</h3><p>如果在<code>display</code>中将元素的类型设定为<code>list-item</code>类型，可以将多个元素作为列表来显示，同时在元素的开头加上列表的标记。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: list-item;</span><br><span class="line">    <span class="attribute">list-style-type</span>: circle;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、run-in、compact"><a href="#四、run-in、compact" class="headerlink" title="四、run-in、compact"></a>四、run-in、compact</h3><p>将元素指定为<code>run-in</code>类型或者<code>compact</code>类型的时候，如果元素后面还有block类型的元素，<code>run-in</code>类型的元素将被包含在<code>block</code>类型的元素内部，而<code>compact</code>类型的元素将被放置在<code>block</code>类型的元素左边。</p><hr><h3 id="五、超出盒容纳的内容"><a href="#五、超出盒容纳的内容" class="headerlink" title="五、超出盒容纳的内容"></a>五、超出盒容纳的内容</h3><p>如果在样式中指定了盒的宽度与高度，就有可能出现某些内容在盒中容纳不下的情况，可以使用<code>overflow</code>属性来指定如何显示这些内容。</p><ul><li><p>overflow: hidden</p><p>  超出容纳范围的文字被隐藏</p></li><li><p>overflow: scroll</p><p>  元素中出现固定的水平滚动条与垂直滚动条</p></li><li><p>overflow: auto</p><p>  文字超出div元素的容纳范围时，根据需要出现水平滚动条或垂直滚动条</p></li><li><p>overflow: visible</p><p>  显示效果与不使用overflow属性时一样</p></li><li><p>text-overflow</p><p>  当通过把<code>overflow</code>属性设定为<code>ellipsis</code>，将盒中容纳不下的内容隐藏起来时，如果使用<code>text-overflow</code>属性，可以在盒的末尾显示一个代表省略的符号<code>“...”</code>。但是，<code>text-overflow</code>属性只在当盒中的内容在水平方向上超出盒的容纳范围时有效。通过将<code>white-space</code>属性设定为<code>nowrap</code>，使得盒右端的内容不能换行显示。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="attribute">-webkit-text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="attribute">-o-text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="六、对盒使用阴影"><a href="#六、对盒使用阴影" class="headerlink" title="六、对盒使用阴影"></a>六、对盒使用阴影</h3><p>在css3中，可以使用<code>box-shadow</code>属性让盒在显示时产生阴影特效</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">length</span> <span class="selector-tag">length</span> <span class="selector-tag">length</span> <span class="selector-tag">color</span>;</span><br><span class="line">-webkit-box-shadow: length length length color; // safari</span><br><span class="line">-moz-box-shadow: length length length color; // firefox</span><br></pre></td></tr></table></figure><p>前面三个<code>length</code>分别指阴影离开文字的 <strong>横向距离</strong>、<strong>纵向距离</strong>、<strong>模糊半径</strong>，color指阴影的 <strong>颜色</strong></p><p><strong>对第一个文字或第一行使用阴影</strong></p><p>可以使用<code>first-letter</code>选择器或<code>first-line</code>选择器来只让第一个文字或第一行具有阴影效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:first-letter</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">22px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:first-line</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="七、盒的宽度和高度"><a href="#七、盒的宽度和高度" class="headerlink" title="七、盒的宽度和高度"></a>七、盒的宽度和高度</h3><p>在css3中，使用<code>box-sizing</code>属性来指定针对元素的宽度和高度的计算方法，是否包含元素内部的补白区域，以及边框的宽度和高度。</p><h4 id="1-content-box"><a href="#1-content-box" class="headerlink" title="1. content-box"></a>1. content-box</h4><p>元素的宽度和高度不包括内容补白区域，以及边框的宽度和高度</p><h4 id="2-border-box"><a href="#2-border-box" class="headerlink" title="2. border-box"></a>2. border-box</h4><p>元素的宽度和高度包括内部补白区域，以及边框的宽度和高度</p><h4 id="3-为什么要使用box-sizing属性"><a href="#3-为什么要使用box-sizing属性" class="headerlink" title="3. 为什么要使用box-sizing属性"></a>3. 为什么要使用box-sizing属性</h4><p>使用<code>box-sizing</code>属性的目的是控制元素的总宽度，如果不使用该属性，样式中默认使用的是<code>content-box</code>属性值，它只对内容的宽度做了一个指定，却没有对元素的总宽度进行指定。有些场合下利用<code>border-box</code>属性值会使得页面布局更加方便。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在css中，使用&lt;code&gt;display&lt;/code&gt;属性来定义盒的类型。总体上来说，css的盒分为&lt;code&gt;block&lt;/code&gt;类型与&lt;code&gt;inline&lt;/code&gt;类型。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="盒模型" scheme="http://www.xiaoleon.cn/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="box-sizing" scheme="http://www.xiaoleon.cn/tags/box-sizing/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(3) 文字与字体相关样式</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-3/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-3/</id>
    <published>2018-01-22T13:40:32.000Z</published>
    <updated>2018-01-27T09:00:27.251Z</updated>
    
    <content type="html"><![CDATA[<p>本章针对css3中与文字、字体相关的一些属性做详细介绍，其中包括<code>text-shadow</code>属性、<code>word-break</code>属性、<code>word-wrap</code>属性、<code>Web Font</code>和<code>@font-face</code>属性，以及<code>font-size-adjust</code>属性。</p><a id="more"></a><h3 id="一、文字添加阴影"><a href="#一、文字添加阴影" class="headerlink" title="一、文字添加阴影"></a>一、文字添加阴影</h3><p><code>text-shadow</code>属性用于给页面上的文字添加阴影效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text-shadow</span>: <span class="selector-tag">length</span> <span class="selector-tag">length</span> <span class="selector-tag">length</span> <span class="selector-tag">color</span></span><br></pre></td></tr></table></figure><p>其中，前三个<code>length</code>分别指阴影离开文字的 <strong>横方向距离</strong>、<strong>纵方向距离</strong>、<strong>模糊半径</strong>，color指阴影的 <strong>颜色</strong>。</p><p><strong>指定多个阴影</strong></p><p>可以使用<code>text-shadow</code>属性给文字指定多个阴影，并且针对每个阴影使用不同颜色，指定多个阴影时使用逗号将多个阴影进行分隔。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">5px</span> <span class="number">#f39800</span>,</span><br><span class="line">                <span class="number">40px</span> <span class="number">35px</span> <span class="number">5px</span> <span class="number">#fff100</span>,</span><br><span class="line">                <span class="number">70px</span> <span class="number">60px</span> <span class="number">5px</span> <span class="number">#c0ff00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、文本自动换行"><a href="#二、文本自动换行" class="headerlink" title="二、文本自动换行"></a>二、文本自动换行</h3><p>在css3中，使用<code>word-break</code>属性来让文字自动换行</p><p>浏览器显示文本的时候，会让文本在浏览器或div元素的右端自动实现换行。对于西方文字来说，浏览器会在半角空格或连字符的地方自动换行，而不会在单词的当中突然换行。对于中文来说，可以在任何一个中文字后面进行换行。如果中文当中含有西方文字，浏览器也会在半角空格或连字符的地方进行换行，而不会在单词中强制换行。</p><p>当中文当中含有标点符号的时候，浏览器总是不可能让标点符号位于一行文字的行首，通常将标点符号以及它前面的一个文字作为一个整体来统一换行。</p><h4 id="1-指定自动换行"><a href="#1-指定自动换行" class="headerlink" title="1. 指定自动换行"></a>1. 指定自动换行</h4><p>在css3中，可以使用<code>word-break</code>属性来自己决定自动换行的处理方法。通过<code>word-break</code>属性的指定，不仅仅可以让浏览器实现半角空格或连字符后面的换行，而且可以让浏览器实现任意位置的换行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">word-break</span>: keep-all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>换行规则</th></tr></thead><tbody><tr><td>normal</td><td>使用浏览器默认换行规则</td></tr><tr><td>keep-all</td><td>只能在半角空格或连字符处换行</td></tr><tr><td>break-all</td><td>允许在单词内换行</td></tr></tbody></table><h4 id="2-长单词与URL地址自动换行"><a href="#2-长单词与URL地址自动换行" class="headerlink" title="2. 长单词与URL地址自动换行"></a>2. 长单词与URL地址自动换行</h4><p>对于西方文字来说，浏览器在半角空格或连字符的地方进行换行。因此，浏览器不能给较长的单词自动换行。当浏览器窗口比较窄的时候，文字会超出浏览器的窗口，浏览器下部出现滚动条，让用户通过拖动滚动条的方法来查看没有在当前窗口显示的文字。</p><p>在css3中，使用<code>word-wrap</code>属性来实现长单词与url地址的自动换行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>word-wrap</code>属性可以使用的属性值为<code>normal</code>与<code>break-word</code>两个。使用<code>normal</code>属性值时浏览器保持默认处理，只在半角空格或连字符的地方进行换行。使用<code>break-word</code>时浏览器可以在长单词或url地址内部进行换行。</p><hr><h3 id="三、使用服务器端字体"><a href="#三、使用服务器端字体" class="headerlink" title="三、使用服务器端字体"></a>三、使用服务器端字体</h3><p>在css3之前，页面文字所使用的字体必须已经在客户端中被安装才能正常显示，在样式表中允许指定当前字体不能正常显示时使用的替代字体，但是如果这个替代字体在客户端中也没有被安装时，使用这个字体的文字就不能正常显示了。</p><p>在css3中，使用<code>@font-face</code>属性来利用服务器端字体</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: WebFont;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'font/Fontin_Sans_R_45b.otf'</span>) <span class="built_in">format</span>(<span class="string">'opentype'</span>);</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>font-family</code>属性值用<code>WebFont</code>来声明使用服务器端的字体。<code>src</code>属性值指定服务器端字体的字体文件所在的路径。</p><p>在针对元素使用这个服务器端字体的时候，还需要在元素样式中将<code>font-family</code>属性值指定为<code>WebFont</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: WebFont;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@font-face</code>属性不仅可以用于显示服务器端的字体，也可以用来显示客户端本地的字体。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">local</span>(<span class="string">'Arial'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@font-face</code>属性显示客户端本地字体的好处是可以让浏览器在对字体进行显示时首先在客户端本地寻找是否存在该字体，当客户端寻找不到时在可使用服务器端的字体。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: MyHelvetica;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">local</span>(<span class="string">'Helvetica Neue'</span>) <span class="built_in">url</span>(MgOpenModernaRegular.ttf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、修改字体种类而保持字体尺寸不变"><a href="#四、修改字体种类而保持字体尺寸不变" class="headerlink" title="四、修改字体种类而保持字体尺寸不变"></a>四、修改字体种类而保持字体尺寸不变</h3><p>如果改变了字体的种类，则页面中所有使用改字体的文字大小都可能发生变化，从而使得原来安排好的页面布局产生混乱。</p><p>因此，在css3中增加了<code>font-size-adjust</code>属性，可以在保持文字大小不发生变化的情况下改变字体的种类。</p><p><code>font-size-adjust</code>属性的使用方法很简单，但是它需要使用每个字体种类自带的一个<code>aspect</code>值（比例值）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Times New Roman;</span><br><span class="line">    <span class="attribute">font-size-adjust</span>: <span class="number">0.46</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>aspect</code>值可以用来在将字体修改为其他字体时保持字体大小基本不变，这个<code>aspect</code>值的计算方法为<code>x-height</code>值除以该字体的尺寸，<code>x-height</code>值是指使用这个字体书写出来的小写<code>x</code>的高度（像素为单位）。如果某个字体的尺寸为100px时，<code>x-height</code>值为58px，则该字体的<code>aspect</code>为0.58，因为字体的<code>x-height</code>值总是随着字体的尺寸一起改变的，所以字体的<code>aspect</code>值都是一个常数。</p><p><strong>常用的西方字体aspect值</strong></p><table><thead><tr><th>字体种类</th><th>aspect值</th></tr></thead><tbody><tr><td>Verdana</td><td>0.58</td></tr><tr><td>Comic Sans MS</td><td>0.54</td></tr><tr><td>Trebuchet MS</td><td>0.53</td></tr><tr><td>Georgia</td><td>0.5</td></tr><tr><td>Myriad Web</td><td>0.48</td></tr><tr><td>Minion Web</td><td>0.47</td></tr><tr><td>Times New Roman</td><td>0.46</td></tr><tr><td>Gill Sans</td><td>0.46</td></tr><tr><td>Bernhard Modern</td><td>0.4</td></tr><tr><td>Caflisch Script Web</td><td>0.37</td></tr><tr><td>Fjemish Script</td><td>0.28</td></tr></tbody></table><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章针对css3中与文字、字体相关的一些属性做详细介绍，其中包括&lt;code&gt;text-shadow&lt;/code&gt;属性、&lt;code&gt;word-break&lt;/code&gt;属性、&lt;code&gt;word-wrap&lt;/code&gt;属性、&lt;code&gt;Web Font&lt;/code&gt;和&lt;code&gt;@font-face&lt;/code&gt;属性，以及&lt;code&gt;font-size-adjust&lt;/code&gt;属性。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="文字样式" scheme="http://www.xiaoleon.cn/tags/%E6%96%87%E5%AD%97%E6%A0%B7%E5%BC%8F/"/>
    
      <category term="服务器端字体" scheme="http://www.xiaoleon.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(2) 巧用Content</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-2/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-2/</id>
    <published>2018-01-22T13:36:53.000Z</published>
    <updated>2018-01-27T09:00:09.432Z</updated>
    
    <content type="html"><![CDATA[<p><code>content</code>是<code>before</code>与<code>after</code>伪元素中的属性值，用于在伪元素中展示相关内容，我们可以利用这个属性实现一些小功能。</p><a id="more"></a><h3 id="一、读取元素属性"><a href="#一、读取元素属性" class="headerlink" title="一、读取元素属性"></a>一、读取元素属性</h3><p>可以将<code>alt</code>属性的值作为图像的标题来显示，如果在<code>content</code>属性中通过<code>“attr(属性名)”</code>这种形式来指定<code>attr</code>属性值，可以将某个属性的属性值显示出来。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">attr</span>(alt);</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"sky.jpg"</span> <span class="attr">alt</span>=<span class="string">"蓝天白云"</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="二、插入项目编号"><a href="#二、插入项目编号" class="headerlink" title="二、插入项目编号"></a>二、插入项目编号</h3><p>可以使用<code>content</code>属性来插入项目编号，在<code>content</code>属性中使用<code>counter</code>属性来针对多个项目追加连续编号。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(mycounter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'Part '</span><span class="built_in">counter</span>(mycounter)<span class="string">': '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>before</code>选择器或<code>after</code>选择器的<code>content</code>属性，不仅可以追加数字编号，还可以追加字母编号或罗马数字编号</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(mycounter, upper-alpha)<span class="string">'. '</span>;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">42px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>list-style-type</code>属性来指定编号的种类，例如，指定大写字母编号时，使用<code>upper-alpha</code>属性，指定大写罗马字母时，使用<code>upper-roman</code>属性。</p><h4 id="1-编号嵌套"><a href="#1-编号嵌套" class="headerlink" title="1. 编号嵌套"></a>1. 编号嵌套</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(mycounter)<span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(subcounter)<span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: subcounter;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要对编号进行重置，则需要使用 <code>counter-reset</code> 属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: mycounter;</span><br><span class="line">    <span class="attribute">counter-reset</span>: subcounter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-大编号嵌套中编号"><a href="#2-大编号嵌套中编号" class="headerlink" title="2. 大编号嵌套中编号"></a>2. 大编号嵌套中编号</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(mycounter) <span class="string">'-'</span> <span class="built_in">counter</span>(subcounter) <span class="string">'. '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、添加嵌套文字符号"><a href="#三、添加嵌套文字符号" class="headerlink" title="三、添加嵌套文字符号"></a>三、添加嵌套文字符号</h3><p>可以使用<code>content</code>属性的<code>open-quote</code>属性值与<code>close-quote</code>属性值在字符串两边添加诸如括号、单引号、双引号之类的嵌套文字符号。</p><p>另外，在元素的样式中使用<code>quotes</code>属性来指定使用什么嵌套文字符号。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: open-quote;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: close-quote;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">quotes</span>: <span class="string">"("</span> <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;content&lt;/code&gt;是&lt;code&gt;before&lt;/code&gt;与&lt;code&gt;after&lt;/code&gt;伪元素中的属性值，用于在伪元素中展示相关内容，我们可以利用这个属性实现一些小功能。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Content应用" scheme="http://www.xiaoleon.cn/tags/Content%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSS3(1) 选择器</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/css3-1/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/css3-1/</id>
    <published>2018-01-22T13:29:23.000Z</published>
    <updated>2018-01-27T08:59:56.781Z</updated>
    
    <content type="html"><![CDATA[<p>选择器是CSS3中的一个重要内容，使用它可以大幅度提高开发人员书写或修改样式表时的工作效率。</p><a id="more"></a><p>通常我们会在元素上定义<code>class</code>属性，然后根据元素的<code>class</code>属性在css文件中定义相关的样式。使用<code>class</code>属性有两个缺点：</p><ul><li><p><code>class</code>属性本身没有语义，它纯粹时用来为css样式服务的，属于多余属性。</p></li><li><p>使用<code>class</code>属性的话，并没有把样式与元素绑定起来，针对同一个<code>class</code>属性，文本框也可以使用，下拉框也可以使用，甚至按钮也可以使用，这样其实是非常混乱的，修改样式的时候也很不方便。</p></li></ul><p>所以在CSS3中，提倡使用选择器来将样式与元素直接绑定起来，这样的话，在样式表中什么样式与什么元素相匹配变得一目了然，修改起来也很方便。不仅如此，通过选择器，我们还可以实现各种复杂的指定，同时也能大量减少样式表的代码书写量，最终书写出来的样式表也会变得简洁明了。</p><h3 id="一、属性选择器"><a href="#一、属性选择器" class="headerlink" title="一、属性选择器"></a>一、属性选择器</h3><p>html中，我们可以通过各种各样的属性，给元素增加很多附加信息。例如通过<code>width</code>属性，我们可以指定<code>div</code>元素的宽度；通过<code>id</code>属性，我们可以将不同的<code>div</code>元素进行区分。</p><p>css3中，增加了如下所示三种属性选择器，使得属性选择器有了通配符的概念</p><ul><li><p>[att*=val]</p><p>  如果元素用<code>att</code>表示的属性之属性值包含用<code>val</code>指定的字符的话，则该元素使用这个样式。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[id*=section]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id="section1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="section1-1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="hs-section"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="hs-section-1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><p>[att^=val]</p><p>  如果元素用<code>att</code>表示的属性之属性值的开头字符为用<code>val</code>指定的字符的话，则该元素使用这个样式。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[id^=section]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id="section1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="section1-1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><p>[att$=val]</p><p>  如果元素用<code>att</code>表示的属性之属性值的结尾字符为用<code>val</code>指定的字符的话，则该元素使用这个样式。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[id$=section]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id="hssection"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="hs-section"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>使用示例</strong>: 根据<code>a</code>标签的<code>href</code>中不同的文件扩展符，使用不同的样式，在超链接地址的末尾添加不同的文字</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=\/]</span><span class="selector-pseudo">:after</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$=htm]</span><span class="selector-pseudo">:after</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$=html]</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'web网页'</span>;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=jpg]</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'jpg图片'</span>;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、伪类选择器"><a href="#二、伪类选择器" class="headerlink" title="二、伪类选择器"></a>二、伪类选择器</h3><p>所谓伪类选择器，是指并不是针对真正的元素使用的选择器，而针对CSS中已经定义号的伪元素使用的选择器。CSS中主要有四个伪元素选择器：</p><ul><li><p><code>first-line</code>伪元素选择器</p><p>  用于为某个元素中的第一行文字使用样式</p></li><li><p><code>first-letter</code>伪元素选择器</p><p>  用于为某个元素中的文字的首字母或第一个字使用样式</p></li><li><p><code>before</code>伪元素选择器</p><p>  用于在某个元素之前插入一些内容</p></li><li><p><code>after</code>伪元素选择器</p><p>  用于在某个元素之后插入一些内容</p></li></ul><hr><h3 id="三、root、not、empty、target"><a href="#三、root、not、empty、target" class="headerlink" title="三、root、not、empty、target"></a>三、root、not、empty、target</h3><h4 id="1-root选择器"><a href="#1-root选择器" class="headerlink" title="1. root选择器"></a>1. root选择器</h4><p><code>root</code>选择器将样式绑定到页面的根元素中。所谓根元素，是指位于文档树中最顶层结构的元素，在HTML页面中就是指包含着整个页面的<code>“&lt;html&gt;”</code>部分。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: limegreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-not"><a href="#2-not" class="headerlink" title="2. not"></a>2. not</h4><p>如果相对某个结构元素使用样式，但是想排除这个结构元素下面的子结构元素，让它不使用这个样式时，可以使用<code>not</code>选择器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> *<span class="selector-pseudo">:not(h1)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-empty"><a href="#3-empty" class="headerlink" title="3. empty"></a>3. empty</h4><p>使用<code>empty</code>选择器来指定当元素内容为空白时使用的样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:empty</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-target"><a href="#4-target" class="headerlink" title="4. target"></a>4. target</h4><p>使用<code>target</code>选择器来对页面中的某个<code>target</code>元素（该元素的<code>id</code>被当作页面中的超链接来使用）指定样式，该样式只在用户点击了页面中的超链接，并且跳转到<code>target</code>元素后起作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:target</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、first-child、last-child、nth-child、nth-last-child"><a href="#四、first-child、last-child、nth-child、nth-last-child" class="headerlink" title="四、first-child、last-child、nth-child、nth-last-child"></a>四、first-child、last-child、nth-child、nth-last-child</h3><p>利用这几个选择器，能够特殊针对父元素的第一个子元素、最后一个子元素、指定序号的子元素、甚至第偶数个、第奇数个子元素进行样式的指定。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(n)</span> &#123;</span><br><span class="line">    <span class="comment">/* css中的n从1开始计数 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(even)</span> &#123;</span><br><span class="line">    <span class="comment">/* 所有正数下来的第偶数个子元素 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(odd)</span> &#123;</span><br><span class="line">    <span class="comment">/* 所有正数下来的第奇数个子元素 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-last-child(odd)</span> &#123;</span><br><span class="line">    <span class="comment">/* 所有倒数上去的第奇数个子元素 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="五、nth-of-type、nth-last-of-type"><a href="#五、nth-of-type、nth-last-of-type" class="headerlink" title="五、nth-of-type、nth-last-of-type"></a>五、nth-of-type、nth-last-of-type</h3><p>在css3中，使用<code>nth-of-type</code>选择器与<code>nth-last-of-type</code>选择器可以避免父元素下不同类型子元素的序号选择问题。使用这两个选择器的时候，css3在计算子元素是第奇数个还是第偶数个的时候，就只针对同类型的子元素进行计算。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:nth-of-type(odd)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:nth-of-type(even)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="六、循环使用样式"><a href="#六、循环使用样式" class="headerlink" title="六、循环使用样式"></a>六、循环使用样式</h3><p>如果我们有100个列表项目，需要重复使用前四种样式的设置，可以采用循环指定的方式，只要在 <code>nth-child(n)</code> 语句中，把参数 <code>n</code> 改成可循环的 <code>an + b</code> 的形式就可以，<code>a</code> 表示每次循环中共包括几种样式， <code>b</code> 表示指定的样式在循环中的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(4n+1)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(4n+2)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: limegreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(4n+3)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(4n)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="七、only-child"><a href="#七、only-child" class="headerlink" title="七、only-child"></a>七、only-child</h3><p>如果采用如下琐事的方法结合运用<code>nth-child</code>选择器与<code>nth-last-child</code>选择器的话，可以指定当某个父元素中只有一个子元素时才使用的样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span><span class="selector-pseudo">:nth-last-child(1)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外也可以使用<code>only-child</code>选择器来替代上面的实现方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:only-child</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="八、UI元素状态伪类选择器"><a href="#八、UI元素状态伪类选择器" class="headerlink" title="八、UI元素状态伪类选择器"></a>八、UI元素状态伪类选择器</h3><p>在CSS3的选择器中，除了结构性伪类选择器外，还有一种UI元素状态伪类选择器。这些选择器的共同特征是：指定的样式只有当元素处于某种状态下时才起作用，在默认状态下不起作用。</p><p>在CSS3中，共有11种UI元素状态伪类选择器，分别是</p><p><code>E:hover  E:active  E:focus  E:enabled  E:disabled  E:read-only  E:read-write  E:checked  E:default  E:indeterminate  E::selection</code></p><h4 id="1-E-hover"><a href="#1-E-hover" class="headerlink" title="1. E:hover"></a>1. E:hover</h4><p>指定当鼠标指针移动到元素上面时元素所使用的样式</p><h4 id="2-E-active"><a href="#2-E-active" class="headerlink" title="2. E:active"></a>2. E:active</h4><p>指定元素被激活（鼠标在元素上按下还没有松开）时使用的样式</p><h4 id="3-E-focus"><a href="#3-E-focus" class="headerlink" title="3. E:focus"></a>3. E:focus</h4><p>指定元素获得光标焦点时使用的样式，主要是在文本框控件获得焦点并进行文字输入的时候使用</p><h4 id="4-E-enabled"><a href="#4-E-enabled" class="headerlink" title="4. E:enabled"></a>4. E:enabled</h4><p>指定当元素处于可用状态时的样式</p><h4 id="5-E-disabled"><a href="#5-E-disabled" class="headerlink" title="5. E:disabled"></a>5. E:disabled</h4><p>指定当元素处于不可用状态时的样式</p><h4 id="6-E-read-only"><a href="#6-E-read-only" class="headerlink" title="6. E:read-only"></a>6. E:read-only</h4><p>指定当元素处于只读状态时的样式</p><h4 id="7-E-read-write"><a href="#7-E-read-write" class="headerlink" title="7. E:read-write"></a>7. E:read-write</h4><p>指定当元素处于非只读状态时的样式</p><h4 id="8-E-checked"><a href="#8-E-checked" class="headerlink" title="8. E:checked"></a>8. E:checked</h4><p>指定当表单中的<code>radio</code>或<code>checkbox</code>处于选取状态时的样式，在firefox浏览器中，需要写成 <code>-moz-checked</code> 的形式</p><h4 id="9-E-default"><a href="#9-E-default" class="headerlink" title="9. E:default"></a>9. E:default</h4><p>指定当页面打开默认处于选取状态的单选框或复选框控件的样式</p><h4 id="10-E-indeterminate"><a href="#10-E-indeterminate" class="headerlink" title="10. E:indeterminate"></a>10. E:indeterminate</h4><p>指定当页面打开时，如果一组单选框中任何一个单选框都没有被设定为选取状态时整组单选框的样式，如果用户选取了对其中任何一个单选框，则该样式被取消指定</p><h4 id="11-E-selection"><a href="#11-E-selection" class="headerlink" title="11. E::selection"></a>11. E::selection</h4><p>指定当元素处于选中状态时的样式</p><hr><h3 id="九、通用兄弟元素选择器"><a href="#九、通用兄弟元素选择器" class="headerlink" title="九、通用兄弟元素选择器"></a>九、通用兄弟元素选择器</h3><p>通用兄弟元素选择器，用来指定位于同一个父元素之中的某个元素之后的所有其他某个种类的兄弟元素所使用的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;子元素&gt;~&lt;子元素之后的同级兄弟元素&gt; &#123;</span><br><span class="line">    // 指定样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;选择器是CSS3中的一个重要内容，使用它可以大幅度提高开发人员书写或修改样式表时的工作效率。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS3抄书笔记" scheme="http://www.xiaoleon.cn/categories/CSS3%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS选择器" scheme="http://www.xiaoleon.cn/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>H5(13) Geolocation</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/html5-13/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/html5-13/</id>
    <published>2018-01-22T13:23:54.000Z</published>
    <updated>2018-01-27T09:03:18.531Z</updated>
    
    <content type="html"><![CDATA[<p>在HTML5中，为<code>window.navigator</code>对象新增了一个<code>geolocation</code>属性，可以使用<code>Geolocation API</code>来对该属性进行访问。</p><a id="more"></a><h3 id="一、获取当前位置"><a href="#一、获取当前位置" class="headerlink" title="一、获取当前位置"></a>一、获取当前位置</h3><p>可以使用<code>getCurrentPosition</code>方法来取得用户当前的地理位置信息，该方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> getCurrentPosition(onSuccess, onError, options);</span><br></pre></td></tr></table></figure><p>第一个参数为获取当前地理位置信息成功时所执行的回调函数</p><p>第二个参数为获取当前地理位置信息失败时所执行的回调函数（可选）</p><p>第三个参数为一些可选属性的列表（可选）</p><p><code>onSuccess</code>回调函数中，用到了一个参数<code>position</code>，它代表一个<code>position</code>对象，我们在后面对这个对象进行介绍</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(<span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取成功时的处理</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>onError</code>回调函数中，用到了一个<code>error</code>对象，该对象具有以下两个属性：</p><ul><li><p><code>code</code>属性。<code>code</code>属性为以下三个值其中之一：</p><ul><li><p>用户拒绝了位置服务（数字值为1）</p></li><li><p>获取不到位置信息（数字值为2）</p></li><li><p>获取信息超时错误（数字值为3）</p></li></ul></li><li><p><code>message</code>属性。</p><p>  <code>message</code>属性为一个字符串，在该字符串中包含了错误信息。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> coords = position.coords;</span><br><span class="line">        showMap(coords.latitude, coords.longitude, coords.accuracy);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> errorTypes = &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="string">'位置服务被拒绝'</span>,</span><br><span class="line">            <span class="number">2</span>: <span class="string">'获取不到位置信息'</span>,</span><br><span class="line">            <span class="number">3</span>: <span class="string">'获取信息超时'</span></span><br><span class="line">        &#125;;</span><br><span class="line">        alert(errorTypes[error.code] + <span class="string">': 不能确定你的当前地理位置'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>options</code>是一些可选属性的列表，包含如下：</p><ul><li><p>enableHighAccuracy</p><p>  是否要求高精度的地理位置信息，这个参数在很多设备上设置了都没用，因为使用在设备上时要结合设备电量、具体地理情况来综合考虑</p></li><li><p>timeout</p><p>  对地理位置信息的获取操作做一个超时限制（单位为毫秒）。如果在改时间内未获取到地理位置信息，则返回错误</p></li><li><p>maximumAge</p><p>  对地理位置信息进行缓存的有效时间（单位为毫秒）。如果该值指定为0，则无条件重新获取新的地理位置信息</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        maximumAge: <span class="number">60</span> * <span class="number">1000</span> * <span class="number">2</span>,</span><br><span class="line">        timeout: <span class="number">5000</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h3 id="二、持续监视当前地理位置信息"><a href="#二、持续监视当前地理位置信息" class="headerlink" title="二、持续监视当前地理位置信息"></a>二、持续监视当前地理位置信息</h3><p>使用<code>watchPosition</code>方法来持续获取用户当前地理位置信息，它会定期地自动获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int watchCurrentPosition(onSuccess, onError, options);</span><br></pre></td></tr></table></figure><p>该方法与<code>getCurrentPosition</code>方法的参数说明与使用方法相同，该方法返回一个数字，这个数字的使用与<code>setInterval</code>的返回参数值类似，可以被<code>clearWatch</code>方法使用，停止对当前地理位置信息的监视。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> clearWatch(watchId)</span><br></pre></td></tr></table></figure><hr><h3 id="三、position对象"><a href="#三、position对象" class="headerlink" title="三、position对象"></a>三、position对象</h3><p>通过访问<code>position</code>对象，可以得到地理位置信息</p><ul><li><p>latitude</p><p>  当前地理位置的纬度</p></li><li><p>longitude</p><p>  当前地理位置的精度</p></li><li><p>altitude</p><p>  当前位置的海拔高度</p></li><li><p>accuracy</p><p>  获取到的纬度或经度的精度（单位为米）</p></li><li><p>altitudeAccurancy</p><p>  获取到的海拔高度的精度（单位为米）</p></li><li><p>heading</p><p>  设备的前进方向，以面朝正北方向的顺时针旋转角度来表示</p></li><li><p>speed</p><p>  设备的前进速度（单位为米/秒）</p></li><li><p>timestamp</p><p>  获取地理位置信息时的时间</p></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在HTML5中，为&lt;code&gt;window.navigator&lt;/code&gt;对象新增了一个&lt;code&gt;geolocation&lt;/code&gt;属性，可以使用&lt;code&gt;Geolocation API&lt;/code&gt;来对该属性进行访问。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5抄书笔记" scheme="http://www.xiaoleon.cn/categories/HTML5%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Geolocation" scheme="http://www.xiaoleon.cn/tags/Geolocation/"/>
    
  </entry>
  
  <entry>
    <title>H5(12) Web Workers</title>
    <link href="http://www.xiaoleon.cn/2018/01/22/html5-12/"/>
    <id>http://www.xiaoleon.cn/2018/01/22/html5-12/</id>
    <published>2018-01-22T13:19:17.000Z</published>
    <updated>2018-01-27T09:03:09.203Z</updated>
    
    <content type="html"><![CDATA[<p><code>Web Workers</code>是HTML5中新增的，用来在Web应用程序中实现后台处理的一项技术。</p><p>在使用HTML4与Javascript创建出来的Web程序中，因为所有的处理都是在单线程内执行的，所以如果花费的事件比较长的话，程序界面会处于长时间没有响应的状态。最恶劣的是，当时间长到一定程度的话，浏览器还会跳出一个提示脚本运行时间过长的提示框，使用户不得不中断正在执行的处理。</p><a id="more"></a><h3 id="一、Web-Worker介绍"><a href="#一、Web-Worker介绍" class="headerlink" title="一、Web Worker介绍"></a>一、Web Worker介绍</h3><p>为了解决这个问题，HTML5新增了一个<code>Web Workers API</code>。使用这个API，用户可以很容易地创建在后台运行的线程（在HTML5中被称为<code>worker</code>），如果将可能耗费较长时间的处理交给后台去执行的话，对用户在前台页面中执行的操作就完全没有影响了。</p><p>创建后台线程的步骤十分简单。只要在<code>Worker</code>类的构造器中，将需要在后台线程中执行的脚本文件的url地址作为参数，然后创建<code>Worker</code>对象就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>要注意在后台线程中是不能访问页面或窗口对象的。如果在后台线程的脚本文件中使用到<code>window</code>对象或<code>document</code>对象，则会引起错误的发生。</p></blockquote><p>另外，可以通过发送和接收消息来与后台线程互相传递数据。通过对<code>Worker</code>对象的<code>onmessage</code>事件句柄的获取可以在后台线程之中接收消息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理收到的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>Worker</code>对象的<code>postMessage</code>方法来对后台线程发送消息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(message);</span><br></pre></td></tr></table></figure><p>另外，同样可以通过获取<code>Worker</code>对象的<code>onmessage</code>事件句柄及<code>Worker</code>对象的<code>postMessage</code>方法在后台线程内部进行消息的接收和发送。</p><p>使用示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>从1到给定数值的求和示例<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    输入数值：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">id</span>=<span class="string">"num"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"calculate()"</span>&gt;</span>计算<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'calculate.js'</span>);</span></span><br><span class="line"><span class="javascript">        worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">`合计值：<span class="subst">$&#123;event.data&#125;</span>`</span>);</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="built_in">document</span>.getElementById(<span class="string">'num'</span>).value, <span class="number">10</span>);</span></span><br><span class="line"><span class="undefined">            worker.postMessage(num);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate.js</span></span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = event.data;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        result += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向线程创建源送回消息</span></span><br><span class="line">    postMessage(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、线程嵌套"><a href="#二、线程嵌套" class="headerlink" title="二、线程嵌套"></a>二、线程嵌套</h3><p>线程中可以嵌套子线程，这样的话我们可以把一个较大的后台线程切分成几个子线程，在每个子线程中各自完成相对独立的一部分工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker1.js</span></span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> intArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        intArray[i] = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> worker;</span><br><span class="line">    worker = <span class="keyword">new</span> Worker(<span class="string">'worker2.js'</span>);</span><br><span class="line">    worker.postMessage(<span class="built_in">JSON</span>.stringify(intArray));</span><br><span class="line">    worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        postMessage(event.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker2.js</span></span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> intArray = <span class="built_in">JSON</span>.parse(event.data);</span><br><span class="line">    <span class="keyword">var</span> returnStr = <span class="string">''</span>;</span><br><span class="line">    ...</span><br><span class="line">    postMessage(returnStr);</span><br><span class="line">    close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：在子线程中向发送源发送回消息后，最好使用<code>close</code>语句关闭子线程，如果该子线程不再使用的话。</p></blockquote><hr><h3 id="三、线程中可用的变量、函数与类"><a href="#三、线程中可用的变量、函数与类" class="headerlink" title="三、线程中可用的变量、函数与类"></a>三、线程中可用的变量、函数与类</h3><p>我们总体看一下在线程用的Javascript中所有可用的变量、函数与类</p><h4 id="1-self"><a href="#1-self" class="headerlink" title="1. self"></a>1. self</h4><p><code>self</code>关键词用来表示本线程范围内的作用域</p><h4 id="2-postMessage-message"><a href="#2-postMessage-message" class="headerlink" title="2. postMessage(message)"></a>2. postMessage(message)</h4><p>向创建线程的源窗口发送消息</p><h4 id="3-onmessage"><a href="#3-onmessage" class="headerlink" title="3. onmessage"></a>3. onmessage</h4><p>获取接收消息的事件句柄</p><h4 id="4-importScripts-urls"><a href="#4-importScripts-urls" class="headerlink" title="4. importScripts(urls)"></a>4. importScripts(urls)</h4><p>导入其他Javascript文件，参数为该文件的url地址，可以导入多个文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importScripts(<span class="string">'script1.js'</span>, <span class="string">'scripts\script2.js'</span>, <span class="string">'script\script3.js'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>导入的文件必须与使用该线程的文件的页面在同一个域中，并在同一个端口中</p></blockquote><h4 id="5-navigator对象"><a href="#5-navigator对象" class="headerlink" title="5. navigator对象"></a>5. navigator对象</h4><p>与<code>window.navigator</code>对象相似，具有<code>appName</code>、<code>platform</code>、<code>userAgent</code>、<code>appVersion</code>属性</p><h4 id="6-sessionStorage-localStorage"><a href="#6-sessionStorage-localStorage" class="headerlink" title="6. sessionStorage/localStorage"></a>6. sessionStorage/localStorage</h4><p>可以在线程中使用<code>Web Storage</code></p><h4 id="7-XMLHttpRequest"><a href="#7-XMLHttpRequest" class="headerlink" title="7. XMLHttpRequest"></a>7. XMLHttpRequest</h4><p>可以在线程中处理<code>Ajax</code>请求</p><h4 id="8-Web-Workers"><a href="#8-Web-Workers" class="headerlink" title="8. Web Workers"></a>8. Web Workers</h4><p>可以在线程中嵌套线程</p><h4 id="9-setTimeout-setInterval"><a href="#9-setTimeout-setInterval" class="headerlink" title="9. setTimeout()/setInterval()"></a>9. setTimeout()/setInterval()</h4><p>可以在线程中实现定时处理</p><h4 id="10-close"><a href="#10-close" class="headerlink" title="10. close"></a>10. close</h4><p>可以结束本线程</p><h4 id="11-eval-、isNaN-、escape-等"><a href="#11-eval-、isNaN-、escape-等" class="headerlink" title="11. eval()、isNaN()、escape()等"></a>11. eval()、isNaN()、escape()等</h4><p>可以使用所有的Javascript核心函数</p><h4 id="12-object"><a href="#12-object" class="headerlink" title="12. object"></a>12. object</h4><p>可以创建和使用本地对象</p><h4 id="13-WebSockets"><a href="#13-WebSockets" class="headerlink" title="13. WebSockets"></a>13. WebSockets</h4><p>可以使用<code>WebSockets API</code>来向服务器发送和接收消息</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="">《HTML5与CSS3权威指南》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Web Workers&lt;/code&gt;是HTML5中新增的，用来在Web应用程序中实现后台处理的一项技术。&lt;/p&gt;
&lt;p&gt;在使用HTML4与Javascript创建出来的Web程序中，因为所有的处理都是在单线程内执行的，所以如果花费的事件比较长的话，程序界面会处于长时间没有响应的状态。最恶劣的是，当时间长到一定程度的话，浏览器还会跳出一个提示脚本运行时间过长的提示框，使用户不得不中断正在执行的处理。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5抄书笔记" scheme="http://www.xiaoleon.cn/categories/HTML5%E6%8A%84%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Web Workers" scheme="http://www.xiaoleon.cn/tags/Web-Workers/"/>
    
  </entry>
  
</feed>
